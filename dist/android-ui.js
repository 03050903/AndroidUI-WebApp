var android;
(function (android) {
    var util;
    (function (util) {
        class SparseArray {
            constructor(initialCapacity) {
                this.map = new Map();
            }
            clone() {
                let clone = new SparseArray();
                clone.map = new Map(this.map);
                return clone;
            }
            get(key, valueIfKeyNotFound = null) {
                let value = this.map.get(key);
                if (value === undefined)
                    return valueIfKeyNotFound;
                return value;
            }
            delete(key) {
                this.map.delete(key);
            }
            remove(key) {
                this.delete(key);
            }
            removeAt(index) {
                this.removeAtRange(index);
            }
            removeAtRange(index, size = 1) {
                let keys = [...this.map.keys()];
                let end = Math.min(this.map.size, index + size);
                for (let i = index; i < end; i++) {
                    this.map.delete(keys[i]);
                }
            }
            put(key, value) {
                this.map.set(key, value);
            }
            size() {
                return this.map.size;
            }
            keyAt(index) {
                return [...this.map.keys()][index];
            }
            valueAt(index) {
                return [...this.map.values()][index];
            }
            setValueAt(index, value) {
                let key = this.keyAt(index);
                this.map.set(key, value);
            }
            indexOfKey(key) {
                return [...this.map.keys()].indexOf(key);
            }
            indexOfValue(value) {
                return [...this.map.values()].indexOf(value);
            }
            clear() {
                this.map.clear();
            }
            append(key, value) {
                this.put(key, value);
            }
        }
        util.SparseArray = SparseArray;
    })(util = android.util || (android.util = {}));
})(android || (android = {}));
var android;
(function (android) {
    var util;
    (function (util) {
        class Log {
            static getPriorityString(priority) {
                if (priority > Log.PriorityString.length)
                    return "";
                return Log.PriorityString[priority - 2];
            }
            static v(tag, msg, tr) {
                console.log(Log.getLogMsg(Log.VERBOSE, tag, msg));
                if (tr)
                    console.log(tr);
            }
            static d(tag, msg) {
                console.debug(Log.getLogMsg(Log.DEBUG, tag, msg));
            }
            static i(tag, msg, tr) {
                console.info(Log.getLogMsg(Log.INFO, tag, msg));
                if (tr)
                    console.info(tr);
            }
            static w(tag, msg, tr) {
                console.warn(Log.getLogMsg(Log.WARN, tag, msg));
                if (tr)
                    console.warn(tr);
            }
            static e(tag, msg, tr) {
                console.error(Log.getLogMsg(Log.ERROR, tag, msg));
                if (tr)
                    console.error(tr);
            }
            static getLogMsg(priority, tag, msg) {
                let d = new Date();
                let dateFormat = d.toLocaleTimeString() + '.' + d.getUTCMilliseconds();
                return "[" + Log.getPriorityString(priority) + "] " + dateFormat + " \t " + tag + " \t " + msg;
            }
        }
        Log.View_DBG = false;
        Log.VelocityTracker_DBG = false;
        Log.DBG_DrawableContainer = false;
        Log.DBG_StateListDrawable = false;
        Log.VERBOSE = 2;
        Log.DEBUG = 3;
        Log.INFO = 4;
        Log.WARN = 5;
        Log.ERROR = 6;
        Log.ASSERT = 7;
        Log.PriorityString = ["VERBOSE", "DEBUG", "INFO", "WARN", "ERROR", "ASSERT"];
        util.Log = Log;
    })(util = android.util || (android.util = {}));
})(android || (android = {}));
var java;
(function (java) {
    var lang;
    (function (lang) {
        class StringBuilder {
            constructor(arg) {
                this.array = [];
                if (!Number.isInteger(arg) && arg) {
                    this.append(arg);
                }
            }
            length() {
                return this.array.length;
            }
            append(a) {
                let str = a + '';
                this.array.push(...str.split(''));
                return this;
            }
            deleteCharAt(index) {
                this.array.splice(index, 1);
                return this;
            }
            replace(start, end, str) {
                this.array.splice(start, end - start, ...str.split(''));
                return this;
            }
            setLength(length) {
                let arrayLength = this.array.length;
                if (length === arrayLength)
                    return;
                if (length < arrayLength) {
                    this.array = this.array.splice(length, arrayLength - length);
                }
                else {
                    for (let i = 0; i < arrayLength - length; i++) {
                        this.array.push('\0');
                    }
                }
            }
            toString() {
                return this.array.join('');
            }
        }
        lang.StringBuilder = StringBuilder;
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
///<reference path="../../java/lang/StringBuilder.ts"/>
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        var StringBuilder = java.lang.StringBuilder;
        class Rect {
            constructor(...args) {
                this.left = 0;
                this.top = 0;
                this.right = 0;
                this.bottom = 0;
                if (args.length === 1) {
                    let rect = args[0];
                    this.left = rect.left;
                    this.top = rect.top;
                    this.right = rect.right;
                    this.bottom = rect.bottom;
                }
                else if (args.length === 4 || args.length === 0) {
                    let [left = 0, top = 0, right = 0, bottom = 0] = args;
                    this.left = left;
                    this.top = top;
                    this.right = right;
                    this.bottom = bottom;
                }
            }
            equals(r) {
                if (this === r)
                    return true;
                if (!r || !(r instanceof Rect))
                    return false;
                return this.left === r.left && this.top === r.top
                    && this.right === r.right && this.bottom === r.bottom;
            }
            toString() {
                let sb = new StringBuilder();
                sb.append("Rect(");
                sb.append(this.left);
                sb.append(", ");
                sb.append(this.top);
                sb.append(" - ");
                sb.append(this.right);
                sb.append(", ");
                sb.append(this.bottom);
                sb.append(")");
                return sb.toString();
            }
            toShortString(sb = new StringBuilder()) {
                sb.setLength(0);
                sb.append('[');
                sb.append(this.left);
                sb.append(',');
                sb.append(this.top);
                sb.append("][");
                sb.append(this.right);
                sb.append(',');
                sb.append(this.bottom);
                sb.append(']');
                return sb.toString();
            }
            flattenToString() {
                let sb = new StringBuilder(32);
                sb.append(this.left);
                sb.append(' ');
                sb.append(this.top);
                sb.append(' ');
                sb.append(this.right);
                sb.append(' ');
                sb.append(this.bottom);
                return sb.toString();
            }
            static unflattenFromString(str) {
                let parts = str.split(" ");
                return new Rect(Number.parseInt(parts[0]), Number.parseInt(parts[1]), Number.parseInt(parts[2]), Number.parseInt(parts[3]));
            }
            isEmpty() {
                return this.left >= this.right || this.top >= this.bottom;
            }
            width() {
                return this.right - this.left;
            }
            height() {
                return this.bottom - this.top;
            }
            centerX() {
                return (this.left + this.right) >> 1;
            }
            centerY() {
                return (this.top + this.bottom) >> 1;
            }
            exactCenterX() {
                return (this.left + this.right) * 0.5;
            }
            exactCenterY() {
                return (this.top + this.bottom) * 0.5;
            }
            setEmpty() {
                this.left = this.right = this.top = this.bottom = 0;
            }
            set(...args) {
                if (args.length === 1) {
                    let rect = args[0];
                    [this.left, this.top, this.right, this.bottom] = [rect.left, rect.top, rect.right, rect.bottom];
                }
                else {
                    let [left = 0, top = 0, right = 0, bottom = 0] = args;
                    this.left = left;
                    this.top = top;
                    this.right = right;
                    this.bottom = bottom;
                }
            }
            offset(dx, dy) {
                this.left += dx;
                this.top += dy;
                this.right += dx;
                this.bottom += dy;
            }
            offsetTo(newLeft, newTop) {
                this.right += newLeft - this.left;
                this.bottom += newTop - this.top;
                this.left = newLeft;
                this.top = newTop;
            }
            inset(dx, dy) {
                this.left += dx;
                this.top += dy;
                this.right -= dx;
                this.bottom -= dy;
            }
            contains(...args) {
                if (args.length === 1) {
                    let r = args[0];
                    return this.left < this.right && this.top < this.bottom
                        && this.left <= r.left && this.top <= r.top && this.right >= r.right && this.bottom >= r.bottom;
                }
                else if (args.length === 2) {
                    let [x, y] = args;
                    return this.left < this.right && this.top < this.bottom
                        && x >= this.left && x < this.right && y >= this.top && y < this.bottom;
                }
                else {
                    let [left = 0, top = 0, right = 0, bottom = 0] = args;
                    return this.left < this.right && this.top < this.bottom
                        && this.left <= left && this.top <= top
                        && this.right >= right && this.bottom >= bottom;
                }
            }
            intersect(...args) {
                if (args.length === 1) {
                    let rect = args[0];
                    return this.intersect(rect.left, rect.top, rect.right, rect.bottom);
                }
                else {
                    let [left = 0, t = 0, right = 0, bottom = 0] = args;
                    if (this.left < right && left < this.right && this.top < bottom && t < this.bottom) {
                        if (this.left < left)
                            this.left = left;
                        if (this.top < t)
                            this.top = t;
                        if (this.right > right)
                            this.right = right;
                        if (this.bottom > bottom)
                            this.bottom = bottom;
                        return true;
                    }
                    return false;
                }
            }
            intersects(...args) {
                if (args.length === 1) {
                    let rect = args[0];
                    return this.intersects(rect.left, rect.top, rect.right, rect.bottom);
                }
                else {
                    let [left = 0, t = 0, right = 0, bottom = 0] = args;
                    return this.left < right && left < this.right && this.top < bottom && t < this.bottom;
                }
            }
            union(...args) {
                if (arguments.length === 1) {
                    let rect = args[0];
                    this.union(rect.left, rect.top, rect.right, rect.bottom);
                }
                else if (arguments.length === 2) {
                    let [x = 0, y = 0] = args;
                    if (x < this.left) {
                        this.left = x;
                    }
                    else if (x > this.right) {
                        this.right = x;
                    }
                    if (y < this.top) {
                        this.top = y;
                    }
                    else if (y > this.bottom) {
                        this.bottom = y;
                    }
                }
                else {
                    let [left = 0, top = 0, right = 0, bottom = 0] = args;
                    if ((left < right) && (top < bottom)) {
                        if ((this.left < this.right) && (this.top < this.bottom)) {
                            if (this.left > left)
                                this.left = left;
                            if (this.top > top)
                                this.top = top;
                            if (this.right < right)
                                this.right = right;
                            if (this.bottom < bottom)
                                this.bottom = bottom;
                        }
                        else {
                            this.left = left;
                            this.top = top;
                            this.right = right;
                            this.bottom = bottom;
                        }
                    }
                }
            }
            sort() {
                if (this.left > this.right) {
                    [this.left, this.right] = [this.right, this.left];
                }
                if (this.top > this.bottom) {
                    [this.top, this.bottom] = [this.bottom, this.top];
                }
            }
            scale(scale) {
                if (scale != 1) {
                    this.left = this.left * scale;
                    this.top = this.top * scale;
                    this.right = this.right * scale;
                    this.bottom = this.bottom * scale;
                }
            }
        }
        graphics.Rect = Rect;
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        class PixelFormat {
        }
        PixelFormat.UNKNOWN = 0;
        PixelFormat.TRANSLUCENT = -3;
        PixelFormat.TRANSPARENT = -2;
        PixelFormat.OPAQUE = -1;
        PixelFormat.RGBA_8888 = 1;
        PixelFormat.RGBX_8888 = 2;
        PixelFormat.RGB_888 = 3;
        PixelFormat.RGB_565 = 4;
        graphics.PixelFormat = PixelFormat;
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
var java;
(function (java) {
    var lang;
    (function (lang) {
        var ref;
        (function (ref) {
            class WeakReference {
                constructor(referent) {
                    this.weakMap = new WeakMap();
                    this.weakMap.set(this, referent);
                }
                get() {
                    return this.weakMap.get(this);
                }
                set(value) {
                    this.weakMap.set(this, value);
                }
                clear() {
                    this.weakMap.delete(this);
                }
            }
            ref.WeakReference = WeakReference;
        })(ref = lang.ref || (lang.ref = {}));
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
var java;
(function (java) {
    var lang;
    (function (lang) {
        class System {
            static currentTimeMillis() {
                return new Date().getTime();
            }
            static arraycopy(src, srcPos, dest, destPos, length) {
                let srcLength = src.length;
                let destLength = dest.length;
                for (let i = 0; i < length; i++) {
                    let srcIndex = i + srcPos;
                    if (srcIndex >= srcLength)
                        return;
                    let destIndex = i + destPos;
                    if (destIndex >= destLength)
                        return;
                    dest[destIndex] = src[srcIndex];
                }
            }
        }
        System.out = {
            println(any) {
                console.log('\n');
                console.log(any);
            },
            print(any) {
                console.log(any);
            }
        };
        lang.System = System;
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
/**
 * Created by linfaxin on 15/10/29.
 */
///<reference path="../../java/lang/System.ts"/>
var android;
(function (android) {
    var util;
    (function (util) {
        var System = java.lang.System;
        class StateSet {
            static isWildCard(stateSetOrSpec) {
                return stateSetOrSpec.length == 0 || stateSetOrSpec[0] == 0;
            }
            static stateSetMatches(stateSpec, stateSetOrState) {
                if (Number.isInteger(stateSetOrState)) {
                    return StateSet._stateSetMatches_single(stateSpec, stateSetOrState);
                }
                let stateSet = stateSetOrState;
                if (stateSet == null) {
                    return (stateSpec == null || this.isWildCard(stateSpec));
                }
                let stateSpecSize = stateSpec.length;
                let stateSetSize = stateSet.length;
                for (let i = 0; i < stateSpecSize; i++) {
                    let stateSpecState = stateSpec[i];
                    if (stateSpecState == 0) {
                        return true;
                    }
                    let mustMatch;
                    if (stateSpecState > 0) {
                        mustMatch = true;
                    }
                    else {
                        mustMatch = false;
                        stateSpecState = -stateSpecState;
                    }
                    let found = false;
                    for (let j = 0; j < stateSetSize; j++) {
                        const state = stateSet[j];
                        if (state == 0) {
                            if (mustMatch) {
                                return false;
                            }
                            else {
                                break;
                            }
                        }
                        if (state == stateSpecState) {
                            if (mustMatch) {
                                found = true;
                                break;
                            }
                            else {
                                return false;
                            }
                        }
                    }
                    if (mustMatch && !found) {
                        return false;
                    }
                }
                return true;
            }
            static _stateSetMatches_single(stateSpec, state) {
                let stateSpecSize = stateSpec.length;
                for (let i = 0; i < stateSpecSize; i++) {
                    let stateSpecState = stateSpec[i];
                    if (stateSpecState == 0) {
                        return true;
                    }
                    if (stateSpecState > 0) {
                        if (state != stateSpecState) {
                            return false;
                        }
                    }
                    else {
                        if (state == -stateSpecState) {
                            return false;
                        }
                    }
                }
                return true;
            }
            static trimStateSet(states, newSize) {
                if (states.length == newSize) {
                    return states;
                }
                let trimmedStates = new Array(newSize);
                System.arraycopy(states, 0, trimmedStates, 0, newSize);
                return trimmedStates;
            }
        }
        StateSet.WILD_CARD = [];
        StateSet.NOTHING = [0];
        util.StateSet = StateSet;
    })(util = android.util || (android.util = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/3.
 */
///<reference path="../Rect.ts"/>
///<reference path="../PixelFormat.ts"/>
///<reference path="../../../java/lang/ref/WeakReference.ts"/>
///<reference path="../../../java/lang/Runnable.ts"/>
///<reference path="../../util/StateSet.ts"/>
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        var drawable;
        (function (drawable) {
            var Rect = android.graphics.Rect;
            var PixelFormat = android.graphics.PixelFormat;
            var WeakReference = java.lang.ref.WeakReference;
            var StateSet = android.util.StateSet;
            class Drawable {
                constructor() {
                    this.mBounds = Drawable.ZERO_BOUNDS_RECT;
                    this.mStateSet = StateSet.WILD_CARD;
                    this.mLevel = 0;
                    this.mVisible = true;
                }
                draw(canvas) {
                }
                setBounds(...args) {
                    if (args.length === 1) {
                        let rect = args[0];
                        return this.setBounds(rect.left, rect.top, rect.right, rect.bottom);
                    }
                    else {
                        let [left = 0, top = 0, right = 0, bottom = 0] = args;
                        let oldBounds = this.mBounds;
                        if (oldBounds == Drawable.ZERO_BOUNDS_RECT) {
                            oldBounds = this.mBounds = new Rect();
                        }
                        if (oldBounds.left != left || oldBounds.top != top ||
                            oldBounds.right != right || oldBounds.bottom != bottom) {
                            if (!oldBounds.isEmpty()) {
                                this.invalidateSelf();
                            }
                            this.mBounds.set(left, top, right, bottom);
                            this.onBoundsChange(this.mBounds);
                        }
                    }
                }
                copyBounds(bounds = new Rect()) {
                    bounds.set(this.mBounds);
                    return bounds;
                }
                getBounds() {
                    if (this.mBounds == Drawable.ZERO_BOUNDS_RECT) {
                        this.mBounds = new Rect();
                    }
                    return this.mBounds;
                }
                setDither(dither) { }
                setCallback(cb) {
                    this.mCallback = new WeakReference(cb);
                }
                getCallback() {
                    if (this.mCallback != null) {
                        return this.mCallback.get();
                    }
                    return null;
                }
                invalidateSelf() {
                    let callback = this.getCallback();
                    if (callback != null) {
                        callback.invalidateDrawable(this);
                    }
                }
                scheduleSelf(what, when) {
                    let callback = this.getCallback();
                    if (callback != null) {
                        callback.scheduleDrawable(this, what, when);
                    }
                }
                unscheduleSelf(what) {
                    let callback = this.getCallback();
                    if (callback != null) {
                        callback.unscheduleDrawable(this, what);
                    }
                }
                setAlpha(alpha) {
                }
                getAlpha() {
                    return 0xFF;
                }
                isStateful() {
                    return false;
                }
                setState(stateSet) {
                    if (this.mStateSet + '' !== stateSet + '') {
                        this.mStateSet = stateSet;
                        return this.onStateChange(stateSet);
                    }
                    return false;
                }
                getState() {
                    return this.mStateSet;
                }
                jumpToCurrentState() {
                }
                getCurrent() {
                    return this;
                }
                setLevel(level) {
                    if (this.mLevel != level) {
                        this.mLevel = level;
                        return this.onLevelChange(level);
                    }
                    return false;
                }
                getLevel() {
                    return this.mLevel;
                }
                setVisible(visible, restart) {
                    let changed = this.mVisible != visible;
                    if (changed) {
                        this.mVisible = visible;
                        this.invalidateSelf();
                    }
                    return changed;
                }
                isVisible() {
                    return this.mVisible;
                }
                setAutoMirrored(mirrored) {
                }
                isAutoMirrored() {
                    return false;
                }
                getOpacity() {
                    return PixelFormat.TRANSLUCENT;
                }
                static resolveOpacity(op1, op2) {
                    if (op1 == op2) {
                        return op1;
                    }
                    if (op1 == PixelFormat.UNKNOWN || op2 == PixelFormat.UNKNOWN) {
                        return PixelFormat.UNKNOWN;
                    }
                    if (op1 == PixelFormat.TRANSLUCENT || op2 == PixelFormat.TRANSLUCENT) {
                        return PixelFormat.TRANSLUCENT;
                    }
                    if (op1 == PixelFormat.TRANSPARENT || op2 == PixelFormat.TRANSPARENT) {
                        return PixelFormat.TRANSPARENT;
                    }
                    return PixelFormat.OPAQUE;
                }
                onStateChange(state) {
                    return false;
                }
                onLevelChange(level) {
                    return false;
                }
                onBoundsChange(bounds) {
                }
                getIntrinsicWidth() {
                    return -1;
                }
                getIntrinsicHeight() {
                    return -1;
                }
                getMinimumWidth() {
                    let intrinsicWidth = this.getIntrinsicWidth();
                    return intrinsicWidth > 0 ? intrinsicWidth : 0;
                }
                getMinimumHeight() {
                    let intrinsicHeight = this.getIntrinsicHeight();
                    return intrinsicHeight > 0 ? intrinsicHeight : 0;
                }
                getPadding(padding) {
                    padding.set(0, 0, 0, 0);
                    return false;
                }
                mutate() {
                    return this;
                }
                getConstantState() {
                    return null;
                }
            }
            Drawable.ZERO_BOUNDS_RECT = new Rect();
            drawable.Drawable = Drawable;
        })(drawable = graphics.drawable || (graphics.drawable = {}));
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
var android;
(function (android) {
    var util;
    (function (util) {
        class Pools {
        }
        util.Pools = Pools;
        (function (Pools) {
            class SimplePool {
                constructor(maxPoolSize) {
                    this.mPoolSize = 0;
                    if (maxPoolSize <= 0) {
                        throw new Error("The max pool size must be > 0");
                    }
                    this.mPool = new Array(maxPoolSize);
                }
                acquire() {
                    if (this.mPoolSize > 0) {
                        const lastPooledIndex = this.mPoolSize - 1;
                        let instance = this.mPool[lastPooledIndex];
                        this.mPool[lastPooledIndex] = null;
                        this.mPoolSize--;
                        return instance;
                    }
                    return null;
                }
                release(instance) {
                    if (this.isInPool(instance)) {
                        throw new Error("Already in the pool!");
                    }
                    if (this.mPoolSize < this.mPool.length) {
                        this.mPool[this.mPoolSize] = instance;
                        this.mPoolSize++;
                        return true;
                    }
                    return false;
                }
                isInPool(instance) {
                    for (let i = 0; i < this.mPoolSize; i++) {
                        if (this.mPool[i] == instance) {
                            return true;
                        }
                    }
                    return false;
                }
            }
            Pools.SimplePool = SimplePool;
            class SynchronizedPool extends SimplePool {
            }
            Pools.SynchronizedPool = SynchronizedPool;
        })(Pools = util.Pools || (util.Pools = {}));
    })(util = android.util || (android.util = {}));
})(android || (android = {}));
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        class Color {
            static alpha(color) {
                return color >>> 24;
            }
            static red(color) {
                return (color >> 16) & 0xFF;
            }
            static green(color) {
                return (color >> 8) & 0xFF;
            }
            static blue(color) {
                return color & 0xFF;
            }
            static rgb(red, green, blue) {
                return (0xFF << 24) | (red << 16) | (green << 8) | blue;
            }
            static argb(alpha, red, green, blue) {
                return (alpha << 24) | (red << 16) | (green << 8) | blue;
            }
            static rgba(red, green, blue, alpha) {
                return (alpha << 24) | (red << 16) | (green << 8) | blue;
            }
            static parseColor(colorString) {
                if (colorString.charAt(0) == '#') {
                    let color = parseInt(colorString.substring(1), 16);
                    if (colorString.length == 7) {
                        color |= 0x00000000ff000000;
                    }
                    else if (colorString.length != 9) {
                        throw new Error("Unknown color");
                    }
                    return color;
                }
                else {
                    let color = Color.sColorNameMap.get(colorString.toLowerCase());
                    if (color != null) {
                        return color;
                    }
                }
                throw new Error("Unknown color");
            }
            static toARGBHex(color) {
                let r = Color.red(color);
                let g = Color.green(color);
                let b = Color.blue(color);
                let a = Color.alpha(color);
                let hR = r < 16 ? '0' + r.toString(16) : r.toString(16);
                let hG = g < 16 ? '0' + g.toString(16) : g.toString(16);
                let hB = b < 16 ? '0' + b.toString(16) : b.toString(16);
                let hA = a < 16 ? '0' + a.toString(16) : a.toString(16);
                return "#" + hA + hR + hG + hB;
            }
            static toRGBAFunc(color) {
                let r = Color.red(color);
                let g = Color.green(color);
                let b = Color.blue(color);
                let a = Color.alpha(color);
                return `rgba(${r},${g},${b},${a / 255})`;
            }
            static getHtmlColor(color) {
                let i = Color.sColorNameMap.get(color.toLowerCase());
                return i;
            }
        }
        Color.BLACK = 0xFF000000;
        Color.DKGRAY = 0xFF444444;
        Color.GRAY = 0xFF888888;
        Color.LTGRAY = 0xFFCCCCCC;
        Color.WHITE = 0xFFFFFFFF;
        Color.RED = 0xFFFF0000;
        Color.GREEN = 0xFF00FF00;
        Color.BLUE = 0xFF0000FF;
        Color.YELLOW = 0xFFFFFF00;
        Color.CYAN = 0xFF00FFFF;
        Color.MAGENTA = 0xFFFF00FF;
        Color.TRANSPARENT = 0;
        Color.sColorNameMap = new Map();
        graphics.Color = Color;
        Color.sColorNameMap = new Map();
        Color.sColorNameMap.set("black", Color.BLACK);
        Color.sColorNameMap.set("darkgray", Color.DKGRAY);
        Color.sColorNameMap.set("gray", Color.GRAY);
        Color.sColorNameMap.set("lightgray", Color.LTGRAY);
        Color.sColorNameMap.set("white", Color.WHITE);
        Color.sColorNameMap.set("red", Color.RED);
        Color.sColorNameMap.set("green", Color.GREEN);
        Color.sColorNameMap.set("blue", Color.BLUE);
        Color.sColorNameMap.set("yellow", Color.YELLOW);
        Color.sColorNameMap.set("cyan", Color.CYAN);
        Color.sColorNameMap.set("magenta", Color.MAGENTA);
        Color.sColorNameMap.set("aqua", 0xFF00FFFF);
        Color.sColorNameMap.set("fuchsia", 0xFFFF00FF);
        Color.sColorNameMap.set("darkgrey", Color.DKGRAY);
        Color.sColorNameMap.set("grey", Color.GRAY);
        Color.sColorNameMap.set("lightgrey", Color.LTGRAY);
        Color.sColorNameMap.set("lime", 0xFF00FF00);
        Color.sColorNameMap.set("maroon", 0xFF800000);
        Color.sColorNameMap.set("navy", 0xFF000080);
        Color.sColorNameMap.set("olive", 0xFF808000);
        Color.sColorNameMap.set("purple", 0xFF800080);
        Color.sColorNameMap.set("silver", 0xFFC0C0C0);
        Color.sColorNameMap.set("teal", 0xFF008080);
        Color.sColorNameMap.set("transparent", Color.TRANSPARENT);
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/29.
 */
///<reference path="Canvas.ts"/>
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        class Paint {
            constructor(flag = 0) {
                this.mFlag = 0;
                this.shadowDx = 0;
                this.shadowDy = 0;
                this.shadowRadius = 0;
                this.shadowColor = 0;
                this.mFlag = flag;
            }
            set(src) {
                if (this != src) {
                    this.setClassVariablesFrom(src);
                }
            }
            setClassVariablesFrom(paint) {
                Object.assign(this, paint);
            }
            getStyle() {
                return this.mTextStyle;
            }
            setStyle(style) {
                this.mTextStyle = style;
            }
            getFlags() {
                return this.mFlag;
            }
            setFlags(flags) {
                this.mFlag = flags;
            }
            getTextScaleX() {
                return 1;
            }
            setTextScaleX(scaleX) {
            }
            getColor() {
                return this.mColor;
            }
            setColor(color) {
                this.mColor = color;
            }
            setARGB(a, r, g, b) {
                this.setColor((a << 24) | (r << 16) | (g << 8) | b);
            }
            getAlpha() {
                return this.mAlpha;
            }
            setAlpha(alpha) {
                this.mAlpha = alpha;
            }
            getStrokeWidth() {
                return this.mStrokeWidth;
            }
            setStrokeWidth(width) {
                this.mStrokeWidth = width;
            }
            getStrokeCap() {
                return this.mStrokeCap;
            }
            setStrokeCap(cap) {
                this.mStrokeCap = cap;
            }
            getStrokeJoin() {
                return this.mStrokeJoin;
            }
            setStrokeJoin(join) {
                this.mStrokeJoin = join;
            }
            setAntiAlias(enable) {
            }
            isAntiAlias() {
                return true;
            }
            setShadowLayer(radius, dx, dy, color) {
                this.hasShadow = radius > 0.0;
                this.shadowRadius = radius;
                this.shadowDx = dx;
                this.shadowDy = dy;
                this.shadowColor = color;
            }
            clearShadowLayer() {
                this.hasShadow = false;
            }
            getTextAlign() {
                return this.align;
            }
            setTextAlign(align) {
                this.align = align;
            }
            getTextSize() {
                return this.textSize;
            }
            setTextSize(textSize) {
                this.textSize = textSize;
            }
            ascent() {
                return this.textSize * Paint.FontMetrics_Size_Ascent;
            }
            descent() {
                return this.textSize * Paint.FontMetrics_Size_Descent;
            }
            getFontMetricsInt(fmi) {
                if (fmi == null) {
                    return Math.floor((Paint.FontMetrics_Size_Descent - Paint.FontMetrics_Size_Ascent) * this.textSize);
                }
                fmi.ascent = Math.floor(Paint.FontMetrics_Size_Ascent * this.textSize);
                fmi.bottom = Math.floor(Paint.FontMetrics_Size_Bottom * this.textSize);
                fmi.descent = Math.floor(Paint.FontMetrics_Size_Descent * this.textSize);
                fmi.leading = Math.floor(Paint.FontMetrics_Size_Leading * this.textSize);
                fmi.top = Math.floor(Paint.FontMetrics_Size_Top * this.textSize);
                return fmi.descent - fmi.ascent;
            }
            getFontMetrics(metrics) {
                if (metrics == null) {
                    return (Paint.FontMetrics_Size_Descent - Paint.FontMetrics_Size_Ascent) * this.textSize;
                }
                metrics.ascent = Paint.FontMetrics_Size_Ascent * this.textSize;
                metrics.bottom = Paint.FontMetrics_Size_Bottom * this.textSize;
                metrics.descent = Paint.FontMetrics_Size_Descent * this.textSize;
                metrics.leading = Paint.FontMetrics_Size_Leading * this.textSize;
                metrics.top = Paint.FontMetrics_Size_Top * this.textSize;
                return metrics.descent - metrics.ascent;
            }
            measureText(text, index = 0, count = text.length) {
                if (this.textSize != Paint._measureTextSize) {
                    Paint._measureTextSize = this.textSize;
                    if (this.textSize != null) {
                        let fontParts = Paint._measureTextContext.font.split(' ');
                        Paint._measureTextContext.font = this.textSize + 'px ' + fontParts[fontParts.length - 1];
                    }
                    else {
                        Paint._measureTextContext.font = '';
                    }
                }
                return Paint._measureTextContext.measureText(text.substr(index, count)).width;
            }
            getTextWidths_count(text, index, count, widths) {
                return this.getTextWidths_end(text, index, index + count, widths);
            }
            getTextWidths_end(text, start, end, widths) {
                if (text == null) {
                    throw Error(`new IllegalArgumentException("text cannot be null")`);
                }
                if ((start | end | (end - start) | (text.length - end)) < 0) {
                    throw Error(`new IndexOutOfBoundsException()`);
                }
                if (end - start > widths.length) {
                    throw Error(`new ArrayIndexOutOfBoundsException()`);
                }
                if (text.length == 0 || start == end) {
                    return 0;
                }
                for (let i = start; i < end; i++) {
                    widths[i - start] = this.measureText(text[i]);
                }
                return end - start;
            }
            getTextWidths_2(text, widths) {
                return this.getTextWidths_end(text, 0, text.length, widths);
            }
            getTextRunAdvances_count(chars, index, count, contextIndex, contextCount, flags, advances, advancesIndex) {
                return this.getTextRunAdvances_end(chars, index, index + count, contextIndex, contextCount, flags, advances, advancesIndex);
            }
            getTextRunAdvances_end(text, start, end, contextStart, contextEnd, flags, advances, advancesIndex) {
                if (text == null) {
                    throw Error(`new IllegalArgumentException("text cannot be null")`);
                }
                if (flags != Paint.DIRECTION_LTR && flags != Paint.DIRECTION_RTL) {
                    throw Error(`new IllegalArgumentException("unknown flags value: " + flags)`);
                }
                if ((start | end | contextStart | contextEnd | advancesIndex | (end - start)
                    | (start - contextStart) | (contextEnd - end) | (text.length - contextEnd)
                    | (advances == null ? 0 : (advances.length - advancesIndex - (end - start)))) < 0) {
                    throw Error(`new IndexOutOfBoundsException()`);
                }
                if (text.length == 0 || start == end) {
                    return 0;
                }
                let totalAdvance = 0;
                for (let i = start; i < end; i++) {
                    let width = this.measureText(text[i]);
                    if (advances)
                        advances[i - start + advancesIndex] = width;
                    totalAdvance += width;
                }
                return totalAdvance;
            }
            getTextRunCursor_len(text, contextStart, contextLength, flags, offset, cursorOpt) {
                let contextEnd = contextStart + contextLength;
                if (((contextStart | contextEnd | offset | (contextEnd - contextStart) | (offset - contextStart) | (contextEnd - offset)
                    | (text.length - contextEnd) | cursorOpt) < 0) || cursorOpt > Paint.CURSOR_OPT_MAX_VALUE) {
                    throw Error(`new IndexOutOfBoundsException()`);
                }
                const scalarArray = new Array(contextLength);
                this.getTextRunAdvances_count(text, contextStart, contextLength, contextStart, contextLength, flags, scalarArray, 0);
                let pos = offset - contextStart;
                switch (cursorOpt) {
                    case Paint.CURSOR_AFTER:
                        if (pos < contextLength) {
                            pos += 1;
                        }
                    case Paint.CURSOR_AT_OR_AFTER:
                        while (pos < contextLength && scalarArray[pos] == 0) {
                            ++pos;
                        }
                        break;
                    case Paint.CURSOR_BEFORE:
                        if (pos > 0) {
                            --pos;
                        }
                    case Paint.CURSOR_AT_OR_BEFORE:
                        while (pos > 0 && scalarArray[pos] == 0) {
                            --pos;
                        }
                        break;
                    case Paint.CURSOR_AT:
                    default:
                        if (scalarArray[pos] == 0) {
                            pos = -1;
                        }
                        break;
                }
                if (pos != -1) {
                    pos += contextStart;
                }
                return pos;
            }
            getTextRunCursor_end(text, contextStart, contextEnd, flags, offset, cursorOpt) {
                if (((contextStart | contextEnd | offset | (contextEnd - contextStart) | (offset - contextStart) | (contextEnd - offset)
                    | (text.length - contextEnd) | cursorOpt) < 0) || cursorOpt > Paint.CURSOR_OPT_MAX_VALUE) {
                    throw Error(`new IndexOutOfBoundsException()`);
                }
                let contextLen = contextEnd - contextStart;
                return this.getTextRunCursor_len(text, 0, contextLen, flags, offset - contextStart, cursorOpt);
            }
            _setToCanvasContent(context) {
                if (Number.isInteger(this.mColor)) {
                    context.fillStyle = graphics.Color.toRGBAFunc(this.mColor);
                }
                if (this.align != null) {
                    context.textAlign = Paint.Align[this.align].toLowerCase();
                }
                if (this.mStrokeWidth != null) {
                    context.lineWidth = this.mStrokeWidth;
                }
                if (this.mStrokeCap != null) {
                    context.lineCap = Paint.Cap[this.mStrokeCap].toLowerCase();
                }
                if (this.mStrokeJoin != null) {
                    context.lineJoin = Paint.Join[this.mStrokeJoin].toLowerCase();
                }
                if (this.hasShadow) {
                    context.shadowBlur = this.shadowRadius;
                    context.shadowOffsetX = this.shadowDx;
                    context.shadowOffsetY = this.shadowDy;
                    context.shadowColor = graphics.Color.toRGBAFunc(this.shadowColor);
                }
                const fontStyles = [];
                if (this.textSize != null) {
                    fontStyles.push(this.textSize + 'px');
                }
                if (fontStyles.length > 0) {
                    let cFont = context.font;
                    let fontParts = cFont.split(' ');
                    fontStyles.push(fontParts[fontParts.length - 1]);
                    let font = fontStyles.join(' ');
                    if (font != cFont)
                        context.font = font;
                }
            }
        }
        Paint.FontMetrics_Size_Ascent = -0.9277344;
        Paint.FontMetrics_Size_Bottom = 0.2709961;
        Paint.FontMetrics_Size_Descent = 0.24414062;
        Paint.FontMetrics_Size_Leading = 0;
        Paint.FontMetrics_Size_Top = -1.05615234;
        Paint.DIRECTION_LTR = 0;
        Paint.DIRECTION_RTL = 1;
        Paint.CURSOR_AFTER = 0;
        Paint.CURSOR_AT_OR_AFTER = 1;
        Paint.CURSOR_BEFORE = 2;
        Paint.CURSOR_AT_OR_BEFORE = 3;
        Paint.CURSOR_AT = 4;
        Paint.CURSOR_OPT_MAX_VALUE = Paint.CURSOR_AT;
        Paint.ANTI_ALIAS_FLAG = 0x01;
        Paint.FILTER_BITMAP_FLAG = 0x02;
        Paint.DITHER_FLAG = 0x04;
        Paint.UNDERLINE_TEXT_FLAG = 0x08;
        Paint.STRIKE_THRU_TEXT_FLAG = 0x10;
        Paint.FAKE_BOLD_TEXT_FLAG = 0x20;
        Paint.LINEAR_TEXT_FLAG = 0x40;
        Paint.SUBPIXEL_TEXT_FLAG = 0x80;
        Paint.DEV_KERN_TEXT_FLAG = 0x100;
        Paint.LCD_RENDER_TEXT_FLAG = 0x200;
        Paint.EMBEDDED_BITMAP_TEXT_FLAG = 0x400;
        Paint.AUTO_HINTING_TEXT_FLAG = 0x800;
        Paint.VERTICAL_TEXT_FLAG = 0x1000;
        Paint.DEFAULT_PAINT_FLAGS = Paint.DEV_KERN_TEXT_FLAG | Paint.EMBEDDED_BITMAP_TEXT_FLAG;
        Paint._measureTextContext = document.createElement('canvas').getContext('2d');
        Paint._measureTextSize = -1;
        graphics.Paint = Paint;
        (function (Paint) {
            (function (Align) {
                Align[Align["LEFT"] = 0] = "LEFT";
                Align[Align["CENTER"] = 1] = "CENTER";
                Align[Align["RIGHT"] = 2] = "RIGHT";
            })(Paint.Align || (Paint.Align = {}));
            var Align = Paint.Align;
            class FontMetrics {
                constructor() {
                    this.top = 0;
                    this.ascent = 0;
                    this.descent = 0;
                    this.bottom = 0;
                    this.leading = 0;
                }
            }
            Paint.FontMetrics = FontMetrics;
            class FontMetricsInt {
                constructor() {
                    this.top = 0;
                    this.ascent = 0;
                    this.descent = 0;
                    this.bottom = 0;
                    this.leading = 0;
                }
                toString() {
                    return "FontMetricsInt: top=" + this.top + " ascent=" + this.ascent + " descent=" + this.descent + " bottom=" + this.bottom + " leading=" + this.leading;
                }
            }
            Paint.FontMetricsInt = FontMetricsInt;
            (function (Style) {
                Style[Style["FILL"] = 0] = "FILL";
                Style[Style["STROKE"] = 1] = "STROKE";
                Style[Style["FILL_AND_STROKE"] = 2] = "FILL_AND_STROKE";
            })(Paint.Style || (Paint.Style = {}));
            var Style = Paint.Style;
            (function (Cap) {
                Cap[Cap["BUTT"] = 0] = "BUTT";
                Cap[Cap["ROUND"] = 1] = "ROUND";
                Cap[Cap["SQUARE"] = 2] = "SQUARE";
            })(Paint.Cap || (Paint.Cap = {}));
            var Cap = Paint.Cap;
            (function (Join) {
                Join[Join["MITER"] = 0] = "MITER";
                Join[Join["ROUND"] = 1] = "ROUND";
                Join[Join["BEVEL"] = 2] = "BEVEL";
            })(Paint.Join || (Paint.Join = {}));
            var Join = Paint.Join;
        })(Paint = graphics.Paint || (graphics.Paint = {}));
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        class Path {
            reset() {
            }
        }
        graphics.Path = Path;
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
///<reference path="../util/Pools.ts"/>
///<reference path="../util/Log.ts"/>
///<reference path="Rect.ts"/>
///<reference path="Color.ts"/>
///<reference path="Paint.ts"/>
///<reference path="Path.ts"/>
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        var Pools = android.util.Pools;
        var Rect = android.graphics.Rect;
        var Color = android.graphics.Color;
        class Canvas {
            constructor(width, height) {
                this.mWidth = 0;
                this.mHeight = 0;
                this._saveCount = 0;
                this.shouldDoRectBeforeRestoreMap = new Map();
                this.mClipStateMap = new Map();
                this.mWidth = width;
                this.mHeight = height;
                this.init();
            }
            static obtainRect(copy) {
                let rect = Canvas.sRectPool.acquire();
                if (!rect)
                    rect = new Rect();
                if (copy)
                    rect.set(copy);
                return rect;
            }
            static recycleRect(...rects) {
                for (let rect of rects) {
                    rect.setEmpty();
                    Canvas.sRectPool.release(rect);
                }
            }
            init() {
                this.mCanvasElement = document.createElement("canvas");
                this.mCanvasElement.width = this.mWidth;
                this.mCanvasElement.height = this.mHeight;
                this._mCanvasContent = this.mCanvasElement.getContext("2d");
                this.mCurrentClip = Canvas.obtainRect();
                this.mCurrentClip.set(0, 0, this.mWidth, this.mHeight);
                this._saveCount = 0;
                this.fullRectForClip();
                this.save();
            }
            recycle() {
                Canvas.recycleRect(this.mCurrentClip);
                Canvas.recycleRect(...this.mClipStateMap.values());
                for (let rects of this.shouldDoRectBeforeRestoreMap.values()) {
                    Canvas.recycleRect(...rects);
                }
                this.mCanvasElement.width = this.mCanvasElement.height = 0;
            }
            get canvasElement() {
                return this.mCanvasElement;
            }
            getHeight() {
                return this.mHeight;
            }
            getWidth() {
                return this.mWidth;
            }
            translate(dx, dy) {
                if (this.mCurrentClip)
                    this.mCurrentClip.offset(-dx, -dy);
                this._mCanvasContent.translate(dx, dy);
            }
            scale(sx, sy, px, py) {
                if (px && py)
                    this.translate(px, py);
                this._mCanvasContent.scale(sx, sy);
                if (px && py)
                    this.translate(-px, -py);
            }
            rotate(degrees, px, py) {
                if (px && py)
                    this.translate(px, py);
                this._mCanvasContent.rotate(degrees);
                if (px && py)
                    this.translate(-px, -py);
            }
            drawRGB(r, g, b) {
                this._mCanvasContent.fillStyle = `rgb(${r},${g},${b})`;
                this._mCanvasContent.fillRect(this.mCurrentClip.left, this.mCurrentClip.top, this.mCurrentClip.width(), this.mCurrentClip.height());
            }
            drawARGB(a, r, g, b) {
                this._mCanvasContent.fillStyle = `rgba(${r},${g},${b},${a / 255})`;
                this._mCanvasContent.fillRect(this.mCurrentClip.left, this.mCurrentClip.top, this.mCurrentClip.width(), this.mCurrentClip.height());
            }
            drawColor(color) {
                this.drawARGB(Color.alpha(color), Color.red(color), Color.green(color), Color.blue(color));
            }
            clearColor() {
                this._mCanvasContent.clearRect(this.mCurrentClip.left, this.mCurrentClip.top, this.mCurrentClip.width(), this.mCurrentClip.height());
            }
            save() {
                this._mCanvasContent.save();
                if (this.mCurrentClip)
                    this.mClipStateMap.set(this._saveCount, Canvas.obtainRect(this.mCurrentClip));
                this._saveCount++;
                return this._saveCount;
            }
            restore() {
                //let doRects = this.shouldDoRectBeforeRestoreMap.get(this._saveCount);
                //if(doRects && doRects.length>0){
                //    doRects.forEach((rect:Rect)=>{
                //        this._mCanvasContent.rect(rect.left, rect.top, rect.width(), rect.height());
                //    });
                //    if(doRects.length%2 == 1){
                //        this.fullRectForClip();
                //    }
                //    while(doRects.length>0){
                //        Canvas.recycleRect(doRects.pop());
                //    }
                //}
                this._saveCount--;
                this._mCanvasContent.restore();
                let savedClip = this.mClipStateMap.get(this._saveCount);
                if (savedClip) {
                    this.mClipStateMap.delete(this._saveCount);
                    this.mCurrentClip.set(savedClip);
                    Canvas.recycleRect(savedClip);
                }
            }
            restoreToCount(saveCount) {
                if (saveCount <= 0)
                    throw Error('saveCount can\'t <= 0');
                while (saveCount <= this._saveCount) {
                    this.restore();
                }
            }
            getSaveCount() {
                return this._saveCount;
            }
            fullRectForClip() {
            }
            clipRect(...args) {
                let rect = Canvas.obtainRect();
                if (args.length === 1) {
                    rect.set(args[0]);
                }
                else {
                    let [left = 0, top = 0, right = 0, bottom = 0] = args;
                    rect.set(left, top, right, bottom);
                }
                this.mCurrentClip.intersect(rect);
                return rect.isEmpty();
            }
            getClipBounds(bounds) {
                if (!this.mCurrentClip)
                    this.mCurrentClip = Canvas.obtainRect();
                let rect = bounds || Canvas.obtainRect();
                rect.set(this.mCurrentClip);
                return rect;
            }
            quickReject(...args) {
                if (!this.mCurrentClip)
                    return false;
                if (args.length == 1) {
                    return !this.mCurrentClip.intersects(args[0]);
                }
                else {
                    let [left = 0, t = 0, right = 0, bottom = 0] = args;
                    return !this.mCurrentClip.intersects(left, t, right, bottom);
                }
            }
            drawCanvas(canvas, offsetX, offsetY) {
                this._mCanvasContent.drawImage(canvas.canvasElement, offsetX, offsetY);
            }
            drawRect(...args) {
                if (args.length == 2) {
                    let rect = args[0];
                    this.drawRect(rect.left, rect.top, rect.right, rect.bottom, args[1]);
                }
                else {
                    let [left, top, right, bottom, paint] = args;
                    this._mCanvasContent.save();
                    paint._setToCanvasContent(this._mCanvasContent);
                    this._mCanvasContent.fillRect(left, top, right - left, bottom - top);
                    this._mCanvasContent.restore();
                }
            }
            drawPath(path, paint) {
            }
            drawText_count(text, index, count, x, y, paint) {
                if ((index | count | (index + count) | (text.length - index - count)) < 0) {
                    throw Error(`new IndexOutOfBoundsException()`);
                }
                this.drawText(text.substr(index, count), x, y, paint);
            }
            drawText_end(text, start, end, x, y, paint) {
                if ((start | end | (end - start) | (text.length - end)) < 0) {
                    throw Error(`new IndexOutOfBoundsException()`);
                }
                this.drawText(text.substring(start, end), x, y, paint);
            }
            drawText(text, x, y, paint) {
                this._mCanvasContent.save();
                if (paint) {
                    paint._setToCanvasContent(this._mCanvasContent);
                    switch (paint.getStyle()) {
                        case graphics.Paint.Style.STROKE:
                            this._mCanvasContent.strokeText(text, x, y);
                            break;
                        case graphics.Paint.Style.FILL_AND_STROKE:
                            this._mCanvasContent.strokeText(text, x, y);
                            this._mCanvasContent.fillText(text, x, y);
                            break;
                        case graphics.Paint.Style.FILL:
                        default:
                            this._mCanvasContent.fillText(text, x, y);
                            break;
                    }
                }
                else {
                    this._mCanvasContent.fillText(text, x, y);
                }
                this._mCanvasContent.restore();
            }
            drawTextRun_count(text, index, count, contextIndex, contextCount, x, y, dir, paint) {
                this.drawText_count(text, index, count, x, y, paint);
            }
            drawTextRun_end(text, start, end, contextStart, contextEnd, x, y, dir, paint) {
                this.drawText_end(text, start, end, x, y, paint);
            }
        }
        Canvas.FullRect = new Rect(-1000000000, -1000000000, 1000000000, 1000000000);
        Canvas.DIRECTION_LTR = 0;
        Canvas.DIRECTION_RTL = 1;
        Canvas.sRectPool = new Pools.SynchronizedPool(100);
        graphics.Canvas = Canvas;
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/29.
 */
///<reference path="Drawable.ts"/>
///<reference path="../Canvas.ts"/>
///<reference path="../Paint.ts"/>
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        var drawable;
        (function (drawable) {
            class ColorDrawable extends drawable.Drawable {
                constructor(color) {
                    super();
                    this.mMutated = false;
                    this.mPaint = new graphics.Paint();
                    this.mState = new ColorState();
                    if (color !== undefined) {
                        this.setColor(color);
                    }
                }
                _setStateCopyFrom(state) {
                    this.mState = new ColorState(state);
                }
                mutate() {
                    if (!this.mMutated && super.mutate() == this) {
                        this.mState = new ColorState(this.mState);
                        this.mMutated = true;
                    }
                    return this;
                }
                draw(canvas) {
                    if ((this.mState.mUseColor >>> 24) != 0) {
                        this.mPaint.setColor(this.mState.mUseColor);
                        canvas.drawRect(this.getBounds(), this.mPaint);
                    }
                }
                getColor() {
                    return this.mState.mUseColor;
                }
                setColor(color) {
                    if (this.mState.mBaseColor != color || this.mState.mUseColor != color) {
                        this.invalidateSelf();
                        this.mState.mBaseColor = this.mState.mUseColor = color;
                    }
                }
                getAlpha() {
                    return this.mState.mUseColor >>> 24;
                }
                setAlpha(alpha) {
                    alpha += alpha >> 7;
                    let baseAlpha = this.mState.mBaseColor >>> 24;
                    let useAlpha = baseAlpha * alpha >> 8;
                    let oldUseColor = this.mState.mUseColor;
                    this.mState.mUseColor = (this.mState.mBaseColor << 8 >>> 8) | (useAlpha << 24);
                    if (oldUseColor != this.mState.mUseColor) {
                        this.invalidateSelf();
                    }
                }
                getOpacity() {
                    switch (this.mState.mUseColor >>> 24) {
                        case 255:
                            return graphics.PixelFormat.OPAQUE;
                        case 0:
                            return graphics.PixelFormat.TRANSPARENT;
                    }
                    return graphics.PixelFormat.TRANSLUCENT;
                }
                getConstantState() {
                    return this.mState;
                }
            }
            drawable.ColorDrawable = ColorDrawable;
            class ColorState {
                constructor(state) {
                    this.mBaseColor = 0;
                    this.mUseColor = 0;
                    if (state != null) {
                        this.mBaseColor = state.mBaseColor;
                        this.mUseColor = state.mUseColor;
                    }
                }
                newDrawable() {
                    let c = new ColorDrawable();
                    c._setStateCopyFrom(this);
                    return c;
                }
            }
        })(drawable = graphics.drawable || (graphics.drawable = {}));
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/30.
 */
///<reference path="Drawable.ts"/>
///<reference path="../Canvas.ts"/>
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        var drawable;
        (function (drawable) {
            var Drawable = android.graphics.drawable.Drawable;
            class ScrollBarDrawable extends Drawable {
                constructor(...args) {
                    super(...args);
                    this.mRange = 0;
                    this.mOffset = 0;
                    this.mExtent = 0;
                    this.mVertical = false;
                    this.mChanged = false;
                    this.mRangeChanged = false;
                    this.mTempBounds = new graphics.Rect();
                    this.mAlwaysDrawHorizontalTrack = false;
                    this.mAlwaysDrawVerticalTrack = false;
                }
                setAlwaysDrawHorizontalTrack(alwaysDrawTrack) {
                    this.mAlwaysDrawHorizontalTrack = alwaysDrawTrack;
                }
                setAlwaysDrawVerticalTrack(alwaysDrawTrack) {
                    this.mAlwaysDrawVerticalTrack = alwaysDrawTrack;
                }
                getAlwaysDrawVerticalTrack() {
                    return this.mAlwaysDrawVerticalTrack;
                }
                getAlwaysDrawHorizontalTrack() {
                    return this.mAlwaysDrawHorizontalTrack;
                }
                setParameters(range, offset, extent, vertical) {
                    if (this.mVertical != vertical) {
                        this.mChanged = true;
                    }
                    if (this.mRange != range || this.mOffset != offset || this.mExtent != extent) {
                        this.mRangeChanged = true;
                    }
                    this.mRange = range;
                    this.mOffset = offset;
                    this.mExtent = extent;
                    this.mVertical = vertical;
                }
                draw(canvas) {
                    const vertical = this.mVertical;
                    const extent = this.mExtent;
                    const range = this.mRange;
                    let drawTrack = true;
                    let drawThumb = true;
                    if (extent <= 0 || range <= extent) {
                        drawTrack = vertical ? this.mAlwaysDrawVerticalTrack : this.mAlwaysDrawHorizontalTrack;
                        drawThumb = false;
                    }
                    let r = this.getBounds();
                    if (drawTrack) {
                        this.drawTrack(canvas, r, vertical);
                    }
                    if (drawThumb) {
                        let size = vertical ? r.height() : r.width();
                        let thickness = vertical ? r.width() : r.height();
                        let length = Math.round(size * extent / range);
                        let offset = Math.round((size - length) * this.mOffset / (range - extent));
                        let minLength = thickness * 2;
                        if (length < minLength) {
                            length = minLength;
                        }
                        if (offset + length > size) {
                            offset = size - length;
                        }
                        this.drawThumb(canvas, r, offset, length, vertical);
                    }
                }
                onBoundsChange(bounds) {
                    super.onBoundsChange(bounds);
                    this.mChanged = true;
                }
                drawTrack(canvas, bounds, vertical) {
                    let track;
                    if (vertical) {
                        track = this.mVerticalTrack;
                    }
                    else {
                        track = this.mHorizontalTrack;
                    }
                    if (track != null) {
                        if (this.mChanged) {
                            track.setBounds(bounds);
                        }
                        track.draw(canvas);
                    }
                }
                drawThumb(canvas, bounds, offset, length, vertical) {
                    const thumbRect = this.mTempBounds;
                    const changed = this.mRangeChanged || this.mChanged;
                    if (changed) {
                        if (vertical) {
                            thumbRect.set(bounds.left, bounds.top + offset, bounds.right, bounds.top + offset + length);
                        }
                        else {
                            thumbRect.set(bounds.left + offset, bounds.top, bounds.left + offset + length, bounds.bottom);
                        }
                    }
                    if (vertical) {
                        const thumb = this.mVerticalThumb;
                        if (changed)
                            thumb.setBounds(thumbRect);
                        thumb.draw(canvas);
                    }
                    else {
                        const thumb = this.mHorizontalThumb;
                        if (changed)
                            thumb.setBounds(thumbRect);
                        thumb.draw(canvas);
                    }
                }
                setVerticalThumbDrawable(thumb) {
                    if (thumb != null) {
                        this.mVerticalThumb = thumb;
                    }
                }
                setVerticalTrackDrawable(track) {
                    this.mVerticalTrack = track;
                }
                setHorizontalThumbDrawable(thumb) {
                    if (thumb != null) {
                        this.mHorizontalThumb = thumb;
                    }
                }
                setHorizontalTrackDrawable(track) {
                    this.mHorizontalTrack = track;
                }
                getSize(vertical) {
                    if (vertical) {
                        return (this.mVerticalTrack != null ?
                            this.mVerticalTrack : this.mVerticalThumb).getIntrinsicWidth();
                    }
                    else {
                        return (this.mHorizontalTrack != null ?
                            this.mHorizontalTrack : this.mHorizontalThumb).getIntrinsicHeight();
                    }
                }
                setAlpha(alpha) {
                    if (this.mVerticalTrack != null) {
                        this.mVerticalTrack.setAlpha(alpha);
                    }
                    this.mVerticalThumb.setAlpha(alpha);
                    if (this.mHorizontalTrack != null) {
                        this.mHorizontalTrack.setAlpha(alpha);
                    }
                    this.mHorizontalThumb.setAlpha(alpha);
                }
                getAlpha() {
                    return this.mVerticalThumb.getAlpha();
                }
                getOpacity() {
                    return graphics.PixelFormat.TRANSLUCENT;
                }
                toString() {
                    return "ScrollBarDrawable: range=" + this.mRange + " offset=" + this.mOffset +
                        " extent=" + this.mExtent + (this.mVertical ? " V" : " H");
                }
            }
            drawable.ScrollBarDrawable = ScrollBarDrawable;
        })(drawable = graphics.drawable || (graphics.drawable = {}));
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/2.
 */
///<reference path="Drawable.ts"/>
///<reference path="../Canvas.ts"/>
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        var drawable;
        (function (drawable_1) {
            class InsetDrawable extends drawable_1.Drawable {
                constructor(drawable, insetLeft, insetTop = insetLeft, insetRight = insetTop, insetBottom = insetRight) {
                    super();
                    this.mTmpRect = new graphics.Rect();
                    this.mMutated = false;
                    this.mInsetState = new InsetState(null, this);
                    this.mInsetState.mDrawable = drawable;
                    this.mInsetState.mInsetLeft = insetLeft;
                    this.mInsetState.mInsetTop = insetTop;
                    this.mInsetState.mInsetRight = insetRight;
                    this.mInsetState.mInsetBottom = insetBottom;
                    if (drawable != null) {
                        drawable.setCallback(this);
                    }
                }
                invalidateDrawable(who) {
                    const callback = this.getCallback();
                    if (callback != null) {
                        callback.invalidateDrawable(this);
                    }
                }
                scheduleDrawable(who, what, when) {
                    const callback = this.getCallback();
                    if (callback != null) {
                        callback.scheduleDrawable(this, what, when);
                    }
                }
                unscheduleDrawable(who, what) {
                    const callback = this.getCallback();
                    if (callback != null) {
                        callback.unscheduleDrawable(this, what);
                    }
                }
                draw(canvas) {
                    this.mInsetState.mDrawable.draw(canvas);
                }
                getPadding(padding) {
                    let pad = this.mInsetState.mDrawable.getPadding(padding);
                    padding.left += this.mInsetState.mInsetLeft;
                    padding.right += this.mInsetState.mInsetRight;
                    padding.top += this.mInsetState.mInsetTop;
                    padding.bottom += this.mInsetState.mInsetBottom;
                    if (pad || (this.mInsetState.mInsetLeft | this.mInsetState.mInsetRight |
                        this.mInsetState.mInsetTop | this.mInsetState.mInsetBottom) != 0) {
                        return true;
                    }
                    else {
                        return false;
                    }
                }
                setVisible(visible, restart) {
                    this.mInsetState.mDrawable.setVisible(visible, restart);
                    return super.setVisible(visible, restart);
                }
                setAlpha(alpha) {
                    this.mInsetState.mDrawable.setAlpha(alpha);
                }
                getAlpha() {
                    return this.mInsetState.mDrawable.getAlpha();
                }
                getOpacity() {
                    return this.mInsetState.mDrawable.getOpacity();
                }
                isStateful() {
                    return this.mInsetState.mDrawable.isStateful();
                }
                onStateChange(state) {
                    let changed = this.mInsetState.mDrawable.setState(state);
                    this.onBoundsChange(this.getBounds());
                    return changed;
                }
                onBoundsChange(bounds) {
                    const r = this.mTmpRect;
                    r.set(bounds);
                    r.left += this.mInsetState.mInsetLeft;
                    r.top += this.mInsetState.mInsetTop;
                    r.right -= this.mInsetState.mInsetRight;
                    r.bottom -= this.mInsetState.mInsetBottom;
                    this.mInsetState.mDrawable.setBounds(r.left, r.top, r.right, r.bottom);
                }
                getIntrinsicWidth() {
                    return this.mInsetState.mDrawable.getIntrinsicWidth();
                }
                getIntrinsicHeight() {
                    return this.mInsetState.mDrawable.getIntrinsicHeight();
                }
                getConstantState() {
                    if (this.mInsetState.canConstantState()) {
                        return this.mInsetState;
                    }
                    return null;
                }
                mutate() {
                    if (!this.mMutated && super.mutate() == this) {
                        this.mInsetState.mDrawable.mutate();
                        this.mMutated = true;
                    }
                    return this;
                }
                getDrawable() {
                    return this.mInsetState.mDrawable;
                }
            }
            drawable_1.InsetDrawable = InsetDrawable;
            class InsetState {
                constructor(orig, owner) {
                    this.mInsetLeft = 0;
                    this.mInsetTop = 0;
                    this.mInsetRight = 0;
                    this.mInsetBottom = 0;
                    if (orig != null) {
                        this.mDrawable = orig.mDrawable.getConstantState().newDrawable();
                        this.mDrawable.setCallback(owner);
                        this.mInsetLeft = orig.mInsetLeft;
                        this.mInsetTop = orig.mInsetTop;
                        this.mInsetRight = orig.mInsetRight;
                        this.mInsetBottom = orig.mInsetBottom;
                        this.mCheckedConstantState = this.mCanConstantState = true;
                    }
                }
                newDrawable() {
                    let drawable = new InsetDrawable(null, 0);
                    drawable.mInsetState = new InsetState(this, drawable);
                    return drawable;
                }
                canConstantState() {
                    if (!this.mCheckedConstantState) {
                        this.mCanConstantState = this.mDrawable.getConstantState() != null;
                        this.mCheckedConstantState = true;
                    }
                    return this.mCanConstantState;
                }
            }
        })(drawable = graphics.drawable || (graphics.drawable = {}));
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/18.
 */
///<reference path="Rect.ts"/>
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        class Matrix {
            isIdentity() {
                return true;
            }
            mapRect(boundingRect) {
                return false;
            }
        }
        Matrix.IDENTITY_MATRIX = new Matrix();
        graphics.Matrix = Matrix;
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
var java;
(function (java) {
    var lang;
    (function (lang) {
        let hashCodeGenerator = 0;
        class JavaObject {
            constructor() {
                this.hash = hashCodeGenerator++;
                this._class = new Class(this.constructor.name);
            }
            static get class() {
                return new Class(this.name);
            }
            hashCode() {
                return this.hash;
            }
            getClass() {
                return this._class;
            }
            equals(o) {
                return this === o;
            }
        }
        lang.JavaObject = JavaObject;
        class Class {
            constructor(name) {
                this.name = name;
            }
            getName() {
                return this.name;
            }
        }
        lang.Class = Class;
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
var java;
(function (java) {
    var lang;
    (function (lang) {
        var util;
        (function (util) {
            var concurrent;
            (function (concurrent) {
                class CopyOnWriteArrayList {
                    constructor() {
                        this.mData = [];
                        this.isDataNew = true;
                    }
                    iterator() {
                        this.isDataNew = false;
                        return this.mData;
                    }
                    [Symbol.iterator]() {
                        this.isDataNew = false;
                        return this.mData[Symbol.iterator]();
                    }
                    checkNewData() {
                        if (!this.isDataNew) {
                            this.isDataNew = true;
                            this.mData = [...this.mData];
                        }
                    }
                    size() {
                        return this.mData.length;
                    }
                    add(...items) {
                        this.checkNewData();
                        this.mData.push(...items);
                    }
                    addAll(array) {
                        this.checkNewData();
                        this.mData.push(...array.mData);
                    }
                    remove(item) {
                        this.checkNewData();
                        this.mData.splice(this.mData.indexOf(item), 1);
                    }
                }
                concurrent.CopyOnWriteArrayList = CopyOnWriteArrayList;
            })(concurrent = util.concurrent || (util.concurrent = {}));
        })(util = lang.util || (lang.util = {}));
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
/**
 * Created by linfaxin on 15/10/28.
 */
///<reference path="List.ts"/>
var java;
(function (java) {
    var util;
    (function (util) {
        class ArrayList {
            constructor(initialCapacity = 0) {
                this.array = [];
            }
            size() {
                return this.array.length;
            }
            isEmpty() {
                return this.size() === 0;
            }
            contains(o) {
                return this.indexOf(o) >= 0;
            }
            indexOf(o) {
                return this.array.indexOf(o);
            }
            lastIndexOf(o) {
                return this.array.lastIndexOf(o);
            }
            clone() {
                let arrayList = new ArrayList();
                arrayList.array.push(...this.array);
                return arrayList;
            }
            toArray(a = new Array(this.size())) {
                let size = this.size();
                for (let i = 0; i < size; i++) {
                    a[i] = this.array[i];
                }
                return a;
            }
            getArray() {
                return this.array;
            }
            get(index) {
                return this.array[index];
            }
            set(index, element) {
                let old = this.array[index];
                this.array[index] = element;
                return old;
            }
            add(...args) {
                let index, t;
                if (args.length === 1)
                    t = args[0];
                else if (args.length === 2) {
                    index = args[0];
                    t = args[1];
                }
                if (index === undefined)
                    this.array.push(t);
                else
                    this.array.splice(index, 0, t);
            }
            remove(o) {
                let index;
                if (Number.isInteger(o)) {
                    index = o;
                }
                else {
                    index = this.array.indexOf(o);
                }
                let old = this.array[index];
                this.array.splice(index, 1);
                return old;
            }
            clear() {
                this.array = [];
            }
            addAll(...args) {
                let index, list;
                if (args.length === 1) {
                    list = args[0];
                }
                else if (args.length === 2) {
                    index = args[0];
                    list = args[1];
                }
                if (index === undefined) {
                    this.array.push(...list.array);
                }
                else {
                    this.array.splice(index, 0, ...list.array);
                }
            }
            removeAll(list) {
                let oldSize = this.size();
                list.array.forEach((item) => {
                    let index = this.array.indexOf(item);
                    this.array.splice(index, 1);
                });
                return this.size() === oldSize;
            }
            [Symbol.iterator]() {
                return this.array[Symbol.iterator];
            }
            subList(fromIndex, toIndex) {
                let list = new ArrayList();
                for (var i = fromIndex; i < toIndex; i++) {
                    list.array.push(this.array[i]);
                }
                return list;
            }
            toString() {
                return this.array.toString();
            }
            sort(compareFn) {
                this.array.sort(compareFn);
            }
        }
        util.ArrayList = ArrayList;
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
var android;
(function (android) {
    var util;
    (function (util) {
        class Access {
            get(index) {
                return this.mData[index];
            }
            size() {
                return this.mSize;
            }
        }
        class CopyOnWriteArray {
            constructor() {
                this.mData = [];
                this.mAccess = new Access();
            }
            getArray() {
                if (this.mStart) {
                    if (this.mDataCopy == null)
                        this.mDataCopy = [...this.mData];
                    return this.mDataCopy;
                }
                return this.mData;
            }
            start() {
                if (this.mStart)
                    throw new Error("Iteration already started");
                this.mStart = true;
                this.mDataCopy = null;
                this.mAccess.mData = this.mData;
                this.mAccess.mSize = this.mData.length;
                return this.mAccess.mData;
            }
            end() {
                if (!this.mStart)
                    throw new Error("Iteration not started");
                this.mStart = false;
                if (this.mDataCopy != null) {
                    this.mData = this.mDataCopy;
                    this.mAccess.mData = [];
                    this.mAccess.mSize = 0;
                }
                this.mDataCopy = null;
            }
            size() {
                return this.getArray().length;
            }
            add(...items) {
                this.getArray().push(...items);
            }
            addAll(array) {
                this.getArray().push(...array.mData);
            }
            remove(item) {
                this.getArray().splice(this.getArray().indexOf(item), 1);
            }
        }
        util.CopyOnWriteArray = CopyOnWriteArray;
    })(util = android.util || (android.util = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/8.
 */
///<reference path="../../java/lang/util/concurrent/CopyOnWriteArrayList.ts"/>
///<reference path="../util/CopyOnWriteArray.ts"/>
///<reference path="../view/View.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var CopyOnWriteArrayList = java.lang.util.concurrent.CopyOnWriteArrayList;
        var CopyOnWriteArray = android.util.CopyOnWriteArray;
        class ViewTreeObserver {
            constructor() {
                this.mAlive = true;
            }
            addOnWindowAttachListener(listener) {
                this.checkIsAlive();
                if (this.mOnWindowAttachListeners == null) {
                    this.mOnWindowAttachListeners = new CopyOnWriteArrayList();
                }
                this.mOnWindowAttachListeners.add(listener);
            }
            removeOnWindowAttachListener(victim) {
                this.checkIsAlive();
                if (this.mOnWindowAttachListeners == null) {
                    return;
                }
                this.mOnWindowAttachListeners.remove(victim);
            }
            dispatchOnWindowAttachedChange(attached) {
                let listeners = this.mOnWindowAttachListeners;
                if (listeners != null && listeners.size() > 0) {
                    for (let listener of listeners) {
                        if (attached)
                            listener.onWindowAttached();
                        else
                            listener.onWindowDetached();
                    }
                }
            }
            addOnGlobalLayoutListener(listener) {
                this.checkIsAlive();
                if (this.mOnGlobalLayoutListeners == null) {
                    this.mOnGlobalLayoutListeners = new CopyOnWriteArray();
                }
                this.mOnGlobalLayoutListeners.add(listener);
            }
            removeGlobalOnLayoutListener(victim) {
                this.removeOnGlobalLayoutListener(victim);
            }
            removeOnGlobalLayoutListener(victim) {
                this.checkIsAlive();
                if (this.mOnGlobalLayoutListeners == null) {
                    return;
                }
                this.mOnGlobalLayoutListeners.remove(victim);
            }
            dispatchOnGlobalLayout() {
                let listeners = this.mOnGlobalLayoutListeners;
                if (listeners != null && listeners.size() > 0) {
                    let access = listeners.start();
                    try {
                        let count = access.length;
                        for (let i = 0; i < count; i++) {
                            access[i].onGlobalLayout();
                        }
                    }
                    finally {
                        listeners.end();
                    }
                }
            }
            addOnGlobalFocusChangeListener(listener) {
                this.checkIsAlive();
                if (this.mOnGlobalFocusListeners == null) {
                    this.mOnGlobalFocusListeners = new CopyOnWriteArrayList();
                }
                this.mOnGlobalFocusListeners.add(listener);
            }
            removeOnGlobalFocusChangeListener(victim) {
                this.checkIsAlive();
                if (this.mOnGlobalFocusListeners == null) {
                    return;
                }
                this.mOnGlobalFocusListeners.remove(victim);
            }
            dispatchOnGlobalFocusChange(oldFocus, newFocus) {
                const listeners = this.mOnGlobalFocusListeners;
                if (listeners != null && listeners.size() > 0) {
                    for (let listener of listeners) {
                        listener.onGlobalFocusChanged(oldFocus, newFocus);
                    }
                }
            }
            addOnPreDrawListener(listener) {
                this.checkIsAlive();
                if (this.mOnPreDrawListeners == null) {
                    this.mOnPreDrawListeners = new CopyOnWriteArray();
                }
                this.mOnPreDrawListeners.add(listener);
            }
            removeOnPreDrawListener(victim) {
                this.checkIsAlive();
                if (this.mOnPreDrawListeners == null) {
                    return;
                }
                this.mOnPreDrawListeners.remove(victim);
            }
            dispatchOnPreDraw() {
                let cancelDraw = false;
                const listeners = this.mOnPreDrawListeners;
                if (listeners != null && listeners.size() > 0) {
                    let access = listeners.start();
                    try {
                        let count = access.length;
                        for (let i = 0; i < count; i++) {
                            cancelDraw = cancelDraw || !(access[i].onPreDraw());
                        }
                    }
                    finally {
                        listeners.end();
                    }
                }
                return cancelDraw;
            }
            addOnTouchModeChangeListener(listener) {
                this.checkIsAlive();
                if (this.mOnTouchModeChangeListeners == null) {
                    this.mOnTouchModeChangeListeners = new CopyOnWriteArrayList();
                }
                this.mOnTouchModeChangeListeners.add(listener);
            }
            removeOnTouchModeChangeListener(victim) {
                this.checkIsAlive();
                if (this.mOnTouchModeChangeListeners == null) {
                    return;
                }
                this.mOnTouchModeChangeListeners.remove(victim);
            }
            dispatchOnTouchModeChanged(inTouchMode) {
                const listeners = this.mOnTouchModeChangeListeners;
                if (listeners != null && listeners.size() > 0) {
                    for (let listener of listeners) {
                        listener.onTouchModeChanged(inTouchMode);
                    }
                }
            }
            addOnScrollChangedListener(listener) {
                this.checkIsAlive();
                if (this.mOnScrollChangedListeners == null) {
                    this.mOnScrollChangedListeners = new CopyOnWriteArray();
                }
                this.mOnScrollChangedListeners.add(listener);
            }
            removeOnScrollChangedListener(victim) {
                this.checkIsAlive();
                if (this.mOnScrollChangedListeners == null) {
                    return;
                }
                this.mOnScrollChangedListeners.remove(victim);
            }
            dispatchOnScrollChanged() {
                let listeners = this.mOnScrollChangedListeners;
                if (listeners != null && listeners.size() > 0) {
                    let access = listeners.start();
                    try {
                        let count = access.length;
                        for (let i = 0; i < count; i++) {
                            access[i].onScrollChanged();
                        }
                    }
                    finally {
                        listeners.end();
                    }
                }
            }
            addOnDrawListener(listener) {
                this.checkIsAlive();
                if (this.mOnDrawListeners == null) {
                    this.mOnDrawListeners = new CopyOnWriteArrayList();
                }
                this.mOnDrawListeners.add(listener);
            }
            removeOnDrawListener(victim) {
                this.checkIsAlive();
                if (this.mOnDrawListeners == null) {
                    return;
                }
                this.mOnDrawListeners.remove(victim);
            }
            dispatchOnDraw() {
                if (this.mOnDrawListeners != null) {
                    for (let listener of this.mOnDrawListeners) {
                        listener.onDraw();
                    }
                }
            }
            merge(observer) {
                if (observer.mOnWindowAttachListeners != null) {
                    if (this.mOnWindowAttachListeners != null) {
                        this.mOnWindowAttachListeners.addAll(observer.mOnWindowAttachListeners);
                    }
                    else {
                        this.mOnWindowAttachListeners = observer.mOnWindowAttachListeners;
                    }
                }
                if (observer.mOnGlobalLayoutListeners != null) {
                    if (this.mOnGlobalLayoutListeners != null) {
                        this.mOnGlobalLayoutListeners.addAll(observer.mOnGlobalLayoutListeners);
                    }
                    else {
                        this.mOnGlobalLayoutListeners = observer.mOnGlobalLayoutListeners;
                    }
                }
                if (observer.mOnPreDrawListeners != null) {
                    if (this.mOnPreDrawListeners != null) {
                        this.mOnPreDrawListeners.addAll(observer.mOnPreDrawListeners);
                    }
                    else {
                        this.mOnPreDrawListeners = observer.mOnPreDrawListeners;
                    }
                }
                if (observer.mOnScrollChangedListeners != null) {
                    if (this.mOnScrollChangedListeners != null) {
                        this.mOnScrollChangedListeners.addAll(observer.mOnScrollChangedListeners);
                    }
                    else {
                        this.mOnScrollChangedListeners = observer.mOnScrollChangedListeners;
                    }
                }
                observer.kill();
            }
            checkIsAlive() {
                if (!this.mAlive) {
                    throw new Error("This ViewTreeObserver is not alive, call "
                        + "getViewTreeObserver() again");
                }
            }
            isAlive() {
                return this.mAlive;
            }
            kill() {
                this.mAlive = false;
            }
        }
        view.ViewTreeObserver = ViewTreeObserver;
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
var android;
(function (android) {
    var util;
    (function (util) {
        class DisplayMetrics {
        }
        DisplayMetrics.DENSITY_LOW = 120;
        DisplayMetrics.DENSITY_MEDIUM = 160;
        DisplayMetrics.DENSITY_HIGH = 240;
        DisplayMetrics.DENSITY_XHIGH = 320;
        DisplayMetrics.DENSITY_XXHIGH = 480;
        DisplayMetrics.DENSITY_XXXHIGH = 640;
        DisplayMetrics.DENSITY_DEFAULT = DisplayMetrics.DENSITY_MEDIUM;
        util.DisplayMetrics = DisplayMetrics;
    })(util = android.util || (android.util = {}));
})(android || (android = {}));
///<reference path="../../util/DisplayMetrics.ts"/>
var android;
(function (android) {
    var content;
    (function (content) {
        var res;
        (function (res) {
            var DisplayMetrics = android.util.DisplayMetrics;
            class Resources {
                static from(any) {
                    return Resources.instance;
                }
                static getDisplayMetrics() {
                    return Resources.instance.getDisplayMetrics();
                }
                getDisplayMetrics() {
                    if (this.displayMetrics)
                        return this.displayMetrics;
                    this.displayMetrics = new DisplayMetrics();
                    let displayMetrics = this.displayMetrics;
                    let density = Resources.globalDensity;
                    displayMetrics.xdpi = window.screen.deviceXDPI || DisplayMetrics.DENSITY_DEFAULT;
                    displayMetrics.ydpi = window.screen.deviceYDPI || DisplayMetrics.DENSITY_DEFAULT;
                    displayMetrics.density = window.devicePixelRatio;
                    displayMetrics.densityDpi = density * DisplayMetrics.DENSITY_DEFAULT;
                    displayMetrics.scaledDensity = density;
                    displayMetrics.widthPixels = window.innerWidth * density;
                    displayMetrics.heightPixels = window.innerHeight * density;
                    return displayMetrics;
                }
            }
            Resources.instance = new Resources();
            Resources.globalDensity = 1;
            res.Resources = Resources;
        })(res = content.res || (content.res = {}));
    })(content = android.content || (android.content = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/5.
 */
///<reference path="../util/SparseArray.ts"/>
///<reference path="../content/res/Resources.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var Resources = android.content.res.Resources;
        class ViewConfiguration {
            constructor() {
                this.density = Resources.getDisplayMetrics().density;
                this.sizeAndDensity = this.density;
                this.mEdgeSlop = this.sizeAndDensity * ViewConfiguration.EDGE_SLOP;
                this.mFadingEdgeLength = this.sizeAndDensity * ViewConfiguration.FADING_EDGE_LENGTH;
                this.mMinimumFlingVelocity = this.density * ViewConfiguration.MINIMUM_FLING_VELOCITY;
                this.mMaximumFlingVelocity = this.density * ViewConfiguration.MAXIMUM_FLING_VELOCITY;
                this.mScrollbarSize = this.density * ViewConfiguration.SCROLL_BAR_SIZE;
                this.mTouchSlop = this.density * ViewConfiguration.TOUCH_SLOP;
                this.mDoubleTapTouchSlop = this.sizeAndDensity * ViewConfiguration.DOUBLE_TAP_TOUCH_SLOP;
                this.mPagingTouchSlop = this.density * ViewConfiguration.PAGING_TOUCH_SLOP;
                this.mDoubleTapSlop = this.density * ViewConfiguration.DOUBLE_TAP_SLOP;
                this.mWindowTouchSlop = this.sizeAndDensity * ViewConfiguration.WINDOW_TOUCH_SLOP;
                this.mOverscrollDistance = this.sizeAndDensity * ViewConfiguration.OVERSCROLL_DISTANCE;
                this.mOverflingDistance = this.sizeAndDensity * ViewConfiguration.OVERFLING_DISTANCE;
                this.mMaximumDrawingCacheSize = ViewConfiguration.MAXIMUM_DRAWING_CACHE_SIZE;
            }
            static get(arg) {
                if (!ViewConfiguration.instance) {
                    ViewConfiguration.instance = new ViewConfiguration();
                }
                return ViewConfiguration.instance;
            }
            getScaledScrollBarSize() {
                return this.mScrollbarSize;
            }
            static getScrollBarFadeDuration() {
                return ViewConfiguration.SCROLL_BAR_FADE_DURATION;
            }
            static getScrollDefaultDelay() {
                return ViewConfiguration.SCROLL_BAR_DEFAULT_DELAY;
            }
            getScaledFadingEdgeLength() {
                return this.mFadingEdgeLength;
            }
            static getPressedStateDuration() {
                return ViewConfiguration.PRESSED_STATE_DURATION;
            }
            static getLongPressTimeout() {
                return ViewConfiguration.DEFAULT_LONG_PRESS_TIMEOUT;
            }
            static getKeyRepeatDelay() {
                return ViewConfiguration.KEY_REPEAT_DELAY;
            }
            static getTapTimeout() {
                return ViewConfiguration.TAP_TIMEOUT;
            }
            static getJumpTapTimeout() {
                return ViewConfiguration.JUMP_TAP_TIMEOUT;
            }
            static getDoubleTapTimeout() {
                return ViewConfiguration.DOUBLE_TAP_TIMEOUT;
            }
            static getDoubleTapMinTime() {
                return ViewConfiguration.DOUBLE_TAP_MIN_TIME;
            }
            getScaledEdgeSlop() {
                return this.mEdgeSlop;
            }
            getScaledTouchSlop() {
                return this.mTouchSlop;
            }
            getScaledDoubleTapTouchSlop() {
                return this.mDoubleTapTouchSlop;
            }
            getScaledPagingTouchSlop() {
                return this.mPagingTouchSlop;
            }
            getScaledDoubleTapSlop() {
                return this.mDoubleTapSlop;
            }
            getScaledWindowTouchSlop() {
                return this.mWindowTouchSlop;
            }
            getScaledMinimumFlingVelocity() {
                return this.mMinimumFlingVelocity;
            }
            getScaledMaximumFlingVelocity() {
                return this.mMaximumFlingVelocity;
            }
            getScaledMaximumDrawingCacheSize() {
                return this.mMaximumDrawingCacheSize;
            }
            getScaledOverscrollDistance() {
                return this.mOverscrollDistance;
            }
            getScaledOverflingDistance() {
                return this.mOverflingDistance;
            }
            static getScrollFriction() {
                return ViewConfiguration.SCROLL_FRICTION;
            }
        }
        ViewConfiguration.SCROLL_BAR_SIZE = 8;
        ViewConfiguration.SCROLL_BAR_FADE_DURATION = 250;
        ViewConfiguration.SCROLL_BAR_DEFAULT_DELAY = 300;
        ViewConfiguration.FADING_EDGE_LENGTH = 12;
        ViewConfiguration.PRESSED_STATE_DURATION = 64;
        ViewConfiguration.DEFAULT_LONG_PRESS_TIMEOUT = 500;
        ViewConfiguration.KEY_REPEAT_DELAY = 50;
        ViewConfiguration.GLOBAL_ACTIONS_KEY_TIMEOUT = 500;
        ViewConfiguration.TAP_TIMEOUT = 180;
        ViewConfiguration.JUMP_TAP_TIMEOUT = 500;
        ViewConfiguration.DOUBLE_TAP_TIMEOUT = 300;
        ViewConfiguration.DOUBLE_TAP_MIN_TIME = 40;
        ViewConfiguration.HOVER_TAP_TIMEOUT = 150;
        ViewConfiguration.HOVER_TAP_SLOP = 20;
        ViewConfiguration.ZOOM_CONTROLS_TIMEOUT = 3000;
        ViewConfiguration.EDGE_SLOP = 12;
        ViewConfiguration.TOUCH_SLOP = 8;
        ViewConfiguration.DOUBLE_TAP_TOUCH_SLOP = ViewConfiguration.TOUCH_SLOP;
        ViewConfiguration.PAGING_TOUCH_SLOP = ViewConfiguration.TOUCH_SLOP * 2;
        ViewConfiguration.DOUBLE_TAP_SLOP = 100;
        ViewConfiguration.WINDOW_TOUCH_SLOP = 16;
        ViewConfiguration.MINIMUM_FLING_VELOCITY = 50;
        ViewConfiguration.MAXIMUM_FLING_VELOCITY = 8000;
        ViewConfiguration.MAXIMUM_DRAWING_CACHE_SIZE = 480 * 800 * 4;
        ViewConfiguration.SCROLL_FRICTION = 0.015;
        ViewConfiguration.OVERSCROLL_DISTANCE = 800;
        ViewConfiguration.OVERFLING_DISTANCE = 100;
        view.ViewConfiguration = ViewConfiguration;
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/6.
 */
///<reference path="../content/res/Resources.ts"/>
///<reference path="../graphics/Rect.ts"/>
///<reference path="../view/ViewConfiguration.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var Resources = android.content.res.Resources;
        var Rect = android.graphics.Rect;
        var ViewConfiguration = android.view.ViewConfiguration;
        class MotionEvent {
            constructor() {
                this.mAction = 0;
                this.mEdgeFlags = 0;
                this.mDownTime = 0;
                this.mEventTime = 0;
                this.mActivePointerId = 0;
                this.mXOffset = 0;
                this.mYOffset = 0;
                this._axisValues = new Map();
            }
            static obtainWithTouchEvent(e, action) {
                let event = new MotionEvent();
                event.initWithTouch(e, action);
                return event;
            }
            static obtain(event) {
                let newEv = new MotionEvent();
                Object.assign(newEv, event);
                return newEv;
            }
            static obtainWithAction(downTime, eventTime, action, x, y, metaState = 0) {
                let newEv = new MotionEvent();
                newEv.mAction = action;
                newEv.mDownTime = downTime;
                newEv.mEventTime = eventTime;
                let touch = {
                    identifier: 0,
                    target: null,
                    screenX: x,
                    screenY: y,
                    clientX: x,
                    clientY: y,
                    pageX: x,
                    pageY: y
                };
                newEv.mTouchingPointers = [touch];
                return newEv;
            }
            initWithTouch(event, baseAction, windowBound = new Rect()) {
                this._event = event;
                let e = event;
                let action = baseAction;
                let actionIndex = -1;
                let activeTouch = e.changedTouches[0];
                this._activeTouch = activeTouch;
                let activePointerId = activeTouch.identifier;
                for (let i = 0, length = e.touches.length; i < length; i++) {
                    if (e.touches[i].identifier === activePointerId) {
                        actionIndex = i;
                        MotionEvent.IdIndexCache.set(activePointerId, i);
                        break;
                    }
                }
                if (actionIndex < 0 && (baseAction === MotionEvent.ACTION_UP || baseAction === MotionEvent.ACTION_CANCEL)) {
                    actionIndex = MotionEvent.IdIndexCache.get(activePointerId);
                }
                if (actionIndex < 0)
                    throw Error('not find action index');
                switch (baseAction) {
                    case MotionEvent.ACTION_DOWN:
                    case MotionEvent.ACTION_UP:
                        MotionEvent.TouchMoveRecord.set(activePointerId, []);
                        break;
                    case MotionEvent.ACTION_MOVE:
                        let moveHistory = MotionEvent.TouchMoveRecord.get(activePointerId);
                        if (moveHistory) {
                            activeTouch.mEventTime = e.timeStamp;
                            moveHistory.push(activeTouch);
                            if (moveHistory.length > MotionEvent.HistoryMaxSize)
                                moveHistory.shift();
                        }
                        break;
                }
                this.mTouchingPointers = Array.from(e.touches);
                if (baseAction === MotionEvent.ACTION_UP) {
                    this.mTouchingPointers.splice(actionIndex, 0, activeTouch);
                }
                if (this.mTouchingPointers.length > 1) {
                    switch (action) {
                        case MotionEvent.ACTION_DOWN:
                            action = MotionEvent.ACTION_POINTER_DOWN;
                            break;
                        case MotionEvent.ACTION_UP:
                            action = MotionEvent.ACTION_POINTER_UP;
                            break;
                    }
                }
                this.mAction = actionIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT | action;
                this.mActivePointerId = activePointerId;
                if (activePointerId === 0 && action == MotionEvent.ACTION_DOWN) {
                    this.mDownTime = e.timeStamp;
                }
                this.mEventTime = e.timeStamp;
                this.mXOffset = this.mYOffset = 0;
                let edgeFlag = 0;
                let unScaledX = activeTouch.clientX;
                let unScaledY = activeTouch.clientY;
                let edgeSlop = ViewConfiguration.EDGE_SLOP;
                let tempBound = new Rect();
                tempBound.set(windowBound);
                tempBound.right = tempBound.left + edgeSlop;
                if (tempBound.contains(unScaledX, unScaledY)) {
                    edgeFlag |= MotionEvent.EDGE_LEFT;
                }
                tempBound.set(windowBound);
                tempBound.bottom = tempBound.top + edgeSlop;
                if (tempBound.contains(unScaledX, unScaledY)) {
                    edgeFlag |= MotionEvent.EDGE_TOP;
                }
                tempBound.set(windowBound);
                tempBound.left = tempBound.right - edgeSlop;
                if (tempBound.contains(unScaledX, unScaledY)) {
                    edgeFlag |= MotionEvent.EDGE_RIGHT;
                }
                tempBound.set(windowBound);
                tempBound.top = tempBound.bottom - edgeSlop;
                if (tempBound.contains(unScaledX, unScaledY)) {
                    edgeFlag |= MotionEvent.EDGE_BOTTOM;
                }
                this.mEdgeFlags = edgeFlag;
            }
            initWithMouseWheel(e) {
                this.mAction = MotionEvent.ACTION_SCROLL;
                this.mActivePointerId = 0;
                let touch = {
                    identifier: 0,
                    target: null,
                    screenX: e.screenX,
                    screenY: e.screenY,
                    clientX: e.clientX,
                    clientY: e.clientY,
                    pageX: e.pageX,
                    pageY: e.pageY
                };
                this.mTouchingPointers = [touch];
                this.mDownTime = e.timeStamp;
                this.mEventTime = e.timeStamp;
                this.mXOffset = this.mYOffset = 0;
                this._axisValues.clear();
                this._axisValues.set(MotionEvent.AXIS_VSCROLL, -e.deltaY);
                this._axisValues.set(MotionEvent.AXIS_HSCROLL, -e.deltaX);
            }
            recycle() {
            }
            getAction() {
                return this.mAction;
            }
            getActionMasked() {
                return this.mAction & MotionEvent.ACTION_MASK;
            }
            getActionIndex() {
                return (this.mAction & MotionEvent.ACTION_POINTER_INDEX_MASK) >> MotionEvent.ACTION_POINTER_INDEX_SHIFT;
            }
            getDownTime() {
                return this.mDownTime;
            }
            getEventTime() {
                return this.mEventTime;
            }
            getX(pointerIndex = 0) {
                let density = Resources.getDisplayMetrics().density;
                return (this.mTouchingPointers[pointerIndex].clientX) * density + this.mXOffset;
            }
            getY(pointerIndex = 0) {
                let density = Resources.getDisplayMetrics().density;
                return (this.mTouchingPointers[pointerIndex].clientY) * density + this.mYOffset;
            }
            getPointerCount() {
                return this.mTouchingPointers.length;
            }
            getPointerId(pointerIndex) {
                return this.mTouchingPointers[pointerIndex].identifier;
            }
            findPointerIndex(pointerId) {
                for (let i = 0, length = this.mTouchingPointers.length; i < length; i++) {
                    if (this.mTouchingPointers[i].identifier === pointerId) {
                        return i;
                    }
                }
                return -1;
            }
            getRawX() {
                let density = Resources.getDisplayMetrics().density;
                return (this.mTouchingPointers[0].clientX) * density;
            }
            getRawY() {
                let density = Resources.getDisplayMetrics().density;
                return (this.mTouchingPointers[0].clientY) * density;
            }
            getHistorySize(id = this.mActivePointerId) {
                let moveHistory = MotionEvent.TouchMoveRecord.get(id);
                return moveHistory ? moveHistory.length : 0;
            }
            getHistoricalX(pointerIndex, pos) {
                let density = Resources.getDisplayMetrics().density;
                let moveHistory = MotionEvent.TouchMoveRecord.get(this.mTouchingPointers[pointerIndex].identifier);
                return (moveHistory[pos].clientX) * density + this.mXOffset;
            }
            getHistoricalY(pointerIndex, pos) {
                let density = Resources.getDisplayMetrics().density;
                let moveHistory = MotionEvent.TouchMoveRecord.get(this.mTouchingPointers[pointerIndex].identifier);
                return (moveHistory[pos].clientY) * density + this.mYOffset;
            }
            getHistoricalEventTime(...args) {
                let pos, activePointerId;
                if (args.length === 1) {
                    pos = args[0];
                    activePointerId = this.mActivePointerId;
                }
                else {
                    pos = args[1];
                    activePointerId = this.getPointerId(args[0]);
                }
                let moveHistory = MotionEvent.TouchMoveRecord.get(activePointerId);
                return moveHistory[pos].mEventTime;
            }
            getEdgeFlags() {
                return this.mEdgeFlags;
            }
            setEdgeFlags(flags) {
                this.mEdgeFlags = flags;
            }
            setAction(action) {
                this.mAction = action;
            }
            isTouchEvent() {
                let action = this.getActionMasked();
                switch (action) {
                    case MotionEvent.ACTION_DOWN:
                    case MotionEvent.ACTION_UP:
                    case MotionEvent.ACTION_MOVE:
                    case MotionEvent.ACTION_CANCEL:
                    case MotionEvent.ACTION_OUTSIDE:
                    case MotionEvent.ACTION_POINTER_DOWN:
                    case MotionEvent.ACTION_POINTER_UP:
                        return true;
                }
                return false;
            }
            isPointerEvent() {
                return true;
            }
            offsetLocation(deltaX, deltaY) {
                this.mXOffset += deltaX;
                this.mYOffset += deltaY;
            }
            setLocation(x, y) {
                this.mXOffset = x - this.getRawX();
                this.mYOffset = y - this.getRawY();
            }
            getPointerIdBits() {
                let idBits = 0;
                let pointerCount = this.getPointerCount();
                for (let i = 0; i < pointerCount; i++) {
                    idBits |= 1 << this.getPointerId(i);
                }
                return idBits;
            }
            split(idBits) {
                let ev = MotionEvent.obtain(this);
                let oldPointerCount = this.getPointerCount();
                const oldAction = this.getAction();
                const oldActionMasked = oldAction & MotionEvent.ACTION_MASK;
                let newPointerIds = [];
                for (let i = 0; i < oldPointerCount; i++) {
                    let pointerId = this.getPointerId(i);
                    let idBit = 1 << pointerId;
                    if ((idBit & idBits) != 0) {
                        newPointerIds.push(pointerId);
                    }
                }
                let newActionPointerIndex = newPointerIds.indexOf(this.mActivePointerId);
                let newPointerCount = newPointerIds.length;
                let newAction;
                if (oldActionMasked == MotionEvent.ACTION_POINTER_DOWN || oldActionMasked == MotionEvent.ACTION_POINTER_UP) {
                    if (newActionPointerIndex < 0) {
                        newAction = MotionEvent.ACTION_MOVE;
                    }
                    else if (newPointerCount == 1) {
                        newAction = oldActionMasked == MotionEvent.ACTION_POINTER_DOWN
                            ? MotionEvent.ACTION_DOWN : MotionEvent.ACTION_UP;
                    }
                    else {
                        newAction = oldActionMasked | (newActionPointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT);
                    }
                }
                else {
                    newAction = oldAction;
                }
                ev.mAction = newAction;
                ev.mTouchingPointers = this.mTouchingPointers.filter((item) => {
                    return newPointerIds.indexOf(item.identifier) >= 0;
                });
                return ev;
            }
            getAxisValue(axis) {
                let value = this._axisValues.get(axis);
                return value ? value : 0;
            }
            toString() {
                return "MotionEvent{action=" + this.getAction() + " x=" + this.getX()
                    + " y=" + this.getY() + "}";
            }
        }
        MotionEvent.ACTION_MASK = 0xff;
        MotionEvent.ACTION_DOWN = 0;
        MotionEvent.ACTION_UP = 1;
        MotionEvent.ACTION_MOVE = 2;
        MotionEvent.ACTION_CANCEL = 3;
        MotionEvent.ACTION_OUTSIDE = 4;
        MotionEvent.ACTION_POINTER_DOWN = 5;
        MotionEvent.ACTION_POINTER_UP = 6;
        MotionEvent.ACTION_HOVER_MOVE = 7;
        MotionEvent.ACTION_SCROLL = 8;
        MotionEvent.ACTION_HOVER_ENTER = 9;
        MotionEvent.ACTION_HOVER_EXIT = 10;
        MotionEvent.EDGE_TOP = 0x00000001;
        MotionEvent.EDGE_BOTTOM = 0x00000002;
        MotionEvent.EDGE_LEFT = 0x00000004;
        MotionEvent.EDGE_RIGHT = 0x00000008;
        MotionEvent.ACTION_POINTER_INDEX_MASK = 0xff00;
        MotionEvent.ACTION_POINTER_INDEX_SHIFT = 8;
        MotionEvent.AXIS_VSCROLL = 9;
        MotionEvent.AXIS_HSCROLL = 10;
        MotionEvent.HistoryMaxSize = 10;
        MotionEvent.TouchMoveRecord = new Map();
        MotionEvent.IdIndexCache = new Map();
        view.MotionEvent = MotionEvent;
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/16.
 */
///<reference path="View.ts"/>
///<reference path="../graphics/Rect.ts"/>
///<reference path="ViewConfiguration.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var Rect = android.graphics.Rect;
        class TouchDelegate {
            constructor(bounds, delegateView) {
                this.mDelegateTargeted = false;
                this.mSlop = 0;
                this.mBounds = bounds;
                this.mSlop = view.ViewConfiguration.get().getScaledTouchSlop();
                this.mSlopBounds = new Rect(bounds);
                this.mSlopBounds.inset(-this.mSlop, -this.mSlop);
                this.mDelegateView = delegateView;
            }
            onTouchEvent(event) {
                let x = event.getX();
                let y = event.getY();
                let sendToDelegate = false;
                let hit = true;
                let handled = false;
                switch (event.getAction()) {
                    case view.MotionEvent.ACTION_DOWN:
                        let bounds = this.mBounds;
                        if (bounds.contains(x, y)) {
                            this.mDelegateTargeted = true;
                            sendToDelegate = true;
                        }
                        break;
                    case view.MotionEvent.ACTION_UP:
                    case view.MotionEvent.ACTION_MOVE:
                        sendToDelegate = this.mDelegateTargeted;
                        if (sendToDelegate) {
                            let slopBounds = this.mSlopBounds;
                            if (!slopBounds.contains(x, y)) {
                                hit = false;
                            }
                        }
                        break;
                    case view.MotionEvent.ACTION_CANCEL:
                        sendToDelegate = this.mDelegateTargeted;
                        this.mDelegateTargeted = false;
                        break;
                }
                if (sendToDelegate) {
                    let delegateView = this.mDelegateView;
                    if (hit) {
                        event.setLocation(delegateView.getWidth() / 2, delegateView.getHeight() / 2);
                    }
                    else {
                        let slop = this.mSlop;
                        event.setLocation(-(slop * 2), -(slop * 2));
                    }
                    handled = delegateView.dispatchTouchEvent(event);
                }
                return handled;
            }
        }
        view.TouchDelegate = TouchDelegate;
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
var android;
(function (android) {
    var os;
    (function (os) {
        class SystemClock {
            static uptimeMillis() {
                return new Date().getTime();
            }
        }
        os.SystemClock = SystemClock;
    })(os = android.os || (android.os = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/5.
 */
///<reference path="Handler.ts"/>
///<reference path="../../java/lang/Runnable.ts"/>
///<reference path="../../java/lang/StringBuilder.ts"/>
///<reference path="../util/Pools.ts"/>
///<reference path="SystemClock.ts"/>
var android;
(function (android) {
    var os;
    (function (os) {
        var StringBuilder = java.lang.StringBuilder;
        var Pools = android.util.Pools;
        class Message {
            constructor() {
                this.what = 0;
                this.arg1 = 0;
                this.arg2 = 0;
                this.when = 0;
            }
            recycle() {
                this.clearForRecycle();
                Message.sPool.release(this);
            }
            copyFrom(o) {
                this.what = o.what;
                this.arg1 = o.arg1;
                this.arg2 = o.arg2;
                this.obj = o.obj;
            }
            sendToTarget() {
                this.target.sendMessage(this);
            }
            clearForRecycle() {
                this.what = 0;
                this.arg1 = 0;
                this.arg2 = 0;
                this.obj = null;
                this.when = 0;
                this.target = null;
                this.callback = null;
            }
            toString(now = os.SystemClock.uptimeMillis()) {
                let b = new StringBuilder();
                b.append("{ what=");
                b.append(this.what);
                b.append(" when=");
                b.append(this.when - now).append("ms");
                if (this.arg1 != 0) {
                    b.append(" arg1=");
                    b.append(this.arg1);
                }
                if (this.arg2 != 0) {
                    b.append(" arg2=");
                    b.append(this.arg2);
                }
                if (this.obj != null) {
                    b.append(" obj=");
                    b.append(this.obj);
                }
                b.append(" }");
                return b.toString();
            }
            static obtain(...args) {
                let m = Message.sPool.acquire();
                m = m || new Message();
                if (args.length === 1 && args[0] instanceof Message) {
                    let orig = args[0];
                    [m.target, m.what, m.arg1, m.arg2, m.obj, m.callback] =
                        [orig.target, orig.what, orig.arg1, orig.arg2, orig.obj, orig.callback];
                }
                else if (args.length === 2) {
                    [m.what = 0, m.callback] = args;
                }
                else if (args.length === 3) {
                    [m.what = 0, m.arg1 = 0, m.obj] = args;
                }
                else {
                    [m.target, m.what = 0, m.arg1 = 0, m.arg2 = 0, m.obj, m.callback] = args;
                }
                return m;
            }
        }
        Message.sPool = new Pools.SynchronizedPool(10);
        os.Message = Message;
    })(os = android.os || (android.os = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/5.
 */
///<reference path="Message.ts"/>
///<reference path="Handler.ts"/>
///<reference path="../../java/lang/Runnable.ts"/>
var android;
(function (android) {
    var os;
    (function (os) {
        var requestAnimationFrame = window["requestAnimationFrame"] ||
            window["webkitRequestAnimationFrame"] ||
            window["mozRequestAnimationFrame"] ||
            window["oRequestAnimationFrame"] ||
            window["msRequestAnimationFrame"];
        if (!requestAnimationFrame) {
            requestAnimationFrame = function (callback) {
                return window.setTimeout(callback, 1000 / 60);
            };
        }
        class MessageQueue {
            static getMessages(h, args, object) {
                let msgs = [];
                if (h == null) {
                    return msgs;
                }
                if (typeof args === "number") {
                    let what = args;
                    for (let p of MessageQueue.messages) {
                        if (p.target == h && p.what == what && (object == null || p.obj == object)) {
                            msgs.push(p);
                        }
                    }
                }
                else {
                    let r = args;
                    for (let p of MessageQueue.messages) {
                        if (p.target == h && p.callback == r && (object == null || p.obj == object)) {
                            msgs.push(p);
                        }
                    }
                }
                return msgs;
            }
            static hasMessages(h, args, object) {
                return MessageQueue.getMessages(h, args, object).length > 0;
            }
            static enqueueMessage(msg, when) {
                if (msg.target == null) {
                    throw new Error("Message must have a target.");
                }
                msg.when = when;
                MessageQueue.messages.add(msg);
                MessageQueue.checkLoop();
                return true;
            }
            static recycleMessage(handler, message) {
                message.recycle();
                MessageQueue.messages.delete(message);
            }
            static removeMessages(h, args, object) {
                let p = MessageQueue.getMessages(h, args, object);
                if (p && p.length > 0) {
                    p.forEach((item) => MessageQueue.recycleMessage(h, item));
                }
            }
            static removeCallbacksAndMessages(h, object) {
                if (h == null) {
                    return;
                }
                for (let p of MessageQueue.messages) {
                    if (p != null && p.target == h && (object == null || p.obj == object)) {
                        MessageQueue.recycleMessage(h, p);
                    }
                }
            }
            static checkLoop() {
                if (!MessageQueue._loopActive) {
                    MessageQueue._loopActive = true;
                    requestAnimationFrame(MessageQueue.loop);
                }
            }
            static loop() {
                let dispatchMessages = [];
                const now = os.SystemClock.uptimeMillis();
                for (let msg of MessageQueue.messages) {
                    if (msg.when <= now)
                        dispatchMessages.push(msg);
                }
                for (let msg of dispatchMessages) {
                    if (MessageQueue.messages.has(msg)) {
                        MessageQueue.messages.delete(msg);
                        msg.target.dispatchMessage(msg);
                        MessageQueue.recycleMessage(msg.target, msg);
                    }
                }
                if (MessageQueue.messages.size > 0)
                    requestAnimationFrame(MessageQueue.loop);
                else
                    MessageQueue._loopActive = false;
            }
        }
        MessageQueue.messages = new Set();
        MessageQueue._loopActive = false;
        os.MessageQueue = MessageQueue;
    })(os = android.os || (android.os = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/5.
 */
///<reference path="Message.ts"/>
///<reference path="MessageQueue.ts"/>
///<reference path="../../java/lang/Runnable.ts"/>
///<reference path="SystemClock.ts"/>
var android;
(function (android) {
    var os;
    (function (os) {
        class Handler {
            constructor(mCallback) {
                this.mCallback = mCallback;
            }
            handleMessage(msg) {
            }
            dispatchMessage(msg) {
                if (msg.callback != null) {
                    msg.callback.run.call(msg.callback);
                }
                else {
                    if (this.mCallback != null) {
                        if (this.mCallback.handleMessage(msg)) {
                            return;
                        }
                    }
                    this.handleMessage(msg);
                }
            }
            obtainMessage(...args) {
                if (args.length === 2) {
                    let [what, obj] = args;
                    return os.Message.obtain(this, what, obj);
                }
                else {
                    let [what, arg1, arg2, obj] = args;
                    return os.Message.obtain(this, what, arg1, arg2, obj);
                }
            }
            post(r) {
                return this.sendMessageDelayed(Handler.getPostMessage(r), 0);
            }
            postAtTime(...args) {
                if (args.length === 2) {
                    let [r, uptimeMillis] = args;
                    return this.sendMessageAtTime(Handler.getPostMessage(r), uptimeMillis);
                }
                else {
                    let [r, token, uptimeMillis] = args;
                    return this.sendMessageAtTime(Handler.getPostMessage(r, token), uptimeMillis);
                }
            }
            postDelayed(r, delayMillis) {
                return this.sendMessageDelayed(Handler.getPostMessage(r), delayMillis);
            }
            postAtFrontOfQueue(r) {
                return this.post(r);
            }
            removeCallbacks(r, token) {
                os.MessageQueue.removeMessages(this, r, token);
            }
            sendMessage(msg) {
                return this.sendMessageDelayed(msg, 0);
            }
            sendEmptyMessage(what) {
                return this.sendEmptyMessageDelayed(what, 0);
            }
            sendEmptyMessageDelayed(what, delayMillis) {
                let msg = os.Message.obtain();
                msg.what = what;
                return this.sendMessageDelayed(msg, delayMillis);
            }
            sendEmptyMessageAtTime(what, uptimeMillis) {
                let msg = os.Message.obtain();
                msg.what = what;
                return this.sendMessageAtTime(msg, uptimeMillis);
            }
            sendMessageDelayed(msg, delayMillis) {
                if (delayMillis < 0) {
                    delayMillis = 0;
                }
                return this.sendMessageAtTime(msg, os.SystemClock.uptimeMillis() + delayMillis);
            }
            sendMessageAtTime(msg, uptimeMillis) {
                msg.target = this;
                return os.MessageQueue.enqueueMessage(msg, uptimeMillis);
            }
            sendMessageAtFrontOfQueue(msg) {
                return this.sendMessage(msg);
            }
            removeMessages(what, object) {
                os.MessageQueue.removeMessages(this, what, object);
            }
            removeCallbacksAndMessages(token) {
                os.MessageQueue.removeCallbacksAndMessages(this, token);
            }
            hasMessages(what, object) {
                return os.MessageQueue.hasMessages(this, what, object);
            }
            static getPostMessage(r, token) {
                let m = os.Message.obtain();
                m.obj = token;
                m.callback = r;
                return m;
            }
        }
        os.Handler = Handler;
    })(os = android.os || (android.os = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/29.
 */
///<reference path="../../util/SparseArray.ts"/>
///<reference path="../../../java/lang/ref/WeakReference.ts"/>
///<reference path="../../util/StateSet.ts"/>
var android;
(function (android) {
    var content;
    (function (content) {
        var res;
        (function (res) {
            var SparseArray = android.util.SparseArray;
            var StateSet = android.util.StateSet;
            var WeakReference = java.lang.ref.WeakReference;
            class ColorStateList {
                constructor(states, colors) {
                    this.mDefaultColor = 0xffff0000;
                    this.mStateSpecs = states;
                    this.mColors = colors;
                    if (states.length > 0) {
                        this.mDefaultColor = colors[0];
                        for (let i = 0; i < states.length; i++) {
                            if (states[i].length == 0) {
                                this.mDefaultColor = colors[i];
                            }
                        }
                    }
                }
                static valueOf(color) {
                    let ref = ColorStateList.sCache.get(color);
                    let csl = ref != null ? ref.get() : null;
                    if (csl != null) {
                        return csl;
                    }
                    csl = new ColorStateList(ColorStateList.EMPTY, [color]);
                    ColorStateList.sCache.put(color, new WeakReference(csl));
                    return csl;
                }
                withAlpha(alpha) {
                    let colors = new Array(this.mColors.length);
                    let len = colors.length;
                    for (let i = 0; i < len; i++) {
                        colors[i] = (this.mColors[i] & 0xFFFFFF) | (alpha << 24);
                    }
                    return new ColorStateList(this.mStateSpecs, colors);
                }
                isStateful() {
                    return this.mStateSpecs.length > 1;
                }
                getColorForState(stateSet, defaultColor) {
                    const setLength = this.mStateSpecs.length;
                    for (let i = 0; i < setLength; i++) {
                        let stateSpec = this.mStateSpecs[i];
                        if (StateSet.stateSetMatches(stateSpec, stateSet)) {
                            return this.mColors[i];
                        }
                    }
                    return defaultColor;
                }
                getDefaultColor() {
                    return this.mDefaultColor;
                }
                toString() {
                    return "ColorStateList{" +
                        "mStateSpecs=" + JSON.stringify(this.mStateSpecs) +
                        "mColors=" + JSON.stringify(this.mColors) +
                        "mDefaultColor=" + this.mDefaultColor + '}';
                }
            }
            ColorStateList.EMPTY = [[]];
            ColorStateList.sCache = new SparseArray();
            res.ColorStateList = ColorStateList;
        })(res = content.res || (content.res = {}));
    })(content = android.content || (android.content = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/27.
 */
///<reference path="DisplayMetrics.ts"/>
///<reference path="../content/res/Resources.ts"/>
var android;
(function (android) {
    var util;
    (function (util) {
        var Resources = android.content.res.Resources;
        class TypedValue {
            static initUnit() {
                this.initUnit = null;
                let temp = document.createElement('div');
                document.body.appendChild(temp);
                temp.style.height = 100 + TypedValue.COMPLEX_UNIT_PT;
                TypedValue.UNIT_SCALE_MAP.set(TypedValue.COMPLEX_UNIT_PT, temp.offsetHeight / 100);
                temp.style.height = 1 + TypedValue.COMPLEX_UNIT_IN;
                TypedValue.UNIT_SCALE_MAP.set(TypedValue.COMPLEX_UNIT_IN, temp.offsetHeight);
                temp.style.height = 100 + TypedValue.COMPLEX_UNIT_MM;
                TypedValue.UNIT_SCALE_MAP.set(TypedValue.COMPLEX_UNIT_MM, temp.offsetHeight / 100);
                temp.style.height = 10 + TypedValue.COMPLEX_UNIT_EM;
                TypedValue.UNIT_SCALE_MAP.set(TypedValue.COMPLEX_UNIT_EM, temp.offsetHeight / 10);
                temp.style.height = 10 + TypedValue.COMPLEX_UNIT_REM;
                TypedValue.UNIT_SCALE_MAP.set(TypedValue.COMPLEX_UNIT_REM, temp.offsetHeight / 10);
                document.body.removeChild(temp);
            }
            static applyDimension(unit, size, dm) {
                let scale = 1;
                if (unit === TypedValue.COMPLEX_UNIT_DP || unit === TypedValue.COMPLEX_UNIT_DIP || unit === TypedValue.COMPLEX_UNIT_SP) {
                    scale = dm.density;
                }
                else {
                    scale = TypedValue.UNIT_SCALE_MAP.get(unit) || 1;
                }
                return size * scale;
            }
            static complexToDimensionPixelSize(valueWithUnit, baseValue = 0, metrics = Resources.getDisplayMetrics()) {
                if (this.initUnit)
                    this.initUnit();
                if (valueWithUnit === undefined || valueWithUnit === null) {
                    throw Error('complexToDimensionPixelSize error: valueWithUnit is ' + valueWithUnit);
                }
                if (valueWithUnit === '' + (Number.parseInt(valueWithUnit)))
                    return Number.parseInt(valueWithUnit);
                if (typeof valueWithUnit !== 'string')
                    valueWithUnit = valueWithUnit + "";
                let scale = 1;
                if (valueWithUnit.endsWith(TypedValue.COMPLEX_UNIT_PX)) {
                    valueWithUnit = valueWithUnit.replace(TypedValue.COMPLEX_UNIT_PX, "");
                }
                else if (valueWithUnit.endsWith(TypedValue.COMPLEX_UNIT_DP)) {
                    valueWithUnit = valueWithUnit.replace(TypedValue.COMPLEX_UNIT_DP, "");
                    scale = metrics.density;
                }
                else if (valueWithUnit.endsWith(TypedValue.COMPLEX_UNIT_DIP)) {
                    valueWithUnit = valueWithUnit.replace(TypedValue.COMPLEX_UNIT_DIP, "");
                    scale = metrics.density;
                }
                else if (valueWithUnit.endsWith(TypedValue.COMPLEX_UNIT_SP)) {
                    valueWithUnit = valueWithUnit.replace(TypedValue.COMPLEX_UNIT_SP, "");
                    scale = metrics.density * (TypedValue.UNIT_SCALE_MAP.get(TypedValue.COMPLEX_UNIT_SP) || 1);
                }
                else if (valueWithUnit.endsWith(TypedValue.COMPLEX_UNIT_PT)) {
                    valueWithUnit = valueWithUnit.replace(TypedValue.COMPLEX_UNIT_PT, "");
                    scale = TypedValue.UNIT_SCALE_MAP.get(TypedValue.COMPLEX_UNIT_PT) || 1;
                }
                else if (valueWithUnit.endsWith(TypedValue.COMPLEX_UNIT_IN)) {
                    valueWithUnit = valueWithUnit.replace(TypedValue.COMPLEX_UNIT_IN, "");
                    scale = TypedValue.UNIT_SCALE_MAP.get(TypedValue.COMPLEX_UNIT_IN) || 1;
                }
                else if (valueWithUnit.endsWith(TypedValue.COMPLEX_UNIT_MM)) {
                    valueWithUnit = valueWithUnit.replace(TypedValue.COMPLEX_UNIT_MM, "");
                    scale = TypedValue.UNIT_SCALE_MAP.get(TypedValue.COMPLEX_UNIT_MM) || 1;
                }
                else if (valueWithUnit.endsWith(TypedValue.COMPLEX_UNIT_EM)) {
                    valueWithUnit = valueWithUnit.replace(TypedValue.COMPLEX_UNIT_EM, "");
                    scale = TypedValue.UNIT_SCALE_MAP.get(TypedValue.COMPLEX_UNIT_EM) || 1;
                }
                else if (valueWithUnit.endsWith(TypedValue.COMPLEX_UNIT_REM)) {
                    valueWithUnit = valueWithUnit.replace(TypedValue.COMPLEX_UNIT_REM, "");
                    scale = TypedValue.UNIT_SCALE_MAP.get(TypedValue.COMPLEX_UNIT_REM) || 1;
                }
                else if (valueWithUnit.endsWith(TypedValue.COMPLEX_UNIT_VH)) {
                    valueWithUnit = valueWithUnit.replace(TypedValue.COMPLEX_UNIT_VH, "");
                    scale = metrics.heightPixels / 100;
                }
                else if (valueWithUnit.endsWith(TypedValue.COMPLEX_UNIT_VW)) {
                    valueWithUnit = valueWithUnit.replace(TypedValue.COMPLEX_UNIT_VW, "");
                    scale = metrics.widthPixels / 100;
                }
                else if (valueWithUnit.endsWith(TypedValue.COMPLEX_UNIT_FRACTION)) {
                    valueWithUnit = valueWithUnit.replace(TypedValue.COMPLEX_UNIT_FRACTION, "");
                    scale = Number.parseInt(valueWithUnit) / 100;
                    if (Number.isNaN(scale))
                        return 0;
                    valueWithUnit = baseValue;
                }
                let value = Number.parseInt(valueWithUnit);
                if (Number.isNaN(value))
                    throw Error('complexToDimensionPixelSize error: ' + valueWithUnit);
                return value * scale;
            }
        }
        TypedValue.COMPLEX_UNIT_PX = 'px';
        TypedValue.COMPLEX_UNIT_DP = 'dp';
        TypedValue.COMPLEX_UNIT_DIP = 'dip';
        TypedValue.COMPLEX_UNIT_SP = 'sp';
        TypedValue.COMPLEX_UNIT_PT = 'pt';
        TypedValue.COMPLEX_UNIT_IN = 'in';
        TypedValue.COMPLEX_UNIT_MM = 'mm';
        TypedValue.COMPLEX_UNIT_EM = 'em';
        TypedValue.COMPLEX_UNIT_REM = 'rem';
        TypedValue.COMPLEX_UNIT_VH = 'vh';
        TypedValue.COMPLEX_UNIT_VW = 'vw';
        TypedValue.COMPLEX_UNIT_FRACTION = '%';
        TypedValue.UNIT_SCALE_MAP = new Map();
        util.TypedValue = TypedValue;
    })(util = android.util || (android.util = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/9.
 */
///<reference path="../graphics/Rect.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        class Gravity {
            static apply(gravity, w, h, container, outRect) {
                let xAdj = 0, yAdj = 0;
                switch (gravity & ((Gravity.AXIS_PULL_BEFORE | Gravity.AXIS_PULL_AFTER) << Gravity.AXIS_X_SHIFT)) {
                    case 0:
                        outRect.left = container.left
                            + ((container.right - container.left - w) / 2) + xAdj;
                        outRect.right = outRect.left + w;
                        if ((gravity & (Gravity.AXIS_CLIP << Gravity.AXIS_X_SHIFT))
                            == (Gravity.AXIS_CLIP << Gravity.AXIS_X_SHIFT)) {
                            if (outRect.left < container.left) {
                                outRect.left = container.left;
                            }
                            if (outRect.right > container.right) {
                                outRect.right = container.right;
                            }
                        }
                        break;
                    case Gravity.AXIS_PULL_BEFORE << Gravity.AXIS_X_SHIFT:
                        outRect.left = container.left + xAdj;
                        outRect.right = outRect.left + w;
                        if ((gravity & (Gravity.AXIS_CLIP << Gravity.AXIS_X_SHIFT))
                            == (Gravity.AXIS_CLIP << Gravity.AXIS_X_SHIFT)) {
                            if (outRect.right > container.right) {
                                outRect.right = container.right;
                            }
                        }
                        break;
                    case Gravity.AXIS_PULL_AFTER << Gravity.AXIS_X_SHIFT:
                        outRect.right = container.right - xAdj;
                        outRect.left = outRect.right - w;
                        if ((gravity & (Gravity.AXIS_CLIP << Gravity.AXIS_X_SHIFT))
                            == (Gravity.AXIS_CLIP << Gravity.AXIS_X_SHIFT)) {
                            if (outRect.left < container.left) {
                                outRect.left = container.left;
                            }
                        }
                        break;
                    default:
                        outRect.left = container.left + xAdj;
                        outRect.right = container.right + xAdj;
                        break;
                }
                switch (gravity & ((Gravity.AXIS_PULL_BEFORE | Gravity.AXIS_PULL_AFTER) << Gravity.AXIS_Y_SHIFT)) {
                    case 0:
                        outRect.top = container.top
                            + ((container.bottom - container.top - h) / 2) + yAdj;
                        outRect.bottom = outRect.top + h;
                        if ((gravity & (Gravity.AXIS_CLIP << Gravity.AXIS_Y_SHIFT))
                            == (Gravity.AXIS_CLIP << Gravity.AXIS_Y_SHIFT)) {
                            if (outRect.top < container.top) {
                                outRect.top = container.top;
                            }
                            if (outRect.bottom > container.bottom) {
                                outRect.bottom = container.bottom;
                            }
                        }
                        break;
                    case Gravity.AXIS_PULL_BEFORE << Gravity.AXIS_Y_SHIFT:
                        outRect.top = container.top + yAdj;
                        outRect.bottom = outRect.top + h;
                        if ((gravity & (Gravity.AXIS_CLIP << Gravity.AXIS_Y_SHIFT))
                            == (Gravity.AXIS_CLIP << Gravity.AXIS_Y_SHIFT)) {
                            if (outRect.bottom > container.bottom) {
                                outRect.bottom = container.bottom;
                            }
                        }
                        break;
                    case Gravity.AXIS_PULL_AFTER << Gravity.AXIS_Y_SHIFT:
                        outRect.bottom = container.bottom - yAdj;
                        outRect.top = outRect.bottom - h;
                        if ((gravity & (Gravity.AXIS_CLIP << Gravity.AXIS_Y_SHIFT))
                            == (Gravity.AXIS_CLIP << Gravity.AXIS_Y_SHIFT)) {
                            if (outRect.top < container.top) {
                                outRect.top = container.top;
                            }
                        }
                        break;
                    default:
                        outRect.top = container.top + yAdj;
                        outRect.bottom = container.bottom + yAdj;
                        break;
                }
            }
        }
        Gravity.NO_GRAVITY = 0x0000;
        Gravity.AXIS_SPECIFIED = 0x0001;
        Gravity.AXIS_PULL_BEFORE = 0x0002;
        Gravity.AXIS_PULL_AFTER = 0x0004;
        Gravity.AXIS_CLIP = 0x0008;
        Gravity.AXIS_X_SHIFT = 0;
        Gravity.AXIS_Y_SHIFT = 4;
        Gravity.TOP = (Gravity.AXIS_PULL_BEFORE | Gravity.AXIS_SPECIFIED) << Gravity.AXIS_Y_SHIFT;
        Gravity.BOTTOM = (Gravity.AXIS_PULL_AFTER | Gravity.AXIS_SPECIFIED) << Gravity.AXIS_Y_SHIFT;
        Gravity.LEFT = (Gravity.AXIS_PULL_BEFORE | Gravity.AXIS_SPECIFIED) << Gravity.AXIS_X_SHIFT;
        Gravity.RIGHT = (Gravity.AXIS_PULL_AFTER | Gravity.AXIS_SPECIFIED) << Gravity.AXIS_X_SHIFT;
        Gravity.CENTER_VERTICAL = Gravity.AXIS_SPECIFIED << Gravity.AXIS_Y_SHIFT;
        Gravity.FILL_VERTICAL = Gravity.TOP | Gravity.BOTTOM;
        Gravity.CENTER_HORIZONTAL = Gravity.AXIS_SPECIFIED << Gravity.AXIS_X_SHIFT;
        Gravity.FILL_HORIZONTAL = Gravity.LEFT | Gravity.RIGHT;
        Gravity.CENTER = Gravity.CENTER_VERTICAL | Gravity.CENTER_HORIZONTAL;
        Gravity.FILL = Gravity.FILL_VERTICAL | Gravity.FILL_HORIZONTAL;
        Gravity.CLIP_VERTICAL = Gravity.AXIS_CLIP << Gravity.AXIS_Y_SHIFT;
        Gravity.CLIP_HORIZONTAL = Gravity.AXIS_CLIP << Gravity.AXIS_X_SHIFT;
        Gravity.HORIZONTAL_GRAVITY_MASK = (Gravity.AXIS_SPECIFIED |
            Gravity.AXIS_PULL_BEFORE | Gravity.AXIS_PULL_AFTER) << Gravity.AXIS_X_SHIFT;
        Gravity.VERTICAL_GRAVITY_MASK = (Gravity.AXIS_SPECIFIED |
            Gravity.AXIS_PULL_BEFORE | Gravity.AXIS_PULL_AFTER) << Gravity.AXIS_Y_SHIFT;
        Gravity.DISPLAY_CLIP_VERTICAL = 0x10000000;
        Gravity.DISPLAY_CLIP_HORIZONTAL = 0x01000000;
        view.Gravity = Gravity;
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/1.
 */
///<reference path="Interpolator.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var animation;
        (function (animation) {
            class LinearInterpolator {
                getInterpolation(input) {
                    return input;
                }
            }
            animation.LinearInterpolator = LinearInterpolator;
        })(animation = view.animation || (view.animation = {}));
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/1.
 */
///<reference path="../../os/SystemClock.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var animation;
        (function (animation) {
            var SystemClock = android.os.SystemClock;
            class AnimationUtils {
                static currentAnimationTimeMillis() {
                    return SystemClock.uptimeMillis();
                }
            }
            animation.AnimationUtils = AnimationUtils;
        })(animation = view.animation || (view.animation = {}));
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/3.
 */
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/util/StateSet.ts"/>
var androidui;
(function (androidui) {
    var attr;
    (function (attr) {
        class StateAttr {
            constructor(state) {
                this.attributes = new Map();
                this.stateSpec = state.sort();
            }
            setAttr(name, value) {
                this.attributes.set(name, value);
            }
            hasAttr(name) {
                return this.attributes.has(name);
            }
            getAttrMap() {
                return this.attributes;
            }
            putAll(stateAttr) {
                for (let [key, value] of stateAttr.attributes.entries()) {
                    this.attributes.set(key, value);
                }
            }
            isStateEquals(state) {
                if (!state)
                    return false;
                return this.stateSpec + '' === state.sort() + '';
            }
            isStateMatch(state) {
                return android.util.StateSet.stateSetMatches(this.stateSpec, state);
            }
            mergeRemovedFrom(another) {
                if (!another)
                    return this.attributes;
                let removed = new Map(another.attributes);
                for (let key of this.attributes.keys())
                    removed.delete(key);
                let merge = new Map(this.attributes);
                for (let key of removed.keys())
                    merge.set(key, null);
                return merge;
            }
            static parseStateAttrName(stateDesc) {
                if (stateDesc.startsWith('android:'))
                    stateDesc = stateDesc.substring('android:'.length);
                if (stateDesc.startsWith('state_'))
                    stateDesc = stateDesc.substring('state_'.length);
                let stateSet = new Set();
                let stateParts = stateDesc.split('&');
                for (let part of stateParts) {
                    let sign = 1;
                    while (part.startsWith('!')) {
                        sign *= -1;
                        part = part.substring(1);
                    }
                    let stateValue = android.view.View['VIEW_STATE_' + part.toUpperCase()];
                    if (stateValue !== undefined) {
                        stateSet.add(stateValue * sign);
                    }
                }
                return stateSet;
            }
        }
        attr.StateAttr = StateAttr;
    })(attr = androidui.attr || (androidui.attr = {}));
})(androidui || (androidui = {}));
/**
 * Created by linfaxin on 15/11/3.
 */
///<reference path="StateAttr.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/util/StateSet.ts"/>
var androidui;
(function (androidui) {
    var attr;
    (function (attr_1) {
        class StateAttrList {
            constructor(ele, rootElement) {
                this.list = new Array(0);
                this.match_list = new Array(0);
                this.list.push(new attr_1.StateAttr([]));
                this._initStyleAttributes(ele, [], rootElement);
            }
            _initStyleAttributes(ele, inParseState, rootElement) {
                let attributes = Array.from(ele.attributes);
                attributes.forEach((attr) => {
                    if (attr.name === 'style' || attr.name === 'android:style') {
                        this._initStyleAttr(attr, ele, inParseState, rootElement);
                    }
                });
                attributes.forEach((attr) => {
                    if (attr.name === 'style' || attr.name === 'android:style') {
                        return;
                    }
                    if (attr.name.startsWith('android:state_') || attr.name.startsWith('state_')) {
                        return;
                    }
                    this._initStyleAttr(attr, ele, inParseState, rootElement);
                });
                attributes.forEach((attr) => {
                    if (attr.name.startsWith('android:state_') || attr.name.startsWith('state_')) {
                        this._initStyleAttr(attr, ele, inParseState, rootElement);
                    }
                });
                this.list_reverse = this.list.concat().reverse();
            }
            _initStyleAttr(attr, ele, inParseState, rootElement) {
                let attrName = attr.name;
                if (!attrName.startsWith('android:'))
                    return;
                attrName = attrName.substring('android:'.length);
                if (attrName === 'id')
                    return;
                let attrValue = attr.value;
                if (attrName.startsWith('state_')) {
                    let newStateSet = attr_1.StateAttr.parseStateAttrName(attrName);
                    inParseState = inParseState.concat(Array.from(newStateSet));
                    inParseState = Array.from(new Set(inParseState)).sort();
                }
                let _stateAttr = this.optStateAttr(inParseState);
                if (attrName.startsWith('state_') || attrName === 'style') {
                    if (attrValue.startsWith('@')) {
                        let reference = android.view.View.findReference(attrValue, ele, rootElement, false);
                        if (reference)
                            this._initStyleAttributes(reference, inParseState, rootElement);
                    }
                    else {
                        for (let part of attrValue.split(';')) {
                            let [name, value] = part.split(':');
                            value = value ? android.view.View.optReferenceString(value.trim(), ele, rootElement) : '';
                            if (name)
                                _stateAttr.setAttr(name.trim().toLowerCase(), value);
                        }
                    }
                }
                else {
                    attrValue = android.view.View.optReferenceString(attrValue, ele, rootElement);
                    _stateAttr.setAttr(attrName, attrValue);
                }
            }
            getDefaultStateAttr() {
                return this.getStateAttr(StateAttrList.EmptyArray);
            }
            getStateAttr(state) {
                for (let stateAttr of this.list) {
                    if (stateAttr.isStateEquals(state))
                        return stateAttr;
                }
            }
            optStateAttr(state) {
                let stateAttr = this.getStateAttr(state);
                if (!stateAttr) {
                    stateAttr = new attr_1.StateAttr(state);
                    this.list.splice(0, 0, stateAttr);
                }
                return stateAttr;
            }
            getMatchedAttr(state) {
                for (let stateAttr of this.match_list) {
                    if (stateAttr.isStateEquals(state))
                        return stateAttr;
                }
                let matchedAttr = new attr_1.StateAttr(state);
                for (let stateAttr of this.list_reverse) {
                    if (stateAttr.isStateMatch(state))
                        matchedAttr.putAll(stateAttr);
                }
                this.match_list.push(matchedAttr);
                return matchedAttr;
            }
        }
        StateAttrList.EmptyArray = [];
        attr_1.StateAttrList = StateAttrList;
    })(attr = androidui.attr || (androidui.attr = {}));
})(androidui || (androidui = {}));
/**
 * Created by linfaxin on 15/11/26.
 */
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/Gravity.ts"/>
///<reference path="../../android/graphics/drawable/Drawable.ts"/>
///<reference path="../../android/graphics/drawable/ColorDrawable.ts"/>
///<reference path="../../android/content/res/ColorStateList.ts"/>
var androidui;
(function (androidui) {
    var attr;
    (function (attr) {
        var Gravity = android.view.Gravity;
        var Drawable = android.graphics.drawable.Drawable;
        var ColorDrawable = android.graphics.drawable.ColorDrawable;
        var Color = android.graphics.Color;
        var ColorStateList = android.content.res.ColorStateList;
        var TypedValue = android.util.TypedValue;
        class AttrBinder {
            constructor(host) {
                this.attrChangeMap = new Map();
                this.attrStashMap = new Map();
                this.objectRefs = [];
                this.host = host;
            }
            addAttr(attrName, onAttrChange, stashAttrValueWhenStateChange) {
                if (!attrName)
                    return;
                attrName = attrName.toLowerCase();
                if (onAttrChange)
                    this.attrChangeMap.set(attrName, onAttrChange);
                if (stashAttrValueWhenStateChange)
                    this.attrStashMap.set(attrName, stashAttrValueWhenStateChange);
            }
            onAttrChange(attrName, attrValue, rootElement) {
                this.rootElement = rootElement;
                if (!attrName)
                    return;
                attrName = attrName.toLowerCase();
                let onAttrChangeCall = this.attrChangeMap.get(attrName);
                if (onAttrChangeCall)
                    onAttrChangeCall.call(this.host, attrValue);
            }
            getAttrValue(attrName) {
                if (!attrName)
                    return null;
                attrName = attrName.toLowerCase();
                let getAttrCall = this.attrStashMap.get(attrName);
                if (getAttrCall) {
                    let value = getAttrCall.call(this.host);
                    if (value == null)
                        return null;
                    if (typeof value === "number")
                        return value + '';
                    if (typeof value === "boolean")
                        return value + '';
                    if (typeof value === "string")
                        return value;
                    return this.setRefObject(value);
                }
                return null;
            }
            getRefObject(ref, recycel = true) {
                if (ref && ref.startsWith('@ref/')) {
                    ref = ref.substring(5);
                    let index = Number.parseInt(ref);
                    if (Number.isInteger(index)) {
                        let obj = this.objectRefs[index];
                        if (recycel)
                            this.objectRefs[index] = null;
                        return obj;
                    }
                }
            }
            setRefObject(obj) {
                let length = this.objectRefs.length;
                for (let i = 0; i < length; i++) {
                    if (this.objectRefs[i] == null) {
                        this.objectRefs[i] = obj;
                        return '@ref/' + i;
                    }
                }
                this.objectRefs.push(obj);
                return '@ref/' + length;
            }
            parsePaddingMarginLTRB(value) {
                value = (value + '');
                let parts = [];
                for (let part of value.split(' ')) {
                    if (part)
                        parts.push(part);
                }
                switch (parts.length) {
                    case 1: return [parts[0], parts[0], parts[0], parts[0]];
                    case 2: return [parts[1], parts[0], parts[1], parts[0]];
                    case 3: return [parts[1], parts[0], parts[1], parts[2]];
                    case 4: return [parts[3], parts[0], parts[1], parts[2]];
                }
                throw Error('not a padding or margin value : ' + value);
            }
            parseBoolean(value, defaultValue = true) {
                if (value === false || value === 'fales' || value === '0')
                    return false;
                else if (value === true || value === 'true' || value === '1' || value === '')
                    return true;
                return defaultValue;
            }
            parseGravity(s, defaultValue = Gravity.NO_GRAVITY) {
                let gravity = Number.parseInt(s);
                if (Number.isInteger(gravity))
                    return gravity;
                gravity = Gravity.NO_GRAVITY;
                try {
                    let parts = s.split("|");
                    parts.forEach((part) => {
                        let g = Gravity[part.toUpperCase()];
                        if (Number.isInteger(g))
                            gravity |= g;
                    });
                }
                catch (e) {
                    console.error(e);
                }
                if (Number.isNaN(gravity) || gravity === Gravity.NO_GRAVITY)
                    gravity = defaultValue;
                return gravity;
            }
            parseDrawable(s) {
                if (!s)
                    return null;
                if (s instanceof Drawable)
                    return s;
                if (s.startsWith('@')) {
                    let refObj = this.getRefObject(s);
                    if (refObj)
                        return refObj;
                }
                else {
                    let color = this.parseColor(s);
                    return new ColorDrawable(color);
                }
            }
            parseColor(value, defaultValue) {
                let color = Number.parseInt(value);
                if (Number.isInteger(color))
                    return color;
                try {
                    if (value.startsWith('rgb(')) {
                        value = value.substring(value.indexOf('(') + 1, value.lastIndexOf(')'));
                        let parts = value.split(',');
                        return Color.rgb(Number.parseInt(parts[0]), Number.parseInt(parts[1]), Number.parseInt(parts[2]));
                    }
                    else if (value.startsWith('rgba(')) {
                        value = value.substring(value.indexOf('(') + 1, value.lastIndexOf(')'));
                        let parts = value.split(',');
                        return Color.rgba(Number.parseInt(parts[0]), Number.parseInt(parts[1]), Number.parseInt(parts[2]), Number.parseFloat(parts[3]) * 255);
                    }
                    else {
                        if (value.startsWith('#') && value.length === 4) {
                            value = '#' + value[1] + value[1] + value[2] + value[2] + value[2] + value[2];
                        }
                        return Color.parseColor(value);
                    }
                }
                catch (e) {
                    if (defaultValue == null)
                        throw e;
                    return defaultValue;
                }
            }
            parseColorList(value) {
                if (!value)
                    return null;
                if (value instanceof ColorStateList)
                    return value;
                if (value.startsWith('@')) {
                    let refObj = this.getRefObject(value);
                    if (refObj)
                        return refObj;
                }
                else {
                    let color = this.parseColor(value);
                    return ColorStateList.valueOf(color);
                }
                return null;
            }
            parseNumber(value, defaultValue = 0, baseValue = 0) {
                try {
                    return TypedValue.complexToDimensionPixelSize(value, baseValue);
                }
                catch (e) {
                    return defaultValue;
                }
            }
        }
        attr.AttrBinder = AttrBinder;
    })(attr = androidui.attr || (androidui.attr = {}));
})(androidui || (androidui = {}));
var androidui;
(function (androidui) {
    var util;
    (function (util) {
        class ClassFinder {
            static findClass(classFullName, findInRoot = window) {
                let nameParts = classFullName.split('.');
                let finding = findInRoot;
                for (let part of nameParts) {
                    let quickFind = finding[part.toLowerCase()];
                    if (quickFind) {
                        finding = quickFind;
                        continue;
                    }
                    let found = false;
                    for (let key in finding) {
                        if (key.toUpperCase() === part.toUpperCase()) {
                            finding = finding[key];
                            found = true;
                            break;
                        }
                    }
                    if (!found)
                        return null;
                }
                if (finding === findInRoot) {
                    return null;
                }
                return finding;
            }
        }
        util.ClassFinder = ClassFinder;
    })(util = androidui.util || (androidui.util = {}));
})(androidui || (androidui = {}));
/**
 * Created by linfaxin on 15/11/16.
 */
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
/**
 * Created by linfaxin on 15/12/1.
 */
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/graphics/Canvas.ts"/>
var androidui;
(function (androidui) {
    var util;
    (function (util) {
        var ColorDrawable = android.graphics.drawable.ColorDrawable;
        var Color = android.graphics.Color;
        class PerformanceAdjuster {
            static noCanvasMode() {
                android.graphics.Canvas.prototype = HackCanvas.prototype;
                android.view.View.prototype.onDrawVerticalScrollBar =
                    function (canvas, scrollBar, l, t, r, b) {
                        let scrollBarEl = this.bindElement['VerticalScrollBar'];
                        if (!scrollBarEl) {
                            scrollBarEl = document.createElement('div');
                            this.bindElement['VerticalScrollBar'] = scrollBarEl;
                            scrollBarEl.style.zIndex = '9';
                            scrollBarEl.style.position = 'absolute';
                            scrollBarEl.style.background = 'black';
                            scrollBarEl.style.left = '0px';
                            scrollBarEl.style.top = '0px';
                            this.bindElement.appendChild(scrollBarEl);
                        }
                        let height = b - t;
                        let width = r - l;
                        let size = height;
                        let thickness = width;
                        let extent = this.mScrollCache.scrollBar.mExtent;
                        let range = this.mScrollCache.scrollBar.mRange;
                        let length = Math.round(size * extent / range);
                        let offset = Math.round((size - length) * this.mScrollCache.scrollBar.mOffset / (range - extent));
                        if (t < 0)
                            t = 0;
                        if (offset < 0)
                            offset = 0;
                        scrollBarEl.style.transform = scrollBarEl.style.webkitTransform = `translate(${l}px, ${t + offset}px)`;
                        scrollBarEl.style.width = (r - l) / 2 + 'px';
                        scrollBarEl.style.height = length + 'px';
                        scrollBarEl.style.opacity = this.mScrollCache.scrollBar.mVerticalThumb.getAlpha() / 255 + '';
                    };
                const oldSetBackground = android.view.View.prototype.setBackground;
                android.view.View.prototype.setBackground = function (drawable) {
                    oldSetBackground.call(this, drawable);
                    if (drawable instanceof ColorDrawable) {
                        this.bindElement.style.background = Color.toRGBAFunc(this.mBackground.getColor());
                    }
                };
            }
        }
        util.PerformanceAdjuster = PerformanceAdjuster;
        class HackCanvas extends android.graphics.Canvas {
            init() {
            }
            recycle() {
            }
            translate(dx, dy) {
            }
            scale(sx, sy, px, py) {
            }
            rotate(degrees, px, py) {
            }
            drawRGB(r, g, b) {
            }
            drawARGB(a, r, g, b) {
            }
            drawColor(color) {
            }
            clearColor() {
            }
            save() {
                return 1;
            }
            restore() {
            }
            restoreToCount(saveCount) {
            }
            getSaveCount() {
                return 1;
            }
            clipRect(...args) {
                return false;
            }
            getClipBounds(bounds) {
                return null;
            }
            quickReject(...args) {
                return false;
            }
            drawCanvas(canvas, offsetX, offsetY) {
            }
            drawRect(...args) {
            }
            drawText(text, x, y, paint) {
            }
        }
    })(util = androidui.util || (androidui.util = {}));
})(androidui || (androidui = {}));
///<reference path="../content/res/Resources.ts"/>
///<reference path="../graphics/Rect.ts"/>
///<reference path="../view/ViewConfiguration.ts"/>
///<reference path="../os/SystemClock.ts"/>
///<reference path="../util/Log.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var SystemClock = android.os.SystemClock;
        var Log = android.util.Log;
        const DEBUG = false;
        const TAG = "KeyEvent";
        class KeyEvent {
            constructor() {
                this._downingKeyEventMap = new Map();
            }
            appendKeyEvent(keyEvent, action) {
                this._activeKeyEvent = keyEvent;
                if (action === KeyEvent.ACTION_DOWN) {
                    this.mDownTime = SystemClock.uptimeMillis();
                    let keyEvents = this._downingKeyEventMap.get(keyEvent.keyCode);
                    if (keyEvents == null) {
                        keyEvents = [];
                        this._downingKeyEventMap.set(keyEvent.keyCode, keyEvents);
                    }
                    keyEvents.push(keyEvent);
                }
                else if (action === KeyEvent.ACTION_UP) {
                    this._downingKeyEventMap.delete(keyEvent.keyCode);
                }
                this.mAction = action;
            }
            static isConfirmKey(keyCode) {
                switch (keyCode) {
                    case KeyEvent.KEYCODE_DPAD_CENTER:
                    case KeyEvent.KEYCODE_ENTER:
                        return true;
                    default:
                        return false;
                }
            }
            isAltPressed() {
                return this._activeKeyEvent.altKey;
            }
            isShiftPressed() {
                return this._activeKeyEvent.shiftKey;
            }
            isCtrlPressed() {
                return this._activeKeyEvent.ctrlKey;
            }
            isMetaPressed() {
                return this._activeKeyEvent.metaKey;
            }
            getAction() {
                return this.mAction;
            }
            startTracking() {
                this.mFlags |= KeyEvent.FLAG_START_TRACKING;
            }
            isTracking() {
                return (this.mFlags & KeyEvent.FLAG_TRACKING) != 0;
            }
            isLongPress() {
                return this.getRepeatCount() === 1;
            }
            getKeyCode() {
                return this._activeKeyEvent.keyCode;
            }
            getRepeatCount() {
                let downArray = this._downingKeyEventMap.get(this._activeKeyEvent.keyCode);
                return downArray ? downArray.length - 1 : 0;
            }
            getDownTime() {
                return this.mDownTime;
            }
            getEventTime() {
                return this._activeKeyEvent.timeStamp;
            }
            dispatch(receiver, state, target) {
                switch (this.mAction) {
                    case KeyEvent.ACTION_DOWN: {
                        this.mFlags &= ~KeyEvent.FLAG_START_TRACKING;
                        if (DEBUG)
                            Log.v(TAG, "Key down to " + target + " in " + state
                                + ": " + this);
                        let res = receiver.onKeyDown(this.getKeyCode(), this);
                        if (state != null) {
                            if (res && this.getRepeatCount() == 0 && (this.mFlags & KeyEvent.FLAG_START_TRACKING) != 0) {
                                if (DEBUG)
                                    Log.v(TAG, "  Start tracking!");
                                state.startTracking(this, target);
                            }
                            else if (this.isLongPress() && state.isTracking(this)) {
                                if (receiver.onKeyLongPress(this.getKeyCode(), this)) {
                                    if (DEBUG)
                                        Log.v(TAG, "  Clear from long press!");
                                    state.performedLongPress(this);
                                    res = true;
                                }
                            }
                        }
                        return res;
                    }
                    case KeyEvent.ACTION_UP:
                        if (DEBUG)
                            Log.v(TAG, "Key up to " + target + " in " + state
                                + ": " + this);
                        if (state != null) {
                            state.handleUpEvent(this);
                        }
                        return receiver.onKeyUp(this.getKeyCode(), this);
                }
                return false;
            }
            hasNoModifiers() {
                if (this.isAltPressed())
                    return false;
                if (this.isShiftPressed())
                    return false;
                if (this.isCtrlPressed())
                    return false;
                if (this.isMetaPressed())
                    return false;
                return true;
            }
            hasModifiers(modifiers) {
                if ((modifiers & KeyEvent.META_ALT_ON) === KeyEvent.META_ALT_ON && this.isAltPressed())
                    return true;
                if ((modifiers & KeyEvent.META_SHIFT_ON) === KeyEvent.META_SHIFT_ON && this.isShiftPressed())
                    return true;
                if ((modifiers & KeyEvent.META_META_ON) === KeyEvent.META_META_ON && this.isMetaPressed())
                    return true;
                if ((modifiers & KeyEvent.META_CTRL_ON) === KeyEvent.META_CTRL_ON && this.isCtrlPressed())
                    return true;
            }
            getMetaState() {
                let meta = 0;
                if (this.isAltPressed())
                    meta |= KeyEvent.META_ALT_ON;
                if (this.isShiftPressed())
                    meta |= KeyEvent.META_SHIFT_ON;
                if (this.isCtrlPressed())
                    meta |= KeyEvent.META_CTRL_ON;
                if (this.isMetaPressed())
                    meta |= KeyEvent.META_META_ON;
                return meta;
            }
            toString() {
                return JSON.stringify(this._activeKeyEvent);
            }
            static actionToString(action) {
                switch (action) {
                    case KeyEvent.ACTION_DOWN:
                        return "ACTION_DOWN";
                    case KeyEvent.ACTION_UP:
                        return "ACTION_UP";
                    default:
                        return '' + (action);
                }
            }
            static keyCodeToString(keyCode) {
                return String.fromCharCode(keyCode);
            }
        }
        KeyEvent.KEYCODE_DPAD_UP = 38;
        KeyEvent.KEYCODE_DPAD_DOWN = 40;
        KeyEvent.KEYCODE_DPAD_LEFT = 37;
        KeyEvent.KEYCODE_DPAD_RIGHT = 39;
        KeyEvent.KEYCODE_DPAD_CENTER = 13;
        KeyEvent.KEYCODE_ENTER = 13;
        KeyEvent.KEYCODE_TAB = 9;
        KeyEvent.KEYCODE_SPACE = 32;
        KeyEvent.KEYCODE_ESCAPE = 27;
        KeyEvent.KEYCODE_PAGE_UP = 33;
        KeyEvent.KEYCODE_PAGE_DOWN = 34;
        KeyEvent.KEYCODE_MOVE_HOME = 36;
        KeyEvent.KEYCODE_MOVE_END = 35;
        KeyEvent.ACTION_DOWN = 0;
        KeyEvent.ACTION_UP = 1;
        KeyEvent.META_ALT_ON = 0x02;
        KeyEvent.META_SHIFT_ON = 0x1;
        KeyEvent.META_CTRL_ON = 0x1000;
        KeyEvent.META_META_ON = 0x10000;
        KeyEvent.FLAG_CANCELED = 0x20;
        KeyEvent.FLAG_CANCELED_LONG_PRESS = 0x100;
        KeyEvent.FLAG_LONG_PRESS = 0x80;
        KeyEvent.FLAG_TRACKING = 0x200;
        KeyEvent.FLAG_START_TRACKING = 0x40000000;
        view.KeyEvent = KeyEvent;
        (function (KeyEvent) {
            class DispatcherState {
                constructor() {
                    this.mActiveLongPresses = new android.util.SparseArray();
                }
                reset(target) {
                    if (target == null) {
                        if (DEBUG)
                            Log.v(TAG, "Reset: " + this);
                        this.mDownKeyCode = 0;
                        this.mDownTarget = null;
                        this.mActiveLongPresses.clear();
                    }
                    else {
                        if (this.mDownTarget == target) {
                            if (DEBUG)
                                Log.v(TAG, "Reset in " + target + ": " + this);
                            this.mDownKeyCode = 0;
                            this.mDownTarget = null;
                        }
                    }
                }
                startTracking(event, target) {
                    if (event.getAction() != KeyEvent.ACTION_DOWN) {
                        throw new Error("Can only start tracking on a down event");
                    }
                    if (DEBUG)
                        Log.v(TAG, "Start trackingt in " + target + ": " + this);
                    this.mDownKeyCode = event.getKeyCode();
                    this.mDownTarget = target;
                }
                isTracking(event) {
                    return this.mDownKeyCode == event.getKeyCode();
                }
                performedLongPress(event) {
                    this.mActiveLongPresses.put(event.getKeyCode(), 1);
                }
                handleUpEvent(event) {
                    const keyCode = event.getKeyCode();
                    if (DEBUG)
                        Log.v(TAG, "Handle key up " + event + ": " + this);
                    let index = this.mActiveLongPresses.indexOfKey(keyCode);
                    if (index >= 0) {
                        if (DEBUG)
                            Log.v(TAG, "  Index: " + index);
                        event.mFlags |= KeyEvent.FLAG_CANCELED | KeyEvent.FLAG_CANCELED_LONG_PRESS;
                        this.mActiveLongPresses.removeAt(index);
                    }
                    if (this.mDownKeyCode == keyCode) {
                        if (DEBUG)
                            Log.v(TAG, "  Tracking!");
                        event.mFlags |= KeyEvent.FLAG_TRACKING;
                        this.mDownKeyCode = 0;
                        this.mDownTarget = null;
                    }
                }
            }
            KeyEvent.DispatcherState = DispatcherState;
        })(KeyEvent = view.KeyEvent || (view.KeyEvent = {}));
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/2.
 */
///<reference path="Drawable.ts"/>
///<reference path="../Canvas.ts"/>
///<reference path="../Rect.ts"/>
///<reference path="../PixelFormat.ts"/>
///<reference path="../../../java/lang/ref/WeakReference.ts"/>
///<reference path="../../../java/lang/Runnable.ts"/>
///<reference path="../../util/StateSet.ts"/>
///<reference path="../../util/Log.ts"/>
///<reference path="../../util/SparseArray.ts"/>
///<reference path="../../os/SystemClock.ts"/>
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        var drawable;
        (function (drawable) {
            var Rect = android.graphics.Rect;
            var PixelFormat = android.graphics.PixelFormat;
            var Log = android.util.Log;
            var SparseArray = android.util.SparseArray;
            var SystemClock = android.os.SystemClock;
            class DrawableContainer extends drawable.Drawable {
                constructor(...args) {
                    super(...args);
                    this.mAlpha = 0xFF;
                    this.mCurIndex = -1;
                    this.mMutated = false;
                    this.mEnterAnimationEnd = 0;
                    this.mExitAnimationEnd = 0;
                }
                draw(canvas) {
                    if (this.mCurrDrawable != null) {
                        this.mCurrDrawable.draw(canvas);
                    }
                    if (this.mLastDrawable != null) {
                        this.mLastDrawable.draw(canvas);
                    }
                }
                needsMirroring() {
                    return false && this.isAutoMirrored();
                }
                getPadding(padding) {
                    const r = this.mDrawableContainerState.getConstantPadding();
                    let result;
                    if (r != null) {
                        padding.set(r);
                        result = (r.left | r.top | r.bottom | r.right) != 0;
                    }
                    else {
                        if (this.mCurrDrawable != null) {
                            result = this.mCurrDrawable.getPadding(padding);
                        }
                        else {
                            result = super.getPadding(padding);
                        }
                    }
                    if (this.needsMirroring()) {
                        const left = padding.left;
                        const right = padding.right;
                        padding.left = right;
                        padding.right = left;
                    }
                    return result;
                }
                setAlpha(alpha) {
                    if (this.mAlpha != alpha) {
                        this.mAlpha = alpha;
                        if (this.mCurrDrawable != null) {
                            if (this.mEnterAnimationEnd == 0) {
                                this.mCurrDrawable.mutate().setAlpha(alpha);
                            }
                            else {
                                this.animate(false);
                            }
                        }
                    }
                }
                getAlpha() {
                    return this.mAlpha;
                }
                setDither(dither) {
                    if (this.mDrawableContainerState.mDither != dither) {
                        this.mDrawableContainerState.mDither = dither;
                        if (this.mCurrDrawable != null) {
                            this.mCurrDrawable.mutate().setDither(this.mDrawableContainerState.mDither);
                        }
                    }
                }
                setEnterFadeDuration(ms) {
                    this.mDrawableContainerState.mEnterFadeDuration = ms;
                }
                setExitFadeDuration(ms) {
                    this.mDrawableContainerState.mExitFadeDuration = ms;
                }
                onBoundsChange(bounds) {
                    if (this.mLastDrawable != null) {
                        this.mLastDrawable.setBounds(bounds);
                    }
                    if (this.mCurrDrawable != null) {
                        this.mCurrDrawable.setBounds(bounds);
                    }
                }
                isStateful() {
                    return this.mDrawableContainerState.isStateful();
                }
                setAutoMirrored(mirrored) {
                    this.mDrawableContainerState.mAutoMirrored = mirrored;
                    if (this.mCurrDrawable != null) {
                        this.mCurrDrawable.mutate().setAutoMirrored(this.mDrawableContainerState.mAutoMirrored);
                    }
                }
                isAutoMirrored() {
                    return this.mDrawableContainerState.mAutoMirrored;
                }
                jumpToCurrentState() {
                    let changed = false;
                    if (this.mLastDrawable != null) {
                        this.mLastDrawable.jumpToCurrentState();
                        this.mLastDrawable = null;
                        changed = true;
                    }
                    if (this.mCurrDrawable != null) {
                        this.mCurrDrawable.jumpToCurrentState();
                        this.mCurrDrawable.mutate().setAlpha(this.mAlpha);
                    }
                    if (this.mExitAnimationEnd != 0) {
                        this.mExitAnimationEnd = 0;
                        changed = true;
                    }
                    if (this.mEnterAnimationEnd != 0) {
                        this.mEnterAnimationEnd = 0;
                        changed = true;
                    }
                    if (changed) {
                        this.invalidateSelf();
                    }
                }
                onStateChange(state) {
                    if (this.mLastDrawable != null) {
                        return this.mLastDrawable.setState(state);
                    }
                    if (this.mCurrDrawable != null) {
                        return this.mCurrDrawable.setState(state);
                    }
                    return false;
                }
                onLevelChange(level) {
                    if (this.mLastDrawable != null) {
                        return this.mLastDrawable.setLevel(level);
                    }
                    if (this.mCurrDrawable != null) {
                        return this.mCurrDrawable.setLevel(level);
                    }
                    return false;
                }
                getIntrinsicWidth() {
                    if (this.mDrawableContainerState.isConstantSize()) {
                        return this.mDrawableContainerState.getConstantWidth();
                    }
                    return this.mCurrDrawable != null ? this.mCurrDrawable.getIntrinsicWidth() : -1;
                }
                getIntrinsicHeight() {
                    if (this.mDrawableContainerState.isConstantSize()) {
                        return this.mDrawableContainerState.getConstantHeight();
                    }
                    return this.mCurrDrawable != null ? this.mCurrDrawable.getIntrinsicHeight() : -1;
                }
                getMinimumWidth() {
                    if (this.mDrawableContainerState.isConstantSize()) {
                        return this.mDrawableContainerState.getConstantMinimumWidth();
                    }
                    return this.mCurrDrawable != null ? this.mCurrDrawable.getMinimumWidth() : 0;
                }
                getMinimumHeight() {
                    if (this.mDrawableContainerState.isConstantSize()) {
                        return this.mDrawableContainerState.getConstantMinimumHeight();
                    }
                    return this.mCurrDrawable != null ? this.mCurrDrawable.getMinimumHeight() : 0;
                }
                invalidateDrawable(who) {
                    if (who == this.mCurrDrawable && this.getCallback() != null) {
                        this.getCallback().invalidateDrawable(this);
                    }
                }
                scheduleDrawable(who, what, when) {
                    if (who == this.mCurrDrawable && this.getCallback() != null) {
                        this.getCallback().scheduleDrawable(this, what, when);
                    }
                }
                unscheduleDrawable(who, what) {
                    if (who == this.mCurrDrawable && this.getCallback() != null) {
                        this.getCallback().unscheduleDrawable(this, what);
                    }
                }
                setVisible(visible, restart) {
                    let changed = super.setVisible(visible, restart);
                    if (this.mLastDrawable != null) {
                        this.mLastDrawable.setVisible(visible, restart);
                    }
                    if (this.mCurrDrawable != null) {
                        this.mCurrDrawable.setVisible(visible, restart);
                    }
                    return changed;
                }
                getOpacity() {
                    return this.mCurrDrawable == null || !this.mCurrDrawable.isVisible() ? PixelFormat.TRANSPARENT :
                        this.mDrawableContainerState.getOpacity();
                }
                selectDrawable(idx) {
                    if (idx == this.mCurIndex) {
                        return false;
                    }
                    const now = SystemClock.uptimeMillis();
                    if (DrawableContainer.DEBUG)
                        android.util.Log.i(DrawableContainer.TAG, toString() + " from " + this.mCurIndex + " to " + idx
                            + ": exit=" + this.mDrawableContainerState.mExitFadeDuration
                            + " enter=" + this.mDrawableContainerState.mEnterFadeDuration);
                    if (this.mDrawableContainerState.mExitFadeDuration > 0) {
                        if (this.mLastDrawable != null) {
                            this.mLastDrawable.setVisible(false, false);
                        }
                        if (this.mCurrDrawable != null) {
                            this.mLastDrawable = this.mCurrDrawable;
                            this.mExitAnimationEnd = now + this.mDrawableContainerState.mExitFadeDuration;
                        }
                        else {
                            this.mLastDrawable = null;
                            this.mExitAnimationEnd = 0;
                        }
                    }
                    else if (this.mCurrDrawable != null) {
                        this.mCurrDrawable.setVisible(false, false);
                    }
                    if (idx >= 0 && idx < this.mDrawableContainerState.mNumChildren) {
                        const d = this.mDrawableContainerState.getChild(idx);
                        this.mCurrDrawable = d;
                        this.mCurIndex = idx;
                        if (d != null) {
                            d.mutate();
                            if (this.mDrawableContainerState.mEnterFadeDuration > 0) {
                                this.mEnterAnimationEnd = now + this.mDrawableContainerState.mEnterFadeDuration;
                            }
                            else {
                                d.setAlpha(this.mAlpha);
                            }
                            d.setVisible(this.isVisible(), true);
                            d.setDither(this.mDrawableContainerState.mDither);
                            d.setState(this.getState());
                            d.setLevel(this.getLevel());
                            d.setBounds(this.getBounds());
                            d.setAutoMirrored(this.mDrawableContainerState.mAutoMirrored);
                        }
                        else {
                        }
                    }
                    else {
                        this.mCurrDrawable = null;
                        this.mCurIndex = -1;
                    }
                    if (this.mEnterAnimationEnd != 0 || this.mExitAnimationEnd != 0) {
                        if (this.mAnimationRunnable == null) {
                            let t = this;
                            this.mAnimationRunnable = {
                                run() {
                                    t.animate(true);
                                    t.invalidateSelf();
                                }
                            };
                        }
                        else {
                            this.unscheduleSelf(this.mAnimationRunnable);
                        }
                        this.animate(true);
                    }
                    this.invalidateSelf();
                    return true;
                }
                animate(schedule) {
                    const now = SystemClock.uptimeMillis();
                    let animating = false;
                    if (this.mCurrDrawable != null) {
                        if (this.mEnterAnimationEnd != 0) {
                            if (this.mEnterAnimationEnd <= now) {
                                this.mCurrDrawable.mutate().setAlpha(this.mAlpha);
                                this.mEnterAnimationEnd = 0;
                            }
                            else {
                                let animAlpha = ((this.mEnterAnimationEnd - now) * 255)
                                    / this.mDrawableContainerState.mEnterFadeDuration;
                                if (DrawableContainer.DEBUG)
                                    android.util.Log.i(DrawableContainer.TAG, toString() + " cur alpha " + animAlpha);
                                this.mCurrDrawable.mutate().setAlpha(((255 - animAlpha) * this.mAlpha) / 255);
                                animating = true;
                            }
                        }
                    }
                    else {
                        this.mEnterAnimationEnd = 0;
                    }
                    if (this.mLastDrawable != null) {
                        if (this.mExitAnimationEnd != 0) {
                            if (this.mExitAnimationEnd <= now) {
                                this.mLastDrawable.setVisible(false, false);
                                this.mLastDrawable = null;
                                this.mExitAnimationEnd = 0;
                            }
                            else {
                                let animAlpha = ((this.mExitAnimationEnd - now) * 255)
                                    / this.mDrawableContainerState.mExitFadeDuration;
                                if (DrawableContainer.DEBUG)
                                    android.util.Log.i(DrawableContainer.TAG, toString() + " last alpha " + animAlpha);
                                this.mLastDrawable.mutate().setAlpha((animAlpha * this.mAlpha) / 255);
                                animating = true;
                            }
                        }
                    }
                    else {
                        this.mExitAnimationEnd = 0;
                    }
                    if (schedule && animating) {
                        this.scheduleSelf(this.mAnimationRunnable, now + 1000 / 60);
                    }
                }
                getCurrent() {
                    return this.mCurrDrawable;
                }
                getConstantState() {
                    if (this.mDrawableContainerState.canConstantState()) {
                        return this.mDrawableContainerState;
                    }
                    return null;
                }
                mutate() {
                    if (!this.mMutated && super.mutate() == this) {
                        this.mDrawableContainerState.mutate();
                        this.mMutated = true;
                    }
                    return this;
                }
                setConstantState(state) {
                    this.mDrawableContainerState = state;
                }
            }
            DrawableContainer.DEBUG = Log.DBG_DrawableContainer;
            DrawableContainer.TAG = "DrawableContainer";
            DrawableContainer.DEFAULT_DITHER = true;
            drawable.DrawableContainer = DrawableContainer;
            (function (DrawableContainer) {
                class DrawableContainerState {
                    constructor(orig, owner) {
                        this.mVariablePadding = false;
                        this.mPaddingChecked = false;
                        this.mConstantSize = false;
                        this.mComputedConstantSize = false;
                        this.mConstantWidth = 0;
                        this.mConstantHeight = 0;
                        this.mConstantMinimumWidth = 0;
                        this.mConstantMinimumHeight = 0;
                        this.mCheckedOpacity = false;
                        this.mOpacity = 0;
                        this.mCheckedStateful = false;
                        this.mStateful = false;
                        this.mCheckedConstantState = false;
                        this.mCanConstantState = false;
                        this.mDither = DrawableContainer.DEFAULT_DITHER;
                        this.mMutated = false;
                        this.mEnterFadeDuration = 0;
                        this.mExitFadeDuration = 0;
                        this.mAutoMirrored = false;
                        this.mOwner = owner;
                        if (orig != null) {
                            this.mCheckedConstantState = true;
                            this.mCanConstantState = true;
                            this.mVariablePadding = orig.mVariablePadding;
                            this.mConstantSize = orig.mConstantSize;
                            this.mDither = orig.mDither;
                            this.mMutated = orig.mMutated;
                            this.mEnterFadeDuration = orig.mEnterFadeDuration;
                            this.mExitFadeDuration = orig.mExitFadeDuration;
                            this.mAutoMirrored = orig.mAutoMirrored;
                            this.mConstantPadding = orig.getConstantPadding();
                            this.mPaddingChecked = true;
                            this.mConstantWidth = orig.getConstantWidth();
                            this.mConstantHeight = orig.getConstantHeight();
                            this.mConstantMinimumWidth = orig.getConstantMinimumWidth();
                            this.mConstantMinimumHeight = orig.getConstantMinimumHeight();
                            this.mComputedConstantSize = true;
                            this.mOpacity = orig.getOpacity();
                            this.mCheckedOpacity = true;
                            this.mStateful = orig.isStateful();
                            this.mCheckedStateful = true;
                            const origDr = orig.mDrawables;
                            this.mDrawables = new Array(0);
                            const origDf = orig.mDrawableFutures;
                            if (origDf != null) {
                                this.mDrawableFutures = origDf.clone();
                            }
                            else {
                                this.mDrawableFutures = new SparseArray(this.mNumChildren);
                            }
                            const N = this.mNumChildren;
                            for (let i = 0; i < N; i++) {
                                if (origDr[i] != null) {
                                    this.mDrawableFutures.put(i, new ConstantStateFuture(origDr[i]));
                                }
                            }
                        }
                        else {
                            this.mDrawables = new Array(0);
                        }
                    }
                    get mNumChildren() {
                        return this.mDrawables.length;
                    }
                    addChild(dr) {
                        const pos = this.mNumChildren;
                        dr.setVisible(false, true);
                        dr.setCallback(this.mOwner);
                        this.mDrawables.push(dr);
                        this.mCheckedStateful = false;
                        this.mCheckedOpacity = false;
                        this.mConstantPadding = null;
                        this.mPaddingChecked = false;
                        this.mComputedConstantSize = false;
                        return pos;
                    }
                    getCapacity() {
                        return this.mDrawables.length;
                    }
                    createAllFutures() {
                        if (this.mDrawableFutures != null) {
                            const futureCount = this.mDrawableFutures.size();
                            for (let keyIndex = 0; keyIndex < futureCount; keyIndex++) {
                                const index = this.mDrawableFutures.keyAt(keyIndex);
                                this.mDrawables[index] = this.mDrawableFutures.valueAt(keyIndex).get(this);
                            }
                            this.mDrawableFutures = null;
                        }
                    }
                    getChildCount() {
                        return this.mNumChildren;
                    }
                    getChildren() {
                        this.createAllFutures();
                        return this.mDrawables;
                    }
                    getChild(index) {
                        const result = this.mDrawables[index];
                        if (result != null) {
                            return result;
                        }
                        if (this.mDrawableFutures != null) {
                            const keyIndex = this.mDrawableFutures.indexOfKey(index);
                            if (keyIndex >= 0) {
                                const prepared = this.mDrawableFutures.valueAt(keyIndex).get(this);
                                this.mDrawables[index] = prepared;
                                this.mDrawableFutures.removeAt(keyIndex);
                                return prepared;
                            }
                        }
                        return null;
                    }
                    mutate() {
                        const N = this.mNumChildren;
                        const drawables = this.mDrawables;
                        for (let i = 0; i < N; i++) {
                            if (drawables[i] != null) {
                                drawables[i].mutate();
                            }
                        }
                        this.mMutated = true;
                    }
                    setVariablePadding(variable) {
                        this.mVariablePadding = variable;
                    }
                    getConstantPadding() {
                        if (this.mVariablePadding) {
                            return null;
                        }
                        if ((this.mConstantPadding != null) || this.mPaddingChecked) {
                            return this.mConstantPadding;
                        }
                        this.createAllFutures();
                        let r = null;
                        const t = new Rect();
                        const N = this.mNumChildren;
                        const drawables = this.mDrawables;
                        for (let i = 0; i < N; i++) {
                            if (drawables[i].getPadding(t)) {
                                if (r == null)
                                    r = new Rect(0, 0, 0, 0);
                                if (t.left > r.left)
                                    r.left = t.left;
                                if (t.top > r.top)
                                    r.top = t.top;
                                if (t.right > r.right)
                                    r.right = t.right;
                                if (t.bottom > r.bottom)
                                    r.bottom = t.bottom;
                            }
                        }
                        this.mPaddingChecked = true;
                        return (this.mConstantPadding = r);
                    }
                    setConstantSize(constant) {
                        this.mConstantSize = constant;
                    }
                    isConstantSize() {
                        return this.mConstantSize;
                    }
                    getConstantWidth() {
                        if (!this.mComputedConstantSize) {
                            this.computeConstantSize();
                        }
                        return this.mConstantWidth;
                    }
                    getConstantHeight() {
                        if (!this.mComputedConstantSize) {
                            this.computeConstantSize();
                        }
                        return this.mConstantHeight;
                    }
                    getConstantMinimumWidth() {
                        if (!this.mComputedConstantSize) {
                            this.computeConstantSize();
                        }
                        return this.mConstantMinimumWidth;
                    }
                    getConstantMinimumHeight() {
                        if (!this.mComputedConstantSize) {
                            this.computeConstantSize();
                        }
                        return this.mConstantMinimumHeight;
                    }
                    computeConstantSize() {
                        this.mComputedConstantSize = true;
                        this.createAllFutures();
                        const N = this.mNumChildren;
                        const drawables = this.mDrawables;
                        this.mConstantWidth = this.mConstantHeight = -1;
                        this.mConstantMinimumWidth = this.mConstantMinimumHeight = 0;
                        for (let i = 0; i < N; i++) {
                            const dr = drawables[i];
                            let s = dr.getIntrinsicWidth();
                            if (s > this.mConstantWidth)
                                this.mConstantWidth = s;
                            s = dr.getIntrinsicHeight();
                            if (s > this.mConstantHeight)
                                this.mConstantHeight = s;
                            s = dr.getMinimumWidth();
                            if (s > this.mConstantMinimumWidth)
                                this.mConstantMinimumWidth = s;
                            s = dr.getMinimumHeight();
                            if (s > this.mConstantMinimumHeight)
                                this.mConstantMinimumHeight = s;
                        }
                    }
                    setEnterFadeDuration(duration) {
                        this.mEnterFadeDuration = duration;
                    }
                    getEnterFadeDuration() {
                        return this.mEnterFadeDuration;
                    }
                    setExitFadeDuration(duration) {
                        this.mExitFadeDuration = duration;
                    }
                    getExitFadeDuration() {
                        return this.mExitFadeDuration;
                    }
                    getOpacity() {
                        if (this.mCheckedOpacity) {
                            return this.mOpacity;
                        }
                        this.createAllFutures();
                        this.mCheckedOpacity = true;
                        const N = this.mNumChildren;
                        const drawables = this.mDrawables;
                        let op = (N > 0) ? drawables[0].getOpacity() : PixelFormat.TRANSPARENT;
                        for (let i = 1; i < N; i++) {
                            op = drawable.Drawable.resolveOpacity(op, drawables[i].getOpacity());
                        }
                        this.mOpacity = op;
                        return op;
                    }
                    isStateful() {
                        if (this.mCheckedStateful) {
                            return this.mStateful;
                        }
                        this.createAllFutures();
                        this.mCheckedStateful = true;
                        const N = this.mNumChildren;
                        const drawables = this.mDrawables;
                        for (let i = 0; i < N; i++) {
                            if (drawables[i].isStateful()) {
                                this.mStateful = true;
                                return true;
                            }
                        }
                        this.mStateful = false;
                        return false;
                    }
                    canConstantState() {
                        if (this.mCheckedConstantState) {
                            return this.mCanConstantState;
                        }
                        this.createAllFutures();
                        this.mCheckedConstantState = true;
                        const N = this.mNumChildren;
                        const drawables = this.mDrawables;
                        for (let i = 0; i < N; i++) {
                            if (drawables[i].getConstantState() == null) {
                                this.mCanConstantState = false;
                                return false;
                            }
                        }
                        this.mCanConstantState = true;
                        return true;
                    }
                    newDrawable() {
                        return undefined;
                    }
                }
                DrawableContainer.DrawableContainerState = DrawableContainerState;
                class ConstantStateFuture {
                    constructor(source) {
                        this.mConstantState = source.getConstantState();
                    }
                    get(state) {
                        const result = this.mConstantState.newDrawable();
                        result.setCallback(state.mOwner);
                        if (state.mMutated) {
                            result.mutate();
                        }
                        return result;
                    }
                }
            })(DrawableContainer = drawable.DrawableContainer || (drawable.DrawableContainer = {}));
        })(drawable = graphics.drawable || (graphics.drawable = {}));
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/2.
 */
///<reference path="DrawableContainer.ts"/>
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        var drawable;
        (function (drawable_2) {
            const DEBUG = android.util.Log.DBG_StateListDrawable;
            const TAG = "StateListDrawable";
            const DEFAULT_DITHER = true;
            class StateListDrawable extends drawable_2.DrawableContainer {
                constructor() {
                    super();
                    this.initWithState(null);
                }
                initWithState(state) {
                    let _as = new StateListState(state, this);
                    this.mStateListState = _as;
                    this.setConstantState(_as);
                    this.onStateChange(this.getState());
                }
                addState(stateSet, drawable) {
                    if (drawable != null) {
                        this.mStateListState.addStateSet(stateSet, drawable);
                        this.onStateChange(this.getState());
                    }
                }
                isStateful() {
                    return true;
                }
                onStateChange(stateSet) {
                    let idx = this.mStateListState.indexOfStateSet(stateSet);
                    if (DEBUG)
                        android.util.Log.i(TAG, "onStateChange " + this + " states "
                            + stateSet + " found " + idx);
                    if (idx < 0) {
                        idx = this.mStateListState.indexOfStateSet(android.util.StateSet.WILD_CARD);
                    }
                    if (this.selectDrawable(idx)) {
                        return true;
                    }
                    return super.onStateChange(stateSet);
                }
                getStateCount() {
                    return this.mStateListState.getChildCount();
                }
                getStateSet(index) {
                    return this.mStateListState.mStateSets[index];
                }
                getStateDrawable(index) {
                    return this.mStateListState.getChild(index);
                }
                getStateDrawableIndex(stateSet) {
                    return this.mStateListState.indexOfStateSet(stateSet);
                }
                mutate() {
                    if (!this.mMutated && super.mutate() == this) {
                        const sets = this.mStateListState.mStateSets;
                        const count = sets.length;
                        this.mStateListState.mStateSets = new Array(count);
                        for (let i = 0; i < count; i++) {
                            const _set = sets[i];
                            if (_set != null) {
                                this.mStateListState.mStateSets[i] = _set.concat();
                            }
                        }
                        this.mMutated = true;
                    }
                    return this;
                }
            }
            drawable_2.StateListDrawable = StateListDrawable;
            class StateListState extends drawable_2.DrawableContainer.DrawableContainerState {
                constructor(orig, owner) {
                    super(orig, owner);
                    if (orig != null) {
                        this.mStateSets = orig.mStateSets.concat();
                    }
                    else {
                        this.mStateSets = new Array(this.getCapacity());
                    }
                }
                addStateSet(stateSet, drawable) {
                    let pos = this.addChild(drawable);
                    this.mStateSets[pos] = stateSet;
                    return pos;
                }
                indexOfStateSet(stateSet) {
                    const stateSets = this.mStateSets;
                    const N = this.getChildCount();
                    for (let i = 0; i < N; i++) {
                        if (android.util.StateSet.stateSetMatches(stateSets[i], stateSet)) {
                            return i;
                        }
                    }
                    return -1;
                }
                newDrawable() {
                    let drawable = new StateListDrawable();
                    drawable.initWithState(this);
                    return drawable;
                }
            }
        })(drawable = graphics.drawable || (graphics.drawable = {}));
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/15.
 */
///<reference path="../view/View.ts"/>
///<reference path="../content/res/Resources.ts"/>
///<reference path="../graphics/Color.ts"/>
///<reference path="../graphics/drawable/Drawable.ts"/>
///<reference path="../graphics/drawable/InsetDrawable.ts"/>
///<reference path="../graphics/drawable/ColorDrawable.ts"/>
///<reference path="../graphics/drawable/StateListDrawable.ts"/>
var android;
(function (android) {
    var R;
    (function (R) {
        var Resources = android.content.res.Resources;
        var Color = android.graphics.Color;
        var InsetDrawable = android.graphics.drawable.InsetDrawable;
        var ColorDrawable = android.graphics.drawable.ColorDrawable;
        var StateListDrawable = android.graphics.drawable.StateListDrawable;
        const density = Resources.getDisplayMetrics().density;
        class drawable {
            static get button_background() {
                class DefaultButtonBackgroundDrawable extends InsetDrawable {
                    constructor() {
                        super(DefaultButtonBackgroundDrawable.createStateList(), 6 * density);
                    }
                    static createStateList() {
                        let stateList = new StateListDrawable();
                        stateList.addState([android.view.View.VIEW_STATE_PRESSED], new ColorDrawable(Color.GRAY));
                        stateList.addState([android.view.View.VIEW_STATE_ACTIVATED], new ColorDrawable(Color.GRAY));
                        stateList.addState([android.view.View.VIEW_STATE_FOCUSED], new ColorDrawable(0xffaaaaaa));
                        stateList.addState([-android.view.View.VIEW_STATE_ENABLED], new ColorDrawable(0xffebebeb));
                        stateList.addState([], new ColorDrawable(Color.LTGRAY));
                        return stateList;
                    }
                    getPadding(padding) {
                        let result = super.getPadding(padding);
                        padding.left += 12 * density;
                        padding.right += 12 * density;
                        padding.top += 6 * density;
                        padding.bottom += 6 * density;
                        return result;
                    }
                    getIntrinsicWidth() {
                        return 64 * density;
                    }
                    getIntrinsicHeight() {
                        return 48 * density;
                    }
                }
                return new DefaultButtonBackgroundDrawable();
            }
            static get list_selector_background() {
                let stateList = new StateListDrawable();
                stateList.addState([android.view.View.VIEW_STATE_FOCUSED, -android.view.View.VIEW_STATE_ENABLED], new ColorDrawable(0xffebebeb));
                stateList.addState([android.view.View.VIEW_STATE_FOCUSED, android.view.View.VIEW_STATE_PRESSED], new ColorDrawable(Color.LTGRAY));
                stateList.addState([-android.view.View.VIEW_STATE_FOCUSED, android.view.View.VIEW_STATE_PRESSED], new ColorDrawable(Color.LTGRAY));
                stateList.addState([android.view.View.VIEW_STATE_FOCUSED], new ColorDrawable(0xffaaaaaa));
                stateList.addState([], new ColorDrawable(Color.TRANSPARENT));
                return stateList;
            }
            static get list_divider() {
                let divider = new ColorDrawable(0xffcccccc);
                return divider;
            }
        }
        R.drawable = drawable;
    })(R = android.R || (android.R = {}));
})(android || (android = {}));
///<reference path="../view/View.ts"/>
///<reference path="../content/res/Resources.ts"/>
///<reference path="../content/res/ColorStateList.ts"/>
///<reference path="../graphics/Color.ts"/>
///<reference path="../graphics/drawable/Drawable.ts"/>
///<reference path="../graphics/drawable/InsetDrawable.ts"/>
///<reference path="../graphics/drawable/ColorDrawable.ts"/>
///<reference path="../graphics/drawable/StateListDrawable.ts"/>
var android;
(function (android) {
    var R;
    (function (R) {
        var ColorStateList = android.content.res.ColorStateList;
        class color {
            static get textView_textColor() {
                let _defaultStates = [[-android.view.View.VIEW_STATE_ENABLED], []];
                let _defaultColors = [0xffc0c0c0, 0xff333333];
                class DefaultStyleTextColor extends ColorStateList {
                    constructor() {
                        super(_defaultStates, _defaultColors);
                    }
                }
                return new DefaultStyleTextColor();
            }
        }
        R.color = color;
    })(R = android.R || (android.R = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/26.
 */
///<reference path="drawable.ts"/>
///<reference path="color.ts"/>
///<reference path="../view/Gravity.ts"/>
///<reference path="../view/View.ts"/>
///<reference path="../content/res/Resources.ts"/>
///<reference path="../graphics/Color.ts"/>
///<reference path="../graphics/drawable/Drawable.ts"/>
///<reference path="../graphics/drawable/InsetDrawable.ts"/>
///<reference path="../graphics/drawable/ColorDrawable.ts"/>
///<reference path="../graphics/drawable/StateListDrawable.ts"/>
var android;
(function (android) {
    var R;
    (function (R) {
        var Gravity = android.view.Gravity;
        var Color = android.graphics.Color;
        var ColorDrawable = android.graphics.drawable.ColorDrawable;
        var StateListDrawable = android.graphics.drawable.StateListDrawable;
        class attr {
            static get viewStyle() {
                return attr._viewStyle;
            }
            static get buttonStyle() {
                return {
                    background: R.drawable.button_background,
                    focusable: true,
                    clickable: true,
                    textSize: '18sp',
                    gravity: Gravity.CENTER
                };
            }
            static get textViewStyle() {
                return {
                    textSize: '14sp',
                    textColor: R.color.textView_textColor
                };
            }
            static get imageButtonStyle() {
                return {
                    background: R.drawable.button_background,
                    focusable: true,
                    clickable: true,
                    gravity: Gravity.CENTER
                };
            }
            static get gridViewStyle() {
                return {
                    numColumns: 1
                };
            }
            static get listViewStyle() {
                return {
                    divider: android.R.drawable.list_divider,
                    dividerHeight: 1
                };
            }
            static get numberPickerStyle() {
                return {
                    orientation: 'vertical',
                    solidColor: 'transparent',
                    selectionDivider: new ColorDrawable(0xcc33b5e5),
                    selectionDividerHeight: '2dp',
                    selectionDividersDistance: '48dp',
                    internalMinWidth: '64dp',
                    internalMaxHeight: '180dp',
                    virtualButtonPressedDrawable: (() => {
                        let stateList = new StateListDrawable();
                        stateList.addState([android.view.View.VIEW_STATE_PRESSED], new ColorDrawable(0x44888888));
                        stateList.addState([android.view.View.VIEW_STATE_PRESSED], new ColorDrawable(0x44888888));
                        stateList.addState([], new ColorDrawable(Color.TRANSPARENT));
                        return stateList;
                    })(),
                };
            }
        }
        attr._viewStyle = {};
        R.attr = attr;
    })(R = android.R || (android.R = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/9/27.
 */
///<reference path="../util/SparseArray.ts"/>
///<reference path="../util/Log.ts"/>
///<reference path="../graphics/drawable/Drawable.ts"/>
///<reference path="../graphics/drawable/ColorDrawable.ts"/>
///<reference path="../graphics/drawable/ScrollBarDrawable.ts"/>
///<reference path="../graphics/drawable/InsetDrawable.ts"/>
///<reference path="../graphics/PixelFormat.ts"/>
///<reference path="../graphics/Matrix.ts"/>
///<reference path="../graphics/Color.ts"/>
///<reference path="../graphics/Paint.ts"/>
///<reference path="../../java/lang/StringBuilder.ts"/>
///<reference path="../../java/lang/Runnable.ts"/>
///<reference path="../../java/lang/Object.ts"/>
///<reference path="../../java/lang/util/concurrent/CopyOnWriteArrayList.ts"/>
///<reference path="../../java/util/ArrayList.ts"/>
///<reference path="ViewRootImpl.ts"/>
///<reference path="ViewParent.ts"/>
///<reference path="ViewGroup.ts"/>
///<reference path="ViewOverlay.ts"/>
///<reference path="ViewTreeObserver.ts"/>
///<reference path="MotionEvent.ts"/>
///<reference path="TouchDelegate.ts"/>
///<reference path="../os/Handler.ts"/>
///<reference path="../os/SystemClock.ts"/>
///<reference path="../content/res/Resources.ts"/>
///<reference path="../content/res/ColorStateList.ts"/>
///<reference path="../graphics/Rect.ts"/>
///<reference path="../graphics/Canvas.ts"/>
///<reference path="../util/Pools.ts"/>
///<reference path="../util/TypedValue.ts"/>
///<reference path="Gravity.ts"/>
///<reference path="../view/animation/LinearInterpolator.ts"/>
///<reference path="../view/animation/AnimationUtils.ts"/>
///<reference path="../../java/lang/System.ts"/>
///<reference path="../../androidui/attr/StateAttrList.ts"/>
///<reference path="../../androidui/attr/StateAttr.ts"/>
///<reference path="../../androidui/attr/AttrBinder.ts"/>
///<reference path="../../androidui/util/ClassFinder.ts"/>
///<reference path="../../androidui/widget/HtmlDataAdapter.ts"/>
///<reference path="../../androidui/util/PerformanceAdjuster.ts"/>
///<reference path="KeyEvent.ts"/>
///<reference path="../R/attr.ts"/>
var android;
(function (android) {
    var view;
    (function (view_1) {
        var ColorDrawable = android.graphics.drawable.ColorDrawable;
        var ScrollBarDrawable = android.graphics.drawable.ScrollBarDrawable;
        var InsetDrawable = android.graphics.drawable.InsetDrawable;
        var PixelFormat = android.graphics.PixelFormat;
        var Matrix = android.graphics.Matrix;
        var Color = android.graphics.Color;
        var StringBuilder = java.lang.StringBuilder;
        var JavaObject = java.lang.JavaObject;
        var System = java.lang.System;
        var SystemClock = android.os.SystemClock;
        var Log = android.util.Log;
        var Rect = android.graphics.Rect;
        var Canvas = android.graphics.Canvas;
        var CopyOnWriteArrayList = java.lang.util.concurrent.CopyOnWriteArrayList;
        var ArrayList = java.util.ArrayList;
        var Resources = android.content.res.Resources;
        var Pools = android.util.Pools;
        var TypedValue = android.util.TypedValue;
        var LinearInterpolator = android.view.animation.LinearInterpolator;
        var AnimationUtils = android.view.animation.AnimationUtils;
        var StateAttrList = androidui.attr.StateAttrList;
        var AttrBinder = androidui.attr.AttrBinder;
        var ClassFinder = androidui.util.ClassFinder;
        var KeyEvent = android.view.KeyEvent;
        class View extends JavaObject {
            constructor(bindElement, rootElement) {
                super();
                this.mPrivateFlags = 0;
                this.mPrivateFlags2 = 0;
                this.mPrivateFlags3 = 0;
                this.mOldWidthMeasureSpec = Number.MIN_SAFE_INTEGER;
                this.mOldHeightMeasureSpec = Number.MIN_SAFE_INTEGER;
                this.mMeasuredWidth = 0;
                this.mMeasuredHeight = 0;
                this.mBackgroundSizeChanged = false;
                this.mHasPerformedLongPress = false;
                this.mMinWidth = 0;
                this.mMinHeight = 0;
                this.mDrawingCacheBackgroundColor = 0;
                this.mTouchSlop = 0;
                this.mVerticalScrollFactor = 0;
                this.mOverScrollMode = 0;
                this.mViewFlags = 0;
                this.mLayerType = View.LAYER_TYPE_NONE;
                this.mCachingFailed = false;
                this.mWindowAttachCount = 0;
                this.mTransientStateCount = 0;
                this.mLastIsOpaque = false;
                this._mLeft = 0;
                this._mRight = 0;
                this._mTop = 0;
                this._mBottom = 0;
                this._mScrollX = 0;
                this._mScrollY = 0;
                this.mPaddingLeft = 0;
                this.mPaddingRight = 0;
                this.mPaddingTop = 0;
                this.mPaddingBottom = 0;
                this._attrBinder = new AttrBinder(this);
                this._syncToElementLock = false;
                this.syncToElementFunc = () => {
                    this._syncToElementLock = false;
                    this._syncBoundToElement();
                    this._syncScrollToElement();
                };
                this._lastSyncScrollX = 0;
                this._lastSyncScrollY = 0;
                this.mTouchSlop = view_1.ViewConfiguration.get().getScaledTouchSlop();
                this.setOverScrollMode(View.OVER_SCROLL_ALWAYS);
                this._attrBinder.addAttr('background', (value) => {
                    this.setBackground(this._attrBinder.parseDrawable(value));
                }, () => {
                    if (this.mBackground instanceof ColorDrawable) {
                        return Color.toRGBAFunc(this.mBackground.getColor());
                    }
                    return this.mBackground;
                });
                this._attrBinder.addAttr('padding', (value) => {
                    let [left, top, right, bottom] = this._attrBinder.parsePaddingMarginLTRB(value);
                    this._setPaddingWithUnit(left, top, right, bottom);
                }, () => {
                    return this.mPaddingTop + ' ' + this.mPaddingRight + ' ' + this.mPaddingBottom + ' ' + this.mPaddingLeft;
                }),
                    this._attrBinder.addAttr('paddingLeft', (value) => {
                        this._setPaddingWithUnit(value, this.mPaddingTop, this.mPaddingRight, this.mPaddingBottom);
                    }, () => {
                        return this.mPaddingLeft;
                    }),
                    this._attrBinder.addAttr('paddingTop', (value) => {
                        this._setPaddingWithUnit(this.mPaddingLeft, value, this.mPaddingRight, this.mPaddingBottom);
                    }, () => {
                        return this.mPaddingTop;
                    }),
                    this._attrBinder.addAttr('paddingRight', (value) => {
                        this._setPaddingWithUnit(this.mPaddingLeft, this.mPaddingTop, value, this.mPaddingBottom);
                    }, () => {
                        return this.mPaddingRight;
                    }),
                    this._attrBinder.addAttr('paddingBottom', (value) => {
                        this._setPaddingWithUnit(this.mPaddingLeft, this.mPaddingTop, this.mPaddingRight, value);
                    }, () => {
                        return this.mPaddingBottom;
                    }),
                    this._attrBinder.addAttr('scrollX', (value) => {
                        value = Number.parseInt(value);
                        if (Number.isInteger(value))
                            this.scrollTo(value, this.mScrollY);
                    }),
                    this._attrBinder.addAttr('scrollY', (value) => {
                        value = Number.parseInt(value);
                        if (Number.isInteger(value))
                            this.scrollTo(this.mScrollX, value);
                    }),
                    this._attrBinder.addAttr('alpha', (value) => {
                        value = Number.parseInt(value);
                        if (Number.isInteger(value)) {
                        }
                        ;
                    }),
                    this._attrBinder.addAttr('transformPivotX', (value) => {
                        value = Number.parseInt(value);
                        if (Number.isInteger(value)) {
                        }
                        ;
                    }),
                    this._attrBinder.addAttr('transformPivotY', (value) => {
                        value = Number.parseInt(value);
                        if (Number.isInteger(value)) {
                        }
                        ;
                    }),
                    this._attrBinder.addAttr('translationX', (value) => {
                        value = Number.parseInt(value);
                        if (Number.isInteger(value)) {
                        }
                        ;
                    }),
                    this._attrBinder.addAttr('translationY', (value) => {
                        value = Number.parseInt(value);
                        if (Number.isInteger(value)) {
                        }
                        ;
                    }),
                    this._attrBinder.addAttr('rotation', (value) => {
                        value = Number.parseInt(value);
                        if (Number.isInteger(value)) {
                        }
                        ;
                    }),
                    this._attrBinder.addAttr('rotationX', (value) => {
                        value = Number.parseInt(value);
                        if (Number.isInteger(value)) {
                        }
                        ;
                    }),
                    this._attrBinder.addAttr('rotationY', (value) => {
                        value = Number.parseInt(value);
                        if (Number.isInteger(value)) {
                        }
                        ;
                    }),
                    this._attrBinder.addAttr('scaleX', (value) => {
                        value = Number.parseInt(value);
                        if (Number.isInteger(value)) {
                        }
                        ;
                    }),
                    this._attrBinder.addAttr('scaleY', (value) => {
                        value = Number.parseInt(value);
                        if (Number.isInteger(value)) {
                        }
                        ;
                    }),
                    this._attrBinder.addAttr('tag', (value) => {
                    }),
                    this._attrBinder.addAttr('id', (value) => {
                        this.setId(value);
                    }),
                    this._attrBinder.addAttr('focusable', (value) => {
                        if (this._attrBinder.parseBoolean(value, false)) {
                            this.setFlags(View.FOCUSABLE, View.FOCUSABLE_MASK);
                        }
                    }),
                    this._attrBinder.addAttr('focusableInTouchMode', (value) => {
                        if (this._attrBinder.parseBoolean(value, false)) {
                            this.setFlags(View.FOCUSABLE_IN_TOUCH_MODE | View.FOCUSABLE, View.FOCUSABLE_IN_TOUCH_MODE | View.FOCUSABLE_MASK);
                        }
                    }),
                    this._attrBinder.addAttr('clickable', (value) => {
                        if (this._attrBinder.parseBoolean(value, false)) {
                            this.setFlags(View.CLICKABLE, View.CLICKABLE);
                        }
                    }),
                    this._attrBinder.addAttr('longClickable', (value) => {
                        if (this._attrBinder.parseBoolean(value, false)) {
                            this.setFlags(View.LONG_CLICKABLE, View.LONG_CLICKABLE);
                        }
                    }),
                    this._attrBinder.addAttr('saveEnabled', (value) => {
                        if (this._attrBinder.parseBoolean(value, false)) {
                        }
                    }),
                    this._attrBinder.addAttr('duplicateParentState', (value) => {
                        if (this._attrBinder.parseBoolean(value, false)) {
                            this.setFlags(View.DUPLICATE_PARENT_STATE, View.DUPLICATE_PARENT_STATE);
                        }
                    }),
                    this._attrBinder.addAttr('visibility', (value) => {
                        if (value === 'gone')
                            this.setVisibility(View.GONE);
                        else if (value === 'invisible')
                            this.setVisibility(View.INVISIBLE);
                        else if (value === 'visible')
                            this.setVisibility(View.VISIBLE);
                    }),
                    this._attrBinder.addAttr('scrollbars', (value) => {
                        if (value === 'none') {
                            this.setHorizontalScrollBarEnabled(false);
                            this.setVerticalScrollBarEnabled(false);
                        }
                    }),
                    this._attrBinder.addAttr('isScrollContainer', (value) => {
                        if (this._attrBinder.parseBoolean(value, false)) {
                            this.setScrollContainer(true);
                        }
                    }),
                    this._attrBinder.addAttr('minWidth', (value) => {
                        this.setMinimumWidth(this._attrBinder.parseNumber(value, 0));
                    }, () => {
                        return this.mMinWidth;
                    }),
                    this._attrBinder.addAttr('minHeight', (value) => {
                        this.setMinimumHeight(this._attrBinder.parseNumber(value, 0));
                    }, () => {
                        return this.mMinHeight;
                    }),
                    this._attrBinder.addAttr('onClick', (value) => {
                        if (this._attrBinder.parseBoolean(value))
                            this.setClickable(true);
                    }),
                    this._attrBinder.addAttr('overScrollMode', (value) => {
                        let scrollMode = View[('OVER_SCROLL_' + value).toUpperCase()];
                        if (scrollMode === undefined)
                            scrollMode = View.OVER_SCROLL_IF_CONTENT_SCROLLS;
                        this.setOverScrollMode(scrollMode);
                    }),
                    this._attrBinder.addAttr('layerType', (value) => {
                    });
                this.initBindElement(bindElement, rootElement);
                this.applyDefaultAttributes(android.R.attr.viewStyle);
            }
            get mID() {
                if (this.bindElement) {
                    let id = this.bindElement.id;
                    return id ? id : null;
                }
                return null;
            }
            get mLeft() { return this._mLeft; }
            set mLeft(value) {
                this._mLeft = Math.floor(value);
                this.syncBoundToElement();
            }
            get mRight() { return this._mRight; }
            set mRight(value) {
                this._mRight = Math.floor(value);
                this.syncBoundToElement();
            }
            get mTop() { return this._mTop; }
            set mTop(value) {
                this._mTop = Math.floor(value);
                this.syncBoundToElement();
            }
            get mBottom() { return this._mBottom; }
            set mBottom(value) {
                this._mBottom = Math.floor(value);
                this.syncBoundToElement();
            }
            get mScrollX() { return this._mScrollX; }
            set mScrollX(value) { this._mScrollX = Math.floor(value); }
            get mScrollY() { return this._mScrollY; }
            set mScrollY(value) {
                if (Number.isNaN(value) || value == null) {
                    console.error('set mScrollY value is ' + value);
                    value = 0;
                }
                this._mScrollY = Math.floor(value);
            }
            getWidth() {
                return this.mRight - this.mLeft;
            }
            getHeight() {
                return this.mBottom - this.mTop;
            }
            getTop() {
                return this.mTop;
            }
            setTop(top) {
                if (top != this.mTop) {
                    if (this.mAttachInfo != null) {
                        let minTop;
                        let yLoc;
                        if (top < this.mTop) {
                            minTop = top;
                            yLoc = top - this.mTop;
                        }
                        else {
                            minTop = this.mTop;
                            yLoc = 0;
                        }
                        this.invalidate(0, yLoc, this.mRight - this.mLeft, this.mBottom - minTop);
                    }
                    let width = this.mRight - this.mLeft;
                    let oldHeight = this.mBottom - this.mTop;
                    this.mTop = top;
                    this.sizeChange(width, this.mBottom - this.mTop, width, oldHeight);
                    this.mBackgroundSizeChanged = true;
                }
            }
            getBottom() {
                return this.mBottom;
            }
            setBottom(bottom) {
                if (bottom != this.mBottom) {
                    if (this.mAttachInfo != null) {
                        let maxBottom;
                        if (bottom < this.mBottom) {
                            maxBottom = this.mBottom;
                        }
                        else {
                            maxBottom = bottom;
                        }
                        this.invalidate(0, 0, this.mRight - this.mLeft, maxBottom - this.mTop);
                    }
                    let width = this.mRight - this.mLeft;
                    let oldHeight = this.mBottom - this.mTop;
                    this.mBottom = bottom;
                    this.sizeChange(width, this.mBottom - this.mTop, width, oldHeight);
                    this.mBackgroundSizeChanged = true;
                }
            }
            getLeft() {
                return this.mLeft;
            }
            setLeft(left) {
                if (left != this.mLeft) {
                    if (this.mAttachInfo != null) {
                        let minLeft;
                        let xLoc;
                        if (left < this.mLeft) {
                            minLeft = left;
                            xLoc = left - this.mLeft;
                        }
                        else {
                            minLeft = this.mLeft;
                            xLoc = 0;
                        }
                        this.invalidate(xLoc, 0, this.mRight - minLeft, this.mBottom - this.mTop);
                    }
                    let oldWidth = this.mRight - this.mLeft;
                    let height = this.mBottom - this.mTop;
                    this.mLeft = left;
                    this.sizeChange(this.mRight - this.mLeft, height, oldWidth, height);
                    this.mBackgroundSizeChanged = true;
                }
            }
            getRight() {
                return this.mRight;
            }
            setRight(right) {
                if (right != this.mRight) {
                    if (this.mAttachInfo != null) {
                        let maxRight;
                        if (right < this.mRight) {
                            maxRight = this.mRight;
                        }
                        else {
                            maxRight = right;
                        }
                        this.invalidate(0, 0, maxRight - this.mLeft, this.mBottom - this.mTop);
                    }
                    let oldWidth = this.mRight - this.mLeft;
                    let height = this.mBottom - this.mTop;
                    this.mRight = right;
                    this.sizeChange(this.mRight - this.mLeft, height, oldWidth, height);
                    this.mBackgroundSizeChanged = true;
                }
            }
            getPaddingLeft() {
                return this.mPaddingLeft;
            }
            getPaddingTop() {
                return this.mPaddingTop;
            }
            getPaddingRight() {
                return this.mPaddingRight;
            }
            getPaddingBottom() {
                return this.mPaddingBottom;
            }
            setPaddingLeft(left) {
                if (this.mPaddingLeft != left) {
                    this.mPaddingLeft = left;
                    this.requestLayout();
                }
            }
            setPaddingTop(top) {
                if (this.mPaddingTop != top) {
                    this.mPaddingTop = top;
                    this.requestLayout();
                }
            }
            setPaddingRight(right) {
                if (this.mPaddingRight != right) {
                    this.mPaddingRight = right;
                    this.requestLayout();
                }
            }
            setPaddingBottom(bottom) {
                if (this.mPaddingBottom != bottom) {
                    this.mPaddingBottom = bottom;
                    this.requestLayout();
                }
            }
            setPadding(left, top, right, bottom) {
                let changed = false;
                if (this.mPaddingLeft != left) {
                    changed = true;
                    this.mPaddingLeft = left;
                }
                if (this.mPaddingTop != top) {
                    changed = true;
                    this.mPaddingTop = top;
                }
                if (this.mPaddingRight != right) {
                    changed = true;
                    this.mPaddingRight = right;
                }
                if (this.mPaddingBottom != bottom) {
                    changed = true;
                    this.mPaddingBottom = bottom;
                }
                if (changed) {
                    this.requestLayout();
                }
            }
            _setPaddingWithUnit(left, top, right, bottom) {
                let view = this;
                let dm = Resources.getDisplayMetrics();
                let width = view.getWidth();
                let height = view.getHeight();
                let padLeft = TypedValue.complexToDimensionPixelSize(left, width, dm);
                let padTop = TypedValue.complexToDimensionPixelSize(top, height, dm);
                let padRight = TypedValue.complexToDimensionPixelSize(right, width, dm);
                let padBottom = TypedValue.complexToDimensionPixelSize(bottom, height, dm);
                view.setPadding(padLeft, padTop, padRight, padBottom);
                let unit = TypedValue.COMPLEX_UNIT_FRACTION;
                if ((typeof left === 'string' && left.endsWith(unit)) || (typeof top === 'string' && top.endsWith(unit))
                    || (typeof right === 'string' && right.endsWith(unit)) || (typeof bottom === 'string' && bottom.endsWith(unit))) {
                    view.post({
                        run: () => {
                            let width = view.getWidth();
                            let height = view.getHeight();
                            let padLeftN = TypedValue.complexToDimensionPixelSize(left, width, dm);
                            let padTopN = TypedValue.complexToDimensionPixelSize(top, height, dm);
                            let padRightN = TypedValue.complexToDimensionPixelSize(right, width, dm);
                            let padBottomN = TypedValue.complexToDimensionPixelSize(bottom, height, dm);
                            view.setPadding(padLeftN, padTopN, padRightN, padBottomN);
                        }
                    });
                }
            }
            setScrollX(value) {
                this.scrollTo(value, this.mScrollY);
            }
            setScrollY(value) {
                this.scrollTo(this.mScrollX, value);
            }
            getScrollX() {
                return this.mScrollX;
            }
            getScrollY() {
                return this.mScrollY;
            }
            getFinalAlpha() {
                return 1;
            }
            offsetTopAndBottom(offset) {
                if (offset != 0) {
                    this.updateMatrix();
                    const matrixIsIdentity = true;
                    if (matrixIsIdentity) {
                        const p = this.mParent;
                        if (p != null && this.mAttachInfo != null) {
                            const r = this.mAttachInfo.mTmpInvalRect;
                            let minTop;
                            let maxBottom;
                            let yLoc;
                            if (offset < 0) {
                                minTop = this.mTop + offset;
                                maxBottom = this.mBottom;
                                yLoc = offset;
                            }
                            else {
                                minTop = this.mTop;
                                maxBottom = this.mBottom + offset;
                                yLoc = 0;
                            }
                            r.set(0, yLoc, this.mRight - this.mLeft, maxBottom - minTop);
                            p.invalidateChild(this, r);
                        }
                    }
                    else {
                        this.invalidateViewProperty(false, false);
                    }
                    this.mTop += offset;
                    this.mBottom += offset;
                    if (!matrixIsIdentity) {
                        this.invalidateViewProperty(false, true);
                    }
                    this.invalidateParentIfNeeded();
                }
            }
            offsetLeftAndRight(offset) {
                if (offset != 0) {
                    this.updateMatrix();
                    const matrixIsIdentity = true;
                    if (matrixIsIdentity) {
                        const p = this.mParent;
                        if (p != null && this.mAttachInfo != null) {
                            const r = this.mAttachInfo.mTmpInvalRect;
                            let minLeft;
                            let maxRight;
                            if (offset < 0) {
                                minLeft = this.mLeft + offset;
                                maxRight = this.mRight;
                            }
                            else {
                                minLeft = this.mLeft;
                                maxRight = this.mRight + offset;
                            }
                            r.set(0, 0, maxRight - minLeft, this.mBottom - this.mTop);
                            p.invalidateChild(this, r);
                        }
                    }
                    else {
                        this.invalidateViewProperty(false, false);
                    }
                    this.mLeft += offset;
                    this.mRight += offset;
                    if (!matrixIsIdentity) {
                        this.invalidateViewProperty(false, true);
                    }
                    this.invalidateParentIfNeeded();
                }
            }
            setAlpha(alpha) {
                alpha &= 0xFF;
                this.bindElement.style.opacity = alpha / 255 + '';
            }
            updateMatrix() {
            }
            getMatrix() {
                return Matrix.IDENTITY_MATRIX;
            }
            hasIdentityMatrix() {
                return true;
            }
            transformRect(rect) {
                if (!this.getMatrix().isIdentity()) {
                    let boundingRect = this.mAttachInfo.mTmpTransformRect;
                    boundingRect.set(rect);
                    this.getMatrix().mapRect(boundingRect);
                    rect.set(boundingRect);
                }
            }
            pointInView(localX, localY, slop = 0) {
                return localX >= -slop && localY >= -slop && localX < ((this.mRight - this.mLeft) + slop) &&
                    localY < ((this.mBottom - this.mTop) + slop);
            }
            getHandler() {
                let attachInfo = this.mAttachInfo;
                if (attachInfo != null) {
                    return attachInfo.mHandler;
                }
                return null;
            }
            getViewRootImpl() {
                if (this.mAttachInfo != null) {
                    return this.mAttachInfo.mViewRootImpl;
                }
                return null;
            }
            post(action) {
                let attachInfo = this.mAttachInfo;
                if (attachInfo != null) {
                    return attachInfo.mHandler.post(action);
                }
                view_1.ViewRootImpl.getRunQueue().post(action);
                return true;
            }
            postDelayed(action, delayMillis) {
                let attachInfo = this.mAttachInfo;
                if (attachInfo != null) {
                    return attachInfo.mHandler.postDelayed(action, delayMillis);
                }
                view_1.ViewRootImpl.getRunQueue().postDelayed(action, delayMillis);
                return true;
            }
            postOnAnimation(action) {
                return this.post(action);
            }
            postOnAnimationDelayed(action, delayMillis) {
                return this.postDelayed(action, delayMillis);
            }
            removeCallbacks(action) {
                if (action != null) {
                    let attachInfo = this.mAttachInfo;
                    if (attachInfo != null) {
                        attachInfo.mHandler.removeCallbacks(action);
                    }
                    else {
                        view_1.ViewRootImpl.getRunQueue().removeCallbacks(action);
                    }
                }
                return true;
            }
            getParent() {
                return this.mParent;
            }
            setFlags(flags, mask) {
                let old = this.mViewFlags;
                this.mViewFlags = (this.mViewFlags & ~mask) | (flags & mask);
                let changed = this.mViewFlags ^ old;
                if (changed == 0) {
                    return;
                }
                let privateFlags = this.mPrivateFlags;
                if (((changed & View.FOCUSABLE_MASK) != 0) &&
                    ((privateFlags & View.PFLAG_HAS_BOUNDS) != 0)) {
                    if (((old & View.FOCUSABLE_MASK) == View.FOCUSABLE)
                        && ((privateFlags & View.PFLAG_FOCUSED) != 0)) {
                        this.clearFocus();
                    }
                    else if (((old & View.FOCUSABLE_MASK) == View.NOT_FOCUSABLE)
                        && ((privateFlags & View.PFLAG_FOCUSED) == 0)) {
                        if (this.mParent != null)
                            this.mParent.focusableViewAvailable(this);
                    }
                }
                const newVisibility = flags & View.VISIBILITY_MASK;
                if (newVisibility == View.VISIBLE) {
                    if ((changed & View.VISIBILITY_MASK) != 0) {
                        this.mPrivateFlags |= View.PFLAG_DRAWN;
                        this.invalidate(true);
                        if ((this.mParent != null) && (this.mBottom > this.mTop) && (this.mRight > this.mLeft)) {
                            this.mParent.focusableViewAvailable(this);
                        }
                    }
                }
                if ((changed & View.GONE) != 0) {
                    this.requestLayout();
                    if (((this.mViewFlags & View.VISIBILITY_MASK) == View.GONE)) {
                        if (this.hasFocus())
                            this.clearFocus();
                        this.destroyDrawingCache();
                        if (this.mParent instanceof View) {
                            this.mParent.invalidate(true);
                        }
                        this.mPrivateFlags |= View.PFLAG_DRAWN;
                    }
                    if (this.mAttachInfo != null) {
                        this.mAttachInfo.mViewVisibilityChanged = true;
                    }
                }
                if ((changed & View.INVISIBLE) != 0) {
                    this.mPrivateFlags |= View.PFLAG_DRAWN;
                    if (((this.mViewFlags & View.VISIBILITY_MASK) == View.INVISIBLE)) {
                        if (this.getRootView() != this) {
                            if (this.hasFocus())
                                this.clearFocus();
                        }
                    }
                    if (this.mAttachInfo != null) {
                        this.mAttachInfo.mViewVisibilityChanged = true;
                    }
                }
                if ((changed & View.VISIBILITY_MASK) != 0) {
                    if (newVisibility != View.VISIBLE) {
                        this.cleanupDraw();
                    }
                    if (this.mParent instanceof view_1.ViewGroup) {
                        this.mParent.onChildVisibilityChanged(this, (changed & View.VISIBILITY_MASK), newVisibility);
                        this.mParent.invalidate(true);
                    }
                    else if (this.mParent != null) {
                        this.mParent.invalidateChild(this, null);
                    }
                    this.dispatchVisibilityChanged(this, newVisibility);
                    this.syncVisibleToElement();
                }
                if ((changed & View.WILL_NOT_CACHE_DRAWING) != 0) {
                    this.destroyDrawingCache();
                }
                if ((changed & View.DRAWING_CACHE_ENABLED) != 0) {
                    this.destroyDrawingCache();
                    this.mPrivateFlags &= ~View.PFLAG_DRAWING_CACHE_VALID;
                    this.invalidateParentCaches();
                }
                if ((changed & View.DRAW_MASK) != 0) {
                    if ((this.mViewFlags & View.WILL_NOT_DRAW) != 0) {
                        if (this.mBackground != null) {
                            this.mPrivateFlags &= ~View.PFLAG_SKIP_DRAW;
                            this.mPrivateFlags |= View.PFLAG_ONLY_DRAWS_BACKGROUND;
                        }
                        else {
                            this.mPrivateFlags |= View.PFLAG_SKIP_DRAW;
                        }
                    }
                    else {
                        this.mPrivateFlags &= ~View.PFLAG_SKIP_DRAW;
                    }
                    this.requestLayout();
                    this.invalidate(true);
                }
            }
            bringToFront() {
                if (this.mParent != null) {
                    this.mParent.bringChildToFront(this);
                }
            }
            onScrollChanged(l, t, oldl, oldt) {
                this.mBackgroundSizeChanged = true;
                let ai = this.mAttachInfo;
                if (ai != null) {
                    ai.mViewScrollChanged = true;
                }
            }
            onSizeChanged(w, h, oldw, oldh) {
            }
            getTouchables() {
                let result = new ArrayList();
                this.addTouchables(result);
                return result;
            }
            addTouchables(views) {
                const viewFlags = this.mViewFlags;
                if (((viewFlags & View.CLICKABLE) == View.CLICKABLE || (viewFlags & View.LONG_CLICKABLE) == View.LONG_CLICKABLE)
                    && (viewFlags & View.ENABLED_MASK) == View.ENABLED) {
                    views.add(this);
                }
            }
            onFocusLost() {
                this.resetPressedState();
            }
            resetPressedState() {
                if ((this.mViewFlags & View.ENABLED_MASK) == View.DISABLED) {
                    return;
                }
                if (this.isPressed()) {
                    this.setPressed(false);
                    if (!this.mHasPerformedLongPress) {
                        this.removeLongPressCallback();
                    }
                }
            }
            isFocused() {
                return (this.mPrivateFlags & View.PFLAG_FOCUSED) != 0;
            }
            findFocus() {
                return (this.mPrivateFlags & View.PFLAG_FOCUSED) != 0 ? this : null;
            }
            getNextFocusLeftId() {
                return this.mNextFocusLeftId;
            }
            setNextFocusLeftId(nextFocusLeftId) {
                this.mNextFocusLeftId = nextFocusLeftId;
            }
            getNextFocusRightId() {
                return this.mNextFocusRightId;
            }
            setNextFocusRightId(nextFocusRightId) {
                this.mNextFocusRightId = nextFocusRightId;
            }
            getNextFocusUpId() {
                return this.mNextFocusUpId;
            }
            setNextFocusUpId(nextFocusUpId) {
                this.mNextFocusUpId = nextFocusUpId;
            }
            getNextFocusDownId() {
                return this.mNextFocusDownId;
            }
            setNextFocusDownId(nextFocusDownId) {
                this.mNextFocusDownId = nextFocusDownId;
            }
            getNextFocusForwardId() {
                return this.mNextFocusForwardId;
            }
            setNextFocusForwardId(nextFocusForwardId) {
                this.mNextFocusForwardId = nextFocusForwardId;
            }
            setFocusable(focusable) {
                if (!focusable) {
                    this.setFlags(0, View.FOCUSABLE_IN_TOUCH_MODE);
                }
                this.setFlags(focusable ? View.FOCUSABLE : View.NOT_FOCUSABLE, View.FOCUSABLE_MASK);
            }
            isFocusable() {
                return View.FOCUSABLE == (this.mViewFlags & View.FOCUSABLE_MASK);
            }
            setFocusableInTouchMode(focusableInTouchMode) {
                this.setFlags(focusableInTouchMode ? View.FOCUSABLE_IN_TOUCH_MODE : 0, View.FOCUSABLE_IN_TOUCH_MODE);
                if (focusableInTouchMode) {
                    this.setFlags(View.FOCUSABLE, View.FOCUSABLE_MASK);
                }
            }
            isFocusableInTouchMode() {
                return View.FOCUSABLE_IN_TOUCH_MODE == (this.mViewFlags & View.FOCUSABLE_IN_TOUCH_MODE);
            }
            hasFocusable() {
                return (this.mViewFlags & View.VISIBILITY_MASK) == View.VISIBLE && this.isFocusable();
            }
            clearFocus() {
                if (View.DBG) {
                    System.out.println(this + " clearFocus()");
                }
                this.clearFocusInternal(true, true);
            }
            clearFocusInternal(propagate, refocus) {
                if ((this.mPrivateFlags & View.PFLAG_FOCUSED) != 0) {
                    this.mPrivateFlags &= ~View.PFLAG_FOCUSED;
                    if (propagate && this.mParent != null) {
                        this.mParent.clearChildFocus(this);
                    }
                    this.onFocusChanged(false, 0, null);
                    this.refreshDrawableState();
                    if (propagate && (!refocus || !this.rootViewRequestFocus())) {
                        this.notifyGlobalFocusCleared(this);
                    }
                }
            }
            notifyGlobalFocusCleared(oldFocus) {
                if (oldFocus != null && this.mAttachInfo != null) {
                    this.mAttachInfo.mTreeObserver.dispatchOnGlobalFocusChange(oldFocus, null);
                }
            }
            rootViewRequestFocus() {
                const root = this.getRootView();
                return root != null && root.requestFocus();
            }
            unFocus() {
                if (View.DBG) {
                    System.out.println(this + " unFocus()");
                }
                this.clearFocusInternal(false, false);
            }
            hasFocus() {
                return (this.mPrivateFlags & View.PFLAG_FOCUSED) != 0;
            }
            onFocusChanged(gainFocus, direction, previouslyFocusedRect) {
                if (!gainFocus) {
                    if (this.isPressed()) {
                        this.setPressed(false);
                    }
                    this.onFocusLost();
                }
                this.invalidate(true);
                let li = this.mListenerInfo;
                if (li != null && li.mOnFocusChangeListener != null) {
                    li.mOnFocusChangeListener.onFocusChange(this, gainFocus);
                }
                if (this.mAttachInfo != null) {
                    this.mAttachInfo.mKeyDispatchState.reset(this);
                }
            }
            focusSearch(direction) {
                if (this.mParent != null) {
                    return this.mParent.focusSearch(this, direction);
                }
                else {
                    return null;
                }
            }
            dispatchUnhandledMove(focused, direction) {
                return false;
            }
            findUserSetNextFocus(root, direction) {
                switch (direction) {
                    case View.FOCUS_LEFT:
                        if (!this.mNextFocusLeftId)
                            return null;
                        return this.findViewInsideOutShouldExist(root, this.mNextFocusLeftId);
                    case View.FOCUS_RIGHT:
                        if (!this.mNextFocusRightId)
                            return null;
                        return this.findViewInsideOutShouldExist(root, this.mNextFocusRightId);
                    case View.FOCUS_UP:
                        if (!this.mNextFocusUpId)
                            return null;
                        return this.findViewInsideOutShouldExist(root, this.mNextFocusUpId);
                    case View.FOCUS_DOWN:
                        if (!this.mNextFocusDownId)
                            return null;
                        return this.findViewInsideOutShouldExist(root, this.mNextFocusDownId);
                    case View.FOCUS_FORWARD:
                        if (!this.mNextFocusForwardId)
                            return null;
                        return this.findViewInsideOutShouldExist(root, this.mNextFocusForwardId);
                    case View.FOCUS_BACKWARD: {
                        if (!this.mID)
                            return null;
                        let id = this.mID;
                        return root.findViewByPredicateInsideOut(this, {
                            apply(t) {
                                return t.mNextFocusForwardId == id;
                            }
                        });
                    }
                }
                return null;
            }
            findViewInsideOutShouldExist(root, id) {
                if (this.mMatchIdPredicate == null) {
                    this.mMatchIdPredicate = new MatchIdPredicate();
                }
                this.mMatchIdPredicate.mId = id;
                let result = root.findViewByPredicateInsideOut(this, this.mMatchIdPredicate);
                if (result == null) {
                    Log.w(View.VIEW_LOG_TAG, "couldn't find view with id " + id);
                }
                return result;
            }
            getFocusables(direction) {
                let result = new ArrayList(24);
                this.addFocusables(result, direction);
                return result;
            }
            addFocusables(views, direction, focusableMode = View.FOCUSABLES_TOUCH_MODE) {
                if (views == null) {
                    return;
                }
                if (!this.isFocusable()) {
                    return;
                }
                if ((focusableMode & View.FOCUSABLES_TOUCH_MODE) == View.FOCUSABLES_TOUCH_MODE
                    && this.isInTouchMode() && !this.isFocusableInTouchMode()) {
                    return;
                }
                views.add(this);
            }
            setOnFocusChangeListener(l) {
                this.getListenerInfo().mOnFocusChangeListener = l;
            }
            getOnFocusChangeListener() {
                let li = this.mListenerInfo;
                return li != null ? li.mOnFocusChangeListener : null;
            }
            requestFocus(direction = View.FOCUS_DOWN, previouslyFocusedRect = null) {
                return this.requestFocusNoSearch(direction, previouslyFocusedRect);
            }
            requestFocusNoSearch(direction, previouslyFocusedRect) {
                if ((this.mViewFlags & View.FOCUSABLE_MASK) != View.FOCUSABLE ||
                    (this.mViewFlags & View.VISIBILITY_MASK) != View.VISIBLE) {
                    return false;
                }
                if (this.isInTouchMode() &&
                    (View.FOCUSABLE_IN_TOUCH_MODE != (this.mViewFlags & View.FOCUSABLE_IN_TOUCH_MODE))) {
                    return false;
                }
                if (this.hasAncestorThatBlocksDescendantFocus()) {
                    return false;
                }
                this.handleFocusGainInternal(direction, previouslyFocusedRect);
                return true;
            }
            requestFocusFromTouch() {
                if (this.isInTouchMode()) {
                    let viewRoot = this.getViewRootImpl();
                    if (viewRoot != null) {
                        viewRoot.ensureTouchMode(false);
                    }
                }
                return this.requestFocus(View.FOCUS_DOWN);
            }
            hasAncestorThatBlocksDescendantFocus() {
                let ancestor = this.mParent;
                while (ancestor instanceof view_1.ViewGroup) {
                    const vgAncestor = ancestor;
                    if (vgAncestor.getDescendantFocusability() == view_1.ViewGroup.FOCUS_BLOCK_DESCENDANTS) {
                        return true;
                    }
                    else {
                        ancestor = vgAncestor.getParent();
                    }
                }
                return false;
            }
            handleFocusGainInternal(direction, previouslyFocusedRect) {
                if (View.DBG) {
                    System.out.println(this + " requestFocus()");
                }
                if ((this.mPrivateFlags & View.PFLAG_FOCUSED) == 0) {
                    this.mPrivateFlags |= View.PFLAG_FOCUSED;
                    let oldFocus = (this.mAttachInfo != null) ? this.getRootView().findFocus() : null;
                    if (this.mParent != null) {
                        this.mParent.requestChildFocus(this, this);
                    }
                    if (this.mAttachInfo != null) {
                        this.mAttachInfo.mTreeObserver.dispatchOnGlobalFocusChange(oldFocus, this);
                    }
                    this.onFocusChanged(true, direction, previouslyFocusedRect);
                    this.refreshDrawableState();
                }
            }
            hasTransientState() {
                return (this.mPrivateFlags2 & View.PFLAG2_HAS_TRANSIENT_STATE) == View.PFLAG2_HAS_TRANSIENT_STATE;
            }
            setHasTransientState(hasTransientState) {
                this.mTransientStateCount = hasTransientState ? this.mTransientStateCount + 1 :
                    this.mTransientStateCount - 1;
                if (this.mTransientStateCount < 0) {
                    this.mTransientStateCount = 0;
                    Log.e(View.VIEW_LOG_TAG, "hasTransientState decremented below 0: " +
                        "unmatched pair of setHasTransientState calls");
                }
                else if ((hasTransientState && this.mTransientStateCount == 1) ||
                    (!hasTransientState && this.mTransientStateCount == 0)) {
                    this.mPrivateFlags2 = (this.mPrivateFlags2 & ~View.PFLAG2_HAS_TRANSIENT_STATE) |
                        (hasTransientState ? View.PFLAG2_HAS_TRANSIENT_STATE : 0);
                    if (this.mParent != null) {
                        this.mParent.childHasTransientStateChanged(this, hasTransientState);
                    }
                }
            }
            isScrollContainer() {
                return (this.mPrivateFlags & View.PFLAG_SCROLL_CONTAINER_ADDED) != 0;
            }
            setScrollContainer(isScrollContainer) {
                if (isScrollContainer) {
                    if (this.mAttachInfo != null && (this.mPrivateFlags & View.PFLAG_SCROLL_CONTAINER_ADDED) == 0) {
                        this.mAttachInfo.mScrollContainers.add(this);
                        this.mPrivateFlags |= View.PFLAG_SCROLL_CONTAINER_ADDED;
                    }
                    this.mPrivateFlags |= View.PFLAG_SCROLL_CONTAINER;
                }
                else {
                    if ((this.mPrivateFlags & View.PFLAG_SCROLL_CONTAINER_ADDED) != 0) {
                        this.mAttachInfo.mScrollContainers.delete(this);
                    }
                    this.mPrivateFlags &= ~(View.PFLAG_SCROLL_CONTAINER | View.PFLAG_SCROLL_CONTAINER_ADDED);
                }
            }
            isInTouchMode() {
                if (this.mAttachInfo != null) {
                    return this.mAttachInfo.mInTouchMode;
                }
                else {
                    return false;
                }
            }
            isShown() {
                let current = this;
                do {
                    if ((current.mViewFlags & View.VISIBILITY_MASK) != View.VISIBLE) {
                        return false;
                    }
                    let parent = current.mParent;
                    if (parent == null) {
                        return false;
                    }
                    if (!(parent instanceof View)) {
                        return true;
                    }
                    current = parent;
                } while (current != null);
                return false;
            }
            getVisibility() {
                return this.mViewFlags & View.VISIBILITY_MASK;
            }
            setVisibility(visibility) {
                this.setFlags(visibility, View.VISIBILITY_MASK);
                if (this.mBackground != null)
                    this.mBackground.setVisible(visibility == View.VISIBLE, false);
            }
            dispatchVisibilityChanged(changedView, visibility) {
                this.onVisibilityChanged(changedView, visibility);
            }
            onVisibilityChanged(changedView, visibility) {
                if (visibility == View.VISIBLE) {
                    if (this.mAttachInfo != null) {
                        this.initialAwakenScrollBars();
                    }
                    else {
                        this.mPrivateFlags |= View.PFLAG_AWAKEN_SCROLL_BARS_ON_ATTACH;
                    }
                }
            }
            dispatchDisplayHint(hint) {
                this.onDisplayHint(hint);
            }
            onDisplayHint(hint) {
            }
            dispatchWindowVisibilityChanged(visibility) {
                this.onWindowVisibilityChanged(visibility);
            }
            onWindowVisibilityChanged(visibility) {
                if (visibility == View.VISIBLE) {
                    this.initialAwakenScrollBars();
                }
            }
            getWindowVisibility() {
                return this.mAttachInfo != null ? this.mAttachInfo.mWindowVisibility : View.GONE;
            }
            isEnabled() {
                return (this.mViewFlags & View.ENABLED_MASK) == View.ENABLED;
            }
            setEnabled(enabled) {
                if (enabled == this.isEnabled())
                    return;
                this.setFlags(enabled ? View.ENABLED : View.DISABLED, View.ENABLED_MASK);
                this.refreshDrawableState();
                this.invalidate(true);
            }
            dispatchGenericMotionEvent(event) {
                if (event.isPointerEvent()) {
                    const action = event.getAction();
                    if (action == view_1.MotionEvent.ACTION_HOVER_ENTER
                        || action == view_1.MotionEvent.ACTION_HOVER_MOVE
                        || action == view_1.MotionEvent.ACTION_HOVER_EXIT) {
                    }
                    else if (this.dispatchGenericPointerEvent(event)) {
                        return true;
                    }
                }
                if (this.dispatchGenericMotionEventInternal(event)) {
                    return true;
                }
                return false;
            }
            dispatchGenericMotionEventInternal(event) {
                let li = this.mListenerInfo;
                if (li != null && li.mOnGenericMotionListener != null
                    && (this.mViewFlags & View.ENABLED_MASK) == View.ENABLED
                    && li.mOnGenericMotionListener.onGenericMotion(this, event)) {
                    return true;
                }
                if (this.onGenericMotionEvent(event)) {
                    return true;
                }
                return false;
            }
            onGenericMotionEvent(event) {
                return false;
            }
            dispatchGenericPointerEvent(event) {
                return false;
            }
            dispatchKeyEvent(event) {
                let li = this.mListenerInfo;
                if (li != null && li.mOnKeyListener != null && (this.mViewFlags & View.ENABLED_MASK) == View.ENABLED
                    && li.mOnKeyListener.onKey(this, event.getKeyCode(), event)) {
                    return true;
                }
                if (event.dispatch(this, this.mAttachInfo != null
                    ? this.mAttachInfo.mKeyDispatchState : null, this)) {
                    return true;
                }
                return false;
            }
            setOnKeyListener(l) {
                this.getListenerInfo().mOnKeyListener = l;
            }
            getKeyDispatcherState() {
                return this.mAttachInfo != null ? this.mAttachInfo.mKeyDispatchState : null;
            }
            onKeyDown(keyCode, event) {
                let result = false;
                if (KeyEvent.isConfirmKey(keyCode)) {
                    if ((this.mViewFlags & View.ENABLED_MASK) == View.DISABLED) {
                        return true;
                    }
                    if (((this.mViewFlags & View.CLICKABLE) == View.CLICKABLE ||
                        (this.mViewFlags & View.LONG_CLICKABLE) == View.LONG_CLICKABLE) &&
                        (event.getRepeatCount() == 0)) {
                        this.setPressed(true);
                        this.checkForLongClick(0);
                        return true;
                    }
                }
                return result;
            }
            onKeyLongPress(keyCode, event) {
                return false;
            }
            onKeyUp(keyCode, event) {
                if (KeyEvent.isConfirmKey(keyCode)) {
                    if ((this.mViewFlags & View.ENABLED_MASK) == View.DISABLED) {
                        return true;
                    }
                    if ((this.mViewFlags & View.CLICKABLE) == View.CLICKABLE && this.isPressed()) {
                        this.setPressed(false);
                        if (!this.mHasPerformedLongPress) {
                            this.removeLongPressCallback();
                            return this.performClick();
                        }
                    }
                }
                return false;
            }
            dispatchTouchEvent(event) {
                if (this.onFilterTouchEventForSecurity(event)) {
                    let li = this.mListenerInfo;
                    if (li != null && li.mOnTouchListener != null && (this.mViewFlags & View.ENABLED_MASK) == View.ENABLED
                        && li.mOnTouchListener.onTouch(this, event)) {
                        return true;
                    }
                    if (this.onTouchEvent(event)) {
                        return true;
                    }
                }
                return false;
            }
            onFilterTouchEventForSecurity(event) {
                return true;
            }
            onTouchEvent(event) {
                let viewFlags = this.mViewFlags;
                if ((viewFlags & View.ENABLED_MASK) == View.DISABLED) {
                    if (event.getAction() == view_1.MotionEvent.ACTION_UP && (this.mPrivateFlags & View.PFLAG_PRESSED) != 0) {
                        this.setPressed(false);
                    }
                    return (((viewFlags & View.CLICKABLE) == View.CLICKABLE ||
                        (viewFlags & View.LONG_CLICKABLE) == View.LONG_CLICKABLE));
                }
                if (this.mTouchDelegate != null) {
                    if (this.mTouchDelegate.onTouchEvent(event)) {
                        return true;
                    }
                }
                if (((viewFlags & View.CLICKABLE) == View.CLICKABLE ||
                    (viewFlags & View.LONG_CLICKABLE) == View.LONG_CLICKABLE)) {
                    switch (event.getAction()) {
                        case view_1.MotionEvent.ACTION_UP:
                            let prepressed = (this.mPrivateFlags & View.PFLAG_PREPRESSED) != 0;
                            if ((this.mPrivateFlags & View.PFLAG_PRESSED) != 0 || prepressed) {
                                let focusTaken = false;
                                if (prepressed) {
                                    this.setPressed(true);
                                }
                                if (!this.mHasPerformedLongPress) {
                                    this.removeLongPressCallback();
                                    if (!focusTaken) {
                                        if (this.mPerformClick == null) {
                                            this.mPerformClick = new PerformClick(this);
                                        }
                                        if (!this.post(this.mPerformClick)) {
                                            this.performClick(event);
                                        }
                                    }
                                }
                                if (this.mUnsetPressedState == null) {
                                    this.mUnsetPressedState = new UnsetPressedState(this);
                                }
                                if (prepressed) {
                                    this.postDelayed(this.mUnsetPressedState, view_1.ViewConfiguration.getPressedStateDuration());
                                }
                                else if (!this.post(this.mUnsetPressedState)) {
                                    this.mUnsetPressedState.run();
                                }
                                this.removeTapCallback();
                            }
                            break;
                        case view_1.MotionEvent.ACTION_DOWN:
                            this.mHasPerformedLongPress = false;
                            let isInScrollingContainer = this.isInScrollingContainer();
                            if (isInScrollingContainer) {
                                this.mPrivateFlags |= View.PFLAG_PREPRESSED;
                                if (this.mPendingCheckForTap == null) {
                                    this.mPendingCheckForTap = new CheckForTap(this);
                                }
                                this.postDelayed(this.mPendingCheckForTap, view_1.ViewConfiguration.getTapTimeout());
                            }
                            else {
                                this.setPressed(true);
                                this.checkForLongClick(0);
                            }
                            break;
                        case view_1.MotionEvent.ACTION_CANCEL:
                            this.setPressed(false);
                            this.removeTapCallback();
                            this.removeLongPressCallback();
                            break;
                        case view_1.MotionEvent.ACTION_MOVE:
                            const x = event.getX();
                            const y = event.getY();
                            if (!this.pointInView(x, y, this.mTouchSlop)) {
                                this.removeTapCallback();
                                if ((this.mPrivateFlags & View.PFLAG_PRESSED) != 0) {
                                    this.removeLongPressCallback();
                                    this.setPressed(false);
                                }
                            }
                            break;
                    }
                    return true;
                }
                return false;
            }
            isInScrollingContainer() {
                let p = this.getParent();
                while (p != null && p instanceof view_1.ViewGroup) {
                    if (p.shouldDelayChildPressedState()) {
                        return true;
                    }
                    p = p.getParent();
                }
                return false;
            }
            cancelPendingInputEvents() {
                this.dispatchCancelPendingInputEvents();
            }
            dispatchCancelPendingInputEvents() {
                this.mPrivateFlags3 &= ~View.PFLAG3_CALLED_SUPER;
                this.onCancelPendingInputEvents();
                if ((this.mPrivateFlags3 & View.PFLAG3_CALLED_SUPER) != View.PFLAG3_CALLED_SUPER) {
                    throw Error(`new SuperNotCalledException("View " + this.getClass().getSimpleName() + " did not call through to super.onCancelPendingInputEvents()")`);
                }
            }
            onCancelPendingInputEvents() {
                this.removePerformClickCallback();
                this.cancelLongPress();
                this.mPrivateFlags3 |= View.PFLAG3_CALLED_SUPER;
            }
            removeLongPressCallback() {
                if (this.mPendingCheckForLongPress != null) {
                    this.removeCallbacks(this.mPendingCheckForLongPress);
                }
            }
            removePerformClickCallback() {
                if (this.mPerformClick != null) {
                    this.removeCallbacks(this.mPerformClick);
                }
            }
            removeUnsetPressCallback() {
                if ((this.mPrivateFlags & View.PFLAG_PRESSED) != 0 && this.mUnsetPressedState != null) {
                    this.setPressed(false);
                    this.removeCallbacks(this.mUnsetPressedState);
                }
            }
            removeTapCallback() {
                if (this.mPendingCheckForTap != null) {
                    this.mPrivateFlags &= ~View.PFLAG_PREPRESSED;
                    this.removeCallbacks(this.mPendingCheckForTap);
                }
            }
            cancelLongPress() {
                this.removeLongPressCallback();
                this.removeTapCallback();
            }
            setTouchDelegate(delegate) {
                this.mTouchDelegate = delegate;
            }
            getTouchDelegate() {
                return this.mTouchDelegate;
            }
            getListenerInfo() {
                if (this.mListenerInfo != null) {
                    return this.mListenerInfo;
                }
                this.mListenerInfo = new View.ListenerInfo();
                return this.mListenerInfo;
            }
            addOnLayoutChangeListener(listener) {
                let li = this.getListenerInfo();
                if (li.mOnLayoutChangeListeners == null) {
                    li.mOnLayoutChangeListeners = new ArrayList();
                }
                if (!li.mOnLayoutChangeListeners.contains(listener)) {
                    li.mOnLayoutChangeListeners.add(listener);
                }
            }
            removeOnLayoutChangeListener(listener) {
                let li = this.mListenerInfo;
                if (li == null || li.mOnLayoutChangeListeners == null) {
                    return;
                }
                li.mOnLayoutChangeListeners.remove(listener);
            }
            addOnAttachStateChangeListener(listener) {
                let li = this.getListenerInfo();
                if (li.mOnAttachStateChangeListeners == null) {
                    li.mOnAttachStateChangeListeners
                        = new CopyOnWriteArrayList();
                }
                li.mOnAttachStateChangeListeners.add(listener);
            }
            removeOnAttachStateChangeListener(listener) {
                let li = this.mListenerInfo;
                if (li == null || li.mOnAttachStateChangeListeners == null) {
                    return;
                }
                li.mOnAttachStateChangeListeners.remove(listener);
            }
            setOnClickListener(l) {
                if (!this.isClickable()) {
                    this.setClickable(true);
                }
                this.getListenerInfo().mOnClickListener = l;
            }
            hasOnClickListeners() {
                let li = this.mListenerInfo;
                return (li != null && li.mOnClickListener != null);
            }
            setOnLongClickListener(l) {
                if (!this.isLongClickable()) {
                    this.setLongClickable(true);
                }
                this.getListenerInfo().mOnLongClickListener = l;
            }
            playSoundEffect(soundConstant) {
            }
            performHapticFeedback(feedbackConstant) {
                return false;
            }
            performClick(event) {
                this._sendClickToBindElement(event);
                let li = this.mListenerInfo;
                if (li != null && li.mOnClickListener != null) {
                    li.mOnClickListener.onClick(this);
                    return true;
                }
                return false;
            }
            _sendClickToBindElement(event) {
                let touch = event ? event._activeTouch : null;
                let screenX = touch ? touch.screenX : 0;
                let screenY = touch ? touch.screenY : 0;
                let clientX = touch ? touch.clientX : 0;
                let clientY = touch ? touch.clientY : 0;
                let clickEvent = document.createEvent('MouseEvents');
                clickEvent.initMouseEvent('click', false, true, window, 1, screenX, screenY, clientX, clientY, false, false, false, false, 0, null);
                clickEvent.forwardedTouchEvent = true;
                clickEvent[View.AndroidViewProperty] = this;
                this.bindElement.dispatchEvent(clickEvent);
            }
            callOnClick() {
                let li = this.mListenerInfo;
                if (li != null && li.mOnClickListener != null) {
                    li.mOnClickListener.onClick(this);
                    return true;
                }
                return false;
            }
            performLongClick() {
                let handled = false;
                let li = this.mListenerInfo;
                if (li != null && li.mOnLongClickListener != null) {
                    handled = li.mOnLongClickListener.onLongClick(this);
                }
                return handled;
            }
            performButtonActionOnTouchDown(event) {
                return false;
            }
            checkForLongClick(delayOffset = 0) {
                if ((this.mViewFlags & View.LONG_CLICKABLE) == View.LONG_CLICKABLE) {
                    this.mHasPerformedLongPress = false;
                    if (this.mPendingCheckForLongPress == null) {
                        this.mPendingCheckForLongPress = new CheckForLongPress(this);
                    }
                    this.mPendingCheckForLongPress.rememberWindowAttachCount();
                    this.postDelayed(this.mPendingCheckForLongPress, view_1.ViewConfiguration.getLongPressTimeout() - delayOffset);
                }
            }
            setOnTouchListener(l) {
                this.getListenerInfo().mOnTouchListener = l;
            }
            isClickable() {
                return (this.mViewFlags & View.CLICKABLE) == View.CLICKABLE;
            }
            setClickable(clickable) {
                this.setFlags(clickable ? View.CLICKABLE : 0, View.CLICKABLE);
            }
            isLongClickable() {
                return (this.mViewFlags & View.LONG_CLICKABLE) == View.LONG_CLICKABLE;
            }
            setLongClickable(longClickable) {
                this.setFlags(longClickable ? View.LONG_CLICKABLE : 0, View.LONG_CLICKABLE);
            }
            setPressed(pressed) {
                const needsRefresh = pressed != ((this.mPrivateFlags & View.PFLAG_PRESSED) == View.PFLAG_PRESSED);
                if (pressed) {
                    this.mPrivateFlags |= View.PFLAG_PRESSED;
                }
                else {
                    this.mPrivateFlags &= ~View.PFLAG_PRESSED;
                }
                if (needsRefresh) {
                    this.refreshDrawableState();
                }
                this.dispatchSetPressed(pressed);
            }
            dispatchSetPressed(pressed) {
            }
            isPressed() {
                return (this.mPrivateFlags & View.PFLAG_PRESSED) == View.PFLAG_PRESSED;
            }
            setSelected(selected) {
                if (((this.mPrivateFlags & View.PFLAG_SELECTED) != 0) != selected) {
                    this.mPrivateFlags = (this.mPrivateFlags & ~View.PFLAG_SELECTED) | (selected ? View.PFLAG_SELECTED : 0);
                    if (!selected)
                        this.resetPressedState();
                    this.invalidate(true);
                    this.refreshDrawableState();
                    this.dispatchSetSelected(selected);
                }
            }
            dispatchSetSelected(selected) {
            }
            isSelected() {
                return (this.mPrivateFlags & View.PFLAG_SELECTED) != 0;
            }
            setActivated(activated) {
                if (((this.mPrivateFlags & View.PFLAG_ACTIVATED) != 0) != activated) {
                    this.mPrivateFlags = (this.mPrivateFlags & ~View.PFLAG_ACTIVATED) | (activated ? View.PFLAG_ACTIVATED : 0);
                    this.invalidate(true);
                    this.refreshDrawableState();
                    this.dispatchSetActivated(activated);
                }
            }
            dispatchSetActivated(activated) {
            }
            isActivated() {
                return (this.mPrivateFlags & View.PFLAG_ACTIVATED) != 0;
            }
            getViewTreeObserver() {
                if (this.mAttachInfo != null) {
                    return this.mAttachInfo.mTreeObserver;
                }
                if (this.mFloatingTreeObserver == null) {
                    this.mFloatingTreeObserver = new view_1.ViewTreeObserver();
                }
                return this.mFloatingTreeObserver;
            }
            isLayoutRtl() {
                return false;
            }
            getBaseline() {
                return -1;
            }
            isLayoutRequested() {
                return (this.mPrivateFlags & View.PFLAG_FORCE_LAYOUT) == View.PFLAG_FORCE_LAYOUT;
            }
            getLayoutParams() {
                return this.mLayoutParams;
            }
            setLayoutParams(params) {
                if (params == null) {
                    throw new Error("Layout parameters cannot be null");
                }
                this.mLayoutParams = params;
                let p = this.mParent;
                if (p instanceof view_1.ViewGroup) {
                    p.onSetLayoutParams(this, params);
                }
                this.requestLayout();
            }
            requestLayout() {
                if (this.mMeasureCache != null)
                    this.mMeasureCache.clear();
                if (this.mAttachInfo != null && this.mAttachInfo.mViewRequestingLayout == null) {
                    let viewRoot = this.getViewRootImpl();
                    if (viewRoot != null && viewRoot.isInLayout()) {
                        if (!viewRoot.requestLayoutDuringLayout(this)) {
                            return;
                        }
                    }
                    this.mAttachInfo.mViewRequestingLayout = this;
                }
                this.mPrivateFlags |= View.PFLAG_FORCE_LAYOUT;
                this.mPrivateFlags |= View.PFLAG_INVALIDATED;
                if (this.mParent != null && !this.mParent.isLayoutRequested()) {
                    this.mParent.requestLayout();
                }
            }
            forceLayout() {
                if (this.mMeasureCache != null)
                    this.mMeasureCache.clear();
                this.mPrivateFlags |= View.PFLAG_FORCE_LAYOUT;
                this.mPrivateFlags |= View.PFLAG_INVALIDATED;
            }
            isLaidOut() {
                return (this.mPrivateFlags3 & View.PFLAG3_IS_LAID_OUT) == View.PFLAG3_IS_LAID_OUT;
            }
            layout(l, t, r, b) {
                if ((this.mPrivateFlags3 & View.PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) {
                    this.onMeasure(this.mOldWidthMeasureSpec, this.mOldHeightMeasureSpec);
                    this.mPrivateFlags3 &= ~View.PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
                }
                let oldL = this.mLeft;
                let oldT = this.mTop;
                let oldB = this.mBottom;
                let oldR = this.mRight;
                let changed = this.setFrame(l, t, r, b);
                if (changed || (this.mPrivateFlags & View.PFLAG_LAYOUT_REQUIRED) == View.PFLAG_LAYOUT_REQUIRED) {
                    this.onLayout(changed, l, t, r, b);
                    this.mPrivateFlags &= ~View.PFLAG_LAYOUT_REQUIRED;
                    let li = this.mListenerInfo;
                    if (li != null && li.mOnLayoutChangeListeners != null) {
                        let listenersCopy = li.mOnLayoutChangeListeners.clone();
                        let numListeners = listenersCopy.size();
                        for (let i = 0; i < numListeners; ++i) {
                            listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);
                        }
                    }
                }
                this.mPrivateFlags &= ~View.PFLAG_FORCE_LAYOUT;
                this.mPrivateFlags3 |= View.PFLAG3_IS_LAID_OUT;
            }
            onLayout(changed, left, top, right, bottom) {
            }
            setFrame(left, top, right, bottom) {
                let changed = false;
                if (View.DBG) {
                    Log.i("View", this + " View.setFrame(" + left + "," + top + ","
                        + right + "," + bottom + ")");
                }
                if (this.mLeft != left || this.mRight != right || this.mTop != top || this.mBottom != bottom) {
                    changed = true;
                    let drawn = this.mPrivateFlags & View.PFLAG_DRAWN;
                    let oldWidth = this.mRight - this.mLeft;
                    let oldHeight = this.mBottom - this.mTop;
                    let newWidth = right - left;
                    let newHeight = bottom - top;
                    let sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight);
                    this.invalidate(sizeChanged);
                    this.mLeft = left;
                    this.mTop = top;
                    this.mRight = right;
                    this.mBottom = bottom;
                    this.mPrivateFlags |= View.PFLAG_HAS_BOUNDS;
                    if (sizeChanged) {
                        if ((this.mPrivateFlags & View.PFLAG_PIVOT_EXPLICITLY_SET) == 0) {
                        }
                        this.sizeChange(newWidth, newHeight, oldWidth, oldHeight);
                    }
                    if ((this.mViewFlags & View.VISIBILITY_MASK) == View.VISIBLE) {
                        this.mPrivateFlags |= View.PFLAG_DRAWN;
                        this.invalidate(sizeChanged);
                    }
                    this.mPrivateFlags |= drawn;
                    this.mBackgroundSizeChanged = true;
                }
                return changed;
            }
            sizeChange(newWidth, newHeight, oldWidth, oldHeight) {
                this.onSizeChanged(newWidth, newHeight, oldWidth, oldHeight);
                if (this.mOverlay != null) {
                    this.mOverlay.getOverlayView().setRight(newWidth);
                    this.mOverlay.getOverlayView().setBottom(newHeight);
                }
            }
            getHitRect(outRect) {
                outRect.set(this.mLeft, this.mTop, this.mRight, this.mBottom);
            }
            getFocusedRect(r) {
                this.getDrawingRect(r);
            }
            getDrawingRect(outRect) {
                outRect.left = this.mScrollX;
                outRect.top = this.mScrollY;
                outRect.right = this.mScrollX + (this.mRight - this.mLeft);
                outRect.bottom = this.mScrollY + (this.mBottom - this.mTop);
            }
            getGlobalVisibleRect(r, globalOffset = null) {
                let width = this.mRight - this.mLeft;
                let height = this.mBottom - this.mTop;
                if (width > 0 && height > 0) {
                    r.set(0, 0, width, height);
                    if (globalOffset != null) {
                        globalOffset.set(-this.mScrollX, -this.mScrollY);
                    }
                    return this.mParent == null || this.mParent.getChildVisibleRect(this, r, globalOffset);
                }
                return false;
            }
            getMeasuredWidth() {
                return this.mMeasuredWidth & View.MEASURED_SIZE_MASK;
            }
            getMeasuredWidthAndState() {
                return this.mMeasuredWidth;
            }
            getMeasuredHeight() {
                return this.mMeasuredHeight & View.MEASURED_SIZE_MASK;
            }
            getMeasuredHeightAndState() {
                return this.mMeasuredHeight;
            }
            getMeasuredState() {
                return (this.mMeasuredWidth & View.MEASURED_STATE_MASK)
                    | ((this.mMeasuredHeight >> View.MEASURED_HEIGHT_STATE_SHIFT)
                        & (View.MEASURED_STATE_MASK >> View.MEASURED_HEIGHT_STATE_SHIFT));
            }
            measure(widthMeasureSpec, heightMeasureSpec) {
                let key = widthMeasureSpec + ',' + heightMeasureSpec;
                if (this.mMeasureCache == null)
                    this.mMeasureCache = new Map();
                if ((this.mPrivateFlags & View.PFLAG_FORCE_LAYOUT) == View.PFLAG_FORCE_LAYOUT ||
                    widthMeasureSpec != this.mOldWidthMeasureSpec ||
                    heightMeasureSpec != this.mOldHeightMeasureSpec) {
                    this.mPrivateFlags &= ~View.PFLAG_MEASURED_DIMENSION_SET;
                    let cacheValue = (this.mPrivateFlags & View.PFLAG_FORCE_LAYOUT) == View.PFLAG_FORCE_LAYOUT ? null : this.mMeasureCache.get(key);
                    if (cacheValue == null) {
                        this.onMeasure(widthMeasureSpec, heightMeasureSpec);
                        this.mPrivateFlags3 &= ~View.PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
                    }
                    else {
                        this.setMeasuredDimension(cacheValue[0], cacheValue[1]);
                        this.mPrivateFlags3 |= View.PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
                    }
                    if ((this.mPrivateFlags & View.PFLAG_MEASURED_DIMENSION_SET) != View.PFLAG_MEASURED_DIMENSION_SET) {
                        throw new Error("onMeasure() did not set the"
                            + " measured dimension by calling"
                            + " setMeasuredDimension()");
                    }
                    this.mPrivateFlags |= View.PFLAG_LAYOUT_REQUIRED;
                }
                this.mOldWidthMeasureSpec = widthMeasureSpec;
                this.mOldHeightMeasureSpec = heightMeasureSpec;
                this.mMeasureCache.set(key, [this.mMeasuredWidth, this.mMeasuredHeight]);
            }
            onMeasure(widthMeasureSpec, heightMeasureSpec) {
                this.setMeasuredDimension(View.getDefaultSize(this.getSuggestedMinimumWidth(), widthMeasureSpec), View.getDefaultSize(this.getSuggestedMinimumHeight(), heightMeasureSpec));
            }
            setMeasuredDimension(measuredWidth, measuredHeight) {
                this.mMeasuredWidth = measuredWidth;
                this.mMeasuredHeight = measuredHeight;
                this.mPrivateFlags |= View.PFLAG_MEASURED_DIMENSION_SET;
            }
            static combineMeasuredStates(curState, newState) {
                return curState | newState;
            }
            static resolveSize(size, measureSpec) {
                return View.resolveSizeAndState(size, measureSpec, 0) & View.MEASURED_SIZE_MASK;
            }
            static resolveSizeAndState(size, measureSpec, childMeasuredState) {
                let MeasureSpec = View.MeasureSpec;
                let result = size;
                let specMode = MeasureSpec.getMode(measureSpec);
                let specSize = MeasureSpec.getSize(measureSpec);
                switch (specMode) {
                    case MeasureSpec.UNSPECIFIED:
                        result = size;
                        break;
                    case MeasureSpec.AT_MOST:
                        if (specSize < size) {
                            result = specSize | View.MEASURED_STATE_TOO_SMALL;
                        }
                        else {
                            result = size;
                        }
                        break;
                    case MeasureSpec.EXACTLY:
                        result = specSize;
                        break;
                }
                return result | (childMeasuredState & View.MEASURED_STATE_MASK);
            }
            static getDefaultSize(size, measureSpec) {
                let MeasureSpec = View.MeasureSpec;
                let result = size;
                let specMode = MeasureSpec.getMode(measureSpec);
                let specSize = MeasureSpec.getSize(measureSpec);
                switch (specMode) {
                    case MeasureSpec.UNSPECIFIED:
                        result = size;
                        break;
                    case MeasureSpec.AT_MOST:
                    case MeasureSpec.EXACTLY:
                        result = specSize;
                        break;
                }
                return result;
            }
            getSuggestedMinimumHeight() {
                return (this.mBackground == null) ? this.mMinHeight :
                    Math.max(this.mMinHeight, this.mBackground.getMinimumHeight());
            }
            getSuggestedMinimumWidth() {
                return (this.mBackground == null) ? this.mMinWidth :
                    Math.max(this.mMinWidth, this.mBackground.getMinimumWidth());
            }
            getMinimumHeight() {
                return this.mMinHeight;
            }
            setMinimumHeight(minHeight) {
                this.mMinHeight = minHeight;
                this.requestLayout();
            }
            getMinimumWidth() {
                return this.mMinWidth;
            }
            setMinimumWidth(minWidth) {
                this.mMinWidth = minWidth;
                this.requestLayout();
            }
            _invalidateRect(l, t, r, b) {
                if (this.skipInvalidate()) {
                    return;
                }
                if ((this.mPrivateFlags & (View.PFLAG_DRAWN | View.PFLAG_HAS_BOUNDS)) == (View.PFLAG_DRAWN | View.PFLAG_HAS_BOUNDS) ||
                    (this.mPrivateFlags & View.PFLAG_DRAWING_CACHE_VALID) == View.PFLAG_DRAWING_CACHE_VALID ||
                    (this.mPrivateFlags & View.PFLAG_INVALIDATED) != View.PFLAG_INVALIDATED) {
                    this.mPrivateFlags &= ~View.PFLAG_DRAWING_CACHE_VALID;
                    this.mPrivateFlags |= View.PFLAG_INVALIDATED;
                    this.mPrivateFlags |= View.PFLAG_DIRTY;
                    const p = this.mParent;
                    const ai = this.mAttachInfo;
                    if (p != null && ai != null && l < r && t < b) {
                        const scrollX = this.mScrollX;
                        const scrollY = this.mScrollY;
                        const tmpr = ai.mTmpInvalRect;
                        tmpr.set(l - scrollX, t - scrollY, r - scrollX, b - scrollY);
                        p.invalidateChild(this, tmpr);
                    }
                }
            }
            _invalidateCache(invalidateCache = true) {
                if (this.skipInvalidate()) {
                    return;
                }
                if ((this.mPrivateFlags & (View.PFLAG_DRAWN | View.PFLAG_HAS_BOUNDS)) == (View.PFLAG_DRAWN | View.PFLAG_HAS_BOUNDS) ||
                    (invalidateCache && (this.mPrivateFlags & View.PFLAG_DRAWING_CACHE_VALID) == View.PFLAG_DRAWING_CACHE_VALID) ||
                    (this.mPrivateFlags & View.PFLAG_INVALIDATED) != View.PFLAG_INVALIDATED || this.isOpaque() != this.mLastIsOpaque) {
                    this.mLastIsOpaque = this.isOpaque();
                    this.mPrivateFlags &= ~View.PFLAG_DRAWN;
                    this.mPrivateFlags |= View.PFLAG_DIRTY;
                    if (invalidateCache) {
                        this.mPrivateFlags |= View.PFLAG_INVALIDATED;
                        this.mPrivateFlags &= ~View.PFLAG_DRAWING_CACHE_VALID;
                    }
                    const ai = this.mAttachInfo;
                    const p = this.mParent;
                    if (p != null && ai != null) {
                        const r = ai.mTmpInvalRect;
                        r.set(0, 0, this.mRight - this.mLeft, this.mBottom - this.mTop);
                        p.invalidateChild(this, r);
                    }
                }
            }
            invalidate(...args) {
                if (args.length === 0 || (args.length === 1 && typeof args[0] === 'boolean')) {
                    this._invalidateCache(args[0]);
                }
                else if (args.length === 1 && args[0] instanceof Rect) {
                    let rect = args[0];
                    this._invalidateRect(rect.left, rect.top, rect.right, rect.bottom);
                }
                else if (args.length === 4) {
                    this._invalidateRect(...args);
                }
            }
            invalidateViewProperty(invalidateParent, forceRedraw) {
                if ((this.mPrivateFlags & View.PFLAG_DRAW_ANIMATION) == View.PFLAG_DRAW_ANIMATION) {
                    if (invalidateParent) {
                        this.invalidateParentCaches();
                    }
                    if (forceRedraw) {
                        this.mPrivateFlags |= View.PFLAG_DRAWN;
                    }
                    this.invalidate(false);
                }
                else {
                    const ai = this.mAttachInfo;
                    const p = this.mParent;
                    if (p != null && ai != null) {
                        const r = ai.mTmpInvalRect;
                        r.set(0, 0, this.mRight - this.mLeft, this.mBottom - this.mTop);
                        if (this.mParent instanceof view_1.ViewGroup) {
                            this.mParent.invalidateChildFast(this, r);
                        }
                        else {
                            this.mParent.invalidateChild(this, r);
                        }
                    }
                }
            }
            invalidateParentCaches() {
                if (this.mParent instanceof View) {
                    this.mParent.mPrivateFlags |= View.PFLAG_INVALIDATED;
                }
            }
            invalidateParentIfNeeded() {
            }
            postInvalidate(l, t, r, b) {
                this.postInvalidateDelayed(0, l, t, r, b);
            }
            postInvalidateDelayed(delayMilliseconds, left, top, right, bottom) {
                const attachInfo = this.mAttachInfo;
                if (attachInfo != null) {
                    if (!Number.isInteger(left) || !Number.isInteger(top) || !Number.isInteger(right) || !Number.isInteger(bottom)) {
                        attachInfo.mViewRootImpl.dispatchInvalidateDelayed(this, delayMilliseconds);
                    }
                    else {
                        const info = View.AttachInfo.InvalidateInfo.obtain();
                        info.target = this;
                        info.left = left;
                        info.top = top;
                        info.right = right;
                        info.bottom = bottom;
                        attachInfo.mViewRootImpl.dispatchInvalidateRectDelayed(info, delayMilliseconds);
                    }
                }
            }
            postInvalidateOnAnimation(left, top, right, bottom) {
                const attachInfo = this.mAttachInfo;
                if (attachInfo != null) {
                    if (!Number.isInteger(left) || !Number.isInteger(top) || !Number.isInteger(right) || !Number.isInteger(bottom)) {
                        attachInfo.mViewRootImpl.dispatchInvalidateOnAnimation(this);
                    }
                    else {
                        const info = View.AttachInfo.InvalidateInfo.obtain();
                        info.target = this;
                        info.left = left;
                        info.top = top;
                        info.right = right;
                        info.bottom = bottom;
                        attachInfo.mViewRootImpl.dispatchInvalidateRectOnAnimation(info);
                    }
                }
            }
            skipInvalidate() {
                return (this.mViewFlags & View.VISIBILITY_MASK) != View.VISIBLE;
            }
            isOpaque() {
                return (this.mPrivateFlags & View.PFLAG_OPAQUE_MASK) == View.PFLAG_OPAQUE_MASK &&
                    this.getFinalAlpha() >= 1;
            }
            computeOpaqueFlags() {
                // Opaque if:
                //   - Has a background
                //   - Background is opaque
                //   - Doesn't have scrollbars or scrollbars overlay
                if (this.mBackground != null && this.mBackground.getOpacity() == PixelFormat.OPAQUE) {
                    this.mPrivateFlags |= View.PFLAG_OPAQUE_BACKGROUND;
                }
                else {
                    this.mPrivateFlags &= ~View.PFLAG_OPAQUE_BACKGROUND;
                }
                const flags = this.mViewFlags;
                if (((flags & View.SCROLLBARS_VERTICAL) == 0 && (flags & View.SCROLLBARS_HORIZONTAL) == 0)) {
                    this.mPrivateFlags |= View.PFLAG_OPAQUE_SCROLLBARS;
                }
                else {
                    this.mPrivateFlags &= ~View.PFLAG_OPAQUE_SCROLLBARS;
                }
            }
            getLayerType() {
                return this.mLayerType;
            }
            setClipBounds(clipBounds) {
                if (clipBounds != null) {
                    if (clipBounds.equals(this.mClipBounds)) {
                        return;
                    }
                    if (this.mClipBounds == null) {
                        this.invalidate();
                        this.mClipBounds = new Rect(clipBounds);
                    }
                    else {
                        this.invalidate(Math.min(this.mClipBounds.left, clipBounds.left), Math.min(this.mClipBounds.top, clipBounds.top), Math.max(this.mClipBounds.right, clipBounds.right), Math.max(this.mClipBounds.bottom, clipBounds.bottom));
                        this.mClipBounds.set(clipBounds);
                    }
                }
                else {
                    if (this.mClipBounds != null) {
                        this.invalidate();
                        this.mClipBounds = null;
                    }
                }
            }
            getClipBounds() {
                return (this.mClipBounds != null) ? new Rect(this.mClipBounds) : null;
            }
            getDrawingTime() {
                return this.mAttachInfo != null ? this.mAttachInfo.mDrawingTime : 0;
            }
            drawFromParent(canvas, parent, drawingTime) {
                let useDisplayListProperties = false;
                let more = false;
                let childHasIdentityMatrix = true;
                let flags = parent.mGroupFlags;
                let scalingRequired = false;
                let concatMatrix = false;
                let caching = false;
                let layerType = this.getLayerType();
                if ((flags & view_1.ViewGroup.FLAG_CHILDREN_DRAWN_WITH_CACHE) != 0 ||
                    (flags & view_1.ViewGroup.FLAG_ALWAYS_DRAWN_WITH_CACHE) != 0) {
                    caching = true;
                }
                else {
                    caching = (layerType != View.LAYER_TYPE_NONE);
                }
                concatMatrix == concatMatrix || !childHasIdentityMatrix;
                this.mPrivateFlags |= View.PFLAG_DRAWN;
                if (!concatMatrix &&
                    (flags & (view_1.ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS |
                        view_1.ViewGroup.FLAG_CLIP_CHILDREN)) == view_1.ViewGroup.FLAG_CLIP_CHILDREN &&
                    canvas.quickReject(this.mLeft, this.mTop, this.mRight, this.mBottom) &&
                    (this.mPrivateFlags & View.PFLAG_DRAW_ANIMATION) == 0) {
                    this.mPrivateFlags2 |= View.PFLAG2_VIEW_QUICK_REJECTED;
                    return more;
                }
                this.mPrivateFlags2 &= ~View.PFLAG2_VIEW_QUICK_REJECTED;
                let cache = null;
                if (caching) {
                    if (layerType != View.LAYER_TYPE_NONE) {
                        layerType = View.LAYER_TYPE_SOFTWARE;
                        this.buildDrawingCache(true);
                    }
                    cache = this.getDrawingCache(true);
                }
                this.computeScroll();
                let sx = this.mScrollX;
                let sy = this.mScrollY;
                this.syncScrollToElement();
                let hasNoCache = cache == null;
                let offsetForScroll = cache == null;
                let restoreTo = canvas.save();
                if (offsetForScroll) {
                    canvas.translate(this.mLeft - sx, this.mTop - sy);
                }
                else {
                    canvas.translate(this.mLeft, this.mTop);
                }
                let alpha = 1;
                if ((flags & view_1.ViewGroup.FLAG_CLIP_CHILDREN) == view_1.ViewGroup.FLAG_CLIP_CHILDREN &&
                    !useDisplayListProperties && cache == null) {
                    if (offsetForScroll) {
                        canvas.clipRect(sx, sy, sx + (this.mRight - this.mLeft), sy + (this.mBottom - this.mTop));
                    }
                    else {
                        if (!scalingRequired || cache == null) {
                            canvas.clipRect(0, 0, this.mRight - this.mLeft, this.mBottom - this.mTop);
                        }
                        else {
                            canvas.clipRect(0, 0, cache.getWidth(), cache.getHeight());
                        }
                    }
                }
                if (hasNoCache) {
                    if ((this.mPrivateFlags & View.PFLAG_SKIP_DRAW) == View.PFLAG_SKIP_DRAW) {
                        this.mPrivateFlags &= ~View.PFLAG_DIRTY_MASK;
                        this.dispatchDraw(canvas);
                    }
                    else {
                        this.draw(canvas);
                    }
                }
                else if (cache != null) {
                    this.mPrivateFlags &= ~View.PFLAG_DIRTY_MASK;
                    if (alpha < 1) {
                        parent.mGroupFlags |= view_1.ViewGroup.FLAG_ALPHA_LOWER_THAN_ONE;
                    }
                    else if ((flags & view_1.ViewGroup.FLAG_ALPHA_LOWER_THAN_ONE) != 0) {
                        parent.mGroupFlags &= ~view_1.ViewGroup.FLAG_ALPHA_LOWER_THAN_ONE;
                    }
                    canvas.drawCanvas(cache, 0, 0);
                }
                if (restoreTo >= 0) {
                    canvas.restoreToCount(restoreTo);
                }
                return more;
            }
            draw(canvas) {
                if (this.mClipBounds != null) {
                    canvas.clipRect(this.mClipBounds);
                }
                let privateFlags = this.mPrivateFlags;
                const dirtyOpaque = (privateFlags & View.PFLAG_DIRTY_MASK) == View.PFLAG_DIRTY_OPAQUE &&
                    (this.mAttachInfo == null || !this.mAttachInfo.mIgnoreDirtyState);
                this.mPrivateFlags = (privateFlags & ~View.PFLAG_DIRTY_MASK) | View.PFLAG_DRAWN;
                if (!dirtyOpaque) {
                    let background = this.mBackground;
                    if (background != null) {
                        let scrollX = this.mScrollX;
                        let scrollY = this.mScrollY;
                        if (this.mBackgroundSizeChanged) {
                            background.setBounds(0, 0, this.mRight - this.mLeft, this.mBottom - this.mTop);
                            this.mBackgroundSizeChanged = false;
                        }
                        if ((scrollX | scrollY) == 0) {
                            background.draw(canvas);
                        }
                        else {
                            canvas.translate(scrollX, scrollY);
                            background.draw(canvas);
                            canvas.translate(-scrollX, -scrollY);
                        }
                    }
                }
                if (!dirtyOpaque)
                    this.onDraw(canvas);
                this.dispatchDraw(canvas);
                this.onDrawScrollBars(canvas);
                if (this.mOverlay != null && !this.mOverlay.isEmpty()) {
                    this.mOverlay.getOverlayView().dispatchDraw(canvas);
                }
            }
            onDraw(canvas) {
            }
            dispatchDraw(canvas) {
            }
            onDrawScrollBars(canvas) {
                const cache = this.mScrollCache;
                if (cache != null) {
                    let state = cache.state;
                    if (state == ScrollabilityCache.OFF) {
                        return;
                    }
                    let invalidate = false;
                    if (state == ScrollabilityCache.FADING) {
                        cache._computeAlphaToScrollBar();
                        invalidate = true;
                    }
                    else {
                        cache.scrollBar.setAlpha(255);
                    }
                    const viewFlags = this.mViewFlags;
                    const drawHorizontalScrollBar = (viewFlags & View.SCROLLBARS_HORIZONTAL) == View.SCROLLBARS_HORIZONTAL;
                    const drawVerticalScrollBar = (viewFlags & View.SCROLLBARS_VERTICAL) == View.SCROLLBARS_VERTICAL
                        && !this.isVerticalScrollBarHidden();
                    if (drawVerticalScrollBar || drawHorizontalScrollBar) {
                        const width = this.mRight - this.mLeft;
                        const height = this.mBottom - this.mTop;
                        const scrollBar = cache.scrollBar;
                        const scrollX = this.mScrollX;
                        const scrollY = this.mScrollY;
                        const inside = true;
                        let left;
                        let top;
                        let right;
                        let bottom;
                        if (drawHorizontalScrollBar) {
                            let size = scrollBar.getSize(false);
                            if (size <= 0) {
                                size = cache.scrollBarSize;
                            }
                            scrollBar.setParameters(this.computeHorizontalScrollRange(), this.computeHorizontalScrollOffset(), this.computeHorizontalScrollExtent(), false);
                            const verticalScrollBarGap = drawVerticalScrollBar ?
                                this.getVerticalScrollbarWidth() : 0;
                            top = scrollY + height - size;
                            left = scrollX + (this.mPaddingLeft);
                            right = scrollX + width - -verticalScrollBarGap;
                            bottom = top + size;
                            this.onDrawHorizontalScrollBar(canvas, scrollBar, left, top, right, bottom);
                            if (invalidate) {
                                this.invalidate(left, top, right, bottom);
                            }
                        }
                        if (drawVerticalScrollBar) {
                            let size = scrollBar.getSize(true);
                            if (size <= 0) {
                                size = cache.scrollBarSize;
                            }
                            scrollBar.setParameters(this.computeVerticalScrollRange(), this.computeVerticalScrollOffset(), this.computeVerticalScrollExtent(), true);
                            left = scrollX + width - size;
                            top = scrollY + (this.mPaddingTop);
                            right = left + size;
                            bottom = scrollY + height;
                            this.onDrawVerticalScrollBar(canvas, scrollBar, left, top, right, bottom);
                            if (invalidate) {
                                this.invalidate(left, top, right, bottom);
                            }
                        }
                    }
                }
            }
            isVerticalScrollBarHidden() {
                return false;
            }
            onDrawHorizontalScrollBar(canvas, scrollBar, l, t, r, b) {
                scrollBar.setBounds(l, t, r, b);
                scrollBar.draw(canvas);
            }
            onDrawVerticalScrollBar(canvas, scrollBar, l, t, r, b) {
                scrollBar.setBounds(l, t, r, b);
                scrollBar.draw(canvas);
            }
            isHardwareAccelerated() {
                return false;
            }
            setDrawingCacheEnabled(enabled) {
                this.mCachingFailed = false;
                this.setFlags(enabled ? View.DRAWING_CACHE_ENABLED : 0, View.DRAWING_CACHE_ENABLED);
            }
            isDrawingCacheEnabled() {
                return (this.mViewFlags & View.DRAWING_CACHE_ENABLED) == View.DRAWING_CACHE_ENABLED;
            }
            getDrawingCache(autoScale = false) {
                if ((this.mViewFlags & View.WILL_NOT_CACHE_DRAWING) == View.WILL_NOT_CACHE_DRAWING) {
                    return null;
                }
                if ((this.mViewFlags & View.DRAWING_CACHE_ENABLED) == View.DRAWING_CACHE_ENABLED) {
                    this.buildDrawingCache(autoScale);
                }
                return this.mUnscaledDrawingCache;
            }
            setDrawingCacheBackgroundColor(color) {
                if (color != this.mDrawingCacheBackgroundColor) {
                    this.mDrawingCacheBackgroundColor = color;
                    this.mPrivateFlags &= ~View.PFLAG_DRAWING_CACHE_VALID;
                }
            }
            getDrawingCacheBackgroundColor() {
                return this.mDrawingCacheBackgroundColor;
            }
            destroyDrawingCache() {
                if (this.mUnscaledDrawingCache != null) {
                    this.mUnscaledDrawingCache.recycle();
                    this.mUnscaledDrawingCache = null;
                }
            }
            buildDrawingCache(autoScale = false) {
                if ((this.mPrivateFlags & View.PFLAG_DRAWING_CACHE_VALID) == 0 || this.mUnscaledDrawingCache == null) {
                    this.mCachingFailed = false;
                    let width = this.mRight - this.mLeft;
                    let height = this.mBottom - this.mTop;
                    const attachInfo = this.mAttachInfo;
                    const drawingCacheBackgroundColor = this.mDrawingCacheBackgroundColor;
                    const opaque = drawingCacheBackgroundColor != 0 || this.isOpaque();
                    const use32BitCache = true;
                    const projectedBitmapSize = width * height * (opaque && !use32BitCache ? 2 : 4);
                    const drawingCacheSize = view_1.ViewConfiguration.get().getScaledMaximumDrawingCacheSize();
                    if (width <= 0 || height <= 0 || projectedBitmapSize > drawingCacheSize) {
                        if (width > 0 && height > 0) {
                            Log.w(View.VIEW_LOG_TAG, "View too large to fit into drawing cache, needs " + projectedBitmapSize + " bytes, only " + drawingCacheSize + " available");
                        }
                        this.destroyDrawingCache();
                        this.mCachingFailed = true;
                        return;
                    }
                    if (this.mUnscaledDrawingCache &&
                        (this.mUnscaledDrawingCache.getWidth() !== width || this.mUnscaledDrawingCache.getHeight() !== height)) {
                        this.mUnscaledDrawingCache.recycle();
                        this.mUnscaledDrawingCache = null;
                    }
                    if (this.mUnscaledDrawingCache) {
                        this.mUnscaledDrawingCache.clearColor();
                    }
                    else {
                        this.mUnscaledDrawingCache = new Canvas(width, height);
                    }
                    const canvas = this.mUnscaledDrawingCache;
                    this.computeScroll();
                    const restoreCount = canvas.save();
                    canvas.translate(-this.mScrollX, -this.mScrollY);
                    this.mPrivateFlags |= View.PFLAG_DRAWN;
                    this.mPrivateFlags |= View.PFLAG_DRAWING_CACHE_VALID;
                    if ((this.mPrivateFlags & View.PFLAG_SKIP_DRAW) == View.PFLAG_SKIP_DRAW) {
                        this.mPrivateFlags &= ~View.PFLAG_DIRTY_MASK;
                        this.dispatchDraw(canvas);
                        if (this.mOverlay != null && !this.mOverlay.isEmpty()) {
                            this.mOverlay.getOverlayView().draw(canvas);
                        }
                    }
                    else {
                        this.draw(canvas);
                    }
                    canvas.restoreToCount(restoreCount);
                }
            }
            setWillNotDraw(willNotDraw) {
                this.setFlags(willNotDraw ? View.WILL_NOT_DRAW : 0, View.DRAW_MASK);
            }
            willNotDraw() {
                return (this.mViewFlags & View.DRAW_MASK) == View.WILL_NOT_DRAW;
            }
            setWillNotCacheDrawing(willNotCacheDrawing) {
                this.setFlags(willNotCacheDrawing ? View.WILL_NOT_CACHE_DRAWING : 0, View.WILL_NOT_CACHE_DRAWING);
            }
            willNotCacheDrawing() {
                return (this.mViewFlags & View.WILL_NOT_CACHE_DRAWING) == View.WILL_NOT_CACHE_DRAWING;
            }
            invalidateDrawable(drawable) {
                if (this.verifyDrawable(drawable)) {
                    const dirty = drawable.getBounds();
                    const scrollX = this.mScrollX;
                    const scrollY = this.mScrollY;
                    this.invalidate(dirty.left + scrollX, dirty.top + scrollY, dirty.right + scrollX, dirty.bottom + scrollY);
                }
            }
            scheduleDrawable(who, what, when) {
                if (this.verifyDrawable(who) && what != null) {
                    const delay = when - SystemClock.uptimeMillis();
                    if (this.mAttachInfo != null) {
                        this.mAttachInfo.mHandler.postAtTime(what, who, when);
                    }
                    else {
                        view_1.ViewRootImpl.getRunQueue().postDelayed(what, delay);
                    }
                }
            }
            unscheduleDrawable(who, what) {
                if (this.verifyDrawable(who) && what != null) {
                    if (this.mAttachInfo != null) {
                        this.mAttachInfo.mHandler.removeCallbacks(what, who);
                    }
                    else {
                        view_1.ViewRootImpl.getRunQueue().removeCallbacks(what);
                    }
                }
                else if (what === null) {
                    if (this.mAttachInfo != null && who != null) {
                        this.mAttachInfo.mHandler.removeCallbacksAndMessages(who);
                    }
                }
            }
            verifyDrawable(who) {
                return who == this.mBackground;
            }
            drawableStateChanged() {
                this.getDrawableState();
                let d = this.mBackground;
                if (d != null && d.isStateful()) {
                    d.setState(this.getDrawableState());
                }
            }
            resolveDrawables() {
            }
            refreshDrawableState() {
                this.mPrivateFlags |= View.PFLAG_DRAWABLE_STATE_DIRTY;
                this.drawableStateChanged();
                let parent = this.mParent;
                if (parent != null) {
                    parent.childDrawableStateChanged(this);
                }
            }
            getDrawableState() {
                if ((this.mDrawableState != null) && ((this.mPrivateFlags & View.PFLAG_DRAWABLE_STATE_DIRTY) == 0)) {
                    return this.mDrawableState;
                }
                else {
                    let oldDrawableState = this.mDrawableState;
                    this.mDrawableState = this.onCreateDrawableState(0);
                    this.mPrivateFlags &= ~View.PFLAG_DRAWABLE_STATE_DIRTY;
                    this._fireStateChangeToAttribute(oldDrawableState, this.mDrawableState);
                    this.syncDrawStateToElement();
                    return this.mDrawableState;
                }
            }
            onCreateDrawableState(extraSpace) {
                if ((this.mViewFlags & View.DUPLICATE_PARENT_STATE) == View.DUPLICATE_PARENT_STATE &&
                    this.mParent instanceof View) {
                    return this.mParent.onCreateDrawableState(extraSpace);
                }
                let drawableState;
                let privateFlags = this.mPrivateFlags;
                let viewStateIndex = 0;
                if ((privateFlags & View.PFLAG_PRESSED) != 0)
                    viewStateIndex |= View.VIEW_STATE_PRESSED;
                if ((this.mViewFlags & View.ENABLED_MASK) == View.ENABLED)
                    viewStateIndex |= View.VIEW_STATE_ENABLED;
                if (this.isFocused())
                    viewStateIndex |= View.VIEW_STATE_FOCUSED;
                if ((privateFlags & View.PFLAG_SELECTED) != 0)
                    viewStateIndex |= View.VIEW_STATE_SELECTED;
                if ((privateFlags & View.PFLAG_ACTIVATED) != 0)
                    viewStateIndex |= View.VIEW_STATE_ACTIVATED;
                const privateFlags2 = this.mPrivateFlags2;
                drawableState = View.VIEW_STATE_SETS[viewStateIndex];
                if (extraSpace == 0) {
                    return drawableState;
                }
                let fullState;
                if (drawableState != null) {
                    fullState = new Array(drawableState.length + extraSpace);
                    System.arraycopy(drawableState, 0, fullState, 0, drawableState.length);
                }
                else {
                    fullState = new Array(extraSpace);
                }
                return fullState;
            }
            static mergeDrawableStates(baseState, additionalState) {
                const N = baseState.length;
                let i = N - 1;
                while (i >= 0 && baseState[i] == 0) {
                    i--;
                }
                System.arraycopy(additionalState, 0, baseState, i + 1, additionalState.length);
                return baseState;
            }
            jumpDrawablesToCurrentState() {
                if (this.mBackground != null) {
                    this.mBackground.jumpToCurrentState();
                }
            }
            setBackgroundColor(color) {
                if (this.mBackground instanceof ColorDrawable) {
                    this.mBackground.mutate().setColor(color);
                    this.computeOpaqueFlags();
                }
                else {
                    this.setBackground(new ColorDrawable(color));
                }
            }
            setBackground(background) {
                this.setBackgroundDrawable(background);
            }
            setBackgroundDrawable(background) {
                this.computeOpaqueFlags();
                if (background == this.mBackground) {
                    return;
                }
                let requestLayout = false;
                if (this.mBackground != null) {
                    this.mBackground.setCallback(null);
                    this.unscheduleDrawable(this.mBackground);
                }
                if (background != null) {
                    let padding = new Rect();
                    if (background.getPadding(padding)) {
                        this.setPadding(padding.left, padding.top, padding.right, padding.bottom);
                    }
                    if (this.mBackground == null || this.mBackground.getMinimumHeight() != background.getMinimumHeight() ||
                        this.mBackground.getMinimumWidth() != background.getMinimumWidth()) {
                        requestLayout = true;
                    }
                    background.setCallback(this);
                    if (background.isStateful()) {
                        background.setState(this.getDrawableState());
                    }
                    background.setVisible(this.getVisibility() == View.VISIBLE, false);
                    this.mBackground = background;
                    if ((this.mPrivateFlags & View.PFLAG_SKIP_DRAW) != 0) {
                        this.mPrivateFlags &= ~View.PFLAG_SKIP_DRAW;
                        this.mPrivateFlags |= View.PFLAG_ONLY_DRAWS_BACKGROUND;
                        requestLayout = true;
                    }
                }
                else {
                    this.mBackground = null;
                    if ((this.mPrivateFlags & View.PFLAG_ONLY_DRAWS_BACKGROUND) != 0) {
                        this.mPrivateFlags &= ~View.PFLAG_ONLY_DRAWS_BACKGROUND;
                        this.mPrivateFlags |= View.PFLAG_SKIP_DRAW;
                    }
                    requestLayout = true;
                }
                this.computeOpaqueFlags();
                if (requestLayout) {
                    this.requestLayout();
                }
                this.mBackgroundSizeChanged = true;
                this.invalidate(true);
            }
            getAnimation() {
                return null;
            }
            computeHorizontalScrollRange() {
                return this.getWidth();
            }
            computeHorizontalScrollOffset() {
                return this.mScrollX;
            }
            computeHorizontalScrollExtent() {
                return this.getWidth();
            }
            computeVerticalScrollRange() {
                return this.getHeight();
            }
            computeVerticalScrollOffset() {
                return this.mScrollY;
            }
            computeVerticalScrollExtent() {
                return this.getHeight();
            }
            canScrollHorizontally(direction) {
                const offset = this.computeHorizontalScrollOffset();
                const range = this.computeHorizontalScrollRange() - this.computeHorizontalScrollExtent();
                if (range == 0)
                    return false;
                if (direction < 0) {
                    return offset > 0;
                }
                else {
                    return offset < range - 1;
                }
            }
            canScrollVertically(direction) {
                const offset = this.computeVerticalScrollOffset();
                const range = this.computeVerticalScrollRange() - this.computeVerticalScrollExtent();
                if (range == 0)
                    return false;
                if (direction < 0) {
                    return offset > 0;
                }
                else {
                    return offset < range - 1;
                }
            }
            overScrollBy(deltaX, deltaY, scrollX, scrollY, scrollRangeX, scrollRangeY, maxOverScrollX, maxOverScrollY, isTouchEvent) {
                const overScrollMode = this.mOverScrollMode;
                const canScrollHorizontal = this.computeHorizontalScrollRange() > this.computeHorizontalScrollExtent();
                const canScrollVertical = this.computeVerticalScrollRange() > this.computeVerticalScrollExtent();
                const overScrollHorizontal = overScrollMode == View.OVER_SCROLL_ALWAYS ||
                    (overScrollMode == View.OVER_SCROLL_IF_CONTENT_SCROLLS && canScrollHorizontal);
                const overScrollVertical = overScrollMode == View.OVER_SCROLL_ALWAYS ||
                    (overScrollMode == View.OVER_SCROLL_IF_CONTENT_SCROLLS && canScrollVertical);
                if (isTouchEvent) {
                    if ((deltaX < 0 && scrollX <= 0) || (deltaX > 0 && scrollX >= scrollRangeX)) {
                        deltaX /= 2;
                    }
                    if ((deltaY < 0 && scrollY <= 0) || (deltaY > 0 && scrollY >= scrollRangeY)) {
                        deltaY /= 2;
                    }
                }
                let newScrollX = scrollX + deltaX;
                if (!overScrollHorizontal) {
                    maxOverScrollX = 0;
                }
                let newScrollY = scrollY + deltaY;
                if (!overScrollVertical) {
                    maxOverScrollY = 0;
                }
                const left = -maxOverScrollX;
                const right = maxOverScrollX + scrollRangeX;
                const top = -maxOverScrollY;
                const bottom = maxOverScrollY + scrollRangeY;
                let clampedX = false;
                if (newScrollX > right) {
                    newScrollX = right;
                    clampedX = true;
                }
                else if (newScrollX < left) {
                    newScrollX = left;
                    clampedX = true;
                }
                let clampedY = false;
                if (newScrollY > bottom) {
                    newScrollY = bottom;
                    clampedY = true;
                }
                else if (newScrollY < top) {
                    newScrollY = top;
                    clampedY = true;
                }
                this.onOverScrolled(newScrollX, newScrollY, clampedX, clampedY);
                return clampedX || clampedY;
            }
            onOverScrolled(scrollX, scrollY, clampedX, clampedY) {
            }
            getOverScrollMode() {
                return this.mOverScrollMode;
            }
            setOverScrollMode(overScrollMode) {
                if (overScrollMode != View.OVER_SCROLL_ALWAYS &&
                    overScrollMode != View.OVER_SCROLL_IF_CONTENT_SCROLLS &&
                    overScrollMode != View.OVER_SCROLL_NEVER) {
                    throw new Error("Invalid overscroll mode " + overScrollMode);
                }
                this.mOverScrollMode = overScrollMode;
            }
            getVerticalScrollFactor() {
                if (this.mVerticalScrollFactor == 0) {
                    this.mVerticalScrollFactor = Resources.getDisplayMetrics().density * 1;
                }
                return this.mVerticalScrollFactor;
            }
            getHorizontalScrollFactor() {
                return this.getVerticalScrollFactor();
            }
            computeScroll() {
            }
            scrollTo(x, y) {
                if (this.mScrollX != x || this.mScrollY != y) {
                    let oldX = this.mScrollX;
                    let oldY = this.mScrollY;
                    this.mScrollX = x;
                    this.mScrollY = y;
                    this.invalidateParentCaches();
                    this.onScrollChanged(this.mScrollX, this.mScrollY, oldX, oldY);
                    if (!this.awakenScrollBars()) {
                        this.postInvalidateOnAnimation();
                    }
                }
            }
            scrollBy(x, y) {
                this.scrollTo(this.mScrollX + x, this.mScrollY + y);
            }
            initialAwakenScrollBars() {
                return this.mScrollCache != null &&
                    this.awakenScrollBars(this.mScrollCache.scrollBarDefaultDelayBeforeFade * 4, true);
            }
            awakenScrollBars(startDelay, invalidate = true) {
                const scrollCache = this.mScrollCache;
                if (scrollCache == null)
                    return false;
                startDelay = startDelay || scrollCache.scrollBarDefaultDelayBeforeFade;
                if (scrollCache == null || !scrollCache.fadeScrollBars) {
                    return false;
                }
                if (scrollCache.scrollBar == null) {
                    scrollCache.scrollBar = new ScrollBarDrawable();
                }
                if (this.isHorizontalScrollBarEnabled() || this.isVerticalScrollBarEnabled()) {
                    if (invalidate) {
                        this.postInvalidateOnAnimation();
                    }
                    if (scrollCache.state == ScrollabilityCache.OFF) {
                        const KEY_REPEAT_FIRST_DELAY = 750;
                        startDelay = Math.max(KEY_REPEAT_FIRST_DELAY, startDelay);
                    }
                    let fadeStartTime = AnimationUtils.currentAnimationTimeMillis() + startDelay;
                    scrollCache.fadeStartTime = fadeStartTime;
                    scrollCache.state = ScrollabilityCache.ON;
                    if (this.mAttachInfo != null) {
                        this.mAttachInfo.mHandler.removeCallbacks(scrollCache);
                        this.mAttachInfo.mHandler.postAtTime(scrollCache, fadeStartTime);
                    }
                    return true;
                }
                return false;
            }
            getVerticalFadingEdgeLength() {
                return 0;
            }
            setVerticalFadingEdgeEnabled(enable) {
            }
            setHorizontalFadingEdgeEnabled(enable) {
            }
            setFadingEdgeLength(length) {
            }
            getHorizontalFadingEdgeLength() {
                return 0;
            }
            getVerticalScrollbarWidth() {
                let cache = this.mScrollCache;
                if (cache != null) {
                    let scrollBar = cache.scrollBar;
                    if (scrollBar != null) {
                        let size = scrollBar.getSize(true);
                        if (size <= 0) {
                            size = cache.scrollBarSize;
                        }
                        return size;
                    }
                    return 0;
                }
                return 0;
            }
            getHorizontalScrollbarHeight() {
                let cache = this.mScrollCache;
                if (cache != null) {
                    let scrollBar = cache.scrollBar;
                    if (scrollBar != null) {
                        let size = scrollBar.getSize(false);
                        if (size <= 0) {
                            size = cache.scrollBarSize;
                        }
                        return size;
                    }
                    return 0;
                }
                return 0;
            }
            initializeScrollbars(a) {
                this.initScrollCache();
            }
            initScrollCache() {
                if (this.mScrollCache == null) {
                    this.mScrollCache = new ScrollabilityCache(this);
                }
            }
            getScrollCache() {
                this.initScrollCache();
                return this.mScrollCache;
            }
            isHorizontalScrollBarEnabled() {
                return (this.mViewFlags & View.SCROLLBARS_HORIZONTAL) == View.SCROLLBARS_HORIZONTAL;
            }
            setHorizontalScrollBarEnabled(horizontalScrollBarEnabled) {
                if (this.isHorizontalScrollBarEnabled() != horizontalScrollBarEnabled) {
                    this.mViewFlags ^= View.SCROLLBARS_HORIZONTAL;
                    this.computeOpaqueFlags();
                }
            }
            isVerticalScrollBarEnabled() {
                return (this.mViewFlags & View.SCROLLBARS_VERTICAL) == View.SCROLLBARS_VERTICAL;
            }
            setVerticalScrollBarEnabled(verticalScrollBarEnabled) {
                if (this.isVerticalScrollBarEnabled() != verticalScrollBarEnabled) {
                    this.mViewFlags ^= View.SCROLLBARS_VERTICAL;
                    this.computeOpaqueFlags();
                }
            }
            setScrollbarFadingEnabled(fadeScrollbars) {
                this.initScrollCache();
                const scrollabilityCache = this.mScrollCache;
                scrollabilityCache.fadeScrollBars = fadeScrollbars;
                if (fadeScrollbars) {
                    scrollabilityCache.state = ScrollabilityCache.OFF;
                }
                else {
                    scrollabilityCache.state = ScrollabilityCache.ON;
                }
            }
            setVerticalScrollbarPosition(position) {
            }
            setHorizontalScrollbarPosition(position) {
            }
            setScrollBarStyle(position) {
            }
            getTopFadingEdgeStrength() {
                return 0;
            }
            getBottomFadingEdgeStrength() {
                return 0;
            }
            getLeftFadingEdgeStrength() {
                return 0;
            }
            getRightFadingEdgeStrength() {
                return 0;
            }
            isScrollbarFadingEnabled() {
                return this.mScrollCache != null && this.mScrollCache.fadeScrollBars;
            }
            getScrollBarDefaultDelayBeforeFade() {
                return this.mScrollCache == null ? view_1.ViewConfiguration.getScrollDefaultDelay() :
                    this.mScrollCache.scrollBarDefaultDelayBeforeFade;
            }
            setScrollBarDefaultDelayBeforeFade(scrollBarDefaultDelayBeforeFade) {
                this.getScrollCache().scrollBarDefaultDelayBeforeFade = scrollBarDefaultDelayBeforeFade;
            }
            getScrollBarFadeDuration() {
                return this.mScrollCache == null ? view_1.ViewConfiguration.getScrollBarFadeDuration() :
                    this.mScrollCache.scrollBarFadeDuration;
            }
            setScrollBarFadeDuration(scrollBarFadeDuration) {
                this.getScrollCache().scrollBarFadeDuration = scrollBarFadeDuration;
            }
            getScrollBarSize() {
                return this.mScrollCache == null ? view_1.ViewConfiguration.get().getScaledScrollBarSize() :
                    this.mScrollCache.scrollBarSize;
            }
            setScrollBarSize(scrollBarSize) {
                this.getScrollCache().scrollBarSize = scrollBarSize;
            }
            hasOpaqueScrollbars() {
                return true;
            }
            assignParent(parent) {
                if (this.mParent == null) {
                    this.mParent = parent;
                }
                else if (parent == null) {
                    this.mParent = null;
                }
                else {
                    throw new Error("view " + this + " being added, but"
                        + " it already has a parent");
                }
            }
            onFinishInflate() {
            }
            dispatchStartTemporaryDetach() {
                this.onStartTemporaryDetach();
            }
            onStartTemporaryDetach() {
                this.removeUnsetPressCallback();
                this.mPrivateFlags |= View.PFLAG_CANCEL_NEXT_UP_EVENT;
            }
            dispatchFinishTemporaryDetach() {
                this.onFinishTemporaryDetach();
            }
            onFinishTemporaryDetach() {
            }
            dispatchWindowFocusChanged(hasFocus) {
                this.onWindowFocusChanged(hasFocus);
            }
            onWindowFocusChanged(hasWindowFocus) {
                if (!hasWindowFocus) {
                    if (this.isPressed()) {
                        this.setPressed(false);
                    }
                    this.removeLongPressCallback();
                    this.removeTapCallback();
                    this.onFocusLost();
                }
                this.refreshDrawableState();
            }
            hasWindowFocus() {
                return this.mAttachInfo != null && this.mAttachInfo.mHasWindowFocus;
            }
            getWindowAttachCount() {
                return this.mWindowAttachCount;
            }
            isAttachedToWindow() {
                return this.mAttachInfo != null;
            }
            dispatchAttachedToWindow(info, visibility) {
                this.mAttachInfo = info;
                if (this.mOverlay != null) {
                    this.mOverlay.getOverlayView().dispatchAttachedToWindow(info, visibility);
                }
                this.mWindowAttachCount++;
                this.mPrivateFlags |= View.PFLAG_DRAWABLE_STATE_DIRTY;
                if (this.mFloatingTreeObserver != null) {
                    info.mTreeObserver.merge(this.mFloatingTreeObserver);
                    this.mFloatingTreeObserver = null;
                }
                if ((this.mPrivateFlags & View.PFLAG_SCROLL_CONTAINER) != 0) {
                    this.mAttachInfo.mScrollContainers.add(this);
                    this.mPrivateFlags |= View.PFLAG_SCROLL_CONTAINER_ADDED;
                }
                this.onAttachedToWindow();
                let li = this.mListenerInfo;
                let listeners = li != null ? li.mOnAttachStateChangeListeners : null;
                if (listeners != null && listeners.size() > 0) {
                    for (let listener of listeners) {
                        listener.onViewAttachedToWindow(this);
                    }
                }
                let vis = info.mWindowVisibility;
                if (vis != View.GONE) {
                    this.onWindowVisibilityChanged(vis);
                }
                if ((this.mPrivateFlags & View.PFLAG_DRAWABLE_STATE_DIRTY) != 0) {
                    this.refreshDrawableState();
                }
            }
            onAttachedToWindow() {
                //if ((this.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
                //    this.mParent.requestTransparentRegion(this);
                //}
                if ((this.mPrivateFlags & View.PFLAG_AWAKEN_SCROLL_BARS_ON_ATTACH) != 0) {
                    this.initialAwakenScrollBars();
                    this.mPrivateFlags &= ~View.PFLAG_AWAKEN_SCROLL_BARS_ON_ATTACH;
                }
                this.mPrivateFlags3 &= ~View.PFLAG3_IS_LAID_OUT;
                this.jumpDrawablesToCurrentState();
            }
            dispatchDetachedFromWindow() {
                let info = this.mAttachInfo;
                if (info != null) {
                    let vis = info.mWindowVisibility;
                    if (vis != View.GONE) {
                        this.onWindowVisibilityChanged(View.GONE);
                    }
                }
                this.onDetachedFromWindow();
                let li = this.mListenerInfo;
                let listeners = li != null ? li.mOnAttachStateChangeListeners : null;
                if (listeners != null && listeners.size() > 0) {
                    for (let listener of listeners) {
                        listener.onViewDetachedFromWindow(this);
                    }
                }
                if ((this.mPrivateFlags & View.PFLAG_SCROLL_CONTAINER_ADDED) != 0) {
                    this.mAttachInfo.mScrollContainers.delete(this);
                    this.mPrivateFlags &= ~View.PFLAG_SCROLL_CONTAINER_ADDED;
                }
                this.mAttachInfo = null;
                if (this.mOverlay != null) {
                    this.mOverlay.getOverlayView().dispatchDetachedFromWindow();
                }
            }
            onDetachedFromWindow() {
                this.mPrivateFlags &= ~View.PFLAG_CANCEL_NEXT_UP_EVENT;
                this.mPrivateFlags3 &= ~View.PFLAG3_IS_LAID_OUT;
                this.removeUnsetPressCallback();
                this.removeLongPressCallback();
                this.removePerformClickCallback();
                this.destroyDrawingCache();
                this.cleanupDraw();
            }
            cleanupDraw() {
                if (this.mAttachInfo != null) {
                    this.mAttachInfo.mViewRootImpl.cancelInvalidate(this);
                }
            }
            debug(depth = 0) {
                let originProto = Object.getPrototypeOf(this);
                console.dir(Object.assign(Object.create(originProto), this));
            }
            toString() {
                return this.tagName();
            }
            getRootView() {
                if (this.mAttachInfo != null) {
                    let v = this.mAttachInfo.mRootView;
                    if (v != null) {
                        return v;
                    }
                }
                let parent = this;
                while (parent.mParent != null && parent.mParent instanceof View) {
                    parent = parent.mParent;
                }
                return parent;
            }
            findViewByPredicateTraversal(predicate, childToSkip) {
                if (predicate.apply(this)) {
                    return this;
                }
                return null;
            }
            findViewById(id) {
                if (!id)
                    return null;
                if (id == this.bindElement.id) {
                    return this;
                }
                return this.findViewTraversal(id);
            }
            findViewTraversal(id) {
                let bindEle = this.bindElement.querySelector('#' + id);
                return bindEle ? bindEle[View.AndroidViewProperty] : null;
            }
            findViewByPredicate(predicate) {
                return this.findViewByPredicateTraversal(predicate, null);
            }
            findViewByPredicateInsideOut(start, predicate) {
                let childToSkip = null;
                for (;;) {
                    let view = start.findViewByPredicateTraversal(predicate, childToSkip);
                    if (view != null || start == this) {
                        return view;
                    }
                    let parent = start.getParent();
                    if (parent == null || !(parent instanceof View)) {
                        return null;
                    }
                    childToSkip = start;
                    start = parent;
                }
            }
            setId(id) {
                if (this.bindElement)
                    this.bindElement.id = id;
            }
            getId() {
                return this.mID;
            }
            setIsRootNamespace(isRoot) {
                if (isRoot) {
                    this.mPrivateFlags |= View.PFLAG_IS_ROOT_NAMESPACE;
                }
                else {
                    this.mPrivateFlags &= ~View.PFLAG_IS_ROOT_NAMESPACE;
                }
            }
            isRootNamespace() {
                return (this.mPrivateFlags & View.PFLAG_IS_ROOT_NAMESPACE) != 0;
            }
            getResources() {
                return Resources.from(this);
            }
            static inflate(eleOrRef, rootElement, viewParent) {
                let domtree;
                if (typeof eleOrRef === "string") {
                    let ref = View.findReference(eleOrRef, rootElement);
                    if (ref == null) {
                        console.warn('not find Reference :' + eleOrRef);
                        return null;
                    }
                    domtree = ref.firstElementChild;
                }
                else {
                    domtree = eleOrRef;
                }
                let className = domtree.tagName;
                if (className.startsWith('ANDROID-')) {
                    className = className.substring('ANDROID-'.length);
                }
                if (className === 'LAYOUT') {
                    let child = domtree.firstElementChild;
                    if (child)
                        return View.inflate(child, rootElement, viewParent);
                    return null;
                }
                else if (className === 'INCLUDE') {
                    let refLayoutId = domtree.getAttribute('layout');
                    let view = View.inflate(refLayoutId, rootElement, viewParent);
                    if (view) {
                        for (let attr of Array.from(domtree.attributes)) {
                            let name = attr.name;
                            if (name === 'layout')
                                continue;
                            view.bindElement.setAttribute(name, attr.value);
                        }
                    }
                    return view;
                }
                else if (className === 'MERGE') {
                    if (!viewParent)
                        throw Error('merge tag need ViewParent');
                    Array.from(domtree.children).forEach((item) => {
                        if (item instanceof HTMLElement) {
                            let view = View.inflate(item, rootElement, viewParent);
                            if (view instanceof View)
                                viewParent.addView(view);
                        }
                    });
                    return viewParent;
                }
                let rootViewClass = ClassFinder.findClass(className, android.view);
                if (!rootViewClass)
                    rootViewClass = ClassFinder.findClass(className, android['widget']);
                if (!rootViewClass)
                    rootViewClass = ClassFinder.findClass(className);
                if (!rootViewClass) {
                    if (document.createElement(className) instanceof HTMLUnknownElement) {
                        console.warn('inflate: not find class ' + className);
                    }
                    return null;
                }
                let children = Array.from(domtree.children);
                let rootView = new rootViewClass(domtree, rootElement);
                if (rootView['onInflateAdapter']) {
                    rootView.onInflateAdapter(domtree, rootElement, viewParent);
                    domtree.parentNode.removeChild(domtree);
                }
                if (!(rootView instanceof View))
                    return rootView;
                let params;
                if (viewParent)
                    params = viewParent.generateDefaultLayoutParams();
                else {
                    params = new view_1.ViewGroup.LayoutParams(view_1.ViewGroup.LayoutParams.WRAP_CONTENT, view_1.ViewGroup.LayoutParams.WRAP_CONTENT);
                }
                params.parseAttributeFrom(domtree, rootElement);
                rootView.setLayoutParams(params);
                rootView._fireInitedAttributeChange();
                if (rootView instanceof view_1.ViewGroup) {
                    let parent = rootView;
                    children.forEach((item) => {
                        if (item instanceof HTMLElement) {
                            let view = View.inflate(item, rootElement, parent);
                            if (view instanceof View && view !== parent)
                                parent.addView(view);
                        }
                    });
                }
                rootView.onFinishInflate();
                return rootView;
            }
            static optReferenceString(refString, currentElement = document, rootElement = document) {
                return View.findReferenceString(refString, currentElement, rootElement) || refString;
            }
            static findReferenceString(refString, currentElement = document, rootElement = document) {
                if (!refString.startsWith('@'))
                    return null;
                let referenceArray = [];
                let attrValue = refString;
                while (attrValue && attrValue.startsWith('@')) {
                    let reference = View.findReference(attrValue, currentElement, rootElement, false);
                    if (referenceArray.indexOf(reference) >= 0)
                        throw Error('findReference Error: circle reference');
                    referenceArray.push(reference);
                    attrValue = reference.innerText;
                }
                return attrValue;
            }
            static findReference(refString, currentElement = document, rootElement = document, cloneNode = true) {
                if (refString && refString.startsWith('@')) {
                    let [tagName, ...refIds] = refString.split('/');
                    tagName = tagName.substring(1);
                    if (!refIds || refIds.length === 0)
                        return null;
                    if (!tagName.startsWith('android-'))
                        tagName = 'android-' + tagName;
                    let q = 'resources ' + tagName + '#' + refIds.join(' #');
                    let el = currentElement.querySelector(q) || rootElement.querySelector(q) || document.querySelector(q);
                    return cloneNode ? el.cloneNode(true) : el;
                }
                return null;
            }
            get rootElement() {
                if (this._rootElement)
                    return this._rootElement;
                if (this.getViewRootImpl())
                    return this.getViewRootImpl().rootElement;
                return null;
            }
            _AttrObserverCallBack(arr, observer) {
                arr.forEach((record) => {
                    let target = record.target;
                    let androidView = target[View.AndroidViewProperty];
                    if (!androidView)
                        return;
                    let attrName = record.attributeName;
                    let newValue = target.getAttribute(attrName);
                    let oldValue = record.oldValue;
                    if (newValue === oldValue)
                        return;
                    androidView.onBindElementAttributeChanged(attrName, record.oldValue, newValue);
                });
            }
            initBindElement(bindElement, rootElement) {
                if (this.bindElement) {
                    this.bindElement[View.AndroidViewProperty] = null;
                }
                this.bindElement = bindElement || document.createElement(this.tagName());
                this.bindElement.style.position = 'absolute';
                let oldBindView = this.bindElement[View.AndroidViewProperty];
                if (oldBindView) {
                    if (oldBindView._AttrObserver)
                        oldBindView._AttrObserver.disconnect();
                }
                this.bindElement[View.AndroidViewProperty] = this;
                this._rootElement = rootElement;
                this._stateAttrList = new StateAttrList(this.bindElement, rootElement);
                this._parseInitedAttribute();
                this._initAttrObserver();
            }
            syncBoundToElement() {
                if (!this._syncToElementLock) {
                    this._syncToElementLock = true;
                    setTimeout(this.syncToElementFunc, 300);
                }
            }
            syncScrollToElement() {
                if (!this._syncToElementLock) {
                    this._syncToElementLock = true;
                    setTimeout(this.syncToElementFunc, 300);
                }
            }
            _syncBoundToElement() {
                let change = false;
                const left = this.mLeft;
                const top = this.mTop;
                const width = this.getWidth();
                const height = this.getHeight();
                if (left !== this._lastSyncLeft || top !== this._lastSyncTop
                    || width !== this._lastSyncWidth || height !== this._lastSyncHeight) {
                    this._lastSyncLeft = left;
                    this._lastSyncTop = top;
                    this._lastSyncWidth = width;
                    this._lastSyncHeight = height;
                    let bind = this.bindElement;
                    bind.style.transform = bind.style.webkitTransform = `translate(${left}px, ${top}px)`;
                    bind.style.width = width + 'px';
                    bind.style.height = height + 'px';
                    change = true;
                }
                return change;
            }
            _syncScrollToElement() {
                let change = false;
                let sx = this.mScrollX;
                let sy = this.mScrollY;
                if (this._lastSyncScrollX !== sx || this._lastSyncScrollY !== sy) {
                    this._lastSyncScrollX = sx;
                    this._lastSyncScrollY = sy;
                    if (this instanceof view_1.ViewGroup) {
                        let group = this;
                        for (let i = 0, count = group.getChildCount(); i < count; i++) {
                            let child = group.getChildAt(i);
                            let item = child.bindElement;
                            item.style.transform = item.style.webkitTransform = `translate(${child.mLeft - sx}px, ${child.mTop - sy}px)`;
                        }
                    }
                    change = true;
                }
                return change;
            }
            syncVisibleToElement() {
                let visibility = this.getVisibility();
                if (visibility === View.VISIBLE) {
                    this.bindElement.style.display = '';
                    this.bindElement.style.visibility = '';
                }
                else if (visibility === View.INVISIBLE) {
                    this.bindElement.style.display = '';
                    this.bindElement.style.visibility = 'hidden';
                }
                else {
                    this.bindElement.style.display = 'none';
                    this.bindElement.style.visibility = '';
                }
            }
            syncDrawStateToElement() {
                const bind = this.bindElement;
                if (this.isPressed())
                    bind.classList.add('_pressed');
                else
                    bind.classList.remove('_pressed');
                if (this.isEnabled())
                    bind.classList.remove('_disabled');
                else
                    bind.classList.add('_disabled');
                if (this.isFocused())
                    bind.classList.add('_focused');
                else
                    bind.classList.remove('_focused');
                if (this.isSelected())
                    bind.classList.add('_selected');
                else
                    bind.classList.remove('_selected');
                if (this.isActivated())
                    bind.classList.add('_activated');
                else
                    bind.classList.remove('_activated');
            }
            _initAttrObserver() {
                if (!this._AttrObserver)
                    this._AttrObserver = new MutationObserver(this._AttrObserverCallBack);
                else
                    this._AttrObserver.disconnect();
                this._AttrObserver.observe(this.bindElement, { attributes: true, attributeOldValue: true });
            }
            _parseInitedAttribute() {
                for (let [key, value] of this._stateAttrList.getDefaultStateAttr().getAttrMap().entries()) {
                    key = 'android:' + key;
                    if ((value === null || value === undefined) && this.bindElement.hasAttribute(key)) {
                        this.bindElement.removeAttribute(key);
                    }
                    else {
                        this.bindElement.setAttribute(key, value);
                    }
                }
                let id = this.bindElement.getAttribute('android:id');
                if (id)
                    this.bindElement.id = id;
            }
            _fireInitedAttributeChange() {
                for (let attr of Array.from(this.bindElement.attributes)) {
                    this.onBindElementAttributeChanged(attr.name, null, attr.value);
                }
            }
            _fireStateChangeToAttribute(oldState, newState) {
                if (!this._stateAttrList)
                    return;
                if (oldState + '' === newState + '')
                    return;
                let oldMatchedAttr = oldState ? this._stateAttrList.getMatchedAttr(oldState) : null;
                let matchedAttr = this._stateAttrList.getMatchedAttr(newState);
                let attrMap = matchedAttr.mergeRemovedFrom(oldMatchedAttr);
                for (let [key, value] of attrMap.entries()) {
                    if (oldMatchedAttr) {
                        let oldValue;
                        if (key.startsWith('layout_')) {
                            let params = this.getLayoutParams();
                            if (params) {
                                let attrName = key.substring('layout_'.length);
                                oldValue = params._attrBinder.getAttrValue(attrName);
                            }
                        }
                        else {
                            oldValue = this._attrBinder.getAttrValue(key);
                        }
                        if (oldValue != null) {
                            oldMatchedAttr.setAttr(key, oldValue);
                        }
                    }
                    key = 'android:' + key;
                    if ((value === null || value === undefined)) {
                        if (this.bindElement.hasAttribute(key)) {
                            this.bindElement.removeAttribute(key);
                        }
                        else {
                            this.onBindElementAttributeChanged(key, null, null);
                        }
                    }
                    else {
                        this.bindElement.setAttribute(key, value);
                    }
                }
            }
            onBindElementAttributeChanged(attributeName, oldVal, newVal) {
                let parts = attributeName.split(":");
                let attrName = parts[parts.length - 1].toLowerCase();
                if (newVal === 'true')
                    newVal = true;
                else if (newVal === 'false')
                    newVal = false;
                if (attrName.startsWith('layout_')) {
                    attrName = attrName.substring('layout_'.length);
                    let params = this.getLayoutParams();
                    if (params) {
                        params._attrBinder.onAttrChange(attrName, newVal, this.rootElement);
                    }
                    this.requestLayout();
                    return;
                }
                this._attrBinder.onAttrChange(attrName, newVal, this.rootElement);
            }
            hasAttributeIgnoreCase(name) {
                return this.getAttributeIgnoreCase(name) != null;
            }
            getAttributeIgnoreCase(name) {
                if (!(typeof name === 'string'))
                    return null;
                name = name.toLowerCase();
                if (name.startsWith('android:'))
                    name = name.substring('android:'.length);
                for (let attr of Array.from(this.bindElement.attributes)) {
                    let attrName = attr.name.toLowerCase();
                    if (attrName.startsWith('android:'))
                        attrName = attrName.substring('android:'.length);
                    if (attrName == name)
                        return attr.value;
                }
                return null;
            }
            applyDefaultAttributes(attrs) {
                for (let key in attrs) {
                    if (!this.hasAttributeIgnoreCase(key)) {
                        this._attrBinder.onAttrChange(key, attrs[key], this.rootElement);
                    }
                }
            }
            tagName() {
                return "ANDROID-" + this.constructor.name;
            }
        }
        View.DBG = Log.View_DBG;
        View.VIEW_LOG_TAG = "View";
        View.PFLAG_WANTS_FOCUS = 0x00000001;
        View.PFLAG_FOCUSED = 0x00000002;
        View.PFLAG_SELECTED = 0x00000004;
        View.PFLAG_IS_ROOT_NAMESPACE = 0x00000008;
        View.PFLAG_HAS_BOUNDS = 0x00000010;
        View.PFLAG_DRAWN = 0x00000020;
        View.PFLAG_DRAW_ANIMATION = 0x00000040;
        View.PFLAG_SKIP_DRAW = 0x00000080;
        View.PFLAG_ONLY_DRAWS_BACKGROUND = 0x00000100;
        View.PFLAG_REQUEST_TRANSPARENT_REGIONS = 0x00000200;
        View.PFLAG_DRAWABLE_STATE_DIRTY = 0x00000400;
        View.PFLAG_MEASURED_DIMENSION_SET = 0x00000800;
        View.PFLAG_FORCE_LAYOUT = 0x00001000;
        View.PFLAG_LAYOUT_REQUIRED = 0x00002000;
        View.PFLAG_PRESSED = 0x00004000;
        View.PFLAG_DRAWING_CACHE_VALID = 0x00008000;
        View.PFLAG_ANIMATION_STARTED = 0x00010000;
        View.PFLAG_ALPHA_SET = 0x00040000;
        View.PFLAG_SCROLL_CONTAINER = 0x00080000;
        View.PFLAG_SCROLL_CONTAINER_ADDED = 0x00100000;
        View.PFLAG_DIRTY = 0x00200000;
        View.PFLAG_DIRTY_OPAQUE = 0x00400000;
        View.PFLAG_DIRTY_MASK = 0x00600000;
        View.PFLAG_OPAQUE_BACKGROUND = 0x00800000;
        View.PFLAG_OPAQUE_SCROLLBARS = 0x01000000;
        View.PFLAG_OPAQUE_MASK = 0x01800000;
        View.PFLAG_PREPRESSED = 0x02000000;
        View.PFLAG_CANCEL_NEXT_UP_EVENT = 0x04000000;
        View.PFLAG_AWAKEN_SCROLL_BARS_ON_ATTACH = 0x08000000;
        View.PFLAG_HOVERED = 0x10000000;
        View.PFLAG_PIVOT_EXPLICITLY_SET = 0x20000000;
        View.PFLAG_ACTIVATED = 0x40000000;
        View.PFLAG_INVALIDATED = 0x80000000;
        View.PFLAG2_VIEW_QUICK_REJECTED = 0x10000000;
        View.PFLAG2_HAS_TRANSIENT_STATE = 0x80000000;
        View.PFLAG3_VIEW_IS_ANIMATING_TRANSFORM = 0x1;
        View.PFLAG3_VIEW_IS_ANIMATING_ALPHA = 0x2;
        View.PFLAG3_IS_LAID_OUT = 0x4;
        View.PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT = 0x8;
        View.PFLAG3_CALLED_SUPER = 0x10;
        View.NOT_FOCUSABLE = 0x00000000;
        View.FOCUSABLE = 0x00000001;
        View.FOCUSABLE_MASK = 0x00000001;
        View.OVER_SCROLL_ALWAYS = 0;
        View.OVER_SCROLL_IF_CONTENT_SCROLLS = 1;
        View.OVER_SCROLL_NEVER = 2;
        View.MEASURED_SIZE_MASK = 0x00ffffff;
        View.MEASURED_STATE_MASK = 0xff000000;
        View.MEASURED_HEIGHT_STATE_SHIFT = 16;
        View.MEASURED_STATE_TOO_SMALL = 0x01000000;
        View.VISIBILITY_MASK = 0x0000000C;
        View.VISIBLE = 0x00000000;
        View.INVISIBLE = 0x00000004;
        View.GONE = 0x00000008;
        View.ENABLED = 0x00000000;
        View.DISABLED = 0x00000020;
        View.ENABLED_MASK = 0x00000020;
        View.WILL_NOT_DRAW = 0x00000080;
        View.DRAW_MASK = 0x00000080;
        View.SCROLLBARS_NONE = 0x00000000;
        View.SCROLLBARS_HORIZONTAL = 0x00000100;
        View.SCROLLBARS_VERTICAL = 0x00000200;
        View.SCROLLBARS_MASK = 0x00000300;
        View.FOCUSABLES_ALL = 0x00000000;
        View.FOCUSABLES_TOUCH_MODE = 0x00000001;
        View.FOCUS_BACKWARD = 0x00000001;
        View.FOCUS_FORWARD = 0x00000002;
        View.FOCUS_LEFT = 0x00000011;
        View.FOCUS_UP = 0x00000021;
        View.FOCUS_RIGHT = 0x00000042;
        View.FOCUS_DOWN = 0x00000082;
        View.VIEW_STATE_WINDOW_FOCUSED = 1;
        View.VIEW_STATE_SELECTED = 1 << 1;
        View.VIEW_STATE_FOCUSED = 1 << 2;
        View.VIEW_STATE_ENABLED = 1 << 3;
        View.VIEW_STATE_DISABLE = -View.VIEW_STATE_ENABLED;
        View.VIEW_STATE_PRESSED = 1 << 4;
        View.VIEW_STATE_ACTIVATED = 1 << 5;
        View.VIEW_STATE_HOVERED = 1 << 7;
        View.VIEW_STATE_IDS = [
            View.VIEW_STATE_WINDOW_FOCUSED, View.VIEW_STATE_WINDOW_FOCUSED,
            View.VIEW_STATE_SELECTED, View.VIEW_STATE_SELECTED,
            View.VIEW_STATE_FOCUSED, View.VIEW_STATE_FOCUSED,
            View.VIEW_STATE_ENABLED, View.VIEW_STATE_ENABLED,
            View.VIEW_STATE_PRESSED, View.VIEW_STATE_PRESSED,
            View.VIEW_STATE_ACTIVATED, View.VIEW_STATE_ACTIVATED,
            View.VIEW_STATE_HOVERED, View.VIEW_STATE_HOVERED,
        ];
        View._static = (() => {
            function Integer_bitCount(i) {
                i = i - ((i >>> 1) & 0x55555555);
                i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);
                i = (i + (i >>> 4)) & 0x0f0f0f0f;
                i = i + (i >>> 8);
                i = i + (i >>> 16);
                return i & 0x3f;
            }
            let orderedIds = View.VIEW_STATE_IDS;
            const NUM_BITS = View.VIEW_STATE_IDS.length / 2;
            View.VIEW_STATE_SETS = new Array(1 << NUM_BITS);
            for (let i = 0; i < View.VIEW_STATE_SETS.length; i++) {
                let numBits = Integer_bitCount(i);
                const stataSet = new Array(numBits);
                let pos = 0;
                for (let j = 0; j < orderedIds.length; j += 2) {
                    if ((i & orderedIds[j + 1]) != 0) {
                        stataSet[pos++] = orderedIds[j];
                    }
                }
                View.VIEW_STATE_SETS[i] = stataSet;
            }
            View.EMPTY_STATE_SET = View.VIEW_STATE_SETS[0];
            View.WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED];
            View.SELECTED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_SELECTED];
            View.SELECTED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_SELECTED];
            View.FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_FOCUSED];
            View.FOCUSED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_FOCUSED];
            View.FOCUSED_SELECTED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_SELECTED | View.VIEW_STATE_FOCUSED];
            View.FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_SELECTED | View.VIEW_STATE_FOCUSED];
            View.ENABLED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_ENABLED];
            View.ENABLED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_ENABLED];
            View.ENABLED_SELECTED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_SELECTED | View.VIEW_STATE_ENABLED];
            View.ENABLED_SELECTED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_SELECTED | View.VIEW_STATE_ENABLED];
            View.ENABLED_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_FOCUSED | View.VIEW_STATE_ENABLED];
            View.ENABLED_FOCUSED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_FOCUSED | View.VIEW_STATE_ENABLED];
            View.ENABLED_FOCUSED_SELECTED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_SELECTED | View.VIEW_STATE_FOCUSED | View.VIEW_STATE_ENABLED];
            View.ENABLED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_SELECTED | View.VIEW_STATE_FOCUSED | View.VIEW_STATE_ENABLED];
            View.PRESSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_PRESSED];
            View.PRESSED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_PRESSED];
            View.PRESSED_SELECTED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_SELECTED | View.VIEW_STATE_PRESSED];
            View.PRESSED_SELECTED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_SELECTED | View.VIEW_STATE_PRESSED];
            View.PRESSED_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_FOCUSED | View.VIEW_STATE_PRESSED];
            View.PRESSED_FOCUSED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_FOCUSED | View.VIEW_STATE_PRESSED];
            View.PRESSED_FOCUSED_SELECTED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_SELECTED | View.VIEW_STATE_FOCUSED | View.VIEW_STATE_PRESSED];
            View.PRESSED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_SELECTED | View.VIEW_STATE_FOCUSED | View.VIEW_STATE_PRESSED];
            View.PRESSED_ENABLED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_ENABLED | View.VIEW_STATE_PRESSED];
            View.PRESSED_ENABLED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_ENABLED | View.VIEW_STATE_PRESSED];
            View.PRESSED_ENABLED_SELECTED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_SELECTED | View.VIEW_STATE_ENABLED | View.VIEW_STATE_PRESSED];
            View.PRESSED_ENABLED_SELECTED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_SELECTED | View.VIEW_STATE_ENABLED | View.VIEW_STATE_PRESSED];
            View.PRESSED_ENABLED_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_FOCUSED | View.VIEW_STATE_ENABLED | View.VIEW_STATE_PRESSED];
            View.PRESSED_ENABLED_FOCUSED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_FOCUSED | View.VIEW_STATE_ENABLED | View.VIEW_STATE_PRESSED];
            View.PRESSED_ENABLED_FOCUSED_SELECTED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_SELECTED | View.VIEW_STATE_FOCUSED | View.VIEW_STATE_ENABLED | View.VIEW_STATE_PRESSED];
            View.PRESSED_ENABLED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_SELECTED | View.VIEW_STATE_FOCUSED | View.VIEW_STATE_ENABLED | View.VIEW_STATE_PRESSED];
        })();
        View.CLICKABLE = 0x00004000;
        View.DRAWING_CACHE_ENABLED = 0x00008000;
        View.WILL_NOT_CACHE_DRAWING = 0x000020000;
        View.FOCUSABLE_IN_TOUCH_MODE = 0x00040000;
        View.LONG_CLICKABLE = 0x00200000;
        View.DUPLICATE_PARENT_STATE = 0x00400000;
        View.LAYER_TYPE_NONE = 0;
        View.LAYER_TYPE_SOFTWARE = 1;
        View.AndroidViewProperty = 'AndroidView';
        view_1.View = View;
        (function (View) {
            class MeasureSpec {
                static makeMeasureSpec(size, mode) {
                    return (size & ~MeasureSpec.MODE_MASK) | (mode & MeasureSpec.MODE_MASK);
                }
                static getMode(measureSpec) {
                    return (measureSpec & MeasureSpec.MODE_MASK);
                }
                static getSize(measureSpec) {
                    return (measureSpec & ~MeasureSpec.MODE_MASK);
                }
                static adjust(measureSpec, delta) {
                    return MeasureSpec.makeMeasureSpec(MeasureSpec.getSize(measureSpec + delta), MeasureSpec.getMode(measureSpec));
                }
                static toString(measureSpec) {
                    let mode = MeasureSpec.getMode(measureSpec);
                    let size = MeasureSpec.getSize(measureSpec);
                    let sb = new StringBuilder("MeasureSpec: ");
                    if (mode == MeasureSpec.UNSPECIFIED)
                        sb.append("UNSPECIFIED ");
                    else if (mode == MeasureSpec.EXACTLY)
                        sb.append("EXACTLY ");
                    else if (mode == MeasureSpec.AT_MOST)
                        sb.append("AT_MOST ");
                    else
                        sb.append(mode).append(" ");
                    sb.append(size);
                    return sb.toString();
                }
            }
            MeasureSpec.MODE_SHIFT = 30;
            MeasureSpec.MODE_MASK = 0x3 << MeasureSpec.MODE_SHIFT;
            MeasureSpec.UNSPECIFIED = 0 << MeasureSpec.MODE_SHIFT;
            MeasureSpec.EXACTLY = 1 << MeasureSpec.MODE_SHIFT;
            MeasureSpec.AT_MOST = 2 << MeasureSpec.MODE_SHIFT;
            View.MeasureSpec = MeasureSpec;
            class AttachInfo {
                constructor(mViewRootImpl, mHandler) {
                    this.mWindowLeft = 0;
                    this.mWindowTop = 0;
                    this.mKeyDispatchState = new KeyEvent.DispatcherState();
                    this.mDrawingTime = 0;
                    this.mTmpInvalRect = new Rect();
                    this.mTmpTransformRect = new Rect();
                    this.mScrollContainers = new Set();
                    this.mViewScrollChanged = false;
                    this.mTreeObserver = new view_1.ViewTreeObserver();
                    this.mViewVisibilityChanged = false;
                    this.mInvalidateChildLocation = new Array(2);
                    this.mIgnoreDirtyState = false;
                    this.mSetIgnoreDirtyState = false;
                    this.mHasWindowFocus = false;
                    this.mWindowVisibility = 0;
                    this.mInTouchMode = false;
                    this.mViewRootImpl = mViewRootImpl;
                    this.mHandler = mHandler;
                }
            }
            View.AttachInfo = AttachInfo;
            class ListenerInfo {
            }
            View.ListenerInfo = ListenerInfo;
        })(View = view_1.View || (view_1.View = {}));
        (function (View) {
            var AttachInfo;
            (function (AttachInfo) {
                class InvalidateInfo {
                    constructor() {
                        this.left = 0;
                        this.top = 0;
                        this.right = 0;
                        this.bottom = 0;
                    }
                    static obtain() {
                        let instance = InvalidateInfo.sPool.acquire();
                        return (instance != null) ? instance : new InvalidateInfo();
                    }
                    recycle() {
                        this.target = null;
                        InvalidateInfo.sPool.release(this);
                    }
                }
                InvalidateInfo.POOL_LIMIT = 10;
                InvalidateInfo.sPool = new Pools.SynchronizedPool(InvalidateInfo.POOL_LIMIT);
                AttachInfo.InvalidateInfo = InvalidateInfo;
            })(AttachInfo = View.AttachInfo || (View.AttachInfo = {}));
        })(View = view_1.View || (view_1.View = {}));
        class CheckForLongPress {
            constructor(View_this) {
                this.mOriginalWindowAttachCount = 0;
                this.View_this = View_this;
            }
            run() {
                if (this.View_this.isPressed() && (this.View_this.mParent != null)
                    && this.mOriginalWindowAttachCount == this.View_this.mWindowAttachCount) {
                    if (this.View_this.performLongClick()) {
                        this.View_this.mHasPerformedLongPress = true;
                    }
                }
            }
            rememberWindowAttachCount() {
                this.mOriginalWindowAttachCount = this.View_this.mWindowAttachCount;
            }
        }
        class CheckForTap {
            constructor(View_this) {
                this.View_this = View_this;
            }
            run() {
                this.View_this.mPrivateFlags &= ~View.PFLAG_PREPRESSED;
                this.View_this.setPressed(true);
                this.View_this.checkForLongClick(view_1.ViewConfiguration.getTapTimeout());
            }
        }
        class PerformClick {
            constructor(View_this) {
                this.View_this = View_this;
            }
            run() {
                this.View_this.performClick();
            }
        }
        class UnsetPressedState {
            constructor(View_this) {
                this.View_this = View_this;
            }
            run() {
                this.View_this.setPressed(false);
            }
        }
        class ScrollabilityCache {
            constructor(host) {
                this.fadeScrollBars = true;
                this.fadingEdgeLength = view_1.ViewConfiguration.get().getScaledFadingEdgeLength();
                this.scrollBarDefaultDelayBeforeFade = view_1.ViewConfiguration.getScrollDefaultDelay();
                this.scrollBarFadeDuration = view_1.ViewConfiguration.getScrollBarFadeDuration();
                this.scrollBarSize = view_1.ViewConfiguration.get().getScaledScrollBarSize();
                this.interpolator = new LinearInterpolator();
                this.state = ScrollabilityCache.OFF;
                this.host = host;
                this.scrollBar = new ScrollBarDrawable();
                let thumbColor = new ColorDrawable(0x44000000);
                let density = Resources.getDisplayMetrics().density;
                let thumb = new InsetDrawable(thumbColor, 0, 2 * density, view_1.ViewConfiguration.get().getScaledScrollBarSize() / 2, 2 * density);
                this.scrollBar.setHorizontalThumbDrawable(thumb);
                this.scrollBar.setVerticalThumbDrawable(thumb);
            }
            run() {
                let now = AnimationUtils.currentAnimationTimeMillis();
                if (now >= this.fadeStartTime) {
                    this.state = ScrollabilityCache.FADING;
                    this.host.invalidate(true);
                }
            }
            _computeAlphaToScrollBar() {
                let now = AnimationUtils.currentAnimationTimeMillis();
                let factor = (now - this.fadeStartTime) / this.scrollBarFadeDuration;
                if (factor >= 1) {
                    this.state = ScrollabilityCache.OFF;
                    factor = 1;
                }
                let alpha = 1 - this.interpolator.getInterpolation(factor);
                this.scrollBar.setAlpha(255 * alpha);
            }
        }
        ScrollabilityCache.OFF = 0;
        ScrollabilityCache.ON = 1;
        ScrollabilityCache.FADING = 2;
        class MatchIdPredicate {
            apply(view) {
                return view.mID === this.mId;
            }
        }
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        class Point {
            constructor(...args) {
                this.x = 0;
                this.y = 0;
                if (args.length === 1) {
                    let src = args[0];
                    this.x = src.x;
                    this.y = src.y;
                }
                else {
                    let [x = 0, y = 0] = args;
                    this.x = x;
                    this.y = y;
                }
            }
            set(x, y) {
                this.x = x;
                this.y = y;
            }
            negate() {
                this.x = -this.x;
                this.y = -this.y;
            }
            offset(dx, dy) {
                this.x += dx;
                this.y += dy;
            }
            equals(...args) {
                if (args.length === 2) {
                    let [x = 0, y = 0] = args;
                    return this.x == x && this.y == y;
                }
                else {
                    let o = args[0];
                    if (this === o)
                        return true;
                    if (!o || !(o instanceof Point))
                        return false;
                    let point = o;
                    if (this.x != point.x)
                        return false;
                    if (this.y != point.y)
                        return false;
                    return true;
                }
            }
            toString() {
                return "Point(" + this.x + ", " + this.y + ")";
            }
        }
        graphics.Point = Point;
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/5.
 */
///<reference path="View.ts"/>
///<reference path="../graphics/Point.ts"/>
///<reference path="../graphics/Rect.ts"/>
/**
 * Created by linfaxin on 15/10/13.
 */
///<reference path="../graphics/Rect.ts"/>
///<reference path="../graphics/Canvas.ts"/>
///<reference path="../graphics/Canvas.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var Rect = android.graphics.Rect;
        var Canvas = android.graphics.Canvas;
        class Surface {
            constructor(canvasElement) {
                this.mLockedRect = new Rect();
                this.mCanvasElement = canvasElement;
            }
            lockCanvas(dirty) {
                let fullWidth = this.mCanvasElement.width;
                let fullHeight = this.mCanvasElement.height;
                let rect = this.mLockedRect;
                if (dirty.isEmpty()) {
                    rect.set(0, 0, fullWidth, fullHeight);
                }
                else {
                    rect.set(Math.floor(dirty.left - 1), Math.floor(dirty.top - 1), Math.ceil(dirty.right + 1), Math.ceil(dirty.bottom + 1));
                }
                let width = rect.width();
                let height = rect.height();
                let canvas = new Canvas(width, height);
                canvas.translate(-rect.left, -rect.top);
                let mCanvasContent = this.mCanvasElement.getContext('2d');
                mCanvasContent.clearRect(rect.left, rect.top, width, height);
                return canvas;
            }
            unlockCanvasAndPost(canvas) {
                let mCanvasContent = this.mCanvasElement.getContext('2d');
                if (canvas.canvasElement)
                    mCanvasContent.drawImage(canvas.canvasElement, this.mLockedRect.left, this.mLockedRect.top);
                canvas.recycle();
            }
        }
        view.Surface = Surface;
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
///<reference path="ViewParent.ts"/>
///<reference path="View.ts"/>
///<reference path="Surface.ts"/>
///<reference path="../util/Log.ts"/>
///<reference path="../util/Log.ts"/>
///<reference path="../os/Handler.ts"/>
///<reference path="../os/Message.ts"/>
///<reference path="../os/SystemClock.ts"/>
///<reference path="../content/res/Resources.ts"/>
///<reference path="../graphics/Point.ts"/>
///<reference path="../graphics/Rect.ts"/>
///<reference path="../graphics/Canvas.ts"/>
///<reference path="../../java/lang/Runnable.ts"/>
///<reference path="../../java/lang/System.ts"/>
var android;
(function (android) {
    var view;
    (function (view_2) {
        var View = android.view.View;
        var Resources = android.content.res.Resources;
        var Rect = android.graphics.Rect;
        var Handler = android.os.Handler;
        var SystemClock = android.os.SystemClock;
        var System = java.lang.System;
        var Log = android.util.Log;
        var Surface = android.view.Surface;
        class ViewRootImpl {
            constructor() {
                this.mViewVisibility = View.GONE;
                this.mStopped = false;
                this.mWidth = -1;
                this.mHeight = -1;
                this.mDirty = new Rect();
                this.mTempRect = new Rect();
                this.mVisRect = new Rect();
                this.mTraversalScheduled = false;
                this.mWillDrawSoon = false;
                this.mIsInTraversal = false;
                this.mLayoutRequested = false;
                this.mFirst = true;
                this.mFullRedrawNeeded = false;
                this.mIsDrawing = false;
                this.mAdded = false;
                this.mAddedTouchMode = false;
                this.mWinFrame = new Rect();
                this.mLayoutRequesters = [];
                this.mHandler = new ViewRootHandler();
                this.mFpsStartTime = -1;
                this.mFpsPrevTime = -1;
                this.mFpsNumFrames = 0;
                this.mInvalidateOnAnimationRunnable = new InvalidateOnAnimationRunnable(this.mHandler);
                this.mAttachInfo = new View.AttachInfo(this, this.mHandler);
                this.mTraversalRunnable = new TraversalRunnable(this);
            }
            initSurface(canvasElement) {
                this.mSurface = new Surface(canvasElement);
            }
            setView(view) {
                if (this.mView == null) {
                    this.mView = view;
                    this.mAttachInfo.mRootView = view;
                    this.mAdded = true;
                    this.requestLayout();
                    view.assignParent(this);
                    this.mAddedTouchMode = true;
                    let syntheticInputStage = new SyntheticInputStage(this);
                    let viewPostImeStage = new ViewPostImeInputStage(this, syntheticInputStage);
                    let earlyPostImeStage = new EarlyPostImeInputStage(this, viewPostImeStage);
                    this.mFirstInputStage = earlyPostImeStage;
                }
            }
            getView() {
                return this.mView;
            }
            getHostVisibility() {
                return this.mView.getVisibility();
            }
            scheduleTraversals() {
                if (!this.mTraversalScheduled) {
                    this.mTraversalScheduled = true;
                    this.mHandler.post(this.mTraversalRunnable);
                }
            }
            unscheduleTraversals() {
                if (this.mTraversalScheduled) {
                    this.mTraversalScheduled = false;
                    this.mHandler.removeCallbacks(this.mTraversalRunnable);
                }
            }
            doTraversal() {
                if (this.mTraversalScheduled) {
                    this.mTraversalScheduled = false;
                    this.performTraversals();
                }
            }
            measureHierarchy(host, lp, desiredWindowWidth, desiredWindowHeight) {
                let windowSizeMayChange = false;
                if (ViewRootImpl.DEBUG_ORIENTATION || ViewRootImpl.DEBUG_LAYOUT)
                    Log.v(ViewRootImpl.TAG, "Measuring " + host + " in display " + desiredWindowWidth
                        + "x" + desiredWindowHeight + "...");
                let childWidthMeasureSpec = ViewRootImpl.getRootMeasureSpec(desiredWindowWidth, lp.width);
                let childHeightMeasureSpec = ViewRootImpl.getRootMeasureSpec(desiredWindowHeight, lp.height);
                this.performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
                if (this.mWidth != host.getMeasuredWidth() || this.mHeight != host.getMeasuredHeight()) {
                    windowSizeMayChange = true;
                }
                if (ViewRootImpl.DBG) {
                    System.out.println("======================================");
                    System.out.println("performTraversals -- after measure");
                    host.debug();
                }
                return windowSizeMayChange;
            }
            static getRootMeasureSpec(windowSize, rootDimension) {
                let MeasureSpec = View.MeasureSpec;
                let measureSpec;
                switch (rootDimension) {
                    case view_2.ViewGroup.LayoutParams.MATCH_PARENT:
                        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);
                        break;
                    case view_2.ViewGroup.LayoutParams.WRAP_CONTENT:
                        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);
                        break;
                    default:
                        measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);
                        break;
                }
                return measureSpec;
            }
            performTraversals() {
                let host = this.mView;
                if (ViewRootImpl.DBG) {
                    System.out.println("======================================");
                    System.out.println("performTraversals");
                    host.debug();
                }
                if (host == null || !this.mAdded)
                    return;
                this.mIsInTraversal = true;
                this.mWillDrawSoon = true;
                let windowSizeMayChange = false;
                let newSurface = false;
                let surfaceChanged = false;
                let lp = new view_2.ViewGroup.LayoutParams(view_2.ViewGroup.LayoutParams.MATCH_PARENT, view_2.ViewGroup.LayoutParams.MATCH_PARENT);
                let desiredWindowWidth;
                let desiredWindowHeight;
                let attachInfo = this.mAttachInfo;
                let viewVisibility = this.getHostVisibility();
                let viewVisibilityChanged = this.mViewVisibility != viewVisibility;
                let params = null;
                let frame = this.mWinFrame;
                if (this.mFirst) {
                    this.mFullRedrawNeeded = true;
                    this.mLayoutRequested = true;
                    let packageMetrics = Resources.getDisplayMetrics();
                    desiredWindowWidth = packageMetrics.widthPixels;
                    desiredWindowHeight = packageMetrics.heightPixels;
                    attachInfo.mHasWindowFocus = true;
                    attachInfo.mWindowVisibility = viewVisibility;
                    viewVisibilityChanged = false;
                    host.dispatchAttachedToWindow(attachInfo, 0);
                    attachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true);
                }
                else {
                    desiredWindowWidth = frame.width();
                    desiredWindowHeight = frame.height();
                    if (desiredWindowWidth != this.mWidth || desiredWindowHeight != this.mHeight) {
                        if (ViewRootImpl.DEBUG_ORIENTATION) {
                            Log.v(ViewRootImpl.TAG, "View " + host + " resized to: " + frame);
                        }
                        this.mFullRedrawNeeded = true;
                        this.mLayoutRequested = true;
                        windowSizeMayChange = true;
                    }
                }
                if (viewVisibilityChanged) {
                    attachInfo.mWindowVisibility = viewVisibility;
                    host.dispatchWindowVisibilityChanged(viewVisibility);
                }
                ViewRootImpl.getRunQueue(this).executeActions(attachInfo.mHandler);
                let layoutRequested = this.mLayoutRequested;
                if (layoutRequested) {
                    if (this.mFirst) {
                        this.mAttachInfo.mInTouchMode = !this.mAddedTouchMode;
                        this.ensureTouchModeLocally(this.mAddedTouchMode);
                    }
                    else {
                        if (lp.width < 0 || lp.height < 0) {
                            windowSizeMayChange = true;
                            let packageMetrics = Resources.getDisplayMetrics();
                            desiredWindowWidth = packageMetrics.widthPixels;
                            desiredWindowHeight = packageMetrics.heightPixels;
                        }
                    }
                    windowSizeMayChange == this.measureHierarchy(host, lp, desiredWindowWidth, desiredWindowHeight) || windowSizeMayChange;
                }
                if (this.mFirst || attachInfo.mViewVisibilityChanged) {
                    attachInfo.mViewVisibilityChanged = false;
                }
                if (layoutRequested) {
                    this.mLayoutRequested = false;
                }
                let windowShouldResize = layoutRequested && windowSizeMayChange
                    && ((this.mWidth != host.getMeasuredWidth() || this.mHeight != host.getMeasuredHeight())
                        || (lp.width < 0 && frame.width() !== desiredWindowWidth && frame.width() !== this.mWidth)
                        || (lp.height < 0 && frame.height() !== desiredWindowHeight && frame.height() !== this.mHeight));
                if (this.mFirst || windowShouldResize || viewVisibilityChanged) {
                    if (ViewRootImpl.DEBUG_LAYOUT) {
                        Log.i(ViewRootImpl.TAG, "host=w:" + host.getMeasuredWidth() + ", h:" +
                            host.getMeasuredHeight() + ", params=" + params);
                    }
                    if (ViewRootImpl.DEBUG_ORIENTATION)
                        Log.v(ViewRootImpl.TAG, "Relayout returned: frame=" + frame);
                    attachInfo.mWindowLeft = frame.left;
                    attachInfo.mWindowTop = frame.top;
                    if (this.mWidth != frame.width() || this.mHeight != frame.height()) {
                        this.mWidth = frame.width();
                        this.mHeight = frame.height();
                    }
                    if (this.mWidth != host.getMeasuredWidth()
                        || this.mHeight != host.getMeasuredHeight()) {
                        let childWidthMeasureSpec = ViewRootImpl.getRootMeasureSpec(this.mWidth, lp.width);
                        let childHeightMeasureSpec = ViewRootImpl.getRootMeasureSpec(this.mHeight, lp.height);
                        if (ViewRootImpl.DEBUG_LAYOUT)
                            Log.v(ViewRootImpl.TAG, "Ooops, something changed!  mWidth="
                                + this.mWidth + " measuredWidth=" + host.getMeasuredWidth()
                                + " mHeight=" + this.mHeight
                                + " measuredHeight=" + host.getMeasuredHeight());
                        this.performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
                        layoutRequested = true;
                    }
                }
                else {
                    const windowMoved = (attachInfo.mWindowLeft != frame.left
                        || attachInfo.mWindowTop != frame.top);
                    if (windowMoved) {
                        attachInfo.mWindowLeft = frame.left;
                        attachInfo.mWindowTop = frame.top;
                    }
                }
                const didLayout = layoutRequested;
                let triggerGlobalLayoutListener = didLayout;
                if (didLayout) {
                    this.performLayout(lp, desiredWindowWidth, desiredWindowHeight);
                    if (ViewRootImpl.DBG) {
                        System.out.println("======================================");
                        System.out.println("performTraversals -- after setFrame");
                        host.debug();
                    }
                }
                if (triggerGlobalLayoutListener) {
                    attachInfo.mTreeObserver.dispatchOnGlobalLayout();
                }
                let skipDraw = false;
                if (this.mFirst) {
                    if (ViewRootImpl.DEBUG_INPUT_RESIZE)
                        Log.v(ViewRootImpl.TAG, "First: mView.hasFocus()="
                            + this.mView.hasFocus());
                    if (this.mView != null) {
                        if (!this.mView.hasFocus()) {
                            this.mView.requestFocus(View.FOCUS_FORWARD);
                            if (ViewRootImpl.DEBUG_INPUT_RESIZE)
                                Log.v(ViewRootImpl.TAG, "First: requested focused view="
                                    + this.mView.findFocus());
                        }
                        else {
                            if (ViewRootImpl.DEBUG_INPUT_RESIZE)
                                Log.v(ViewRootImpl.TAG, "First: existing focused view="
                                    + this.mView.findFocus());
                        }
                    }
                }
                this.mFirst = false;
                this.mWillDrawSoon = false;
                this.mViewVisibility = viewVisibility;
                let cancelDraw = attachInfo.mTreeObserver.dispatchOnPreDraw() ||
                    viewVisibility != View.VISIBLE;
                if (!cancelDraw) {
                    if (!skipDraw) {
                        this.performDraw();
                    }
                }
                else {
                    if (viewVisibility == View.VISIBLE) {
                        this.scheduleTraversals();
                    }
                }
                this.mIsInTraversal = false;
            }
            performLayout(lp, desiredWindowWidth, desiredWindowHeight) {
                this.mLayoutRequested = false;
                this.mInLayout = true;
                let host = this.mView;
                if (ViewRootImpl.DEBUG_ORIENTATION || ViewRootImpl.DEBUG_LAYOUT) {
                    Log.v(ViewRootImpl.TAG, "Laying out " + host + " to (" +
                        host.getMeasuredWidth() + ", " + host.getMeasuredHeight() + ")");
                }
                host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());
                this.mInLayout = false;
                let numViewsRequestingLayout = this.mLayoutRequesters.length;
                if (numViewsRequestingLayout > 0) {
                    let validLayoutRequesters = this.getValidLayoutRequesters(this.mLayoutRequesters, false);
                    if (validLayoutRequesters != null) {
                        this.mHandlingLayoutInLayoutRequest = true;
                        let numValidRequests = validLayoutRequesters.length;
                        for (let i = 0; i < numValidRequests; ++i) {
                            let view = validLayoutRequesters[i];
                            Log.w("View", "requestLayout() improperly called by " + view +
                                " during layout: running second layout pass");
                            view.requestLayout();
                        }
                        this.measureHierarchy(host, lp, desiredWindowWidth, desiredWindowHeight);
                        this.mInLayout = true;
                        host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());
                        this.mHandlingLayoutInLayoutRequest = false;
                        validLayoutRequesters = this.getValidLayoutRequesters(this.mLayoutRequesters, true);
                        if (validLayoutRequesters != null) {
                            let finalRequesters = validLayoutRequesters;
                            ViewRootImpl.getRunQueue(this).post({
                                run() {
                                    let numValidRequests = finalRequesters.length;
                                    for (let i = 0; i < numValidRequests; ++i) {
                                        const view = finalRequesters[i];
                                        Log.w("View", "requestLayout() improperly called by " + view +
                                            " during second layout pass: posting in next frame");
                                        view.requestLayout();
                                    }
                                }
                            });
                        }
                    }
                }
                this.mInLayout = false;
            }
            getValidLayoutRequesters(layoutRequesters, secondLayoutRequests) {
                let numViewsRequestingLayout = layoutRequesters.length;
                let validLayoutRequesters = null;
                for (let i = 0; i < numViewsRequestingLayout; ++i) {
                    let view = layoutRequesters[i];
                    if (view != null && view.mAttachInfo != null && view.mParent != null &&
                        (secondLayoutRequests || (view.mPrivateFlags & View.PFLAG_FORCE_LAYOUT) ==
                            View.PFLAG_FORCE_LAYOUT)) {
                        let gone = false;
                        let parent = view;
                        while (parent != null) {
                            if ((parent.mViewFlags & View.VISIBILITY_MASK) == View.GONE) {
                                gone = true;
                                break;
                            }
                            if (parent.mParent instanceof View) {
                                parent = parent.mParent;
                            }
                            else {
                                parent = null;
                            }
                        }
                        if (!gone) {
                            if (validLayoutRequesters == null) {
                                validLayoutRequesters = [];
                            }
                            validLayoutRequesters.push(view);
                        }
                    }
                }
                if (!secondLayoutRequests) {
                    for (let i = 0; i < numViewsRequestingLayout; ++i) {
                        let view = layoutRequesters[i];
                        while (view != null &&
                            (view.mPrivateFlags & View.PFLAG_FORCE_LAYOUT) != 0) {
                            view.mPrivateFlags &= ~View.PFLAG_FORCE_LAYOUT;
                            if (view.mParent instanceof View) {
                                view = view.mParent;
                            }
                            else {
                                view = null;
                            }
                        }
                    }
                }
                layoutRequesters.splice(0, layoutRequesters.length);
                return validLayoutRequesters;
            }
            performMeasure(childWidthMeasureSpec, childHeightMeasureSpec) {
                this.mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);
            }
            isInLayout() {
                return this.mInLayout;
            }
            requestLayoutDuringLayout(view) {
                if (view.mParent == null || view.mAttachInfo == null) {
                    return true;
                }
                if (this.mLayoutRequesters.indexOf(view) === -1) {
                    this.mLayoutRequesters.push(view);
                }
                if (!this.mHandlingLayoutInLayoutRequest) {
                    return true;
                }
                else {
                    return false;
                }
            }
            trackFPS() {
                let nowTime = System.currentTimeMillis();
                if (this.mFpsStartTime < 0) {
                    this.mFpsStartTime = this.mFpsPrevTime = nowTime;
                    this.mFpsNumFrames = 0;
                }
                else {
                    this.mFpsNumFrames++;
                    let frameTime = nowTime - this.mFpsPrevTime;
                    let totalTime = nowTime - this.mFpsStartTime;
                    this.mFpsPrevTime = nowTime;
                    if (totalTime > 1000) {
                        let fps = this.mFpsNumFrames * 1000 / totalTime;
                        Log.v(ViewRootImpl.TAG, "FPS:\t" + fps);
                        if (!this._showFPSNode) {
                            this._showFPSNode = document.createElement('div');
                            this._showFPSNode.style.position = 'absolute';
                            this._showFPSNode.style.left = '0';
                            this._showFPSNode.style.bottom = '0';
                            this._showFPSNode.style.background = 'black';
                            this._showFPSNode.style.color = 'white';
                            this.rootElement.appendChild(this._showFPSNode);
                        }
                        this._showFPSNode.innerText = 'FPS:' + fps.toFixed(1);
                        this.mFpsStartTime = nowTime;
                        this.mFpsNumFrames = 0;
                    }
                }
            }
            performDraw() {
                let fullRedrawNeeded = this.mFullRedrawNeeded;
                this.mFullRedrawNeeded = false;
                this.mIsDrawing = true;
                try {
                    this.draw(fullRedrawNeeded);
                }
                finally {
                    this.mIsDrawing = false;
                }
            }
            draw(fullRedrawNeeded) {
                if (ViewRootImpl.DEBUG_FPS) {
                    this.trackFPS();
                }
                let attachInfo = this.mAttachInfo;
                if (attachInfo.mViewScrollChanged) {
                    attachInfo.mViewScrollChanged = false;
                    attachInfo.mTreeObserver.dispatchOnScrollChanged();
                }
                if (fullRedrawNeeded) {
                    attachInfo.mIgnoreDirtyState = true;
                    this.mDirty.set(0, 0, this.mWidth, this.mHeight);
                }
                if (ViewRootImpl.DEBUG_ORIENTATION || ViewRootImpl.DEBUG_DRAW) {
                    Log.v(ViewRootImpl.TAG, "Draw " + this.mView + ", width=" + this.mWidth + ", height=" + this.mHeight + ", dirty=" + this.mDirty);
                }
                attachInfo.mTreeObserver.dispatchOnDraw();
                this.drawSoftware();
            }
            drawSoftware() {
                let canvas = this.mSurface.lockCanvas(this.mDirty);
                this.mDirty.setEmpty();
                let attachInfo = this.mAttachInfo;
                attachInfo.mDrawingTime = SystemClock.uptimeMillis();
                this.mView.mPrivateFlags |= View.PFLAG_DRAWN;
                attachInfo.mSetIgnoreDirtyState = false;
                this.mView.draw(canvas);
                if (!attachInfo.mSetIgnoreDirtyState) {
                    attachInfo.mIgnoreDirtyState = false;
                }
                this.mSurface.unlockCanvasAndPost(canvas);
                if (ViewRootImpl.LOCAL_LOGV) {
                    Log.v(ViewRootImpl.TAG, "Surface unlockCanvasAndPost");
                }
            }
            isLayoutRequested() {
                return this.mLayoutRequested;
            }
            dispatchInvalidateDelayed(view, delayMilliseconds) {
                let msg = this.mHandler.obtainMessage(ViewRootHandler.MSG_INVALIDATE, view);
                this.mHandler.sendMessageDelayed(msg, delayMilliseconds);
            }
            dispatchInvalidateRectDelayed(info, delayMilliseconds) {
                let msg = this.mHandler.obtainMessage(ViewRootHandler.MSG_INVALIDATE_RECT, info);
                this.mHandler.sendMessageDelayed(msg, delayMilliseconds);
            }
            dispatchInvalidateOnAnimation(view) {
                this.mInvalidateOnAnimationRunnable.addView(view);
            }
            dispatchInvalidateRectOnAnimation(info) {
                this.mInvalidateOnAnimationRunnable.addViewRect(info);
            }
            cancelInvalidate(view) {
                this.mHandler.removeMessages(ViewRootHandler.MSG_INVALIDATE, view);
                this.mHandler.removeMessages(ViewRootHandler.MSG_INVALIDATE_RECT, view);
                this.mInvalidateOnAnimationRunnable.removeView(view);
            }
            getParent() {
                return null;
            }
            requestLayout() {
                if (!this.mHandlingLayoutInLayoutRequest) {
                    this.mLayoutRequested = true;
                    this.scheduleTraversals();
                }
            }
            invalidate() {
                this.mDirty.set(0, 0, this.mWidth, this.mHeight);
                this.scheduleTraversals();
            }
            invalidateWorld(view) {
                view.invalidate();
                if (view instanceof view_2.ViewGroup) {
                    let parent = view;
                    for (let i = 0; i < parent.getChildCount(); i++) {
                        this.invalidateWorld(parent.getChildAt(i));
                    }
                }
            }
            invalidateChild(child, dirty) {
                this.invalidateChildInParent(null, dirty);
            }
            invalidateChildInParent(location, dirty) {
                if (ViewRootImpl.DEBUG_DRAW)
                    Log.v(ViewRootImpl.TAG, "Invalidate child: " + dirty);
                if (dirty == null) {
                    this.invalidate();
                    return null;
                }
                else if (dirty.isEmpty()) {
                    return null;
                }
                const localDirty = this.mDirty;
                if (!localDirty.isEmpty() && !localDirty.contains(dirty)) {
                    this.mAttachInfo.mSetIgnoreDirtyState = true;
                    this.mAttachInfo.mIgnoreDirtyState = true;
                }
                localDirty.union(dirty.left, dirty.top, dirty.right, dirty.bottom);
                const intersected = localDirty.intersect(0, 0, this.mWidth, this.mHeight);
                if (!intersected) {
                    localDirty.setEmpty();
                }
                if (!this.mWillDrawSoon && (intersected)) {
                    this.scheduleTraversals();
                }
                return null;
            }
            requestChildFocus(child, focused) {
                if (ViewRootImpl.DEBUG_INPUT_RESIZE) {
                    Log.v(ViewRootImpl.TAG, "Request child focus: focus now " + focused);
                }
                this.scheduleTraversals();
            }
            clearChildFocus(focused) {
                if (ViewRootImpl.DEBUG_INPUT_RESIZE) {
                    Log.v(ViewRootImpl.TAG, "Request child focus: focus now " + focused);
                }
                this.scheduleTraversals();
            }
            getChildVisibleRect(child, r, offset) {
                if (child != this.mView) {
                    throw new Error("child is not mine, honest!");
                }
                return r.intersect(0, 0, this.mWidth, this.mHeight);
            }
            focusSearch(focused, direction) {
                if (!(this.mView instanceof view_2.ViewGroup)) {
                    return null;
                }
                return view_2.FocusFinder.getInstance().findNextFocus(this.mView, focused, direction);
            }
            bringChildToFront(child) {
            }
            focusableViewAvailable(v) {
                if (this.mView != null) {
                    if (!this.mView.hasFocus()) {
                        v.requestFocus();
                    }
                    else {
                        let focused = this.mView.findFocus();
                        if (focused instanceof view_2.ViewGroup) {
                            let group = focused;
                            if (group.getDescendantFocusability() == view_2.ViewGroup.FOCUS_AFTER_DESCENDANTS
                                && ViewRootImpl.isViewDescendantOf(v, focused)) {
                                v.requestFocus();
                            }
                        }
                    }
                }
            }
            static isViewDescendantOf(child, parent) {
                if (child == parent) {
                    return true;
                }
                const theParent = child.getParent();
                return (theParent instanceof view_2.ViewGroup) && ViewRootImpl.isViewDescendantOf(theParent, parent);
            }
            childDrawableStateChanged(child) {
            }
            requestDisallowInterceptTouchEvent(disallowIntercept) {
            }
            requestChildRectangleOnScreen(child, rectangle, immediate) {
                return false;
            }
            childHasTransientStateChanged(child, hasTransientState) {
            }
            dispatchResized(frame) {
                this.mWinFrame.set(frame.left, frame.top, frame.right, frame.bottom);
                this.requestLayout();
            }
            dispatchInputEvent(event) {
                this.deliverInputEvent(event);
                let result = event[InputStage.FLAG_FINISHED_HANDLED];
                event[InputStage.FLAG_FINISHED] = false;
                event[InputStage.FLAG_FINISHED_HANDLED] = false;
                return result;
            }
            deliverInputEvent(event) {
                this.mFirstInputStage.deliver(event);
            }
            finishInputEvent(event) {
            }
            checkForLeavingTouchModeAndConsume(event) {
                if (!this.mAttachInfo.mInTouchMode) {
                    return false;
                }
                const action = event.getAction();
                if (action != view_2.KeyEvent.ACTION_DOWN) {
                    return false;
                }
                if (ViewRootImpl.isNavigationKey(event)) {
                    return this.ensureTouchMode(false);
                }
                if (ViewRootImpl.isTypingKey(event)) {
                    this.ensureTouchMode(false);
                    return false;
                }
                return false;
            }
            static isNavigationKey(keyEvent) {
                switch (keyEvent.getKeyCode()) {
                    case view_2.KeyEvent.KEYCODE_DPAD_LEFT:
                    case view_2.KeyEvent.KEYCODE_DPAD_RIGHT:
                    case view_2.KeyEvent.KEYCODE_DPAD_UP:
                    case view_2.KeyEvent.KEYCODE_DPAD_DOWN:
                    case view_2.KeyEvent.KEYCODE_DPAD_CENTER:
                    case view_2.KeyEvent.KEYCODE_PAGE_UP:
                    case view_2.KeyEvent.KEYCODE_PAGE_DOWN:
                    case view_2.KeyEvent.KEYCODE_MOVE_HOME:
                    case view_2.KeyEvent.KEYCODE_MOVE_END:
                    case view_2.KeyEvent.KEYCODE_TAB:
                    case view_2.KeyEvent.KEYCODE_SPACE:
                    case view_2.KeyEvent.KEYCODE_ENTER:
                        return true;
                }
                return false;
            }
            static isTypingKey(keyEvent) {
                try {
                    return keyEvent._activeKeyEvent['keyIdentifier'].startsWith('U+');
                }
                catch (e) {
                    console.warn(e);
                }
                return true;
            }
            ensureTouchMode(inTouchMode) {
                if (ViewRootImpl.DBG)
                    Log.d("touchmode", "ensureTouchMode(" + inTouchMode + "), current "
                        + "touch mode is " + this.mAttachInfo.mInTouchMode);
                if (this.mAttachInfo.mInTouchMode == inTouchMode)
                    return false;
                return this.ensureTouchModeLocally(inTouchMode);
            }
            ensureTouchModeLocally(inTouchMode) {
                if (ViewRootImpl.DBG)
                    Log.d("touchmode", "ensureTouchModeLocally(" + inTouchMode + "), current "
                        + "touch mode is " + this.mAttachInfo.mInTouchMode);
                if (this.mAttachInfo.mInTouchMode == inTouchMode)
                    return false;
                this.mAttachInfo.mInTouchMode = inTouchMode;
                this.mAttachInfo.mTreeObserver.dispatchOnTouchModeChanged(inTouchMode);
                return (inTouchMode) ? this.enterTouchMode() : this.leaveTouchMode();
            }
            enterTouchMode() {
                if (this.mView != null && this.mView.hasFocus()) {
                    const focused = this.mView.findFocus();
                    if (focused != null && !focused.isFocusableInTouchMode()) {
                        const ancestorToTakeFocus = ViewRootImpl.findAncestorToTakeFocusInTouchMode(focused);
                        if (ancestorToTakeFocus != null) {
                            return ancestorToTakeFocus.requestFocus();
                        }
                        else {
                            focused.clearFocusInternal(true, false);
                            return true;
                        }
                    }
                }
                return false;
            }
            static findAncestorToTakeFocusInTouchMode(focused) {
                let parent = focused.getParent();
                while (parent instanceof view_2.ViewGroup) {
                    const vgParent = parent;
                    if (vgParent.getDescendantFocusability() == view_2.ViewGroup.FOCUS_AFTER_DESCENDANTS
                        && vgParent.isFocusableInTouchMode()) {
                        return vgParent;
                    }
                    if (vgParent.isRootNamespace()) {
                        return null;
                    }
                    else {
                        parent = vgParent.getParent();
                    }
                }
                return null;
            }
            leaveTouchMode() {
                if (this.mView != null) {
                    if (this.mView.hasFocus()) {
                        let focusedView = this.mView.findFocus();
                        if (!(focusedView instanceof view_2.ViewGroup)) {
                            return false;
                        }
                        else if (focusedView.getDescendantFocusability() !=
                            view_2.ViewGroup.FOCUS_AFTER_DESCENDANTS) {
                            return false;
                        }
                    }
                    const focused = this.focusSearch(null, View.FOCUS_DOWN);
                    if (focused != null) {
                        return focused.requestFocus(View.FOCUS_DOWN);
                    }
                }
                return false;
            }
            static getRunQueue(viewRoot) {
                if (viewRoot) {
                    if (!viewRoot.mRunQueue)
                        viewRoot.mRunQueue = new ViewRootImpl.RunQueue();
                    return viewRoot.mRunQueue;
                }
                else {
                    if (!this.RunQueueInstance) {
                        this.RunQueueInstance = new RunQueueForNoViewRoot();
                    }
                    return this.RunQueueInstance;
                }
            }
        }
        ViewRootImpl.TAG = "ViewRootImpl";
        ViewRootImpl.DBG = Log.View_DBG;
        ViewRootImpl.LOCAL_LOGV = ViewRootImpl.DBG;
        ViewRootImpl.DEBUG_DRAW = false || ViewRootImpl.LOCAL_LOGV;
        ViewRootImpl.DEBUG_LAYOUT = false || ViewRootImpl.LOCAL_LOGV;
        ViewRootImpl.DEBUG_INPUT_RESIZE = false || ViewRootImpl.LOCAL_LOGV;
        ViewRootImpl.DEBUG_ORIENTATION = false || ViewRootImpl.LOCAL_LOGV;
        ViewRootImpl.DEBUG_CONFIGURATION = false || ViewRootImpl.LOCAL_LOGV;
        ViewRootImpl.DEBUG_FPS = false || ViewRootImpl.LOCAL_LOGV;
        view_2.ViewRootImpl = ViewRootImpl;
        (function (ViewRootImpl) {
            class RunQueue {
                constructor() {
                    this.mActions = [];
                }
                post(action) {
                    this.postDelayed(action, 0);
                }
                postDelayed(action, delayMillis) {
                    let handlerAction = {
                        action: action,
                        delay: delayMillis
                    };
                    this.mActions.push(handlerAction);
                }
                removeCallbacks(action) {
                    this.mActions = this.mActions.filter((item) => {
                        return item.action == action;
                    });
                }
                executeActions(handler) {
                    for (let handlerAction of this.mActions) {
                        handler.postDelayed(handlerAction.action, handlerAction.delay);
                    }
                    this.mActions = [];
                }
            }
            ViewRootImpl.RunQueue = RunQueue;
        })(ViewRootImpl = view_2.ViewRootImpl || (view_2.ViewRootImpl = {}));
        class RunQueueForNoViewRoot extends ViewRootImpl.RunQueue {
            postDelayed(action, delayMillis) {
                RunQueueForNoViewRoot.Handler.postDelayed(action, delayMillis);
            }
            removeCallbacks(action) {
                RunQueueForNoViewRoot.Handler.removeCallbacks(action);
            }
        }
        RunQueueForNoViewRoot.Handler = new Handler();
        class TraversalRunnable {
            constructor(impl) {
                this.ViewRootImpl_this = impl;
            }
            run() {
                this.ViewRootImpl_this.doTraversal();
            }
        }
        class InvalidateOnAnimationRunnable {
            constructor(handler) {
                this.mPosted = false;
                this.mViews = new Set();
                this.mViewRects = new Map();
                this.mHandler = handler;
            }
            addView(view) {
                this.mViews.add(view);
                this.postIfNeededLocked();
            }
            addViewRect(info) {
                this.mViewRects.set(info.target, info);
                this.postIfNeededLocked();
            }
            removeView(view) {
                this.mViews.delete(view);
                this.mViewRects.delete(view);
                if (this.mPosted && this.mViews.size === 0 && this.mViewRects.size === 0) {
                    this.mHandler.removeCallbacks(this);
                    this.mPosted = false;
                }
            }
            run() {
                this.mPosted = false;
                for (let view of this.mViews) {
                    view.invalidate();
                }
                this.mViews.clear();
                for (let info of this.mViewRects.values()) {
                    info.target.invalidate(info.left, info.top, info.right, info.bottom);
                    info.recycle();
                }
                this.mViewRects.clear();
            }
            postIfNeededLocked() {
                if (!this.mPosted) {
                    this.mHandler.post(this);
                    this.mPosted = true;
                }
            }
        }
        class ViewRootHandler extends Handler {
            handleMessage(msg) {
                switch (msg.what) {
                    case ViewRootHandler.MSG_INVALIDATE:
                        msg.obj.invalidate();
                        break;
                    case ViewRootHandler.MSG_INVALIDATE_RECT:
                        const info = msg.obj;
                        info.target.invalidate(info.left, info.top, info.right, info.bottom);
                        info.recycle();
                        break;
                }
            }
        }
        ViewRootHandler.MSG_INVALIDATE = 1;
        ViewRootHandler.MSG_INVALIDATE_RECT = 2;
        class InputStage {
            constructor(impl, next) {
                this.ViewRootImpl_this = impl;
                this.mNext = next;
            }
            deliver(event) {
                if (event[InputStage.FLAG_FINISHED]) {
                    this.forward(event);
                }
                else if (this.shouldDropInputEvent(event)) {
                    this.finish(event, false);
                }
                else {
                    this.apply(event, this.onProcess(event));
                }
            }
            finish(event, handled) {
                event[InputStage.FLAG_FINISHED] = true;
                if (handled) {
                    event[InputStage.FLAG_FINISHED_HANDLED] = true;
                }
                this.forward(event);
            }
            forward(event) {
                this.onDeliverToNext(event);
            }
            apply(event, result) {
                if (result == InputStage.FORWARD) {
                    this.forward(event);
                }
                else if (result == InputStage.FINISH_HANDLED) {
                    this.finish(event, true);
                }
                else if (result == InputStage.FINISH_NOT_HANDLED) {
                    this.finish(event, false);
                }
                else {
                    throw new Error("Invalid result: " + result);
                }
            }
            onDeliverToNext(event) {
                if (this.mNext != null) {
                    this.mNext.deliver(event);
                }
                else {
                    this.ViewRootImpl_this.finishInputEvent(event);
                }
            }
            onProcess(event) {
                return InputStage.FORWARD;
            }
            shouldDropInputEvent(event) {
                if (this.ViewRootImpl_this.mView == null || !this.ViewRootImpl_this.mAdded) {
                    Log.w(ViewRootImpl.TAG, "Dropping event due to root view being removed: " + event);
                    return true;
                }
                else if ((!this.ViewRootImpl_this.mAttachInfo.mHasWindowFocus ||
                    this.ViewRootImpl_this.mStopped)) {
                    Log.w(ViewRootImpl.TAG, "Dropping event due to no window focus: " + event);
                    return true;
                }
                return false;
            }
        }
        InputStage.FLAG_FINISHED = Symbol();
        InputStage.FLAG_FINISHED_HANDLED = Symbol();
        InputStage.FORWARD = 0;
        InputStage.FINISH_HANDLED = 1;
        InputStage.FINISH_NOT_HANDLED = 2;
        class EarlyPostImeInputStage extends InputStage {
            onProcess(event) {
                if (event instanceof view_2.MotionEvent) {
                    return this.processMotionEvent(event);
                }
                else if (event instanceof view_2.KeyEvent) {
                    return this.processKeyEvent(event);
                }
                return InputStage.FORWARD;
            }
            processKeyEvent(event) {
                if (this.ViewRootImpl_this.checkForLeavingTouchModeAndConsume(event)) {
                    return InputStage.FINISH_HANDLED;
                }
                return InputStage.FORWARD;
            }
            processMotionEvent(event) {
                const action = event.getAction();
                if (action == view_2.MotionEvent.ACTION_DOWN || action == view_2.MotionEvent.ACTION_SCROLL) {
                    this.ViewRootImpl_this.ensureTouchMode(true);
                }
                event.offsetLocation(this.ViewRootImpl_this.mWinFrame.left, this.ViewRootImpl_this.mWinFrame.top);
                return InputStage.FORWARD;
            }
        }
        class ViewPostImeInputStage extends InputStage {
            onProcess(event) {
                if (event instanceof view_2.KeyEvent) {
                    return this.processKeyEvent(event);
                }
                else if (event instanceof view_2.MotionEvent) {
                    if (event.isTouchEvent()) {
                        return this.processTouchEvent(event);
                    }
                    else {
                        return this.processGenericMotionEvent(event);
                    }
                }
                return InputStage.FORWARD;
            }
            processKeyEvent(event) {
                let mView = this.ViewRootImpl_this.mView;
                if (this.ViewRootImpl_this.mView.dispatchKeyEvent(event)) {
                    return InputStage.FINISH_HANDLED;
                }
                if (this.shouldDropInputEvent(event)) {
                    return InputStage.FINISH_NOT_HANDLED;
                }
                if (event.getAction() == view_2.KeyEvent.ACTION_DOWN
                    && event.isCtrlPressed()
                    && event.getRepeatCount() == 0) {
                    if (this.ViewRootImpl_this.shouldDropInputEvent(event)) {
                        return InputStage.FINISH_NOT_HANDLED;
                    }
                }
                if (this.shouldDropInputEvent(event)) {
                    return InputStage.FINISH_NOT_HANDLED;
                }
                if (event.getAction() == view_2.KeyEvent.ACTION_DOWN) {
                    let direction = 0;
                    switch (event.getKeyCode()) {
                        case view_2.KeyEvent.KEYCODE_DPAD_LEFT:
                            direction = View.FOCUS_LEFT;
                            break;
                        case view_2.KeyEvent.KEYCODE_DPAD_RIGHT:
                            direction = View.FOCUS_RIGHT;
                            break;
                        case view_2.KeyEvent.KEYCODE_DPAD_UP:
                            direction = View.FOCUS_UP;
                            break;
                        case view_2.KeyEvent.KEYCODE_DPAD_DOWN:
                            direction = View.FOCUS_DOWN;
                            break;
                        case view_2.KeyEvent.KEYCODE_TAB:
                            if (event.isShiftPressed()) {
                                direction = View.FOCUS_BACKWARD;
                            }
                            else {
                                direction = View.FOCUS_FORWARD;
                            }
                            break;
                    }
                    if (direction != 0) {
                        let focused = mView.findFocus();
                        if (focused != null) {
                            let v = focused.focusSearch(direction);
                            if (v != null && v != focused) {
                                focused.getFocusedRect(this.ViewRootImpl_this.mTempRect);
                                if (mView instanceof view_2.ViewGroup) {
                                    mView.offsetDescendantRectToMyCoords(focused, this.ViewRootImpl_this.mTempRect);
                                    mView.offsetRectIntoDescendantCoords(v, this.ViewRootImpl_this.mTempRect);
                                }
                                if (v.requestFocus(direction, this.ViewRootImpl_this.mTempRect)) {
                                    return InputStage.FINISH_HANDLED;
                                }
                            }
                            if (mView.dispatchUnhandledMove(focused, direction)) {
                                return InputStage.FINISH_HANDLED;
                            }
                        }
                        else {
                            let v = this.ViewRootImpl_this.focusSearch(null, direction);
                            if (v != null && v.requestFocus(direction)) {
                                return InputStage.FINISH_HANDLED;
                            }
                        }
                    }
                }
                return InputStage.FORWARD;
            }
            processGenericMotionEvent(event) {
                if (this.ViewRootImpl_this.mView.dispatchGenericMotionEvent(event)) {
                    return InputStage.FINISH_HANDLED;
                }
                return InputStage.FORWARD;
            }
            processTouchEvent(event) {
                let handled = this.ViewRootImpl_this.mView.dispatchTouchEvent(event);
                return handled ? InputStage.FINISH_HANDLED : InputStage.FORWARD;
            }
        }
        class SyntheticInputStage extends InputStage {
            onProcess(event) {
                return super.onProcess(event);
            }
        }
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/10.
 */
///<reference path="View.ts"/>
///<reference path="ViewGroup.ts"/>
var android;
(function (android) {
    var view;
    (function (view_3) {
        var View = android.view.View;
        var Rect = android.graphics.Rect;
        var ArrayList = java.util.ArrayList;
        class FocusFinder {
            constructor() {
                this.mFocusedRect = new Rect();
                this.mOtherRect = new Rect();
                this.mBestCandidateRect = new Rect();
                this.mSequentialFocusComparator = new SequentialFocusComparator();
                this.mTempList = new ArrayList();
            }
            static getInstance() {
                if (!FocusFinder.sFocusFinder) {
                    FocusFinder.sFocusFinder = new FocusFinder();
                }
                return FocusFinder.sFocusFinder;
            }
            findNextFocus(root, focused, direction) {
                return this._findNextFocus(root, focused, null, direction);
            }
            findNextFocusFromRect(root, focusedRect, direction) {
                this.mFocusedRect.set(focusedRect);
                return this._findNextFocus(root, null, this.mFocusedRect, direction);
            }
            _findNextFocus(root, focused, focusedRect, direction) {
                let next = null;
                if (focused != null) {
                    next = this.findNextUserSpecifiedFocus(root, focused, direction);
                }
                if (next != null) {
                    return next;
                }
                let focusables = this.mTempList;
                try {
                    focusables.clear();
                    root.addFocusables(focusables, direction);
                    if (!focusables.isEmpty()) {
                        next = this.__findNextFocus(root, focused, focusedRect, direction, focusables);
                    }
                }
                finally {
                    focusables.clear();
                }
                return next;
            }
            findNextUserSpecifiedFocus(root, focused, direction) {
                let userSetNextFocus = focused.findUserSetNextFocus(root, direction);
                if (userSetNextFocus != null && userSetNextFocus.isFocusable()
                    && (!userSetNextFocus.isInTouchMode()
                        || userSetNextFocus.isFocusableInTouchMode())) {
                    return userSetNextFocus;
                }
                return null;
            }
            __findNextFocus(root, focused, focusedRect, direction, focusables) {
                if (focused != null) {
                    if (focusedRect == null) {
                        focusedRect = this.mFocusedRect;
                    }
                    focused.getFocusedRect(focusedRect);
                    root.offsetDescendantRectToMyCoords(focused, focusedRect);
                }
                else {
                    if (focusedRect == null) {
                        focusedRect = this.mFocusedRect;
                        switch (direction) {
                            case View.FOCUS_RIGHT:
                            case View.FOCUS_DOWN:
                                this.setFocusTopLeft(root, focusedRect);
                                break;
                            case View.FOCUS_FORWARD:
                                this.setFocusTopLeft(root, focusedRect);
                                break;
                            case View.FOCUS_LEFT:
                            case View.FOCUS_UP:
                                this.setFocusBottomRight(root, focusedRect);
                                break;
                            case View.FOCUS_BACKWARD:
                                this.setFocusBottomRight(root, focusedRect);
                        }
                    }
                }
                switch (direction) {
                    case View.FOCUS_FORWARD:
                    case View.FOCUS_BACKWARD:
                        return this.findNextFocusInRelativeDirection(focusables, root, focused, focusedRect, direction);
                    case View.FOCUS_UP:
                    case View.FOCUS_DOWN:
                    case View.FOCUS_LEFT:
                    case View.FOCUS_RIGHT:
                        return this.findNextFocusInAbsoluteDirection(focusables, root, focused, focusedRect, direction);
                    default:
                        throw new Error("Unknown direction: " + direction);
                }
            }
            findNextFocusInRelativeDirection(focusables, root, focused, focusedRect, direction) {
                try {
                    this.mSequentialFocusComparator.setRoot(root);
                    this.mSequentialFocusComparator.sort(focusables);
                }
                finally {
                    this.mSequentialFocusComparator.recycle();
                }
                const count = focusables.size();
                switch (direction) {
                    case View.FOCUS_FORWARD:
                        return FocusFinder.getNextFocusable(focused, focusables, count);
                    case View.FOCUS_BACKWARD:
                        return FocusFinder.getPreviousFocusable(focused, focusables, count);
                }
                return focusables.get(count - 1);
            }
            setFocusBottomRight(root, focusedRect) {
                const rootBottom = root.getScrollY() + root.getHeight();
                const rootRight = root.getScrollX() + root.getWidth();
                focusedRect.set(rootRight, rootBottom, rootRight, rootBottom);
            }
            setFocusTopLeft(root, focusedRect) {
                const rootTop = root.getScrollY();
                const rootLeft = root.getScrollX();
                focusedRect.set(rootLeft, rootTop, rootLeft, rootTop);
            }
            findNextFocusInAbsoluteDirection(focusables, root, focused, focusedRect, direction) {
                this.mBestCandidateRect.set(focusedRect);
                switch (direction) {
                    case View.FOCUS_LEFT:
                        this.mBestCandidateRect.offset(focusedRect.width() + 1, 0);
                        break;
                    case View.FOCUS_RIGHT:
                        this.mBestCandidateRect.offset(-(focusedRect.width() + 1), 0);
                        break;
                    case View.FOCUS_UP:
                        this.mBestCandidateRect.offset(0, focusedRect.height() + 1);
                        break;
                    case View.FOCUS_DOWN:
                        this.mBestCandidateRect.offset(0, -(focusedRect.height() + 1));
                }
                let closest = null;
                let numFocusables = focusables.size();
                for (let i = 0; i < numFocusables; i++) {
                    let focusable = focusables.get(i);
                    if (focusable == focused || focusable == root)
                        continue;
                    focusable.getFocusedRect(this.mOtherRect);
                    root.offsetDescendantRectToMyCoords(focusable, this.mOtherRect);
                    if (this.isBetterCandidate(direction, focusedRect, this.mOtherRect, this.mBestCandidateRect)) {
                        this.mBestCandidateRect.set(this.mOtherRect);
                        closest = focusable;
                    }
                }
                return closest;
            }
            static getNextFocusable(focused, focusables, count) {
                if (focused != null) {
                    let position = focusables.lastIndexOf(focused);
                    if (position >= 0 && position + 1 < count) {
                        return focusables.get(position + 1);
                    }
                }
                if (!focusables.isEmpty()) {
                    return focusables.get(0);
                }
                return null;
            }
            static getPreviousFocusable(focused, focusables, count) {
                if (focused != null) {
                    let position = focusables.indexOf(focused);
                    if (position > 0) {
                        return focusables.get(position - 1);
                    }
                }
                if (!focusables.isEmpty()) {
                    return focusables.get(count - 1);
                }
                return null;
            }
            isBetterCandidate(direction, source, rect1, rect2) {
                if (!this.isCandidate(source, rect1, direction)) {
                    return false;
                }
                if (!this.isCandidate(source, rect2, direction)) {
                    return true;
                }
                if (this.beamBeats(direction, source, rect1, rect2)) {
                    return true;
                }
                if (this.beamBeats(direction, source, rect2, rect1)) {
                    return false;
                }
                return (this.getWeightedDistanceFor(FocusFinder.majorAxisDistance(direction, source, rect1), FocusFinder.minorAxisDistance(direction, source, rect1))
                    < this.getWeightedDistanceFor(FocusFinder.majorAxisDistance(direction, source, rect2), FocusFinder.minorAxisDistance(direction, source, rect2)));
            }
            beamBeats(direction, source, rect1, rect2) {
                const rect1InSrcBeam = this.beamsOverlap(direction, source, rect1);
                const rect2InSrcBeam = this.beamsOverlap(direction, source, rect2);
                if (rect2InSrcBeam || !rect1InSrcBeam) {
                    return false;
                }
                if (!this.isToDirectionOf(direction, source, rect2)) {
                    return true;
                }
                if ((direction == View.FOCUS_LEFT || direction == View.FOCUS_RIGHT)) {
                    return true;
                }
                return (FocusFinder.majorAxisDistance(direction, source, rect1)
                    < FocusFinder.majorAxisDistanceToFarEdge(direction, source, rect2));
            }
            getWeightedDistanceFor(majorAxisDistance, minorAxisDistance) {
                return 13 * majorAxisDistance * majorAxisDistance
                    + minorAxisDistance * minorAxisDistance;
            }
            isCandidate(srcRect, destRect, direction) {
                switch (direction) {
                    case View.FOCUS_LEFT:
                        return (srcRect.right > destRect.right || srcRect.left >= destRect.right)
                            && srcRect.left > destRect.left;
                    case View.FOCUS_RIGHT:
                        return (srcRect.left < destRect.left || srcRect.right <= destRect.left)
                            && srcRect.right < destRect.right;
                    case View.FOCUS_UP:
                        return (srcRect.bottom > destRect.bottom || srcRect.top >= destRect.bottom)
                            && srcRect.top > destRect.top;
                    case View.FOCUS_DOWN:
                        return (srcRect.top < destRect.top || srcRect.bottom <= destRect.top)
                            && srcRect.bottom < destRect.bottom;
                }
                throw new Error("direction must be one of "
                    + "{FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT}.");
            }
            beamsOverlap(direction, rect1, rect2) {
                switch (direction) {
                    case View.FOCUS_LEFT:
                    case View.FOCUS_RIGHT:
                        return (rect2.bottom >= rect1.top) && (rect2.top <= rect1.bottom);
                    case View.FOCUS_UP:
                    case View.FOCUS_DOWN:
                        return (rect2.right >= rect1.left) && (rect2.left <= rect1.right);
                }
                throw new Error("direction must be one of "
                    + "{FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT}.");
            }
            isToDirectionOf(direction, src, dest) {
                switch (direction) {
                    case View.FOCUS_LEFT:
                        return src.left >= dest.right;
                    case View.FOCUS_RIGHT:
                        return src.right <= dest.left;
                    case View.FOCUS_UP:
                        return src.top >= dest.bottom;
                    case View.FOCUS_DOWN:
                        return src.bottom <= dest.top;
                }
                throw new Error("direction must be one of "
                    + "{FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT}.");
            }
            static majorAxisDistance(direction, source, dest) {
                return Math.max(0, FocusFinder.majorAxisDistanceRaw(direction, source, dest));
            }
            static majorAxisDistanceRaw(direction, source, dest) {
                switch (direction) {
                    case View.FOCUS_LEFT:
                        return source.left - dest.right;
                    case View.FOCUS_RIGHT:
                        return dest.left - source.right;
                    case View.FOCUS_UP:
                        return source.top - dest.bottom;
                    case View.FOCUS_DOWN:
                        return dest.top - source.bottom;
                }
                throw new Error("direction must be one of "
                    + "{FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT}.");
            }
            static majorAxisDistanceToFarEdge(direction, source, dest) {
                return Math.max(1, FocusFinder.majorAxisDistanceToFarEdgeRaw(direction, source, dest));
            }
            static majorAxisDistanceToFarEdgeRaw(direction, source, dest) {
                switch (direction) {
                    case View.FOCUS_LEFT:
                        return source.left - dest.left;
                    case View.FOCUS_RIGHT:
                        return dest.right - source.right;
                    case View.FOCUS_UP:
                        return source.top - dest.top;
                    case View.FOCUS_DOWN:
                        return dest.bottom - source.bottom;
                }
                throw new Error("direction must be one of "
                    + "{FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT}.");
            }
            static minorAxisDistance(direction, source, dest) {
                switch (direction) {
                    case View.FOCUS_LEFT:
                    case View.FOCUS_RIGHT:
                        return Math.abs(((source.top + source.height() / 2) -
                            ((dest.top + dest.height() / 2))));
                    case View.FOCUS_UP:
                    case View.FOCUS_DOWN:
                        return Math.abs(((source.left + source.width() / 2) -
                            ((dest.left + dest.width() / 2))));
                }
                throw new Error("direction must be one of "
                    + "{FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT}.");
            }
            findNearestTouchable(root, x, y, direction, deltas) {
                let touchables = root.getTouchables();
                let minDistance = Number.MAX_SAFE_INTEGER;
                let closest = null;
                let numTouchables = touchables.size();
                let edgeSlop = view_3.ViewConfiguration.get().getScaledEdgeSlop();
                let closestBounds = new Rect();
                let touchableBounds = this.mOtherRect;
                for (let i = 0; i < numTouchables; i++) {
                    let touchable = touchables.get(i);
                    touchable.getDrawingRect(touchableBounds);
                    root.offsetRectBetweenParentAndChild(touchable, touchableBounds, true, true);
                    if (!this.isTouchCandidate(x, y, touchableBounds, direction)) {
                        continue;
                    }
                    let distance = Number.MAX_SAFE_INTEGER;
                    switch (direction) {
                        case View.FOCUS_LEFT:
                            distance = x - touchableBounds.right + 1;
                            break;
                        case View.FOCUS_RIGHT:
                            distance = touchableBounds.left;
                            break;
                        case View.FOCUS_UP:
                            distance = y - touchableBounds.bottom + 1;
                            break;
                        case View.FOCUS_DOWN:
                            distance = touchableBounds.top;
                            break;
                    }
                    if (distance < edgeSlop) {
                        if (closest == null ||
                            closestBounds.contains(touchableBounds) ||
                            (!touchableBounds.contains(closestBounds) && distance < minDistance)) {
                            minDistance = distance;
                            closest = touchable;
                            closestBounds.set(touchableBounds);
                            switch (direction) {
                                case View.FOCUS_LEFT:
                                    deltas[0] = -distance;
                                    break;
                                case View.FOCUS_RIGHT:
                                    deltas[0] = distance;
                                    break;
                                case View.FOCUS_UP:
                                    deltas[1] = -distance;
                                    break;
                                case View.FOCUS_DOWN:
                                    deltas[1] = distance;
                                    break;
                            }
                        }
                    }
                }
                return closest;
            }
            isTouchCandidate(x, y, destRect, direction) {
                switch (direction) {
                    case View.FOCUS_LEFT:
                        return destRect.left <= x && destRect.top <= y && y <= destRect.bottom;
                    case View.FOCUS_RIGHT:
                        return destRect.left >= x && destRect.top <= y && y <= destRect.bottom;
                    case View.FOCUS_UP:
                        return destRect.top <= y && destRect.left <= x && x <= destRect.right;
                    case View.FOCUS_DOWN:
                        return destRect.top >= y && destRect.left <= x && x <= destRect.right;
                }
                throw new Error("direction must be one of "
                    + "{FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT}.");
            }
        }
        view_3.FocusFinder = FocusFinder;
        class SequentialFocusComparator {
            constructor() {
                this.mFirstRect = new Rect();
                this.mSecondRect = new Rect();
                this.mIsLayoutRtl = false;
                this.compareFn = (first, second) => {
                    if (first == second) {
                        return 0;
                    }
                    this.getRect(first, this.mFirstRect);
                    this.getRect(second, this.mSecondRect);
                    if (this.mFirstRect.top < this.mSecondRect.top) {
                        return -1;
                    }
                    else if (this.mFirstRect.top > this.mSecondRect.top) {
                        return 1;
                    }
                    else if (this.mFirstRect.left < this.mSecondRect.left) {
                        return this.mIsLayoutRtl ? 1 : -1;
                    }
                    else if (this.mFirstRect.left > this.mSecondRect.left) {
                        return this.mIsLayoutRtl ? -1 : 1;
                    }
                    else if (this.mFirstRect.bottom < this.mSecondRect.bottom) {
                        return -1;
                    }
                    else if (this.mFirstRect.bottom > this.mSecondRect.bottom) {
                        return 1;
                    }
                    else if (this.mFirstRect.right < this.mSecondRect.right) {
                        return this.mIsLayoutRtl ? 1 : -1;
                    }
                    else if (this.mFirstRect.right > this.mSecondRect.right) {
                        return this.mIsLayoutRtl ? -1 : 1;
                    }
                    else {
                        return 0;
                    }
                };
            }
            recycle() {
                this.mRoot = null;
            }
            setRoot(root) {
                this.mRoot = root;
            }
            getRect(view, rect) {
                view.getDrawingRect(rect);
                this.mRoot.offsetDescendantRectToMyCoords(view, rect);
            }
            sort(array) {
                array.sort(this.compareFn);
            }
        }
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/5.
 */
///<reference path="ViewRootImpl.ts"/>
///<reference path="View.ts"/>
///<reference path="MotionEvent.ts"/>
///<reference path="ViewParent.ts"/>
///<reference path="../graphics/Canvas.ts"/>
///<reference path="../graphics/Point.ts"/>
///<reference path="../graphics/Matrix.ts"/>
///<reference path="../graphics/Rect.ts"/>
///<reference path="../os/SystemClock.ts"/>
///<reference path="../util/TypedValue.ts"/>
///<reference path="FocusFinder.ts"/>
var android;
(function (android) {
    var view;
    (function (view_4) {
        var Rect = android.graphics.Rect;
        var SystemClock = android.os.SystemClock;
        var TypedValue = android.util.TypedValue;
        var System = java.lang.System;
        var AttrBinder = androidui.attr.AttrBinder;
        class ViewGroup extends view_4.View {
            constructor(bindElement, rootElement) {
                super(bindElement, rootElement);
                this.mLastTouchDownTime = 0;
                this.mLastTouchDownIndex = -1;
                this.mLastTouchDownX = 0;
                this.mLastTouchDownY = 0;
                this.mGroupFlags = 0;
                this.mLayoutMode = ViewGroup.LAYOUT_MODE_UNDEFINED;
                this.mChildren = [];
                this.mSuppressLayout = false;
                this.mLayoutCalledWhileSuppressed = false;
                this.mChildCountWithTransientState = 0;
                this.initViewGroup();
                this._attrBinder.addAttr('clipChildren', (value) => {
                    this.setClipChildren(this._attrBinder.parseBoolean(value));
                }, () => {
                    return this.getClipChildren();
                });
                this._attrBinder.addAttr('clipToPadding', (value) => {
                    this.setClipToPadding(this._attrBinder.parseBoolean(value));
                }, () => {
                    return this.isClipToPadding();
                });
                this._attrBinder.addAttr('animationCache', (value) => {
                });
                this._attrBinder.addAttr('persistentDrawingCache', (value) => {
                });
                this._attrBinder.addAttr('addStatesFromChildren', (value) => {
                });
                this._attrBinder.addAttr('alwaysDrawnWithCache', (value) => {
                });
                this._attrBinder.addAttr('layoutAnimation', (value) => {
                });
                this._attrBinder.addAttr('descendantFocusability', (value) => {
                });
                this._attrBinder.addAttr('animationCache', (value) => {
                });
                this._attrBinder.addAttr('splitMotionEvents', (value) => {
                });
                this._attrBinder.addAttr('animateLayoutChanges', (value) => {
                });
                this._attrBinder.addAttr('layoutMode', (value) => {
                });
            }
            get mChildrenCount() {
                return this.mChildren.length;
            }
            initViewGroup() {
                this.setFlags(view_4.View.WILL_NOT_DRAW, view_4.View.DRAW_MASK);
                this.mGroupFlags |= ViewGroup.FLAG_CLIP_CHILDREN;
                this.mGroupFlags |= ViewGroup.FLAG_CLIP_TO_PADDING;
                this.mGroupFlags |= ViewGroup.FLAG_ANIMATION_DONE;
                this.mGroupFlags |= ViewGroup.FLAG_ANIMATION_CACHE;
                this.mGroupFlags |= ViewGroup.FLAG_ALWAYS_DRAWN_WITH_CACHE;
                this.mGroupFlags |= ViewGroup.FLAG_SPLIT_MOTION_EVENTS;
                this.setDescendantFocusability(ViewGroup.FOCUS_BEFORE_DESCENDANTS);
                this.mPersistentDrawingCache = ViewGroup.PERSISTENT_SCROLLING_CACHE;
            }
            getDescendantFocusability() {
                return this.mGroupFlags & ViewGroup.FLAG_MASK_FOCUSABILITY;
            }
            setDescendantFocusability(focusability) {
                switch (focusability) {
                    case ViewGroup.FOCUS_BEFORE_DESCENDANTS:
                    case ViewGroup.FOCUS_AFTER_DESCENDANTS:
                    case ViewGroup.FOCUS_BLOCK_DESCENDANTS:
                        break;
                    default:
                        throw new Error("must be one of FOCUS_BEFORE_DESCENDANTS, "
                            + "FOCUS_AFTER_DESCENDANTS, FOCUS_BLOCK_DESCENDANTS");
                }
                this.mGroupFlags &= ~ViewGroup.FLAG_MASK_FOCUSABILITY;
                this.mGroupFlags |= (focusability & ViewGroup.FLAG_MASK_FOCUSABILITY);
            }
            handleFocusGainInternal(direction, previouslyFocusedRect) {
                if (this.mFocused != null) {
                    this.mFocused.unFocus();
                    this.mFocused = null;
                }
                super.handleFocusGainInternal(direction, previouslyFocusedRect);
            }
            requestChildFocus(child, focused) {
                if (view_4.View.DBG) {
                    System.out.println(this + " requestChildFocus()");
                }
                if (this.getDescendantFocusability() == ViewGroup.FOCUS_BLOCK_DESCENDANTS) {
                    return;
                }
                super.unFocus();
                if (this.mFocused != child) {
                    if (this.mFocused != null) {
                        this.mFocused.unFocus();
                    }
                    this.mFocused = child;
                }
                if (this.mParent != null) {
                    this.mParent.requestChildFocus(this, focused);
                }
            }
            focusableViewAvailable(v) {
                if (this.mParent != null
                    && (this.getDescendantFocusability() != ViewGroup.FOCUS_BLOCK_DESCENDANTS)
                    && !(this.isFocused() && this.getDescendantFocusability() != ViewGroup.FOCUS_AFTER_DESCENDANTS)) {
                    this.mParent.focusableViewAvailable(v);
                }
            }
            focusSearch(...args) {
                if (arguments.length === 1) {
                    return super.focusSearch(args[0]);
                }
                let [focused, direction] = args;
                if (this.isRootNamespace()) {
                    return view_4.FocusFinder.getInstance().findNextFocus(this, focused, direction);
                }
                else if (this.mParent != null) {
                    return this.mParent.focusSearch(focused, direction);
                }
                return null;
            }
            requestChildRectangleOnScreen(child, rectangle, immediate) {
                return false;
            }
            childHasTransientStateChanged(child, childHasTransientState) {
                const oldHasTransientState = this.hasTransientState();
                if (childHasTransientState) {
                    this.mChildCountWithTransientState++;
                }
                else {
                    this.mChildCountWithTransientState--;
                }
                const newHasTransientState = this.hasTransientState();
                if (this.mParent != null && oldHasTransientState != newHasTransientState) {
                    this.mParent.childHasTransientStateChanged(this, newHasTransientState);
                }
            }
            hasTransientState() {
                return this.mChildCountWithTransientState > 0 || super.hasTransientState();
            }
            dispatchUnhandledMove(focused, direction) {
                return this.mFocused != null && this.mFocused.dispatchUnhandledMove(focused, direction);
            }
            clearChildFocus(child) {
                if (view_4.View.DBG) {
                    System.out.println(this + " clearChildFocus()");
                }
                this.mFocused = null;
                if (this.mParent != null) {
                    this.mParent.clearChildFocus(this);
                }
            }
            clearFocus() {
                if (view_4.View.DBG) {
                    System.out.println(this + " clearFocus()");
                }
                if (this.mFocused == null) {
                    super.clearFocus();
                }
                else {
                    let focused = this.mFocused;
                    this.mFocused = null;
                    focused.clearFocus();
                }
            }
            unFocus() {
                if (view_4.View.DBG) {
                    System.out.println(this + " unFocus()");
                }
                if (this.mFocused == null) {
                    super.unFocus();
                }
                else {
                    this.mFocused.unFocus();
                    this.mFocused = null;
                }
            }
            getFocusedChild() {
                return this.mFocused;
            }
            hasFocus() {
                return (this.mPrivateFlags & view_4.View.PFLAG_FOCUSED) != 0 || this.mFocused != null;
            }
            findFocus() {
                if (ViewGroup.DBG) {
                    System.out.println("Find focus in " + this + ": flags=" + this.isFocused() + ", child=" + this.mFocused);
                }
                if (this.isFocused()) {
                    return this;
                }
                if (this.mFocused != null) {
                    return this.mFocused.findFocus();
                }
                return null;
            }
            hasFocusable() {
                if ((this.mViewFlags & view_4.View.VISIBILITY_MASK) != view_4.View.VISIBLE) {
                    return false;
                }
                if (this.isFocusable()) {
                    return true;
                }
                const descendantFocusability = this.getDescendantFocusability();
                if (descendantFocusability != ViewGroup.FOCUS_BLOCK_DESCENDANTS) {
                    const count = this.mChildrenCount;
                    const children = this.mChildren;
                    for (let i = 0; i < count; i++) {
                        const child = children[i];
                        if (child.hasFocusable()) {
                            return true;
                        }
                    }
                }
                return false;
            }
            addFocusables(views, direction, focusableMode = view_4.View.FOCUSABLES_TOUCH_MODE) {
                const focusableCount = views.size();
                const descendantFocusability = this.getDescendantFocusability();
                if (descendantFocusability != ViewGroup.FOCUS_BLOCK_DESCENDANTS) {
                    const count = this.mChildrenCount;
                    const children = this.mChildren;
                    for (let i = 0; i < count; i++) {
                        const child = children[i];
                        if ((child.mViewFlags & view_4.View.VISIBILITY_MASK) == view_4.View.VISIBLE) {
                            child.addFocusables(views, direction, focusableMode);
                        }
                    }
                }
                if (descendantFocusability != ViewGroup.FOCUS_AFTER_DESCENDANTS
                    || (focusableCount == views.size())) {
                    super.addFocusables(views, direction, focusableMode);
                }
            }
            requestFocus(direction, previouslyFocusedRect) {
                if (view_4.View.DBG) {
                    System.out.println(this + " ViewGroup.requestFocus direction="
                        + direction);
                }
                let descendantFocusability = this.getDescendantFocusability();
                switch (descendantFocusability) {
                    case ViewGroup.FOCUS_BLOCK_DESCENDANTS:
                        return super.requestFocus(direction, previouslyFocusedRect);
                    case ViewGroup.FOCUS_BEFORE_DESCENDANTS: {
                        const took = super.requestFocus(direction, previouslyFocusedRect);
                        return took ? took : this.onRequestFocusInDescendants(direction, previouslyFocusedRect);
                    }
                    case ViewGroup.FOCUS_AFTER_DESCENDANTS: {
                        const took = this.onRequestFocusInDescendants(direction, previouslyFocusedRect);
                        return took ? took : super.requestFocus(direction, previouslyFocusedRect);
                    }
                    default:
                        throw new Error("descendant focusability must be "
                            + "one of FOCUS_BEFORE_DESCENDANTS, FOCUS_AFTER_DESCENDANTS, FOCUS_BLOCK_DESCENDANTS "
                            + "but is " + descendantFocusability);
                }
            }
            onRequestFocusInDescendants(direction, previouslyFocusedRect) {
                let index;
                let increment;
                let end;
                let count = this.mChildrenCount;
                if ((direction & view_4.View.FOCUS_FORWARD) != 0) {
                    index = 0;
                    increment = 1;
                    end = count;
                }
                else {
                    index = count - 1;
                    increment = -1;
                    end = -1;
                }
                const children = this.mChildren;
                for (let i = index; i != end; i += increment) {
                    let child = children[i];
                    if ((child.mViewFlags & view_4.View.VISIBILITY_MASK) == view_4.View.VISIBLE) {
                        if (child.requestFocus(direction, previouslyFocusedRect)) {
                            return true;
                        }
                    }
                }
                return false;
            }
            addView(...args) {
                let child = args[0];
                let params = child.getLayoutParams();
                let index = -1;
                if (args.length == 2) {
                    if (args[1] instanceof ViewGroup.LayoutParams)
                        params = args[1];
                    else
                        index = args[1];
                }
                else if (args.length == 3) {
                    if (args[2] instanceof ViewGroup.LayoutParams) {
                        index = args[1];
                        params = args[2];
                    }
                    else {
                        params = this.generateDefaultLayoutParams();
                        params.width = args[1];
                        params.height = args[2];
                    }
                }
                if (params == null) {
                    params = this.generateDefaultLayoutParams();
                    if (params == null) {
                        throw new Error("generateDefaultLayoutParams() cannot return null");
                    }
                }
                this.requestLayout();
                this.invalidate(true);
                this.addViewInner(child, index, params, false);
            }
            checkLayoutParams(p) {
                return p != null;
            }
            setOnHierarchyChangeListener(listener) {
                this.mOnHierarchyChangeListener = listener;
            }
            onViewAdded(child) {
                if (this.mOnHierarchyChangeListener != null) {
                    this.mOnHierarchyChangeListener.onChildViewAdded(this, child);
                }
            }
            onViewRemoved(child) {
                if (this.mOnHierarchyChangeListener != null) {
                    this.mOnHierarchyChangeListener.onChildViewRemoved(this, child);
                }
            }
            clearCachedLayoutMode() {
                if (!this.hasBooleanFlag(ViewGroup.FLAG_LAYOUT_MODE_WAS_EXPLICITLY_SET)) {
                    this.mLayoutMode = ViewGroup.LAYOUT_MODE_UNDEFINED;
                }
            }
            addViewInLayout(child, index, params, preventRequestLayout = false) {
                child.mParent = null;
                this.addViewInner(child, index, params, preventRequestLayout);
                child.mPrivateFlags = (child.mPrivateFlags & ~ViewGroup.PFLAG_DIRTY_MASK) | ViewGroup.PFLAG_DRAWN;
                return true;
            }
            cleanupLayoutState(child) {
                child.mPrivateFlags &= ~view_4.View.PFLAG_FORCE_LAYOUT;
            }
            addViewInner(child, index, params, preventRequestLayout) {
                if (child.getParent() != null) {
                    throw new Error("The specified child already has a parent. " +
                        "You must call removeView() on the child's parent first.");
                }
                if (!this.checkLayoutParams(params)) {
                    params = this.generateLayoutParams(params);
                }
                if (preventRequestLayout) {
                    child.mLayoutParams = params;
                }
                else {
                    child.setLayoutParams(params);
                }
                if (index < 0) {
                    index = this.mChildrenCount;
                }
                this.addInArray(child, index);
                if (preventRequestLayout) {
                    child.assignParent(this);
                }
                else {
                    child.mParent = this;
                }
                if (child.hasFocus()) {
                    this.requestChildFocus(child, child.findFocus());
                }
                let ai = this.mAttachInfo;
                if (ai != null && (this.mGroupFlags & ViewGroup.FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW) == 0) {
                    child.dispatchAttachedToWindow(this.mAttachInfo, (this.mViewFlags & ViewGroup.VISIBILITY_MASK));
                }
                this.onViewAdded(child);
                if ((child.mViewFlags & ViewGroup.DUPLICATE_PARENT_STATE) == ViewGroup.DUPLICATE_PARENT_STATE) {
                    this.mGroupFlags |= ViewGroup.FLAG_NOTIFY_CHILDREN_ON_DRAWABLE_STATE_CHANGE;
                }
            }
            addInArray(child, index) {
                let count = this.mChildrenCount;
                if (index == count) {
                    this.mChildren.push(child);
                    this.addToBindElement(child.bindElement, null);
                }
                else if (index < count) {
                    let refChild = this.getChildAt(index);
                    this.mChildren.splice(index, 0, child);
                    this.addToBindElement(child.bindElement, refChild.bindElement);
                }
                else {
                    throw new Error("index=" + index + " count=" + count);
                }
            }
            addToBindElement(childElement, insertBeforeElement) {
                if (childElement.parentElement) {
                    if (childElement.parentElement == this.bindElement)
                        return;
                    childElement.parentElement.removeChild(childElement);
                }
                if (insertBeforeElement) {
                    this.bindElement.insertBefore(childElement, insertBeforeElement);
                }
                else {
                    this.bindElement.appendChild(childElement);
                }
            }
            removeChildElement(childElement) {
                try {
                    this.bindElement.removeChild(childElement);
                }
                catch (e) {
                }
            }
            removeFromArray(index, count = 1) {
                let start = Math.max(0, index);
                let end = Math.min(this.mChildrenCount, start + count);
                if (start == end) {
                    return;
                }
                for (let i = start; i < end; i++) {
                    this.mChildren[i].mParent = null;
                    this.removeChildElement(this.mChildren[i].bindElement);
                }
                this.mChildren.splice(index, end - start);
            }
            removeView(view) {
                this.removeViewInternal(view);
                this.requestLayout();
                this.invalidate(true);
            }
            removeViewInLayout(view) {
                this.removeViewInternal(view);
            }
            removeViewsInLayout(start, count) {
                this.removeViewsInternal(start, count);
            }
            removeViewAt(index) {
                this.removeViewsInternal(index, 1);
                this.requestLayout();
                this.invalidate(true);
            }
            removeViews(start, count) {
                this.removeViewsInternal(start, count);
                this.requestLayout();
                this.invalidate(true);
            }
            removeViewInternal(view) {
                let index = this.indexOfChild(view);
                if (index >= 0) {
                    this.removeViewsInternal(index, 1);
                }
            }
            removeViewsInternal(start, count) {
                let focused = this.mFocused;
                let clearChildFocus = false;
                const detach = this.mAttachInfo != null;
                const children = this.mChildren;
                const end = start + count;
                for (let i = start; i < end; i++) {
                    const view = children[i];
                    if (view == focused) {
                        view.unFocus();
                        clearChildFocus = true;
                    }
                    this.cancelTouchTarget(view);
                    if (detach) {
                        view.dispatchDetachedFromWindow();
                    }
                    this.onViewRemoved(view);
                }
                this.removeFromArray(start, count);
                if (clearChildFocus) {
                    this.clearChildFocus(focused);
                    if (!this.rootViewRequestFocus()) {
                        this.notifyGlobalFocusCleared(focused);
                    }
                }
            }
            removeAllViews() {
                this.removeAllViewsInLayout();
                this.requestLayout();
                this.invalidate(true);
            }
            removeAllViewsInLayout() {
                const count = this.mChildrenCount;
                if (count <= 0) {
                    return;
                }
                this.removeViewsInternal(0, count);
            }
            detachViewFromParent(child) {
                if (child instanceof view_4.View)
                    child = this.indexOfChild(child);
                this.removeFromArray(child);
            }
            removeDetachedView(child, animate) {
                if (child == this.mFocused) {
                    child.clearFocus();
                }
                this.cancelTouchTarget(child);
                if ((animate && child.getAnimation() != null)) {
                }
                else if (child.mAttachInfo != null) {
                    child.dispatchDetachedFromWindow();
                }
                if (child.hasTransientState()) {
                    this.childHasTransientStateChanged(child, false);
                }
                this.onViewRemoved(child);
            }
            attachViewToParent(child, index, params) {
                child.mLayoutParams = params;
                if (index < 0) {
                    index = this.mChildrenCount;
                }
                this.addInArray(child, index);
                child.mParent = this;
                child.mPrivateFlags = (child.mPrivateFlags & ~ViewGroup.PFLAG_DIRTY_MASK & ~ViewGroup.PFLAG_DRAWING_CACHE_VALID) | ViewGroup.PFLAG_DRAWN | ViewGroup.PFLAG_INVALIDATED;
                this.mPrivateFlags |= ViewGroup.PFLAG_INVALIDATED;
                if (child.hasFocus()) {
                    this.requestChildFocus(child, child.findFocus());
                }
            }
            detachViewsFromParent(start, count = 1) {
                this.removeFromArray(start, count);
            }
            detachAllViewsFromParent() {
                const count = this.mChildrenCount;
                if (count <= 0) {
                    return;
                }
                const children = this.mChildren;
                this.mChildren = [];
                for (let i = count - 1; i >= 0; i--) {
                    children[i].mParent = null;
                    this.removeChildElement(children[i].bindElement);
                }
            }
            indexOfChild(child) {
                return this.mChildren.indexOf(child);
            }
            getChildCount() {
                return this.mChildrenCount;
            }
            getChildAt(index) {
                if (index < 0 || index >= this.mChildrenCount) {
                    return null;
                }
                return this.mChildren[index];
            }
            bringChildToFront(child) {
                let index = this.indexOfChild(child);
                if (index >= 0) {
                    this.removeFromArray(index);
                    this.addInArray(child, this.mChildrenCount);
                    child.mParent = this;
                    this.requestLayout();
                    this.invalidate();
                }
            }
            hasBooleanFlag(flag) {
                return (this.mGroupFlags & flag) == flag;
            }
            setBooleanFlag(flag, value) {
                if (value) {
                    this.mGroupFlags |= flag;
                }
                else {
                    this.mGroupFlags &= ~flag;
                }
            }
            dispatchGenericPointerEvent(event) {
                const childrenCount = this.mChildrenCount;
                if (childrenCount != 0) {
                    const children = this.mChildren;
                    const x = event.getX();
                    const y = event.getY();
                    const customOrder = this.isChildrenDrawingOrderEnabled();
                    for (let i = childrenCount - 1; i >= 0; i--) {
                        const childIndex = customOrder ? this.getChildDrawingOrder(childrenCount, i) : i;
                        const child = children[childIndex];
                        if (!ViewGroup.canViewReceivePointerEvents(child)
                            || !this.isTransformedTouchPointInView(x, y, child, null)) {
                            continue;
                        }
                        if (this.dispatchTransformedGenericPointerEvent(event, child)) {
                            return true;
                        }
                    }
                }
                return super.dispatchGenericPointerEvent(event);
            }
            dispatchTransformedGenericPointerEvent(event, child) {
                const offsetX = this.mScrollX - child.mLeft;
                const offsetY = this.mScrollY - child.mTop;
                let handled;
                if (!child.hasIdentityMatrix()) {
                }
                else {
                    event.offsetLocation(offsetX, offsetY);
                    handled = child.dispatchGenericMotionEvent(event);
                    event.offsetLocation(-offsetX, -offsetY);
                }
                return handled;
            }
            dispatchKeyEvent(event) {
                if ((this.mPrivateFlags & (view_4.View.PFLAG_FOCUSED | view_4.View.PFLAG_HAS_BOUNDS))
                    == (view_4.View.PFLAG_FOCUSED | view_4.View.PFLAG_HAS_BOUNDS)) {
                    if (super.dispatchKeyEvent(event)) {
                        return true;
                    }
                }
                else if (this.mFocused != null && (this.mFocused.mPrivateFlags & view_4.View.PFLAG_HAS_BOUNDS)
                    == view_4.View.PFLAG_HAS_BOUNDS) {
                    if (this.mFocused.dispatchKeyEvent(event)) {
                        return true;
                    }
                }
                return false;
            }
            dispatchWindowFocusChanged(hasFocus) {
                super.dispatchWindowFocusChanged(hasFocus);
                const count = this.mChildrenCount;
                const children = this.mChildren;
                for (let i = 0; i < count; i++) {
                    children[i].dispatchWindowFocusChanged(hasFocus);
                }
            }
            addTouchables(views) {
                super.addTouchables(views);
                const count = this.mChildrenCount;
                const children = this.mChildren;
                for (let i = 0; i < count; i++) {
                    const child = children[i];
                    if ((child.mViewFlags & view_4.View.VISIBILITY_MASK) == view_4.View.VISIBLE) {
                        child.addTouchables(views);
                    }
                }
            }
            onInterceptTouchEvent(ev) {
                return false;
            }
            dispatchTouchEvent(ev) {
                let handled = false;
                if (this.onFilterTouchEventForSecurity(ev)) {
                    let action = ev.getAction();
                    let actionMasked = action & view_4.MotionEvent.ACTION_MASK;
                    if (actionMasked == view_4.MotionEvent.ACTION_DOWN) {
                        this.cancelAndClearTouchTargets(ev);
                        this.resetTouchState();
                    }
                    let intercepted;
                    if (actionMasked == view_4.MotionEvent.ACTION_DOWN
                        || this.mFirstTouchTarget != null) {
                        let disallowIntercept = (this.mGroupFlags & ViewGroup.FLAG_DISALLOW_INTERCEPT) != 0;
                        if (!disallowIntercept) {
                            intercepted = this.onInterceptTouchEvent(ev);
                            ev.setAction(action);
                        }
                        else {
                            intercepted = false;
                        }
                    }
                    else {
                        intercepted = true;
                    }
                    let canceled = ViewGroup.resetCancelNextUpFlag(this)
                        || actionMasked == view_4.MotionEvent.ACTION_CANCEL;
                    let split = (this.mGroupFlags & ViewGroup.FLAG_SPLIT_MOTION_EVENTS) != 0;
                    let newTouchTarget = null;
                    let alreadyDispatchedToNewTouchTarget = false;
                    if (!canceled && !intercepted) {
                        if (actionMasked == view_4.MotionEvent.ACTION_DOWN
                            || (split && actionMasked == view_4.MotionEvent.ACTION_POINTER_DOWN)
                            || actionMasked == view_4.MotionEvent.ACTION_HOVER_MOVE) {
                            let actionIndex = ev.getActionIndex();
                            let idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex)
                                : TouchTarget.ALL_POINTER_IDS;
                            this.removePointersFromTouchTargets(idBitsToAssign);
                            let childrenCount = this.mChildrenCount;
                            if (newTouchTarget == null && childrenCount != 0) {
                                let x = ev.getX(actionIndex);
                                let y = ev.getY(actionIndex);
                                let children = this.mChildren;
                                let customOrder = this.isChildrenDrawingOrderEnabled();
                                for (let i = childrenCount - 1; i >= 0; i--) {
                                    let childIndex = customOrder ? this.getChildDrawingOrder(childrenCount, i) : i;
                                    let child = children[childIndex];
                                    if (!ViewGroup.canViewReceivePointerEvents(child)
                                        || !this.isTransformedTouchPointInView(x, y, child, null)) {
                                        continue;
                                    }
                                    newTouchTarget = this.getTouchTarget(child);
                                    if (newTouchTarget != null) {
                                        newTouchTarget.pointerIdBits |= idBitsToAssign;
                                        break;
                                    }
                                    ViewGroup.resetCancelNextUpFlag(child);
                                    if (this.dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                                        this.mLastTouchDownTime = ev.getDownTime();
                                        this.mLastTouchDownIndex = childIndex;
                                        this.mLastTouchDownX = ev.getX();
                                        this.mLastTouchDownY = ev.getY();
                                        newTouchTarget = this.addTouchTarget(child, idBitsToAssign);
                                        alreadyDispatchedToNewTouchTarget = true;
                                        break;
                                    }
                                }
                            }
                            if (newTouchTarget == null && this.mFirstTouchTarget != null) {
                                newTouchTarget = this.mFirstTouchTarget;
                                while (newTouchTarget.next != null) {
                                    newTouchTarget = newTouchTarget.next;
                                }
                                newTouchTarget.pointerIdBits |= idBitsToAssign;
                            }
                        }
                    }
                    if (this.mFirstTouchTarget == null) {
                        handled = this.dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);
                    }
                    else {
                        let predecessor = null;
                        let target = this.mFirstTouchTarget;
                        while (target != null) {
                            const next = target.next;
                            if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {
                                handled = true;
                            }
                            else {
                                let cancelChild = ViewGroup.resetCancelNextUpFlag(target.child)
                                    || intercepted;
                                if (this.dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) {
                                    handled = true;
                                }
                                if (cancelChild) {
                                    if (predecessor == null) {
                                        this.mFirstTouchTarget = next;
                                    }
                                    else {
                                        predecessor.next = next;
                                    }
                                    target.recycle();
                                    target = next;
                                    continue;
                                }
                            }
                            predecessor = target;
                            target = next;
                        }
                    }
                    if (canceled
                        || actionMasked == view_4.MotionEvent.ACTION_UP
                        || actionMasked == view_4.MotionEvent.ACTION_HOVER_MOVE) {
                        this.resetTouchState();
                    }
                    else if (split && actionMasked == view_4.MotionEvent.ACTION_POINTER_UP) {
                        let actionIndex = ev.getActionIndex();
                        let idBitsToRemove = 1 << ev.getPointerId(actionIndex);
                        this.removePointersFromTouchTargets(idBitsToRemove);
                    }
                }
                return handled;
            }
            resetTouchState() {
                this.clearTouchTargets();
                ViewGroup.resetCancelNextUpFlag(this);
                this.mGroupFlags &= ~ViewGroup.FLAG_DISALLOW_INTERCEPT;
            }
            static resetCancelNextUpFlag(view) {
                if ((view.mPrivateFlags & view_4.View.PFLAG_CANCEL_NEXT_UP_EVENT) != 0) {
                    view.mPrivateFlags &= ~view_4.View.PFLAG_CANCEL_NEXT_UP_EVENT;
                    return true;
                }
                return false;
            }
            clearTouchTargets() {
                let target = this.mFirstTouchTarget;
                if (target != null) {
                    do {
                        let next = target.next;
                        target.recycle();
                        target = next;
                    } while (target != null);
                    this.mFirstTouchTarget = null;
                }
            }
            cancelAndClearTouchTargets(event) {
                if (this.mFirstTouchTarget != null) {
                    let syntheticEvent = false;
                    if (event == null) {
                        let now = SystemClock.uptimeMillis();
                        event = view_4.MotionEvent.obtainWithAction(now, now, view_4.MotionEvent.ACTION_CANCEL, 0, 0);
                        syntheticEvent = true;
                    }
                    for (let target = this.mFirstTouchTarget; target != null; target = target.next) {
                        ViewGroup.resetCancelNextUpFlag(target.child);
                        this.dispatchTransformedTouchEvent(event, true, target.child, target.pointerIdBits);
                    }
                    this.clearTouchTargets();
                    if (syntheticEvent) {
                        event.recycle();
                    }
                }
            }
            getTouchTarget(child) {
                for (let target = this.mFirstTouchTarget; target != null; target = target.next) {
                    if (target.child == child) {
                        return target;
                    }
                }
                return null;
            }
            addTouchTarget(child, pointerIdBits) {
                let target = TouchTarget.obtain(child, pointerIdBits);
                target.next = this.mFirstTouchTarget;
                this.mFirstTouchTarget = target;
                return target;
            }
            removePointersFromTouchTargets(pointerIdBits) {
                let predecessor = null;
                let target = this.mFirstTouchTarget;
                while (target != null) {
                    let next = target.next;
                    if ((target.pointerIdBits & pointerIdBits) != 0) {
                        target.pointerIdBits &= ~pointerIdBits;
                        if (target.pointerIdBits == 0) {
                            if (predecessor == null) {
                                this.mFirstTouchTarget = next;
                            }
                            else {
                                predecessor.next = next;
                            }
                            target.recycle();
                            target = next;
                            continue;
                        }
                    }
                    predecessor = target;
                    target = next;
                }
            }
            cancelTouchTarget(view) {
                let predecessor = null;
                let target = this.mFirstTouchTarget;
                while (target != null) {
                    let next = target.next;
                    if (target.child == view) {
                        if (predecessor == null) {
                            this.mFirstTouchTarget = next;
                        }
                        else {
                            predecessor.next = next;
                        }
                        target.recycle();
                        let now = SystemClock.uptimeMillis();
                        let event = view_4.MotionEvent.obtainWithAction(now, now, view_4.MotionEvent.ACTION_CANCEL, 0, 0);
                        view.dispatchTouchEvent(event);
                        event.recycle();
                        return;
                    }
                    predecessor = target;
                    target = next;
                }
            }
            static canViewReceivePointerEvents(child) {
                return (child.mViewFlags & view_4.View.VISIBILITY_MASK) == view_4.View.VISIBLE;
            }
            isTransformedTouchPointInView(x, y, child, outLocalPoint) {
                let localX = x + this.mScrollX - child.mLeft;
                let localY = y + this.mScrollY - child.mTop;
                let isInView = child.pointInView(localX, localY);
                if (isInView && outLocalPoint != null) {
                    outLocalPoint.set(localX, localY);
                }
                return isInView;
            }
            dispatchTransformedTouchEvent(event, cancel, child, desiredPointerIdBits) {
                let handled;
                const oldAction = event.getAction();
                if (cancel || oldAction == view_4.MotionEvent.ACTION_CANCEL) {
                    event.setAction(view_4.MotionEvent.ACTION_CANCEL);
                    if (child == null) {
                        handled = super.dispatchTouchEvent(event);
                    }
                    else {
                        handled = child.dispatchTouchEvent(event);
                    }
                    event.setAction(oldAction);
                    return handled;
                }
                const oldPointerIdBits = event.getPointerIdBits();
                const newPointerIdBits = oldPointerIdBits & desiredPointerIdBits;
                if (newPointerIdBits == 0) {
                    return false;
                }
                let transformedEvent;
                if (newPointerIdBits == oldPointerIdBits) {
                    if (child == null || child.hasIdentityMatrix()) {
                        if (child == null) {
                            handled = super.dispatchTouchEvent(event);
                        }
                        else {
                            let offsetX = this.mScrollX - child.mLeft;
                            let offsetY = this.mScrollY - child.mTop;
                            event.offsetLocation(offsetX, offsetY);
                            handled = child.dispatchTouchEvent(event);
                            event.offsetLocation(-offsetX, -offsetY);
                        }
                        return handled;
                    }
                    transformedEvent = view_4.MotionEvent.obtain(event);
                }
                else {
                    transformedEvent = event.split(newPointerIdBits);
                }
                if (child == null) {
                    handled = super.dispatchTouchEvent(transformedEvent);
                }
                else {
                    let offsetX = this.mScrollX - child.mLeft;
                    let offsetY = this.mScrollY - child.mTop;
                    transformedEvent.offsetLocation(offsetX, offsetY);
                    handled = child.dispatchTouchEvent(transformedEvent);
                }
                transformedEvent.recycle();
                return handled;
            }
            isAlwaysDrawnWithCacheEnabled() {
                return (this.mGroupFlags & ViewGroup.FLAG_ALWAYS_DRAWN_WITH_CACHE) == ViewGroup.FLAG_ALWAYS_DRAWN_WITH_CACHE;
            }
            setAlwaysDrawnWithCacheEnabled(always) {
                this.setBooleanFlag(ViewGroup.FLAG_ALWAYS_DRAWN_WITH_CACHE, always);
            }
            isChildrenDrawnWithCacheEnabled() {
                return (this.mGroupFlags & ViewGroup.FLAG_CHILDREN_DRAWN_WITH_CACHE) == ViewGroup.FLAG_CHILDREN_DRAWN_WITH_CACHE;
            }
            setChildrenDrawnWithCacheEnabled(enabled) {
                this.setBooleanFlag(ViewGroup.FLAG_CHILDREN_DRAWN_WITH_CACHE, enabled);
            }
            setChildrenDrawingCacheEnabled(enabled) {
                if (enabled || (this.mPersistentDrawingCache & ViewGroup.PERSISTENT_ALL_CACHES) != ViewGroup.PERSISTENT_ALL_CACHES) {
                    const children = this.mChildren;
                    const count = this.mChildrenCount;
                    for (let i = 0; i < count; i++) {
                        children[i].setDrawingCacheEnabled(enabled);
                    }
                }
            }
            getPersistentDrawingCache() {
                return this.mPersistentDrawingCache;
            }
            setPersistentDrawingCache(drawingCacheToKeep) {
                this.mPersistentDrawingCache = drawingCacheToKeep & ViewGroup.PERSISTENT_ALL_CACHES;
            }
            isChildrenDrawingOrderEnabled() {
                return (this.mGroupFlags & ViewGroup.FLAG_USE_CHILD_DRAWING_ORDER) == ViewGroup.FLAG_USE_CHILD_DRAWING_ORDER;
            }
            setChildrenDrawingOrderEnabled(enabled) {
                this.setBooleanFlag(ViewGroup.FLAG_USE_CHILD_DRAWING_ORDER, enabled);
            }
            getChildDrawingOrder(childCount, i) {
                return i;
            }
            generateLayoutParams(p) {
                return p;
            }
            generateDefaultLayoutParams() {
                return new ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
            }
            measureChildren(widthMeasureSpec, heightMeasureSpec) {
                const size = this.mChildren.length;
                for (let i = 0; i < size; ++i) {
                    const child = this.mChildren[i];
                    if ((child.mViewFlags & view_4.View.VISIBILITY_MASK) != view_4.View.GONE) {
                        this.measureChild(child, widthMeasureSpec, heightMeasureSpec);
                    }
                }
            }
            measureChild(child, parentWidthMeasureSpec, parentHeightMeasureSpec) {
                let lp = child.getLayoutParams();
                lp._measuringParentWidthMeasureSpec = parentWidthMeasureSpec;
                lp._measuringParentHeightMeasureSpec = parentHeightMeasureSpec;
                const childWidthMeasureSpec = ViewGroup.getChildMeasureSpec(parentWidthMeasureSpec, this.mPaddingLeft + this.mPaddingRight, lp.width);
                const childHeightMeasureSpec = ViewGroup.getChildMeasureSpec(parentHeightMeasureSpec, this.mPaddingTop + this.mPaddingBottom, lp.height);
                child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
                lp._measuringParentWidthMeasureSpec = null;
                lp._measuringParentHeightMeasureSpec = null;
            }
            measureChildWithMargins(child, parentWidthMeasureSpec, widthUsed, parentHeightMeasureSpec, heightUsed) {
                let lp = child.getLayoutParams();
                lp._measuringParentWidthMeasureSpec = parentWidthMeasureSpec;
                lp._measuringParentHeightMeasureSpec = parentHeightMeasureSpec;
                if (lp instanceof ViewGroup.MarginLayoutParams) {
                    const childWidthMeasureSpec = ViewGroup.getChildMeasureSpec(parentWidthMeasureSpec, this.mPaddingLeft + this.mPaddingRight + lp.leftMargin + lp.rightMargin
                        + widthUsed, lp.width);
                    const childHeightMeasureSpec = ViewGroup.getChildMeasureSpec(parentHeightMeasureSpec, this.mPaddingTop + this.mPaddingBottom + lp.topMargin + lp.bottomMargin
                        + heightUsed, lp.height);
                    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
                }
                lp._measuringParentWidthMeasureSpec = null;
                lp._measuringParentHeightMeasureSpec = null;
            }
            static getChildMeasureSpec(spec, padding, childDimension) {
                let MeasureSpec = view_4.View.MeasureSpec;
                let specMode = MeasureSpec.getMode(spec);
                let specSize = MeasureSpec.getSize(spec);
                let size = Math.max(0, specSize - padding);
                let resultSize = 0;
                let resultMode = 0;
                switch (specMode) {
                    case MeasureSpec.EXACTLY:
                        if (childDimension >= 0) {
                            resultSize = childDimension;
                            resultMode = MeasureSpec.EXACTLY;
                        }
                        else if (childDimension == ViewGroup.LayoutParams.MATCH_PARENT) {
                            resultSize = size;
                            resultMode = MeasureSpec.EXACTLY;
                        }
                        else if (childDimension == ViewGroup.LayoutParams.WRAP_CONTENT) {
                            resultSize = size;
                            resultMode = MeasureSpec.AT_MOST;
                        }
                        break;
                    case MeasureSpec.AT_MOST:
                        if (childDimension >= 0) {
                            resultSize = childDimension;
                            resultMode = MeasureSpec.EXACTLY;
                        }
                        else if (childDimension == ViewGroup.LayoutParams.MATCH_PARENT) {
                            resultSize = size;
                            resultMode = MeasureSpec.AT_MOST;
                        }
                        else if (childDimension == ViewGroup.LayoutParams.WRAP_CONTENT) {
                            resultSize = size;
                            resultMode = MeasureSpec.AT_MOST;
                        }
                        break;
                    case MeasureSpec.UNSPECIFIED:
                        if (childDimension >= 0) {
                            resultSize = childDimension;
                            resultMode = MeasureSpec.EXACTLY;
                        }
                        else if (childDimension == ViewGroup.LayoutParams.MATCH_PARENT) {
                            resultSize = 0;
                            resultMode = MeasureSpec.UNSPECIFIED;
                        }
                        else if (childDimension == ViewGroup.LayoutParams.WRAP_CONTENT) {
                            resultSize = 0;
                            resultMode = MeasureSpec.UNSPECIFIED;
                        }
                        break;
                }
                return MeasureSpec.makeMeasureSpec(resultSize, resultMode);
            }
            dispatchAttachedToWindow(info, visibility) {
                this.mGroupFlags |= ViewGroup.FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW;
                super.dispatchAttachedToWindow(info, visibility);
                this.mGroupFlags &= ~ViewGroup.FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW;
                const count = this.mChildrenCount;
                const children = this.mChildren;
                for (let i = 0; i < count; i++) {
                    const child = children[i];
                    child.dispatchAttachedToWindow(info, visibility | (child.mViewFlags & view_4.View.VISIBILITY_MASK));
                }
            }
            onAttachedToWindow() {
                super.onAttachedToWindow();
                this.clearCachedLayoutMode();
            }
            onDetachedFromWindow() {
                super.onDetachedFromWindow();
                this.clearCachedLayoutMode();
            }
            dispatchDetachedFromWindow() {
                this.cancelAndClearTouchTargets(null);
                this.mLayoutCalledWhileSuppressed = false;
                this.mChildren.forEach((child) => child.dispatchDetachedFromWindow());
                super.dispatchDetachedFromWindow();
            }
            dispatchDisplayHint(hint) {
                super.dispatchDisplayHint(hint);
                const count = this.mChildrenCount;
                const children = this.mChildren;
                for (let i = 0; i < count; i++) {
                    children[i].dispatchDisplayHint(hint);
                }
            }
            onChildVisibilityChanged(child, oldVisibility, newVisibility) {
            }
            dispatchVisibilityChanged(changedView, visibility) {
                super.dispatchVisibilityChanged(changedView, visibility);
                const count = this.mChildrenCount;
                let children = this.mChildren;
                for (let i = 0; i < count; i++) {
                    children[i].dispatchVisibilityChanged(changedView, visibility);
                }
            }
            dispatchSetSelected(selected) {
                const children = this.mChildren;
                const count = this.mChildrenCount;
                for (let i = 0; i < count; i++) {
                    children[i].setSelected(selected);
                }
            }
            dispatchSetActivated(activated) {
                const children = this.mChildren;
                const count = this.mChildrenCount;
                for (let i = 0; i < count; i++) {
                    children[i].setActivated(activated);
                }
            }
            dispatchSetPressed(pressed) {
                const children = this.mChildren;
                const count = this.mChildrenCount;
                for (let i = 0; i < count; i++) {
                    const child = children[i];
                    if (!pressed || (!child.isClickable() && !child.isLongClickable())) {
                        child.setPressed(pressed);
                    }
                }
            }
            dispatchCancelPendingInputEvents() {
                super.dispatchCancelPendingInputEvents();
                const children = this.mChildren;
                const count = this.mChildrenCount;
                for (let i = 0; i < count; i++) {
                    children[i].dispatchCancelPendingInputEvents();
                }
            }
            offsetDescendantRectToMyCoords(descendant, rect) {
                this.offsetRectBetweenParentAndChild(descendant, rect, true, false);
            }
            offsetRectIntoDescendantCoords(descendant, rect) {
                this.offsetRectBetweenParentAndChild(descendant, rect, false, false);
            }
            offsetRectBetweenParentAndChild(descendant, rect, offsetFromChildToParent, clipToBounds) {
                if (descendant == this) {
                    return;
                }
                let theParent = descendant.mParent;
                while ((theParent != null)
                    && (theParent instanceof view_4.View)
                    && (theParent != this)) {
                    if (offsetFromChildToParent) {
                        rect.offset(descendant.mLeft - descendant.mScrollX, descendant.mTop - descendant.mScrollY);
                        if (clipToBounds) {
                            let p = theParent;
                            rect.intersect(0, 0, p.mRight - p.mLeft, p.mBottom - p.mTop);
                        }
                    }
                    else {
                        if (clipToBounds) {
                            let p = theParent;
                            rect.intersect(0, 0, p.mRight - p.mLeft, p.mBottom - p.mTop);
                        }
                        rect.offset(descendant.mScrollX - descendant.mLeft, descendant.mScrollY - descendant.mTop);
                    }
                    descendant = theParent;
                    theParent = descendant.mParent;
                }
                if (theParent == this) {
                    if (offsetFromChildToParent) {
                        rect.offset(descendant.mLeft - descendant.mScrollX, descendant.mTop - descendant.mScrollY);
                    }
                    else {
                        rect.offset(descendant.mScrollX - descendant.mLeft, descendant.mScrollY - descendant.mTop);
                    }
                }
                else {
                    throw new Error("parameter must be a descendant of this view");
                }
            }
            offsetChildrenTopAndBottom(offset) {
                const count = this.mChildrenCount;
                const children = this.mChildren;
                for (let i = 0; i < count; i++) {
                    const v = children[i];
                    v.mTop += offset;
                    v.mBottom += offset;
                }
                this.invalidateViewProperty(false, false);
            }
            suppressLayout(suppress) {
                this.mSuppressLayout = suppress;
                if (!suppress) {
                    if (this.mLayoutCalledWhileSuppressed) {
                        this.requestLayout();
                        this.mLayoutCalledWhileSuppressed = false;
                    }
                }
            }
            isLayoutSuppressed() {
                return this.mSuppressLayout;
            }
            layout(l, t, r, b) {
                if (!this.mSuppressLayout) {
                    super.layout(l, t, r, b);
                }
                else {
                    this.mLayoutCalledWhileSuppressed = true;
                }
            }
            canAnimate() {
                return false;
            }
            getChildVisibleRect(child, r, offset) {
                const rect = this.mAttachInfo != null ? this.mAttachInfo.mTmpTransformRect : new Rect();
                rect.set(r);
                let dx = child.mLeft - this.mScrollX;
                let dy = child.mTop - this.mScrollY;
                rect.offset(dx, dy);
                if (offset != null) {
                    offset.x += dx;
                    offset.y += dy;
                }
                if (rect.intersect(0, 0, this.mRight - this.mLeft, this.mBottom - this.mTop)) {
                    if (this.mParent == null)
                        return true;
                    r.set(rect);
                    return this.mParent.getChildVisibleRect(this, r, offset);
                }
                return false;
            }
            dispatchDraw(canvas) {
                let count = this.mChildrenCount;
                let children = this.mChildren;
                let flags = this.mGroupFlags;
                let saveCount = 0;
                let clipToPadding = (flags & ViewGroup.CLIP_TO_PADDING_MASK) == ViewGroup.CLIP_TO_PADDING_MASK;
                if (clipToPadding) {
                    saveCount = canvas.save();
                    canvas.clipRect(this.mScrollX + this.mPaddingLeft, this.mScrollY + this.mPaddingTop, this.mScrollX + this.mRight - this.mLeft - this.mPaddingRight, this.mScrollY + this.mBottom - this.mTop - this.mPaddingBottom);
                }
                this.mPrivateFlags &= ~ViewGroup.PFLAG_DRAW_ANIMATION;
                this.mGroupFlags &= ~ViewGroup.FLAG_INVALIDATE_REQUIRED;
                let more = false;
                let drawingTime = this.getDrawingTime();
                let customOrder = this.isChildrenDrawingOrderEnabled();
                for (let i = 0; i < count; i++) {
                    let child = children[customOrder ? this.getChildDrawingOrder(count, i) : i];
                    if ((child.mViewFlags & view_4.View.VISIBILITY_MASK) == view_4.View.VISIBLE) {
                        more = this.drawChild(canvas, child, drawingTime) || more;
                    }
                }
                if (clipToPadding) {
                    canvas.restoreToCount(saveCount);
                }
                flags = this.mGroupFlags;
                if ((flags & ViewGroup.FLAG_INVALIDATE_REQUIRED) == ViewGroup.FLAG_INVALIDATE_REQUIRED) {
                    this.invalidate(true);
                }
            }
            drawChild(canvas, child, drawingTime) {
                return child.drawFromParent(canvas, this, drawingTime);
            }
            drawableStateChanged() {
                super.drawableStateChanged();
                if ((this.mGroupFlags & ViewGroup.FLAG_NOTIFY_CHILDREN_ON_DRAWABLE_STATE_CHANGE) != 0) {
                    if ((this.mGroupFlags & ViewGroup.FLAG_ADD_STATES_FROM_CHILDREN) != 0) {
                        throw new Error("addStateFromChildren cannot be enabled if a"
                            + " child has duplicateParentState set to true");
                    }
                    const children = this.mChildren;
                    const count = this.mChildrenCount;
                    for (let i = 0; i < count; i++) {
                        const child = children[i];
                        if ((child.mViewFlags & view_4.View.DUPLICATE_PARENT_STATE) != 0) {
                            child.refreshDrawableState();
                        }
                    }
                }
            }
            jumpDrawablesToCurrentState() {
                super.jumpDrawablesToCurrentState();
                const children = this.mChildren;
                const count = this.mChildrenCount;
                for (let i = 0; i < count; i++) {
                    children[i].jumpDrawablesToCurrentState();
                }
            }
            onCreateDrawableState(extraSpace) {
                if ((this.mGroupFlags & ViewGroup.FLAG_ADD_STATES_FROM_CHILDREN) == 0) {
                    return super.onCreateDrawableState(extraSpace);
                }
                let need = 0;
                let n = this.getChildCount();
                for (let i = 0; i < n; i++) {
                    let childState = this.getChildAt(i).getDrawableState();
                    if (childState != null) {
                        need += childState.length;
                    }
                }
                let state = super.onCreateDrawableState(extraSpace + need);
                for (let i = 0; i < n; i++) {
                    let childState = this.getChildAt(i).getDrawableState();
                    if (childState != null) {
                        state = view_4.View.mergeDrawableStates(state, childState);
                    }
                }
                return state;
            }
            setAddStatesFromChildren(addsStates) {
                if (addsStates) {
                    this.mGroupFlags |= ViewGroup.FLAG_ADD_STATES_FROM_CHILDREN;
                }
                else {
                    this.mGroupFlags &= ~ViewGroup.FLAG_ADD_STATES_FROM_CHILDREN;
                }
                this.refreshDrawableState();
            }
            addStatesFromChildren() {
                return (this.mGroupFlags & ViewGroup.FLAG_ADD_STATES_FROM_CHILDREN) != 0;
            }
            childDrawableStateChanged(child) {
                if ((this.mGroupFlags & ViewGroup.FLAG_ADD_STATES_FROM_CHILDREN) != 0) {
                    this.refreshDrawableState();
                }
            }
            getClipChildren() {
                return ((this.mGroupFlags & ViewGroup.FLAG_CLIP_CHILDREN) != 0);
            }
            setClipChildren(clipChildren) {
                let previousValue = (this.mGroupFlags & ViewGroup.FLAG_CLIP_CHILDREN) == ViewGroup.FLAG_CLIP_CHILDREN;
                if (clipChildren != previousValue) {
                    this.setBooleanFlag(ViewGroup.FLAG_CLIP_CHILDREN, clipChildren);
                }
            }
            setClipToPadding(clipToPadding) {
                this.setBooleanFlag(ViewGroup.FLAG_CLIP_TO_PADDING, clipToPadding);
            }
            isClipToPadding() {
                return (this.mGroupFlags & ViewGroup.FLAG_CLIP_TO_PADDING) == ViewGroup.FLAG_CLIP_TO_PADDING;
            }
            invalidateChild(child, dirty) {
                let parent = this;
                const attachInfo = this.mAttachInfo;
                if (attachInfo != null) {
                    const drawAnimation = (child.mPrivateFlags & view_4.View.PFLAG_DRAW_ANIMATION)
                        == view_4.View.PFLAG_DRAW_ANIMATION;
                    let childMatrix = child.getMatrix();
                    const isOpaque = child.isOpaque() && !drawAnimation &&
                        child.getAnimation() == null && childMatrix.isIdentity();
                    let opaqueFlag = isOpaque ? view_4.View.PFLAG_DIRTY_OPAQUE : view_4.View.PFLAG_DIRTY;
                    if (child.mLayerType != view_4.View.LAYER_TYPE_NONE) {
                        this.mPrivateFlags |= view_4.View.PFLAG_INVALIDATED;
                        this.mPrivateFlags &= ~view_4.View.PFLAG_DRAWING_CACHE_VALID;
                    }
                    const location = attachInfo.mInvalidateChildLocation;
                    location[0] = child.mLeft;
                    location[1] = child.mTop;
                    do {
                        let view = null;
                        if (parent instanceof view_4.View) {
                            view = parent;
                        }
                        if (view != null) {
                            opaqueFlag = view_4.View.PFLAG_DIRTY;
                            if ((view.mPrivateFlags & view_4.View.PFLAG_DIRTY_MASK) != view_4.View.PFLAG_DIRTY) {
                                view.mPrivateFlags = (view.mPrivateFlags & ~view_4.View.PFLAG_DIRTY_MASK) | opaqueFlag;
                            }
                        }
                        parent = parent.invalidateChildInParent(location, dirty);
                        if (view != null) {
                            let m = view.getMatrix();
                            if (!m.isIdentity()) {
                                let boundingRect = attachInfo.mTmpTransformRect;
                                boundingRect.set(dirty);
                                m.mapRect(boundingRect);
                                dirty.set(boundingRect);
                            }
                        }
                    } while (parent != null);
                }
            }
            invalidateChildInParent(location, dirty) {
                if ((this.mPrivateFlags & view_4.View.PFLAG_DRAWN) == view_4.View.PFLAG_DRAWN ||
                    (this.mPrivateFlags & view_4.View.PFLAG_DRAWING_CACHE_VALID) == view_4.View.PFLAG_DRAWING_CACHE_VALID) {
                    if ((this.mGroupFlags & (ViewGroup.FLAG_OPTIMIZE_INVALIDATE | ViewGroup.FLAG_ANIMATION_DONE)) !=
                        ViewGroup.FLAG_OPTIMIZE_INVALIDATE) {
                        dirty.offset(location[0] - this.mScrollX, location[1] - this.mScrollY);
                        if ((this.mGroupFlags & ViewGroup.FLAG_CLIP_CHILDREN) == 0) {
                            dirty.union(0, 0, this.mRight - this.mLeft, this.mBottom - this.mTop);
                        }
                        const left = this.mLeft;
                        const top = this.mTop;
                        if ((this.mGroupFlags & ViewGroup.FLAG_CLIP_CHILDREN) == ViewGroup.FLAG_CLIP_CHILDREN) {
                            if (!dirty.intersect(0, 0, this.mRight - left, this.mBottom - top)) {
                                dirty.setEmpty();
                            }
                        }
                        this.mPrivateFlags &= ~view_4.View.PFLAG_DRAWING_CACHE_VALID;
                        location[0] = left;
                        location[1] = top;
                        if (this.mLayerType != view_4.View.LAYER_TYPE_NONE) {
                            this.mPrivateFlags |= view_4.View.PFLAG_INVALIDATED;
                        }
                        return this.mParent;
                    }
                    else {
                        this.mPrivateFlags &= ~view_4.View.PFLAG_DRAWN & ~view_4.View.PFLAG_DRAWING_CACHE_VALID;
                        location[0] = this.mLeft;
                        location[1] = this.mTop;
                        if ((this.mGroupFlags & ViewGroup.FLAG_CLIP_CHILDREN) == ViewGroup.FLAG_CLIP_CHILDREN) {
                            dirty.set(0, 0, this.mRight - this.mLeft, this.mBottom - this.mTop);
                        }
                        else {
                            dirty.union(0, 0, this.mRight - this.mLeft, this.mBottom - this.mTop);
                        }
                        if (this.mLayerType != view_4.View.LAYER_TYPE_NONE) {
                            this.mPrivateFlags |= view_4.View.PFLAG_INVALIDATED;
                        }
                        return this.mParent;
                    }
                }
                return null;
            }
            invalidateChildFast(child, dirty) {
                let parent = this;
                const attachInfo = this.mAttachInfo;
                if (attachInfo != null) {
                    let left = child.mLeft;
                    let top = child.mTop;
                    if (!child.getMatrix().isIdentity()) {
                        child.transformRect(dirty);
                    }
                    do {
                        if (parent instanceof ViewGroup) {
                            let parentVG = parent;
                            if (parentVG.mLayerType != view_4.View.LAYER_TYPE_NONE) {
                                parentVG.invalidate();
                                parent = null;
                            }
                            else {
                                parent = parentVG.invalidateChildInParentFast(left, top, dirty);
                                left = parentVG.mLeft;
                                top = parentVG.mTop;
                            }
                        }
                        else {
                            const location = attachInfo.mInvalidateChildLocation;
                            location[0] = left;
                            location[1] = top;
                            parent = parent.invalidateChildInParent(location, dirty);
                        }
                    } while (parent != null);
                }
            }
            invalidateChildInParentFast(left, top, dirty) {
                if ((this.mPrivateFlags & view_4.View.PFLAG_DRAWN) == view_4.View.PFLAG_DRAWN ||
                    (this.mPrivateFlags & view_4.View.PFLAG_DRAWING_CACHE_VALID) == view_4.View.PFLAG_DRAWING_CACHE_VALID) {
                    dirty.offset(left - this.mScrollX, top - this.mScrollY);
                    if ((this.mGroupFlags & ViewGroup.FLAG_CLIP_CHILDREN) == 0) {
                        dirty.union(0, 0, this.mRight - this.mLeft, this.mBottom - this.mTop);
                    }
                    if ((this.mGroupFlags & ViewGroup.FLAG_CLIP_CHILDREN) == 0 ||
                        dirty.intersect(0, 0, this.mRight - this.mLeft, this.mBottom - this.mTop)) {
                        if (this.mLayerType != view_4.View.LAYER_TYPE_NONE) {
                        }
                        if (!this.getMatrix().isIdentity()) {
                            this.transformRect(dirty);
                        }
                        return this.mParent;
                    }
                }
                return null;
            }
            findViewByPredicateTraversal(predicate, childToSkip) {
                if (predicate.apply(this)) {
                    return this;
                }
                const where = this.mChildren;
                const len = this.mChildrenCount;
                for (let i = 0; i < len; i++) {
                    let v = where[i];
                    if (v != childToSkip && (v.mPrivateFlags & view_4.View.PFLAG_IS_ROOT_NAMESPACE) == 0) {
                        v = v.findViewByPredicate(predicate);
                        if (v != null) {
                            return v;
                        }
                    }
                }
                return null;
            }
            requestDisallowInterceptTouchEvent(disallowIntercept) {
                if (disallowIntercept == ((this.mGroupFlags & ViewGroup.FLAG_DISALLOW_INTERCEPT) != 0)) {
                    return;
                }
                if (disallowIntercept) {
                    this.mGroupFlags |= ViewGroup.FLAG_DISALLOW_INTERCEPT;
                }
                else {
                    this.mGroupFlags &= ~ViewGroup.FLAG_DISALLOW_INTERCEPT;
                }
                if (this.mParent != null) {
                    this.mParent.requestDisallowInterceptTouchEvent(disallowIntercept);
                }
            }
            shouldDelayChildPressedState() {
                return true;
            }
            onSetLayoutParams(child, layoutParams) {
            }
        }
        ViewGroup.FLAG_CLIP_CHILDREN = 0x1;
        ViewGroup.FLAG_CLIP_TO_PADDING = 0x2;
        ViewGroup.FLAG_INVALIDATE_REQUIRED = 0x4;
        ViewGroup.FLAG_RUN_ANIMATION = 0x8;
        ViewGroup.FLAG_ANIMATION_DONE = 0x10;
        ViewGroup.FLAG_PADDING_NOT_NULL = 0x20;
        ViewGroup.FLAG_ANIMATION_CACHE = 0x40;
        ViewGroup.FLAG_OPTIMIZE_INVALIDATE = 0x80;
        ViewGroup.FLAG_CLEAR_TRANSFORMATION = 0x100;
        ViewGroup.FLAG_NOTIFY_ANIMATION_LISTENER = 0x200;
        ViewGroup.FLAG_USE_CHILD_DRAWING_ORDER = 0x400;
        ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS = 0x800;
        ViewGroup.FLAG_ALPHA_LOWER_THAN_ONE = 0x1000;
        ViewGroup.FLAG_ADD_STATES_FROM_CHILDREN = 0x2000;
        ViewGroup.FLAG_ALWAYS_DRAWN_WITH_CACHE = 0x4000;
        ViewGroup.FLAG_CHILDREN_DRAWN_WITH_CACHE = 0x8000;
        ViewGroup.FLAG_NOTIFY_CHILDREN_ON_DRAWABLE_STATE_CHANGE = 0x10000;
        ViewGroup.FLAG_MASK_FOCUSABILITY = 0x60000;
        ViewGroup.FOCUS_BEFORE_DESCENDANTS = 0x20000;
        ViewGroup.FOCUS_AFTER_DESCENDANTS = 0x40000;
        ViewGroup.FOCUS_BLOCK_DESCENDANTS = 0x60000;
        ViewGroup.FLAG_DISALLOW_INTERCEPT = 0x80000;
        ViewGroup.FLAG_SPLIT_MOTION_EVENTS = 0x200000;
        ViewGroup.FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW = 0x400000;
        ViewGroup.FLAG_LAYOUT_MODE_WAS_EXPLICITLY_SET = 0x800000;
        ViewGroup.PERSISTENT_NO_CACHE = 0x0;
        ViewGroup.PERSISTENT_ANIMATION_CACHE = 0x1;
        ViewGroup.PERSISTENT_SCROLLING_CACHE = 0x2;
        ViewGroup.PERSISTENT_ALL_CACHES = 0x3;
        ViewGroup.LAYOUT_MODE_UNDEFINED = -1;
        ViewGroup.LAYOUT_MODE_CLIP_BOUNDS = 0;
        ViewGroup.LAYOUT_MODE_DEFAULT = ViewGroup.LAYOUT_MODE_CLIP_BOUNDS;
        ViewGroup.CLIP_TO_PADDING_MASK = ViewGroup.FLAG_CLIP_TO_PADDING | ViewGroup.FLAG_PADDING_NOT_NULL;
        view_4.ViewGroup = ViewGroup;
        (function (ViewGroup) {
            class LayoutParams {
                constructor(...args) {
                    this._width = 0;
                    this._height = 0;
                    this._measuringParentWidthMeasureSpec = 0;
                    this._measuringParentHeightMeasureSpec = 0;
                    if (args.length === 1) {
                        let src = args[0];
                        this.width = src._width;
                        this.height = src._height;
                    }
                    else if (args.length === 2) {
                        let [width = 0, height = 0] = args;
                        this.width = width;
                        this.height = height;
                    }
                    if (!this._attrBinder) {
                        this._attrBinder = new AttrBinder(this);
                        this._attrBinder.addAttr('width', (value) => {
                            if (value == null)
                                value = -2;
                            this.width = value;
                        }, () => {
                            return this._widthOrig;
                        });
                        this._attrBinder.addAttr('height', (value) => {
                            if (value == null)
                                value = -2;
                            this.height = value;
                        }, () => {
                            return this._heightOrig;
                        });
                    }
                }
                get width() {
                    if (typeof this._width === 'number')
                        return this._width;
                    let up = (this._width + "").toUpperCase();
                    if (up === 'FILL_PARENT' || up === 'MATCH_PARENT')
                        this._width = -1;
                    else if (up === 'WRAP_CONTENT')
                        this._width = -2;
                    else {
                        let parentWidth = view_4.View.MeasureSpec.getSize(this._measuringParentWidthMeasureSpec);
                        try {
                            this._width = TypedValue.complexToDimensionPixelSize(this._width, parentWidth, this._measuringMeasureSpec);
                        }
                        catch (e) {
                            console.error(e);
                            this._width = -2;
                        }
                    }
                    return this._width;
                }
                set width(value) {
                    this._width = this._widthOrig = value;
                }
                get height() {
                    if (typeof this._height === 'number')
                        return this._height;
                    let up = (this._height + "").toUpperCase();
                    if (up === 'FILL_PARENT' || up === 'MATCH_PARENT')
                        this._height = -1;
                    else if (up === 'WRAP_CONTENT')
                        this._height = -2;
                    else {
                        let parentHeight = view_4.View.MeasureSpec.getSize(this._measuringParentHeightMeasureSpec);
                        try {
                            this._height = TypedValue.complexToDimensionPixelSize(this._height, parentHeight, this._measuringMeasureSpec);
                        }
                        catch (e) {
                            console.error(e);
                            this._height = -2;
                        }
                    }
                    return this._height;
                }
                set height(value) {
                    this._height = this._heightOrig = value;
                }
                parseAttributeFrom(node, rootElement) {
                    Array.from(node.attributes).forEach((attr) => {
                        let layoutParamFiled = attr.name.split("layout_")[1];
                        this._attrBinder.onAttrChange(layoutParamFiled, attr.value, rootElement);
                    });
                }
            }
            LayoutParams.FILL_PARENT = -1;
            LayoutParams.MATCH_PARENT = -1;
            LayoutParams.WRAP_CONTENT = -2;
            ViewGroup.LayoutParams = LayoutParams;
            class MarginLayoutParams extends LayoutParams {
                constructor(...args) {
                    super();
                    this._leftMargin = 0;
                    this._topMargin = 0;
                    this._rightMargin = 0;
                    this._bottomMargin = 0;
                    this._leftMarginOrig = 0;
                    this._topMarginOrig = 0;
                    this._rightMarginOrig = 0;
                    this._bottomMarginOrig = 0;
                    if (args.length === 1) {
                        let src = args[0];
                        super(src);
                        if (src instanceof MarginLayoutParams) {
                            this.leftMargin = src._leftMargin;
                            this.topMargin = src._topMargin;
                            this.rightMargin = src._rightMargin;
                            this.bottomMargin = src._bottomMargin;
                        }
                    }
                    else if (args.length == 2) {
                        super(args[0], args[1]);
                    }
                    this._attrBinder.addAttr('marginLeft', (value) => {
                        if (value == null)
                            value = 0;
                        this.leftMargin = value;
                    }, () => {
                        return this._leftMarginOrig;
                    });
                    this._attrBinder.addAttr('marginTop', (value) => {
                        if (value == null)
                            value = 0;
                        this.topMargin = value;
                    }, () => {
                        return this._topMarginOrig;
                    });
                    this._attrBinder.addAttr('marginRight', (value) => {
                        if (value == null)
                            value = 0;
                        this.rightMargin = value;
                    }, () => {
                        return this._rightMarginOrig;
                    });
                    this._attrBinder.addAttr('marginBottom', (value) => {
                        if (value == null)
                            value = 0;
                        this.bottomMargin = value;
                    }, () => {
                        return this._bottomMargin;
                    });
                    this._attrBinder.addAttr('margin', (value) => {
                        if (value == null)
                            value = 0;
                        let [left, top, right, bottom] = this._attrBinder.parsePaddingMarginLTRB(value);
                        this.leftMargin = left;
                        this.topMargin = top;
                        this.rightMargin = right;
                        this.bottomMargin = bottom;
                    });
                }
                get leftMargin() {
                    if (typeof this._leftMargin === 'number')
                        return this._leftMargin;
                    let parentWidth = view_4.View.MeasureSpec.getSize(this._measuringParentWidthMeasureSpec);
                    try {
                        this._leftMargin = TypedValue.complexToDimensionPixelSize(this._leftMargin, parentWidth, this._measuringMeasureSpec);
                    }
                    catch (e) {
                        console.warn(e);
                        this._leftMargin = 0;
                    }
                    return this._leftMargin;
                }
                get topMargin() {
                    if (typeof this._topMargin === 'number')
                        return this._topMargin;
                    let parentWidth = view_4.View.MeasureSpec.getSize(this._measuringParentWidthMeasureSpec);
                    try {
                        this._topMargin = TypedValue.complexToDimensionPixelSize(this._topMargin, parentWidth, this._measuringMeasureSpec);
                    }
                    catch (e) {
                        console.warn(e);
                        this._topMargin = 0;
                    }
                    return this._topMargin;
                }
                get rightMargin() {
                    if (typeof this._rightMargin === 'number')
                        return this._rightMargin;
                    let parentWidth = view_4.View.MeasureSpec.getSize(this._measuringParentWidthMeasureSpec);
                    try {
                        this._rightMargin = TypedValue.complexToDimensionPixelSize(this._rightMargin, parentWidth, this._measuringMeasureSpec);
                    }
                    catch (e) {
                        console.warn(e);
                        this._rightMargin = 0;
                    }
                    return this._rightMargin;
                }
                get bottomMargin() {
                    if (typeof this._bottomMargin === 'number')
                        return this._bottomMargin;
                    let parentWidth = view_4.View.MeasureSpec.getSize(this._measuringParentWidthMeasureSpec);
                    try {
                        this._bottomMargin = TypedValue.complexToDimensionPixelSize(this._bottomMargin, parentWidth, this._measuringMeasureSpec);
                    }
                    catch (e) {
                        console.warn(e);
                        this._bottomMargin = 0;
                    }
                    return this._bottomMargin;
                }
                set leftMargin(value) {
                    this._leftMargin = this._leftMarginOrig = value;
                }
                set topMargin(value) {
                    this._topMargin = this._topMarginOrig = value;
                }
                set rightMargin(value) {
                    this._rightMargin = this._rightMarginOrig = value;
                }
                set bottomMargin(value) {
                    this._bottomMargin = this._bottomMarginOrig = value;
                }
                setMargins(left, top, right, bottom) {
                    this.leftMargin = left;
                    this.topMargin = top;
                    this.rightMargin = right;
                    this.bottomMargin = bottom;
                }
            }
            ViewGroup.MarginLayoutParams = MarginLayoutParams;
        })(ViewGroup = view_4.ViewGroup || (view_4.ViewGroup = {}));
        class TouchTarget {
            static obtain(child, pointerIdBits) {
                let target;
                if (TouchTarget.sRecycleBin == null) {
                    target = new TouchTarget();
                }
                else {
                    target = TouchTarget.sRecycleBin;
                    TouchTarget.sRecycleBin = target.next;
                    TouchTarget.sRecycledCount--;
                    target.next = null;
                }
                target.child = child;
                target.pointerIdBits = pointerIdBits;
                return target;
            }
            recycle() {
                if (TouchTarget.sRecycledCount < TouchTarget.MAX_RECYCLED) {
                    this.next = TouchTarget.sRecycleBin;
                    TouchTarget.sRecycleBin = this;
                    TouchTarget.sRecycledCount += 1;
                }
                else {
                    this.next = null;
                }
                this.child = null;
            }
        }
        TouchTarget.MAX_RECYCLED = 32;
        TouchTarget.sRecycledCount = 0;
        TouchTarget.ALL_POINTER_IDS = -1;
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/6.
 */
///<reference path="ViewGroup.ts"/>
///<reference path="ViewRootImpl.ts"/>
///<reference path="View.ts"/>
///<reference path="../graphics/drawable/Drawable.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var Drawable = android.graphics.drawable.Drawable;
        class ViewOverlay {
            constructor(hostView) {
                this.mOverlayViewGroup = new ViewOverlay.OverlayViewGroup(hostView);
            }
            getOverlayView() {
                return this.mOverlayViewGroup;
            }
            add(drawable) {
                this.mOverlayViewGroup.add(drawable);
            }
            remove(drawable) {
            }
            clear() {
                this.mOverlayViewGroup.clear();
            }
            isEmpty() {
                return this.mOverlayViewGroup.isEmpty();
            }
        }
        view.ViewOverlay = ViewOverlay;
        (function (ViewOverlay) {
            class OverlayViewGroup extends view.ViewGroup {
                constructor(hostView) {
                    super();
                    this.mHostView = hostView;
                    this.mAttachInfo = hostView.mAttachInfo;
                    this.mRight = hostView.getWidth();
                    this.mBottom = hostView.getHeight();
                }
                addDrawable(drawable) {
                }
                addView(child) {
                }
                add(arg) {
                    if (arg instanceof Drawable)
                        this.addDrawable(arg);
                    else if (arg instanceof view.View)
                        this.addView(arg);
                }
                clear() {
                }
                isEmpty() {
                    return true;
                }
                onLayout(changed, l, t, r, b) {
                }
            }
            ViewOverlay.OverlayViewGroup = OverlayViewGroup;
        })(ViewOverlay = view.ViewOverlay || (view.ViewOverlay = {}));
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/17.
 */
///<reference path="../util/Log.ts"/>
///<reference path="../util/Pools.ts"/>
///<reference path="MotionEvent.ts"/>
///<reference path="KeyEvent.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var Log = android.util.Log;
        var Pools = android.util.Pools;
        class VelocityTracker {
            constructor() {
                this.mLastTouchIndex = 0;
                this.mGeneration = 0;
                this.clear();
            }
            static obtain() {
                let instance = VelocityTracker.sPool.acquire();
                return (instance != null) ? instance : new VelocityTracker();
            }
            recycle() {
                this.clear();
                VelocityTracker.sPool.release(this);
            }
            setNextPoolable(element) {
                this.mNext = element;
            }
            getNextPoolable() {
                return this.mNext;
            }
            clear() {
                VelocityTracker.releasePointerList(this.mPointerListHead);
                this.mPointerListHead = null;
                this.mLastTouchIndex = 0;
            }
            addMovement(ev) {
                let historySize = ev.getHistorySize();
                const pointerCount = ev.getPointerCount();
                const lastTouchIndex = this.mLastTouchIndex;
                const nextTouchIndex = (lastTouchIndex + 1) % VelocityTracker.NUM_PAST;
                const finalTouchIndex = (nextTouchIndex + historySize) % VelocityTracker.NUM_PAST;
                const generation = this.mGeneration++;
                this.mLastTouchIndex = finalTouchIndex;
                let previousPointer = null;
                for (let i = 0; i < pointerCount; i++) {
                    const pointerId = ev.getPointerId(i);
                    let nextPointer;
                    if (previousPointer == null || pointerId < previousPointer.id) {
                        previousPointer = null;
                        nextPointer = this.mPointerListHead;
                    }
                    else {
                        nextPointer = previousPointer.next;
                    }
                    let pointer;
                    for (;;) {
                        if (nextPointer != null) {
                            const nextPointerId = nextPointer.id;
                            if (nextPointerId == pointerId) {
                                pointer = nextPointer;
                                break;
                            }
                            if (nextPointerId < pointerId) {
                                nextPointer = nextPointer.next;
                                continue;
                            }
                        }
                        pointer = VelocityTracker.obtainPointer();
                        pointer.id = pointerId;
                        pointer.pastTime[lastTouchIndex] = Number.MIN_VALUE;
                        pointer.next = nextPointer;
                        if (previousPointer == null) {
                            this.mPointerListHead = pointer;
                        }
                        else {
                            previousPointer.next = pointer;
                        }
                        break;
                    }
                    pointer.generation = generation;
                    previousPointer = pointer;
                    const pastX = pointer.pastX;
                    const pastY = pointer.pastY;
                    const pastTime = pointer.pastTime;
                    historySize = ev.getHistorySize(pointerId);
                    for (let j = 0; j < historySize; j++) {
                        const touchIndex = (nextTouchIndex + j) % VelocityTracker.NUM_PAST;
                        pastX[touchIndex] = ev.getHistoricalX(i, j);
                        pastY[touchIndex] = ev.getHistoricalY(i, j);
                        pastTime[touchIndex] = ev.getHistoricalEventTime(i, j);
                    }
                    pastX[finalTouchIndex] = ev.getX(i);
                    pastY[finalTouchIndex] = ev.getY(i);
                    pastTime[finalTouchIndex] = ev.getEventTime();
                }
                previousPointer = null;
                for (let pointer = this.mPointerListHead; pointer != null;) {
                    const nextPointer = pointer.next;
                    if (pointer.generation != generation) {
                        if (previousPointer == null) {
                            this.mPointerListHead = nextPointer;
                        }
                        else {
                            previousPointer.next = nextPointer;
                        }
                        VelocityTracker.releasePointer(pointer);
                    }
                    else {
                        previousPointer = pointer;
                    }
                    pointer = nextPointer;
                }
            }
            computeCurrentVelocity(units, maxVelocity = Number.MAX_SAFE_INTEGER) {
                const lastTouchIndex = this.mLastTouchIndex;
                for (let pointer = this.mPointerListHead; pointer != null; pointer = pointer.next) {
                    const pastTime = pointer.pastTime;
                    let oldestTouchIndex = lastTouchIndex;
                    let numTouches = 1;
                    const minTime = pastTime[lastTouchIndex] - VelocityTracker.MAX_AGE_MILLISECONDS;
                    while (numTouches < VelocityTracker.NUM_PAST) {
                        const nextOldestTouchIndex = (oldestTouchIndex + VelocityTracker.NUM_PAST - 1) % VelocityTracker.NUM_PAST;
                        const nextOldestTime = pastTime[nextOldestTouchIndex];
                        if (nextOldestTime < minTime) {
                            break;
                        }
                        oldestTouchIndex = nextOldestTouchIndex;
                        numTouches += 1;
                    }
                    if (numTouches > 3) {
                        numTouches -= 1;
                    }
                    const pastX = pointer.pastX;
                    const pastY = pointer.pastY;
                    const oldestX = pastX[oldestTouchIndex];
                    const oldestY = pastY[oldestTouchIndex];
                    const oldestTime = pastTime[oldestTouchIndex];
                    let accumX = 0;
                    let accumY = 0;
                    for (let i = 1; i < numTouches; i++) {
                        const touchIndex = (oldestTouchIndex + i) % VelocityTracker.NUM_PAST;
                        const duration = (pastTime[touchIndex] - oldestTime);
                        if (duration == 0)
                            continue;
                        let delta = pastX[touchIndex] - oldestX;
                        let velocity = (delta / duration) * units;
                        accumX = (accumX == 0) ? velocity : (accumX + velocity) * .5;
                        delta = pastY[touchIndex] - oldestY;
                        velocity = (delta / duration) * units;
                        accumY = (accumY == 0) ? velocity : (accumY + velocity) * .5;
                    }
                    if (accumX < -maxVelocity) {
                        accumX = -maxVelocity;
                    }
                    else if (accumX > maxVelocity) {
                        accumX = maxVelocity;
                    }
                    if (accumY < -maxVelocity) {
                        accumY = -maxVelocity;
                    }
                    else if (accumY > maxVelocity) {
                        accumY = maxVelocity;
                    }
                    pointer.xVelocity = accumX;
                    pointer.yVelocity = accumY;
                    if (VelocityTracker.localLOGV) {
                        Log.v(VelocityTracker.TAG, "Pointer " + pointer.id
                            + ": Y velocity=" + accumX + " X velocity=" + accumY + " N=" + numTouches);
                    }
                }
            }
            getXVelocity(id = 0) {
                let pointer = this.getPointer(id);
                return pointer != null ? pointer.xVelocity : 0;
            }
            getYVelocity(id = 0) {
                let pointer = this.getPointer(id);
                return pointer != null ? pointer.yVelocity : 0;
            }
            getPointer(id) {
                for (let pointer = this.mPointerListHead; pointer != null; pointer = pointer.next) {
                    if (pointer.id == id) {
                        return pointer;
                    }
                }
                return null;
            }
            static obtainPointer() {
                if (VelocityTracker.sRecycledPointerCount != 0) {
                    let element = VelocityTracker.sRecycledPointerListHead;
                    VelocityTracker.sRecycledPointerCount -= 1;
                    VelocityTracker.sRecycledPointerListHead = element.next;
                    element.next = null;
                    return element;
                }
                return new Pointer();
            }
            static releasePointer(pointer) {
                if (VelocityTracker.sRecycledPointerCount < VelocityTracker.POINTER_POOL_CAPACITY) {
                    pointer.next = VelocityTracker.sRecycledPointerListHead;
                    VelocityTracker.sRecycledPointerCount += 1;
                    VelocityTracker.sRecycledPointerListHead = pointer;
                }
            }
            static releasePointerList(pointer) {
                if (pointer != null) {
                    let count = VelocityTracker.sRecycledPointerCount;
                    if (count >= VelocityTracker.POINTER_POOL_CAPACITY) {
                        return;
                    }
                    let tail = pointer;
                    for (;;) {
                        count += 1;
                        if (count >= VelocityTracker.POINTER_POOL_CAPACITY) {
                            break;
                        }
                        let next = tail.next;
                        if (next == null) {
                            break;
                        }
                        tail = next;
                    }
                    tail.next = VelocityTracker.sRecycledPointerListHead;
                    VelocityTracker.sRecycledPointerCount = count;
                    VelocityTracker.sRecycledPointerListHead = pointer;
                }
            }
        }
        VelocityTracker.TAG = "VelocityTracker";
        VelocityTracker.DEBUG = Log.VelocityTracker_DBG;
        VelocityTracker.localLOGV = VelocityTracker.DEBUG;
        VelocityTracker.NUM_PAST = 10;
        VelocityTracker.MAX_AGE_MILLISECONDS = 200;
        VelocityTracker.POINTER_POOL_CAPACITY = 20;
        VelocityTracker.sPool = new Pools.SynchronizedPool(2);
        VelocityTracker.sRecycledPointerCount = 0;
        view.VelocityTracker = VelocityTracker;
        class Pointer {
            constructor() {
                this.id = 0;
                this.xVelocity = 0;
                this.yVelocity = 0;
                this.pastX = new Array(VelocityTracker.NUM_PAST);
                this.pastY = new Array(VelocityTracker.NUM_PAST);
                this.pastTime = new Array(VelocityTracker.NUM_PAST);
                this.generation = 0;
            }
        }
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/os/Handler.ts"/>
///<reference path="../../android/os/Message.ts"/>
///<reference path="../../android/view/MotionEvent.ts"/>
///<reference path="../../android/view/VelocityTracker.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewConfiguration.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var Handler = android.os.Handler;
        var MotionEvent = android.view.MotionEvent;
        var VelocityTracker = android.view.VelocityTracker;
        var ViewConfiguration = android.view.ViewConfiguration;
        class GestureDetector {
            constructor(listener, handler) {
                this.mTouchSlopSquare = 0;
                this.mDoubleTapTouchSlopSquare = 0;
                this.mDoubleTapSlopSquare = 0;
                this.mMinimumFlingVelocity = 0;
                this.mMaximumFlingVelocity = 0;
                this.mLastFocusX = 0;
                this.mLastFocusY = 0;
                this.mDownFocusX = 0;
                this.mDownFocusY = 0;
                this.mHandler = new GestureDetector.GestureHandler(this);
                this.mListener = listener;
                if (listener['setOnDoubleTapListener']) {
                    this.setOnDoubleTapListener(listener);
                }
                this.init();
            }
            init() {
                if (this.mListener == null) {
                    throw Error(`new NullPointerException("OnGestureListener must not be null")`);
                }
                this.mIsLongpressEnabled = true;
                let touchSlop, doubleTapSlop, doubleTapTouchSlop;
                const configuration = ViewConfiguration.get();
                touchSlop = configuration.getScaledTouchSlop();
                doubleTapTouchSlop = configuration.getScaledDoubleTapTouchSlop();
                doubleTapSlop = configuration.getScaledDoubleTapSlop();
                this.mMinimumFlingVelocity = configuration.getScaledMinimumFlingVelocity();
                this.mMaximumFlingVelocity = configuration.getScaledMaximumFlingVelocity();
                this.mTouchSlopSquare = touchSlop * touchSlop;
                this.mDoubleTapTouchSlopSquare = doubleTapTouchSlop * doubleTapTouchSlop;
                this.mDoubleTapSlopSquare = doubleTapSlop * doubleTapSlop;
            }
            setOnDoubleTapListener(onDoubleTapListener) {
                this.mDoubleTapListener = onDoubleTapListener;
            }
            setIsLongpressEnabled(isLongpressEnabled) {
                this.mIsLongpressEnabled = isLongpressEnabled;
            }
            isLongpressEnabled() {
                return this.mIsLongpressEnabled;
            }
            onTouchEvent(ev) {
                const action = ev.getAction();
                if (this.mVelocityTracker == null) {
                    this.mVelocityTracker = VelocityTracker.obtain();
                }
                this.mVelocityTracker.addMovement(ev);
                const pointerUp = (action & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP;
                const skipIndex = pointerUp ? ev.getActionIndex() : -1;
                let sumX = 0, sumY = 0;
                const count = ev.getPointerCount();
                for (let i = 0; i < count; i++) {
                    if (skipIndex == i)
                        continue;
                    sumX += ev.getX(i);
                    sumY += ev.getY(i);
                }
                const div = pointerUp ? count - 1 : count;
                const focusX = sumX / div;
                const focusY = sumY / div;
                let handled = false;
                switch (action & MotionEvent.ACTION_MASK) {
                    case MotionEvent.ACTION_POINTER_DOWN:
                        this.mDownFocusX = this.mLastFocusX = focusX;
                        this.mDownFocusY = this.mLastFocusY = focusY;
                        this.cancelTaps();
                        break;
                    case MotionEvent.ACTION_POINTER_UP:
                        this.mDownFocusX = this.mLastFocusX = focusX;
                        this.mDownFocusY = this.mLastFocusY = focusY;
                        this.mVelocityTracker.computeCurrentVelocity(1000, this.mMaximumFlingVelocity);
                        const upIndex = ev.getActionIndex();
                        const id1 = ev.getPointerId(upIndex);
                        const x1 = this.mVelocityTracker.getXVelocity(id1);
                        const y1 = this.mVelocityTracker.getYVelocity(id1);
                        for (let i = 0; i < count; i++) {
                            if (i == upIndex)
                                continue;
                            const id2 = ev.getPointerId(i);
                            const x = x1 * this.mVelocityTracker.getXVelocity(id2);
                            const y = y1 * this.mVelocityTracker.getYVelocity(id2);
                            const dot = x + y;
                            if (dot < 0) {
                                this.mVelocityTracker.clear();
                                break;
                            }
                        }
                        break;
                    case MotionEvent.ACTION_DOWN:
                        if (this.mDoubleTapListener != null) {
                            let hadTapMessage = this.mHandler.hasMessages(GestureDetector.TAP);
                            if (hadTapMessage)
                                this.mHandler.removeMessages(GestureDetector.TAP);
                            if ((this.mCurrentDownEvent != null) && (this.mPreviousUpEvent != null) && hadTapMessage && this.isConsideredDoubleTap(this.mCurrentDownEvent, this.mPreviousUpEvent, ev)) {
                                this.mIsDoubleTapping = true;
                                handled = this.mDoubleTapListener.onDoubleTap(this.mCurrentDownEvent) || handled;
                                handled = this.mDoubleTapListener.onDoubleTapEvent(ev) || handled;
                            }
                            else {
                                this.mHandler.sendEmptyMessageDelayed(GestureDetector.TAP, GestureDetector.DOUBLE_TAP_TIMEOUT);
                            }
                        }
                        this.mDownFocusX = this.mLastFocusX = focusX;
                        this.mDownFocusY = this.mLastFocusY = focusY;
                        if (this.mCurrentDownEvent != null) {
                            this.mCurrentDownEvent.recycle();
                        }
                        this.mCurrentDownEvent = MotionEvent.obtain(ev);
                        this.mAlwaysInTapRegion = true;
                        this.mAlwaysInBiggerTapRegion = true;
                        this.mStillDown = true;
                        this.mInLongPress = false;
                        this.mDeferConfirmSingleTap = false;
                        if (this.mIsLongpressEnabled) {
                            this.mHandler.removeMessages(GestureDetector.LONG_PRESS);
                            this.mHandler.sendEmptyMessageAtTime(GestureDetector.LONG_PRESS, this.mCurrentDownEvent.getDownTime() + GestureDetector.TAP_TIMEOUT + GestureDetector.LONGPRESS_TIMEOUT);
                        }
                        this.mHandler.sendEmptyMessageAtTime(GestureDetector.SHOW_PRESS, this.mCurrentDownEvent.getDownTime() + GestureDetector.TAP_TIMEOUT);
                        handled = this.mListener.onDown(ev) || handled;
                        break;
                    case MotionEvent.ACTION_MOVE:
                        if (this.mInLongPress) {
                            break;
                        }
                        const scrollX = this.mLastFocusX - focusX;
                        const scrollY = this.mLastFocusY - focusY;
                        if (this.mIsDoubleTapping) {
                            handled = this.mDoubleTapListener.onDoubleTapEvent(ev) || handled;
                        }
                        else if (this.mAlwaysInTapRegion) {
                            const deltaX = Math.floor((focusX - this.mDownFocusX));
                            const deltaY = Math.floor((focusY - this.mDownFocusY));
                            let distance = (deltaX * deltaX) + (deltaY * deltaY);
                            if (distance > this.mTouchSlopSquare) {
                                handled = this.mListener.onScroll(this.mCurrentDownEvent, ev, scrollX, scrollY);
                                this.mLastFocusX = focusX;
                                this.mLastFocusY = focusY;
                                this.mAlwaysInTapRegion = false;
                                this.mHandler.removeMessages(GestureDetector.TAP);
                                this.mHandler.removeMessages(GestureDetector.SHOW_PRESS);
                                this.mHandler.removeMessages(GestureDetector.LONG_PRESS);
                            }
                            if (distance > this.mDoubleTapTouchSlopSquare) {
                                this.mAlwaysInBiggerTapRegion = false;
                            }
                        }
                        else if ((Math.abs(scrollX) >= 1) || (Math.abs(scrollY) >= 1)) {
                            handled = this.mListener.onScroll(this.mCurrentDownEvent, ev, scrollX, scrollY);
                            this.mLastFocusX = focusX;
                            this.mLastFocusY = focusY;
                        }
                        break;
                    case MotionEvent.ACTION_UP:
                        this.mStillDown = false;
                        let currentUpEvent = MotionEvent.obtain(ev);
                        if (this.mIsDoubleTapping) {
                            handled = this.mDoubleTapListener.onDoubleTapEvent(ev) || handled;
                        }
                        else if (this.mInLongPress) {
                            this.mHandler.removeMessages(GestureDetector.TAP);
                            this.mInLongPress = false;
                        }
                        else if (this.mAlwaysInTapRegion) {
                            handled = this.mListener.onSingleTapUp(ev);
                            if (this.mDeferConfirmSingleTap && this.mDoubleTapListener != null) {
                                this.mDoubleTapListener.onSingleTapConfirmed(ev);
                            }
                        }
                        else {
                            const velocityTracker = this.mVelocityTracker;
                            const pointerId = ev.getPointerId(0);
                            velocityTracker.computeCurrentVelocity(1000, this.mMaximumFlingVelocity);
                            const velocityY = velocityTracker.getYVelocity(pointerId);
                            const velocityX = velocityTracker.getXVelocity(pointerId);
                            if ((Math.abs(velocityY) > this.mMinimumFlingVelocity) || (Math.abs(velocityX) > this.mMinimumFlingVelocity)) {
                                handled = this.mListener.onFling(this.mCurrentDownEvent, ev, velocityX, velocityY);
                            }
                        }
                        if (this.mPreviousUpEvent != null) {
                            this.mPreviousUpEvent.recycle();
                        }
                        this.mPreviousUpEvent = currentUpEvent;
                        if (this.mVelocityTracker != null) {
                            this.mVelocityTracker.recycle();
                            this.mVelocityTracker = null;
                        }
                        this.mIsDoubleTapping = false;
                        this.mDeferConfirmSingleTap = false;
                        this.mHandler.removeMessages(GestureDetector.SHOW_PRESS);
                        this.mHandler.removeMessages(GestureDetector.LONG_PRESS);
                        break;
                    case MotionEvent.ACTION_CANCEL:
                        this.cancel();
                        break;
                }
                return handled;
            }
            cancel() {
                this.mHandler.removeMessages(GestureDetector.SHOW_PRESS);
                this.mHandler.removeMessages(GestureDetector.LONG_PRESS);
                this.mHandler.removeMessages(GestureDetector.TAP);
                this.mVelocityTracker.recycle();
                this.mVelocityTracker = null;
                this.mIsDoubleTapping = false;
                this.mStillDown = false;
                this.mAlwaysInTapRegion = false;
                this.mAlwaysInBiggerTapRegion = false;
                this.mDeferConfirmSingleTap = false;
                if (this.mInLongPress) {
                    this.mInLongPress = false;
                }
            }
            cancelTaps() {
                this.mHandler.removeMessages(GestureDetector.SHOW_PRESS);
                this.mHandler.removeMessages(GestureDetector.LONG_PRESS);
                this.mHandler.removeMessages(GestureDetector.TAP);
                this.mIsDoubleTapping = false;
                this.mAlwaysInTapRegion = false;
                this.mAlwaysInBiggerTapRegion = false;
                this.mDeferConfirmSingleTap = false;
                if (this.mInLongPress) {
                    this.mInLongPress = false;
                }
            }
            isConsideredDoubleTap(firstDown, firstUp, secondDown) {
                if (!this.mAlwaysInBiggerTapRegion) {
                    return false;
                }
                const deltaTime = secondDown.getEventTime() - firstUp.getEventTime();
                if (deltaTime > GestureDetector.DOUBLE_TAP_TIMEOUT || deltaTime < GestureDetector.DOUBLE_TAP_MIN_TIME) {
                    return false;
                }
                let deltaX = Math.floor(firstDown.getX()) - Math.floor(secondDown.getX());
                let deltaY = Math.floor(firstDown.getY()) - Math.floor(secondDown.getY());
                return (deltaX * deltaX + deltaY * deltaY < this.mDoubleTapSlopSquare);
            }
            dispatchLongPress() {
                this.mHandler.removeMessages(GestureDetector.TAP);
                this.mDeferConfirmSingleTap = false;
                this.mInLongPress = true;
                this.mListener.onLongPress(this.mCurrentDownEvent);
            }
        }
        GestureDetector.LONGPRESS_TIMEOUT = ViewConfiguration.getLongPressTimeout();
        GestureDetector.TAP_TIMEOUT = ViewConfiguration.getTapTimeout();
        GestureDetector.DOUBLE_TAP_TIMEOUT = ViewConfiguration.getDoubleTapTimeout();
        GestureDetector.DOUBLE_TAP_MIN_TIME = ViewConfiguration.getDoubleTapMinTime();
        GestureDetector.SHOW_PRESS = 1;
        GestureDetector.LONG_PRESS = 2;
        GestureDetector.TAP = 3;
        view.GestureDetector = GestureDetector;
        (function (GestureDetector) {
            class SimpleOnGestureListener {
                onSingleTapUp(e) {
                    return false;
                }
                onLongPress(e) {
                }
                onScroll(e1, e2, distanceX, distanceY) {
                    return false;
                }
                onFling(e1, e2, velocityX, velocityY) {
                    return false;
                }
                onShowPress(e) {
                }
                onDown(e) {
                    return false;
                }
                onDoubleTap(e) {
                    return false;
                }
                onDoubleTapEvent(e) {
                    return false;
                }
                onSingleTapConfirmed(e) {
                    return false;
                }
            }
            GestureDetector.SimpleOnGestureListener = SimpleOnGestureListener;
            class GestureHandler extends Handler {
                constructor(arg) {
                    super();
                    this._GestureDetector_this = arg;
                }
                handleMessage(msg) {
                    switch (msg.what) {
                        case GestureDetector.SHOW_PRESS:
                            this._GestureDetector_this.mListener.onShowPress(this._GestureDetector_this.mCurrentDownEvent);
                            break;
                        case GestureDetector.LONG_PRESS:
                            this._GestureDetector_this.dispatchLongPress();
                            break;
                        case GestureDetector.TAP:
                            if (this._GestureDetector_this.mDoubleTapListener != null) {
                                if (!this._GestureDetector_this.mStillDown) {
                                    this._GestureDetector_this.mDoubleTapListener.onSingleTapConfirmed(this._GestureDetector_this.mCurrentDownEvent);
                                }
                                else {
                                    this._GestureDetector_this.mDeferConfirmSingleTap = true;
                                }
                            }
                            break;
                        default:
                            throw Error(`new RuntimeException("Unknown message " + msg)`);
                    }
                }
            }
            GestureDetector.GestureHandler = GestureHandler;
        })(GestureDetector = view.GestureDetector || (view.GestureDetector = {}));
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/9.
 */
///<reference path="../view/Gravity.ts"/>
///<reference path="../view/View.ts"/>
///<reference path="../view/ViewGroup.ts"/>
///<reference path="../graphics/drawable/Drawable.ts"/>
///<reference path="../graphics/Rect.ts"/>
///<reference path="../graphics/Canvas.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var Gravity = android.view.Gravity;
        var View = android.view.View;
        var ViewGroup = android.view.ViewGroup;
        var Rect = android.graphics.Rect;
        class FrameLayout extends ViewGroup {
            constructor(bindElement, rootElement) {
                super(bindElement, rootElement);
                this.mMeasureAllChildren = false;
                this.mForegroundPaddingLeft = 0;
                this.mForegroundPaddingTop = 0;
                this.mForegroundPaddingRight = 0;
                this.mForegroundPaddingBottom = 0;
                this.mSelfBounds = new Rect();
                this.mOverlayBounds = new Rect();
                this.mForegroundGravity = Gravity.FILL;
                this.mForegroundInPadding = true;
                this.mForegroundBoundsChanged = false;
                this.mMatchParentChildren = new Array(1);
                this._attrBinder.addAttr('foregroundGravity', (value) => {
                    this.mForegroundGravity = this._attrBinder.parseGravity(value, this.mForegroundGravity);
                }, () => {
                    return this.mForegroundGravity;
                });
            }
            getForegroundGravity() {
                return this.mForegroundGravity;
            }
            setForegroundGravity(foregroundGravity) {
                if (this.mForegroundGravity != foregroundGravity) {
                    if ((foregroundGravity & Gravity.HORIZONTAL_GRAVITY_MASK) == 0) {
                        foregroundGravity |= Gravity.LEFT;
                    }
                    if ((foregroundGravity & Gravity.VERTICAL_GRAVITY_MASK) == 0) {
                        foregroundGravity |= Gravity.TOP;
                    }
                    this.mForegroundGravity = foregroundGravity;
                    if (this.mForegroundGravity == Gravity.FILL && this.mForeground != null) {
                        let padding = new Rect();
                        if (this.mForeground.getPadding(padding)) {
                            this.mForegroundPaddingLeft = padding.left;
                            this.mForegroundPaddingTop = padding.top;
                            this.mForegroundPaddingRight = padding.right;
                            this.mForegroundPaddingBottom = padding.bottom;
                        }
                    }
                    else {
                        this.mForegroundPaddingLeft = 0;
                        this.mForegroundPaddingTop = 0;
                        this.mForegroundPaddingRight = 0;
                        this.mForegroundPaddingBottom = 0;
                    }
                    this.requestLayout();
                }
            }
            verifyDrawable(who) {
                return super.verifyDrawable(who) || (who == this.mForeground);
            }
            jumpDrawablesToCurrentState() {
                super.jumpDrawablesToCurrentState();
                if (this.mForeground != null)
                    this.mForeground.jumpToCurrentState();
            }
            drawableStateChanged() {
                super.drawableStateChanged();
                if (this.mForeground != null && this.mForeground.isStateful()) {
                    this.mForeground.setState(this.getDrawableState());
                }
            }
            generateDefaultLayoutParams() {
                return new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT);
            }
            setForeground(drawable) {
            }
            getForeground() {
                return this.mForeground;
            }
            getPaddingLeftWithForeground() {
                return this.mForegroundInPadding ? Math.max(this.mPaddingLeft, this.mForegroundPaddingLeft) :
                    this.mPaddingLeft + this.mForegroundPaddingLeft;
            }
            getPaddingRightWithForeground() {
                return this.mForegroundInPadding ? Math.max(this.mPaddingRight, this.mForegroundPaddingRight) :
                    this.mPaddingRight + this.mForegroundPaddingRight;
            }
            getPaddingTopWithForeground() {
                return this.mForegroundInPadding ? Math.max(this.mPaddingTop, this.mForegroundPaddingTop) :
                    this.mPaddingTop + this.mForegroundPaddingTop;
            }
            getPaddingBottomWithForeground() {
                return this.mForegroundInPadding ? Math.max(this.mPaddingBottom, this.mForegroundPaddingBottom) :
                    this.mPaddingBottom + this.mForegroundPaddingBottom;
            }
            onMeasure(widthMeasureSpec, heightMeasureSpec) {
                let count = this.getChildCount();
                let measureMatchParentChildren = View.MeasureSpec.getMode(widthMeasureSpec) != View.MeasureSpec.EXACTLY ||
                    View.MeasureSpec.getMode(heightMeasureSpec) != View.MeasureSpec.EXACTLY;
                this.mMatchParentChildren = [];
                let maxHeight = 0;
                let maxWidth = 0;
                let childState = 0;
                for (let i = 0; i < count; i++) {
                    let child = this.getChildAt(i);
                    if (this.mMeasureAllChildren || child.getVisibility() != View.GONE) {
                        this.measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0);
                        let lp = child.getLayoutParams();
                        maxWidth = Math.max(maxWidth, child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
                        maxHeight = Math.max(maxHeight, child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
                        childState = View.combineMeasuredStates(childState, child.getMeasuredState());
                        if (measureMatchParentChildren) {
                            if (lp.width == FrameLayout.LayoutParams.MATCH_PARENT ||
                                lp.height == FrameLayout.LayoutParams.MATCH_PARENT) {
                                this.mMatchParentChildren.push(child);
                            }
                        }
                    }
                }
                maxWidth += this.getPaddingLeftWithForeground() + this.getPaddingRightWithForeground();
                maxHeight += this.getPaddingTopWithForeground() + this.getPaddingBottomWithForeground();
                maxHeight = Math.max(maxHeight, this.getSuggestedMinimumHeight());
                maxWidth = Math.max(maxWidth, this.getSuggestedMinimumWidth());
                let drawable = this.getForeground();
                if (drawable != null) {
                    maxHeight = Math.max(maxHeight, drawable.getMinimumHeight());
                    maxWidth = Math.max(maxWidth, drawable.getMinimumWidth());
                }
                this.setMeasuredDimension(View.resolveSizeAndState(maxWidth, widthMeasureSpec, childState), View.resolveSizeAndState(maxHeight, heightMeasureSpec, childState << View.MEASURED_HEIGHT_STATE_SHIFT));
                count = this.mMatchParentChildren.length;
                if (count > 1) {
                    for (let i = 0; i < count; i++) {
                        let child = this.mMatchParentChildren[i];
                        let lp = child.getLayoutParams();
                        let childWidthMeasureSpec;
                        let childHeightMeasureSpec;
                        if (lp.width == FrameLayout.LayoutParams.MATCH_PARENT) {
                            childWidthMeasureSpec = View.MeasureSpec.makeMeasureSpec(this.getMeasuredWidth() -
                                this.getPaddingLeftWithForeground() - this.getPaddingRightWithForeground() -
                                lp.leftMargin - lp.rightMargin, View.MeasureSpec.EXACTLY);
                        }
                        else {
                            childWidthMeasureSpec = ViewGroup.getChildMeasureSpec(widthMeasureSpec, this.getPaddingLeftWithForeground() + this.getPaddingRightWithForeground() +
                                lp.leftMargin + lp.rightMargin, lp.width);
                        }
                        if (lp.height == FrameLayout.LayoutParams.MATCH_PARENT) {
                            childHeightMeasureSpec = View.MeasureSpec.makeMeasureSpec(this.getMeasuredHeight() -
                                this.getPaddingTopWithForeground() - this.getPaddingBottomWithForeground() -
                                lp.topMargin - lp.bottomMargin, View.MeasureSpec.EXACTLY);
                        }
                        else {
                            childHeightMeasureSpec = ViewGroup.getChildMeasureSpec(heightMeasureSpec, this.getPaddingTopWithForeground() + this.getPaddingBottomWithForeground() +
                                lp.topMargin + lp.bottomMargin, lp.height);
                        }
                        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
                    }
                }
            }
            onLayout(changed, left, top, right, bottom) {
                this.layoutChildren(left, top, right, bottom, false);
            }
            layoutChildren(left, top, right, bottom, forceLeftGravity) {
                const count = this.getChildCount();
                const parentLeft = this.getPaddingLeftWithForeground();
                const parentRight = right - left - this.getPaddingRightWithForeground();
                const parentTop = this.getPaddingTopWithForeground();
                const parentBottom = bottom - top - this.getPaddingBottomWithForeground();
                this.mForegroundBoundsChanged = true;
                for (let i = 0; i < count; i++) {
                    let child = this.getChildAt(i);
                    if (child.getVisibility() != View.GONE) {
                        const lp = child.getLayoutParams();
                        const width = child.getMeasuredWidth();
                        const height = child.getMeasuredHeight();
                        let childLeft;
                        let childTop;
                        let gravity = lp.gravity;
                        if (gravity == -1) {
                            gravity = FrameLayout.DEFAULT_CHILD_GRAVITY;
                        }
                        const absoluteGravity = gravity;
                        const verticalGravity = gravity & Gravity.VERTICAL_GRAVITY_MASK;
                        switch (absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
                            case Gravity.CENTER_HORIZONTAL:
                                childLeft = parentLeft + (parentRight - parentLeft - width) / 2 +
                                    lp.leftMargin - lp.rightMargin;
                                break;
                            case Gravity.RIGHT:
                                if (!forceLeftGravity) {
                                    childLeft = parentRight - width - lp.rightMargin;
                                    break;
                                }
                            case Gravity.LEFT:
                            default:
                                childLeft = parentLeft + lp.leftMargin;
                        }
                        switch (verticalGravity) {
                            case Gravity.TOP:
                                childTop = parentTop + lp.topMargin;
                                break;
                            case Gravity.CENTER_VERTICAL:
                                childTop = parentTop + (parentBottom - parentTop - height) / 2 +
                                    lp.topMargin - lp.bottomMargin;
                                break;
                            case Gravity.BOTTOM:
                                childTop = parentBottom - height - lp.bottomMargin;
                                break;
                            default:
                                childTop = parentTop + lp.topMargin;
                        }
                        child.layout(childLeft, childTop, childLeft + width, childTop + height);
                    }
                }
            }
            onSizeChanged(w, h, oldw, oldh) {
                super.onSizeChanged(w, h, oldw, oldh);
                this.mForegroundBoundsChanged = true;
            }
            draw(canvas) {
                super.draw(canvas);
                if (this.mForeground != null) {
                    const foreground = this.mForeground;
                    if (this.mForegroundBoundsChanged) {
                        this.mForegroundBoundsChanged = false;
                        const selfBounds = this.mSelfBounds;
                        const overlayBounds = this.mOverlayBounds;
                        const w = this.mRight - this.mLeft;
                        const h = this.mBottom - this.mTop;
                        if (this.mForegroundInPadding) {
                            selfBounds.set(0, 0, w, h);
                        }
                        else {
                            selfBounds.set(this.mPaddingLeft, this.mPaddingTop, w - this.mPaddingRight, h - this.mPaddingBottom);
                        }
                        Gravity.apply(this.mForegroundGravity, foreground.getIntrinsicWidth(), foreground.getIntrinsicHeight(), selfBounds, overlayBounds);
                        foreground.setBounds(overlayBounds);
                    }
                    foreground.draw(canvas);
                }
            }
            setMeasureAllChildren(measureAll) {
                this.mMeasureAllChildren = measureAll;
            }
            getMeasureAllChildren() {
                return this.mMeasureAllChildren;
            }
            shouldDelayChildPressedState() {
                return false;
            }
            checkLayoutParams(p) {
                return p instanceof FrameLayout.LayoutParams;
            }
            generateLayoutParams(p) {
                return new FrameLayout.LayoutParams(p);
            }
        }
        FrameLayout.DEFAULT_CHILD_GRAVITY = Gravity.TOP | Gravity.LEFT;
        widget.FrameLayout = FrameLayout;
        (function (FrameLayout) {
            class LayoutParams extends ViewGroup.MarginLayoutParams {
                constructor(...args) {
                    super();
                    this.gravity = -1;
                    if (args.length === 1 && args[0] instanceof LayoutParams) {
                        super(args[0]);
                        this.gravity = args[0].gravity;
                    }
                    else {
                        let [width, height, gravity = -1] = args;
                        super(width, height);
                        this.gravity = gravity;
                    }
                    this._attrBinder.addAttr('gravity', (value) => {
                        this.gravity = this._attrBinder.parseGravity(value, this.gravity);
                    }, () => {
                        return this.gravity;
                    });
                }
            }
            FrameLayout.LayoutParams = LayoutParams;
        })(FrameLayout = widget.FrameLayout || (widget.FrameLayout = {}));
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
var androidui;
(function (androidui) {
    var util;
    (function (util) {
        class NumberChecker {
            static warnNotNumber(...n) {
                try {
                    this.assetNotNumber(...n);
                }
                catch (e) {
                    console.error(e);
                    return true;
                }
                return false;
            }
            static assetNotNumber(...ns) {
                if (!this.checkIsNumber()) {
                    throw Error('assetNotNumber : ' + ns);
                }
            }
            static checkIsNumber(...ns) {
                if (ns == null)
                    return false;
                for (let n of ns) {
                    if (n == null || Number.isNaN(n))
                        return false;
                }
                return true;
            }
        }
        util.NumberChecker = NumberChecker;
    })(util = androidui.util || (androidui.util = {}));
})(androidui || (androidui = {}));
/**
 * Created by linfaxin on 15/10/17.
 */
///<reference path="../view/ViewConfiguration.ts"/>
///<reference path="../view/animation/Interpolator.ts"/>
///<reference path="../content/res/Resources.ts"/>
///<reference path="../os/SystemClock.ts"/>
///<reference path="../util/Log.ts"/>
///<reference path="../../androidui/util/NumberChecker.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var ViewConfiguration = android.view.ViewConfiguration;
        var Resources = android.content.res.Resources;
        var SystemClock = android.os.SystemClock;
        var Log = android.util.Log;
        var NumberChecker = androidui.util.NumberChecker;
        class OverScroller {
            constructor(interpolator, flywheel = true) {
                this.mMode = 0;
                this.mFlywheel = true;
                this.mInterpolator = interpolator;
                this.mFlywheel = flywheel;
                this.mScrollerX = new SplineOverScroller();
                this.mScrollerY = new SplineOverScroller();
            }
            setInterpolator(interpolator) {
                this.mInterpolator = interpolator;
            }
            setFriction(friction) {
                NumberChecker.warnNotNumber(friction);
                this.mScrollerX.setFriction(friction);
                this.mScrollerY.setFriction(friction);
            }
            isFinished() {
                return this.mScrollerX.mFinished && this.mScrollerY.mFinished;
            }
            forceFinished(finished) {
                this.mScrollerX.mFinished = this.mScrollerY.mFinished = finished;
            }
            getCurrX() {
                return this.mScrollerX.mCurrentPosition;
            }
            getCurrY() {
                return this.mScrollerY.mCurrentPosition;
            }
            getCurrVelocity() {
                let squaredNorm = this.mScrollerX.mCurrVelocity * this.mScrollerX.mCurrVelocity;
                squaredNorm += this.mScrollerY.mCurrVelocity * this.mScrollerY.mCurrVelocity;
                return Math.sqrt(squaredNorm);
            }
            getStartX() {
                return this.mScrollerX.mStart;
            }
            getStartY() {
                return this.mScrollerY.mStart;
            }
            getFinalX() {
                return this.mScrollerX.mFinal;
            }
            getFinalY() {
                return this.mScrollerY.mFinal;
            }
            getDuration() {
                return Math.max(this.mScrollerX.mDuration, this.mScrollerY.mDuration);
            }
            computeScrollOffset() {
                if (this.isFinished()) {
                    return false;
                }
                switch (this.mMode) {
                    case OverScroller.SCROLL_MODE:
                        let time = SystemClock.uptimeMillis();
                        const elapsedTime = time - this.mScrollerX.mStartTime;
                        const duration = this.mScrollerX.mDuration;
                        if (elapsedTime < duration) {
                            let q = (elapsedTime) / duration;
                            if (this.mInterpolator == null) {
                                q = Scroller_viscousFluid(q);
                            }
                            else {
                                q = this.mInterpolator.getInterpolation(q);
                            }
                            this.mScrollerX.updateScroll(q);
                            this.mScrollerY.updateScroll(q);
                        }
                        else {
                            this.abortAnimation();
                        }
                        break;
                    case OverScroller.FLING_MODE:
                        if (!this.mScrollerX.mFinished) {
                            if (!this.mScrollerX.update()) {
                                if (!this.mScrollerX.continueWhenFinished()) {
                                    this.mScrollerX.finish();
                                }
                            }
                        }
                        if (!this.mScrollerY.mFinished) {
                            if (!this.mScrollerY.update()) {
                                if (!this.mScrollerY.continueWhenFinished()) {
                                    this.mScrollerY.finish();
                                }
                            }
                        }
                        break;
                }
                return true;
            }
            startScroll(startX, startY, dx, dy, duration = OverScroller.DEFAULT_DURATION) {
                NumberChecker.warnNotNumber(startX, startY, dx, dy, duration);
                this.mMode = OverScroller.SCROLL_MODE;
                this.mScrollerX.startScroll(startX, dx, duration);
                this.mScrollerY.startScroll(startY, dy, duration);
            }
            springBack(startX, startY, minX, maxX, minY, maxY) {
                NumberChecker.warnNotNumber(startX, startY, minX, maxX, minY, maxY);
                this.mMode = OverScroller.FLING_MODE;
                const spingbackX = this.mScrollerX.springback(startX, minX, maxX);
                const spingbackY = this.mScrollerY.springback(startY, minY, maxY);
                return spingbackX || spingbackY;
            }
            fling(startX, startY, velocityX, velocityY, minX, maxX, minY, maxY, overX = 0, overY = 0) {
                NumberChecker.warnNotNumber(startX, startY, velocityX, velocityY, minX, maxX, minY, maxY, overX, overY);
                if (this.mFlywheel && !this.isFinished()) {
                    let oldVelocityX = this.mScrollerX.mCurrVelocity;
                    let oldVelocityY = this.mScrollerY.mCurrVelocity;
                    if (Math_signum(velocityX) == Math_signum(oldVelocityX) &&
                        Math_signum(velocityY) == Math_signum(oldVelocityY)) {
                        velocityX += oldVelocityX;
                        velocityY += oldVelocityY;
                    }
                }
                this.mMode = OverScroller.FLING_MODE;
                this.mScrollerX.fling(startX, velocityX, minX, maxX, overX);
                this.mScrollerY.fling(startY, velocityY, minY, maxY, overY);
            }
            notifyHorizontalEdgeReached(startX, finalX, overX) {
                NumberChecker.warnNotNumber(startX, finalX, overX);
                this.mScrollerX.notifyEdgeReached(startX, finalX, overX);
            }
            notifyVerticalEdgeReached(startY, finalY, overY) {
                NumberChecker.warnNotNumber(startY, finalY, overY);
                this.mScrollerY.notifyEdgeReached(startY, finalY, overY);
            }
            isOverScrolled() {
                return ((!this.mScrollerX.mFinished &&
                    this.mScrollerX.mState != SplineOverScroller.SPLINE) ||
                    (!this.mScrollerY.mFinished &&
                        this.mScrollerY.mState != SplineOverScroller.SPLINE));
            }
            abortAnimation() {
                this.mScrollerX.finish();
                this.mScrollerY.finish();
            }
            timePassed() {
                const time = SystemClock.uptimeMillis();
                const startTime = Math.min(this.mScrollerX.mStartTime, this.mScrollerY.mStartTime);
                return (time - startTime);
            }
            isScrollingInDirection(xvel, yvel) {
                const dx = this.mScrollerX.mFinal - this.mScrollerX.mStart;
                const dy = this.mScrollerY.mFinal - this.mScrollerY.mStart;
                return !this.isFinished() && Math_signum(xvel) == Math_signum(dx) &&
                    Math_signum(yvel) == Math_signum(dy);
            }
        }
        OverScroller.DEFAULT_DURATION = 250;
        OverScroller.SCROLL_MODE = 0;
        OverScroller.FLING_MODE = 1;
        widget.OverScroller = OverScroller;
        class SplineOverScroller {
            constructor() {
                this.mStart = 0;
                this.mCurrentPosition = 0;
                this.mFinal = 0;
                this.mVelocity = 0;
                this._mCurrVelocity = 0;
                this.mDeceleration = 0;
                this.mStartTime = 0;
                this.mDuration = 0;
                this.mSplineDuration = 0;
                this.mSplineDistance = 0;
                this.mFinished = false;
                this.mOver = 0;
                this.mFlingFriction = ViewConfiguration.getScrollFriction();
                this.mState = SplineOverScroller.SPLINE;
                this.mPhysicalCoeff = 0;
                this.mFinished = true;
                let ppi = Resources.getDisplayMetrics().density * 160;
                this.mPhysicalCoeff = 9.80665
                    * 39.37
                    * ppi
                    * 0.84;
            }
            get mCurrVelocity() {
                return this._mCurrVelocity;
            }
            set mCurrVelocity(value) {
                if (!NumberChecker.checkIsNumber(value)) {
                    value = 0;
                }
                this._mCurrVelocity = value;
            }
            setFriction(friction) {
                this.mFlingFriction = friction;
            }
            updateScroll(q) {
                this.mCurrentPosition = this.mStart + Math.round(q * (this.mFinal - this.mStart));
            }
            static getDeceleration(velocity) {
                return velocity > 0 ? -SplineOverScroller.GRAVITY : SplineOverScroller.GRAVITY;
            }
            adjustDuration(start, oldFinal, newFinal) {
                let oldDistance = oldFinal - start;
                let newDistance = newFinal - start;
                let x = Math.abs(newDistance / oldDistance);
                let index = Number.parseInt((SplineOverScroller.NB_SAMPLES * x));
                if (index < SplineOverScroller.NB_SAMPLES) {
                    let x_inf = index / SplineOverScroller.NB_SAMPLES;
                    let x_sup = (index + 1) / SplineOverScroller.NB_SAMPLES;
                    let t_inf = SplineOverScroller.SPLINE_TIME[index];
                    let t_sup = SplineOverScroller.SPLINE_TIME[index + 1];
                    let timeCoef = t_inf + (x - x_inf) / (x_sup - x_inf) * (t_sup - t_inf);
                    this.mDuration *= timeCoef;
                }
            }
            startScroll(start, distance, duration) {
                this.mFinished = false;
                this.mStart = start;
                this.mFinal = start + distance;
                this.mStartTime = SystemClock.uptimeMillis();
                this.mDuration = duration;
                this.mDeceleration = 0;
                this.mVelocity = 0;
            }
            finish() {
                this.mCurrentPosition = this.mFinal;
                this.mFinished = true;
            }
            setFinalPosition(position) {
                this.mFinal = position;
                this.mFinished = false;
            }
            extendDuration(extend) {
                let time = SystemClock.uptimeMillis();
                let elapsedTime = (time - this.mStartTime);
                this.mDuration = elapsedTime + extend;
                this.mFinished = false;
            }
            springback(start, min, max) {
                this.mFinished = true;
                this.mStart = this.mFinal = start;
                this.mVelocity = 0;
                this.mStartTime = SystemClock.uptimeMillis();
                this.mDuration = 0;
                if (start < min) {
                    this.startSpringback(start, min, 0);
                }
                else if (start > max) {
                    this.startSpringback(start, max, 0);
                }
                return !this.mFinished;
            }
            startSpringback(start, end, velocity) {
                this.mFinished = false;
                this.mState = SplineOverScroller.CUBIC;
                this.mStart = start;
                this.mFinal = end;
                const delta = start - end;
                this.mDeceleration = SplineOverScroller.getDeceleration(delta);
                this.mVelocity = -delta;
                this.mOver = Math.abs(delta);
                this.mDuration = (1000.0 * Math.sqrt(-2.0 * delta / this.mDeceleration));
            }
            fling(start, velocity, min, max, over) {
                this.mOver = over;
                this.mFinished = false;
                this.mCurrVelocity = this.mVelocity = velocity;
                this.mDuration = this.mSplineDuration = 0;
                this.mStartTime = SystemClock.uptimeMillis();
                this.mCurrentPosition = this.mStart = start;
                if (start > max || start < min) {
                    this.startAfterEdge(start, min, max, velocity);
                    return;
                }
                this.mState = SplineOverScroller.SPLINE;
                let totalDistance = 0.0;
                if (velocity != 0) {
                    this.mDuration = this.mSplineDuration = this.getSplineFlingDuration(velocity);
                    totalDistance = this.getSplineFlingDistance(velocity);
                }
                this.mSplineDistance = (totalDistance * Math_signum(velocity));
                this.mFinal = start + this.mSplineDistance;
                if (this.mFinal < min) {
                    this.adjustDuration(this.mStart, this.mFinal, min);
                    this.mFinal = min;
                }
                if (this.mFinal > max) {
                    this.adjustDuration(this.mStart, this.mFinal, max);
                    this.mFinal = max;
                }
            }
            getSplineDeceleration(velocity) {
                return Math.log(SplineOverScroller.INFLEXION * Math.abs(velocity) / (this.mFlingFriction * this.mPhysicalCoeff));
            }
            getSplineFlingDistance(velocity) {
                let l = this.getSplineDeceleration(velocity);
                let decelMinusOne = SplineOverScroller.DECELERATION_RATE - 1.0;
                return this.mFlingFriction * this.mPhysicalCoeff * Math.exp(SplineOverScroller.DECELERATION_RATE / decelMinusOne * l);
            }
            getSplineFlingDuration(velocity) {
                let l = this.getSplineDeceleration(velocity);
                let decelMinusOne = SplineOverScroller.DECELERATION_RATE - 1.0;
                return (1000.0 * Math.exp(l / decelMinusOne));
            }
            fitOnBounceCurve(start, end, velocity) {
                let durationToApex = -velocity / this.mDeceleration;
                let distanceToApex = velocity * velocity / 2.0 / Math.abs(this.mDeceleration);
                let distanceToEdge = Math.abs(end - start);
                let totalDuration = Math.sqrt(2.0 * (distanceToApex + distanceToEdge) / Math.abs(this.mDeceleration));
                this.mStartTime -= (1000 * (totalDuration - durationToApex));
                this.mStart = end;
                this.mVelocity = (-this.mDeceleration * totalDuration);
            }
            startBounceAfterEdge(start, end, velocity) {
                this.mDeceleration = SplineOverScroller.getDeceleration(velocity == 0 ? start - end : velocity);
                this.fitOnBounceCurve(start, end, velocity);
                this.onEdgeReached();
            }
            startAfterEdge(start, min, max, velocity) {
                if (start > min && start < max) {
                    Log.e("OverScroller", "startAfterEdge called from a valid position");
                    this.mFinished = true;
                    return;
                }
                const positive = start > max;
                const edge = positive ? max : min;
                const overDistance = start - edge;
                let keepIncreasing = overDistance * velocity >= 0;
                if (keepIncreasing) {
                    this.startBounceAfterEdge(start, edge, velocity);
                }
                else {
                    const totalDistance = this.getSplineFlingDistance(velocity);
                    if (totalDistance > Math.abs(overDistance)) {
                        this.fling(start, velocity, positive ? min : start, positive ? start : max, this.mOver);
                    }
                    else {
                        this.startSpringback(start, edge, velocity);
                    }
                }
            }
            notifyEdgeReached(start, end, over) {
                if (this.mState == SplineOverScroller.SPLINE) {
                    this.mOver = over;
                    this.mStartTime = SystemClock.uptimeMillis();
                    this.startAfterEdge(start, end, end, this.mCurrVelocity);
                }
            }
            onEdgeReached() {
                let distance = this.mVelocity * this.mVelocity / (2 * Math.abs(this.mDeceleration));
                const sign = Math_signum(this.mVelocity);
                if (distance > this.mOver) {
                    this.mDeceleration = -sign * this.mVelocity * this.mVelocity / (2.0 * this.mOver);
                    distance = this.mOver;
                }
                this.mOver = distance;
                this.mState = SplineOverScroller.BALLISTIC;
                this.mFinal = this.mStart + (this.mVelocity > 0 ? distance : -distance);
                this.mDuration = -(1000 * this.mVelocity / this.mDeceleration);
            }
            continueWhenFinished() {
                switch (this.mState) {
                    case SplineOverScroller.SPLINE:
                        if (this.mDuration < this.mSplineDuration) {
                            this.mStart = this.mFinal;
                            this.mVelocity = this.mCurrVelocity;
                            this.mDeceleration = SplineOverScroller.getDeceleration(this.mVelocity);
                            this.mStartTime += this.mDuration;
                            this.onEdgeReached();
                        }
                        else {
                            return false;
                        }
                        break;
                    case SplineOverScroller.BALLISTIC:
                        this.mStartTime += this.mDuration;
                        this.startSpringback(this.mFinal, this.mStart, 0);
                        break;
                    case SplineOverScroller.CUBIC:
                        return false;
                }
                this.update();
                return true;
            }
            update() {
                const time = SystemClock.uptimeMillis();
                const currentTime = time - this.mStartTime;
                if (currentTime > this.mDuration) {
                    return false;
                }
                let distance = 0;
                switch (this.mState) {
                    case SplineOverScroller.SPLINE: {
                        const t = currentTime / this.mSplineDuration;
                        const index = Math.floor(SplineOverScroller.NB_SAMPLES * t);
                        let distanceCoef = 1;
                        let velocityCoef = 0;
                        if (index < SplineOverScroller.NB_SAMPLES) {
                            const t_inf = index / SplineOverScroller.NB_SAMPLES;
                            const t_sup = (index + 1) / SplineOverScroller.NB_SAMPLES;
                            const d_inf = SplineOverScroller.SPLINE_POSITION[index];
                            const d_sup = SplineOverScroller.SPLINE_POSITION[index + 1];
                            velocityCoef = (d_sup - d_inf) / (t_sup - t_inf);
                            distanceCoef = d_inf + (t - t_inf) * velocityCoef;
                        }
                        distance = distanceCoef * this.mSplineDistance;
                        this.mCurrVelocity = velocityCoef * this.mSplineDistance / this.mSplineDuration * 1000;
                        break;
                    }
                    case SplineOverScroller.BALLISTIC: {
                        const t = currentTime / 1000;
                        this.mCurrVelocity = this.mVelocity + this.mDeceleration * t;
                        distance = this.mVelocity * t + this.mDeceleration * t * t / 2;
                        break;
                    }
                    case SplineOverScroller.CUBIC: {
                        const t = (currentTime) / this.mDuration;
                        const t2 = t * t;
                        const sign = Math_signum(this.mVelocity);
                        distance = sign * this.mOver * (3 * t2 - 2 * t * t2);
                        this.mCurrVelocity = sign * this.mOver * 6 * (-t + t2);
                        break;
                    }
                }
                this.mCurrentPosition = this.mStart + Math.round(distance);
                return true;
            }
        }
        SplineOverScroller.DECELERATION_RATE = (Math.log(0.78) / Math.log(0.9));
        SplineOverScroller.INFLEXION = 0.35;
        SplineOverScroller.START_TENSION = 0.5;
        SplineOverScroller.END_TENSION = 1.0;
        SplineOverScroller.P1 = SplineOverScroller.START_TENSION * SplineOverScroller.INFLEXION;
        SplineOverScroller.P2 = 1.0 - SplineOverScroller.END_TENSION * (1 - SplineOverScroller.INFLEXION);
        SplineOverScroller.NB_SAMPLES = 100;
        SplineOverScroller.SPLINE_POSITION = new Array(SplineOverScroller.NB_SAMPLES + 1);
        SplineOverScroller.SPLINE_TIME = new Array(SplineOverScroller.NB_SAMPLES + 1);
        SplineOverScroller.SPLINE = 0;
        SplineOverScroller.CUBIC = 1;
        SplineOverScroller.BALLISTIC = 2;
        SplineOverScroller.GRAVITY = 2000;
        SplineOverScroller._staticFunc = function () {
            let x_min = 0.0;
            let y_min = 0.0;
            for (let i = 0; i < SplineOverScroller.NB_SAMPLES; i++) {
                const alpha = i / SplineOverScroller.NB_SAMPLES;
                let x_max = 1.0;
                let x, tx, coef;
                while (true) {
                    x = x_min + (x_max - x_min) / 2.0;
                    coef = 3.0 * x * (1.0 - x);
                    tx = coef * ((1.0 - x) * SplineOverScroller.P1 + x * SplineOverScroller.P2) + x * x * x;
                    if (Math.abs(tx - alpha) < 1E-5)
                        break;
                    if (tx > alpha)
                        x_max = x;
                    else
                        x_min = x;
                }
                SplineOverScroller.SPLINE_POSITION[i] = coef * ((1.0 - x) * SplineOverScroller.START_TENSION + x) + x * x * x;
                let y_max = 1.0;
                let y, dy;
                while (true) {
                    y = y_min + (y_max - y_min) / 2.0;
                    coef = 3.0 * y * (1.0 - y);
                    dy = coef * ((1.0 - y) * SplineOverScroller.START_TENSION + y) + y * y * y;
                    if (Math.abs(dy - alpha) < 1E-5)
                        break;
                    if (dy > alpha)
                        y_max = y;
                    else
                        y_min = y;
                }
                SplineOverScroller.SPLINE_TIME[i] = coef * ((1.0 - y) * SplineOverScroller.P1 + y * SplineOverScroller.P2) + y * y * y;
            }
            SplineOverScroller.SPLINE_POSITION[SplineOverScroller.NB_SAMPLES] = SplineOverScroller.SPLINE_TIME[SplineOverScroller.NB_SAMPLES] = 1.0;
        }();
        function Math_signum(value) {
            if (value === 0 || Number.isNaN(value))
                return value;
            return Math.abs(value) === value ? 1 : -1;
        }
        let sViscousFluidScale = 8;
        let sViscousFluidNormalize = 1;
        function Scroller_viscousFluid(x) {
            x *= sViscousFluidScale;
            if (x < 1) {
                x -= (1 - Math.exp(-x));
            }
            else {
                let start = 0.36787944117;
                x = 1 - Math.exp(1 - x);
                x = start + x * (1 - start);
            }
            x *= sViscousFluidNormalize;
            return x;
        }
        sViscousFluidNormalize = 1 / Scroller_viscousFluid(1);
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/17.
 */
///<reference path="../view/View.ts"/>
///<reference path="../view/ViewGroup.ts"/>
///<reference path="../view/MotionEvent.ts"/>
///<reference path="FrameLayout.ts"/>
///<reference path="OverScroller.ts"/>
///<reference path="../view/VelocityTracker.ts"/>
///<reference path="../view/ViewConfiguration.ts"/>
///<reference path="../util/Log.ts"/>
///<reference path="../os/SystemClock.ts"/>
///<reference path="../graphics/Rect.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var View = android.view.View;
        var ViewGroup = android.view.ViewGroup;
        var MeasureSpec = View.MeasureSpec;
        var MotionEvent = android.view.MotionEvent;
        var VelocityTracker = android.view.VelocityTracker;
        var ViewConfiguration = android.view.ViewConfiguration;
        var Rect = android.graphics.Rect;
        var OverScroller = android.widget.OverScroller;
        var Log = android.util.Log;
        var SystemClock = android.os.SystemClock;
        var KeyEvent = android.view.KeyEvent;
        class ScrollView extends widget.FrameLayout {
            constructor(bindElement, rootElement) {
                super(bindElement, rootElement);
                this.mLastScroll = 0;
                this.mTempRect = new Rect();
                this.mLastMotionY = 0;
                this.mIsLayoutDirty = true;
                this.mIsBeingDragged = false;
                this.mFillViewport = false;
                this.mSmoothScrollingEnabled = true;
                this.mMinimumVelocity = 0;
                this.mMaximumVelocity = 0;
                this.mOverscrollDistance = 0;
                this._mOverflingDistance = 0;
                this.mActivePointerId = ScrollView.INVALID_POINTER;
                this.initScrollView();
                this._attrBinder.addAttr('fillViewport', (value) => {
                    this.setFillViewport(this._attrBinder.parseBoolean(value));
                });
            }
            get mOverflingDistance() {
                let height = this.getHeight() - this.mPaddingBottom - this.mPaddingTop;
                let bottom = this.getChildAt(0).getHeight();
                let minOverY = this.mScrollY < 0 ? -this.mScrollY : this.mScrollY - (bottom - height);
                return Math.max(this._mOverflingDistance, minOverY + this._mOverflingDistance);
            }
            set mOverflingDistance(value) {
                this._mOverflingDistance = value;
            }
            shouldDelayChildPressedState() {
                return true;
            }
            getMaxScrollAmount() {
                return (ScrollView.MAX_SCROLL_FACTOR * (this.mBottom - this.mTop));
            }
            initScrollView() {
                this.mScroller = new OverScroller();
                this.setFocusable(true);
                this.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);
                this.setWillNotDraw(false);
                const configuration = ViewConfiguration.get();
                this.mTouchSlop = configuration.getScaledTouchSlop();
                this.mMinimumVelocity = configuration.getScaledMinimumFlingVelocity();
                this.mMaximumVelocity = configuration.getScaledMaximumFlingVelocity();
                this.mOverscrollDistance = configuration.getScaledOverscrollDistance();
                this.mOverflingDistance = configuration.getScaledOverflingDistance();
                this.initScrollCache();
                this.setVerticalScrollBarEnabled(true);
            }
            addView(...args) {
                if (this.getChildCount() > 0) {
                    throw new Error("ScrollView can host only one direct child");
                }
                return super.addView(...args);
            }
            canScroll() {
                let child = this.getChildAt(0);
                if (child != null) {
                    let childHeight = child.getHeight();
                    return this.getHeight() < childHeight + this.mPaddingTop + this.mPaddingBottom;
                }
                return false;
            }
            isFillViewport() {
                return this.mFillViewport;
            }
            setFillViewport(fillViewport) {
                if (fillViewport != this.mFillViewport) {
                    this.mFillViewport = fillViewport;
                    this.requestLayout();
                }
            }
            isSmoothScrollingEnabled() {
                return this.mSmoothScrollingEnabled;
            }
            setSmoothScrollingEnabled(smoothScrollingEnabled) {
                this.mSmoothScrollingEnabled = smoothScrollingEnabled;
            }
            onMeasure(widthMeasureSpec, heightMeasureSpec) {
                super.onMeasure(widthMeasureSpec, heightMeasureSpec);
                if (!this.mFillViewport) {
                    return;
                }
                const heightMode = MeasureSpec.getMode(heightMeasureSpec);
                if (heightMode == MeasureSpec.UNSPECIFIED) {
                    return;
                }
                if (this.getChildCount() > 0) {
                    const child = this.getChildAt(0);
                    let height = this.getMeasuredHeight();
                    if (child.getMeasuredHeight() < height) {
                        const lp = child.getLayoutParams();
                        let childWidthMeasureSpec = widget.FrameLayout.getChildMeasureSpec(widthMeasureSpec, this.mPaddingLeft + this.mPaddingRight, lp.width);
                        height -= this.mPaddingTop;
                        height -= this.mPaddingBottom;
                        let childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height, MeasureSpec.EXACTLY);
                        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
                    }
                }
            }
            dispatchKeyEvent(event) {
                return super.dispatchKeyEvent(event) || this.executeKeyEvent(event);
            }
            executeKeyEvent(event) {
                this.mTempRect.setEmpty();
                if (!this.canScroll()) {
                    return false;
                }
                let handled = false;
                if (event.getAction() == KeyEvent.ACTION_DOWN) {
                    switch (event.getKeyCode()) {
                        case KeyEvent.KEYCODE_DPAD_UP:
                            if (!event.isAltPressed()) {
                                handled = this.arrowScroll(View.FOCUS_UP);
                            }
                            else {
                                handled = this.fullScroll(View.FOCUS_UP);
                            }
                            break;
                        case KeyEvent.KEYCODE_DPAD_DOWN:
                            if (!event.isAltPressed()) {
                                handled = this.arrowScroll(View.FOCUS_DOWN);
                            }
                            else {
                                handled = this.fullScroll(View.FOCUS_DOWN);
                            }
                            break;
                        case KeyEvent.KEYCODE_SPACE:
                            this.pageScroll(event.isShiftPressed() ? View.FOCUS_UP : View.FOCUS_DOWN);
                            break;
                    }
                }
                return handled;
            }
            inChild(x, y) {
                if (this.getChildCount() > 0) {
                    const scrollY = this.mScrollY;
                    const child = this.getChildAt(0);
                    return !(y < child.getTop() - scrollY
                        || y >= child.getBottom() - scrollY
                        || x < child.getLeft()
                        || x >= child.getRight());
                }
                return false;
            }
            initOrResetVelocityTracker() {
                if (this.mVelocityTracker == null) {
                    this.mVelocityTracker = VelocityTracker.obtain();
                }
                else {
                    this.mVelocityTracker.clear();
                }
            }
            initVelocityTrackerIfNotExists() {
                if (this.mVelocityTracker == null) {
                    this.mVelocityTracker = VelocityTracker.obtain();
                }
            }
            recycleVelocityTracker() {
                if (this.mVelocityTracker != null) {
                    this.mVelocityTracker.recycle();
                    this.mVelocityTracker = null;
                }
            }
            requestDisallowInterceptTouchEvent(disallowIntercept) {
                if (disallowIntercept) {
                    this.recycleVelocityTracker();
                }
                super.requestDisallowInterceptTouchEvent(disallowIntercept);
            }
            onInterceptTouchEvent(ev) {
                /*
                 * This method JUST determines whether we want to intercept the motion.
                 * If we return true, onMotionEvent will be called and we do the actual
                 * scrolling there.
                 */
                const action = ev.getAction();
                if ((action == MotionEvent.ACTION_MOVE) && (this.mIsBeingDragged)) {
                    return true;
                }
                if (this.getScrollY() == 0 && !this.canScrollVertically(1)) {
                    return false;
                }
                switch (action & MotionEvent.ACTION_MASK) {
                    case MotionEvent.ACTION_MOVE:
                        {
                            const activePointerId = this.mActivePointerId;
                            if (activePointerId == ScrollView.INVALID_POINTER) {
                                break;
                            }
                            const pointerIndex = ev.findPointerIndex(activePointerId);
                            if (pointerIndex == -1) {
                                Log.e(ScrollView.TAG, "Invalid pointerId=" + activePointerId
                                    + " in onInterceptTouchEvent");
                                break;
                            }
                            const y = ev.getY(pointerIndex);
                            const yDiff = Math.abs(y - this.mLastMotionY);
                            if (yDiff > this.mTouchSlop) {
                                this.mIsBeingDragged = true;
                                this.mLastMotionY = y;
                                this.initVelocityTrackerIfNotExists();
                                this.mVelocityTracker.addMovement(ev);
                                const parent = this.getParent();
                                if (parent != null) {
                                    parent.requestDisallowInterceptTouchEvent(true);
                                }
                            }
                            break;
                        }
                    case MotionEvent.ACTION_DOWN:
                        {
                            const y = ev.getY();
                            if (!this.inChild(ev.getX(), y)) {
                                this.mIsBeingDragged = false;
                                this.recycleVelocityTracker();
                                break;
                            }
                            this.mLastMotionY = y;
                            this.mActivePointerId = ev.getPointerId(0);
                            this.initOrResetVelocityTracker();
                            this.mVelocityTracker.addMovement(ev);
                            this.mIsBeingDragged = !this.mScroller.isFinished();
                            break;
                        }
                    case MotionEvent.ACTION_CANCEL:
                    case MotionEvent.ACTION_UP:
                        this.mIsBeingDragged = false;
                        this.mActivePointerId = ScrollView.INVALID_POINTER;
                        this.recycleVelocityTracker();
                        if (this.mScroller.springBack(this.mScrollX, this.mScrollY, 0, 0, 0, this.getScrollRange())) {
                            this.postInvalidateOnAnimation();
                        }
                        break;
                    case MotionEvent.ACTION_POINTER_UP:
                        this.onSecondaryPointerUp(ev);
                        break;
                }
                return this.mIsBeingDragged;
            }
            onTouchEvent(ev) {
                this.initVelocityTrackerIfNotExists();
                this.mVelocityTracker.addMovement(ev);
                const action = ev.getAction();
                switch (action & MotionEvent.ACTION_MASK) {
                    case MotionEvent.ACTION_DOWN:
                        {
                            if (this.getChildCount() == 0) {
                                return false;
                            }
                            if ((this.mIsBeingDragged = !this.mScroller.isFinished())) {
                                const parent = this.getParent();
                                if (parent != null) {
                                    parent.requestDisallowInterceptTouchEvent(true);
                                }
                            }
                            if (!this.mScroller.isFinished()) {
                                this.mScroller.abortAnimation();
                            }
                            this.mLastMotionY = ev.getY();
                            this.mActivePointerId = ev.getPointerId(0);
                            break;
                        }
                    case MotionEvent.ACTION_MOVE:
                        const activePointerIndex = ev.findPointerIndex(this.mActivePointerId);
                        if (activePointerIndex == -1) {
                            Log.e(ScrollView.TAG, "Invalid pointerId=" + this.mActivePointerId + " in onTouchEvent");
                            break;
                        }
                        const y = ev.getY(activePointerIndex);
                        let deltaY = this.mLastMotionY - y;
                        if (!this.mIsBeingDragged && Math.abs(deltaY) > this.mTouchSlop) {
                            const parent = this.getParent();
                            if (parent != null) {
                                parent.requestDisallowInterceptTouchEvent(true);
                            }
                            this.mIsBeingDragged = true;
                            if (deltaY > 0) {
                                deltaY -= this.mTouchSlop;
                            }
                            else {
                                deltaY += this.mTouchSlop;
                            }
                        }
                        if (this.mIsBeingDragged) {
                            this.mLastMotionY = y;
                            const oldX = this.mScrollX;
                            const oldY = this.mScrollY;
                            const range = this.getScrollRange();
                            const overscrollMode = this.getOverScrollMode();
                            const canOverscroll = overscrollMode == ScrollView.OVER_SCROLL_ALWAYS ||
                                (overscrollMode == ScrollView.OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
                            if (this.overScrollBy(0, deltaY, 0, this.mScrollY, 0, range, 0, this.mOverscrollDistance, true)) {
                                this.mVelocityTracker.clear();
                            }
                            if (canOverscroll) {
                                const pulledToY = oldY + deltaY;
                                if (pulledToY < 0) {
                                }
                                else if (pulledToY > range) {
                                }
                            }
                        }
                        break;
                    case MotionEvent.ACTION_UP:
                        if (this.mIsBeingDragged) {
                            let velocityTracker = this.mVelocityTracker;
                            velocityTracker.computeCurrentVelocity(1000, this.mMaximumVelocity);
                            let initialVelocity = velocityTracker.getYVelocity(this.mActivePointerId);
                            if (this.getChildCount() > 0) {
                                let forceSpringBack = (this.mScrollY < -this._mOverflingDistance && initialVelocity > 0)
                                    || (this.mScrollY > (this.getScrollRange() + this._mOverflingDistance) && initialVelocity < 0);
                                if (!forceSpringBack && (Math.abs(initialVelocity) > this.mMinimumVelocity)) {
                                    this.fling(-initialVelocity);
                                }
                                else {
                                    if (this.mScroller.springBack(this.mScrollX, this.mScrollY, 0, 0, 0, this.getScrollRange())) {
                                        this.postInvalidateOnAnimation();
                                    }
                                }
                            }
                            this.mActivePointerId = ScrollView.INVALID_POINTER;
                            this.endDrag();
                        }
                        break;
                    case MotionEvent.ACTION_CANCEL:
                        if (this.mIsBeingDragged && this.getChildCount() > 0) {
                            if (this.mScroller.springBack(this.mScrollX, this.mScrollY, 0, 0, 0, this.getScrollRange())) {
                                this.postInvalidateOnAnimation();
                            }
                            this.mActivePointerId = ScrollView.INVALID_POINTER;
                            this.endDrag();
                        }
                        break;
                    case MotionEvent.ACTION_POINTER_DOWN:
                        {
                            const index = ev.getActionIndex();
                            this.mLastMotionY = ev.getY(index);
                            this.mActivePointerId = ev.getPointerId(index);
                            break;
                        }
                    case MotionEvent.ACTION_POINTER_UP:
                        this.onSecondaryPointerUp(ev);
                        this.mLastMotionY = ev.getY(ev.findPointerIndex(this.mActivePointerId));
                        break;
                }
                return true;
            }
            onSecondaryPointerUp(ev) {
                const pointerIndex = (ev.getAction() & MotionEvent.ACTION_POINTER_INDEX_MASK) >>
                    MotionEvent.ACTION_POINTER_INDEX_SHIFT;
                const pointerId = ev.getPointerId(pointerIndex);
                if (pointerId == this.mActivePointerId) {
                    const newPointerIndex = pointerIndex == 0 ? 1 : 0;
                    this.mLastMotionY = ev.getY(newPointerIndex);
                    this.mActivePointerId = ev.getPointerId(newPointerIndex);
                    if (this.mVelocityTracker != null) {
                        this.mVelocityTracker.clear();
                    }
                }
            }
            onGenericMotionEvent(event) {
                switch (event.getAction()) {
                    case MotionEvent.ACTION_SCROLL: {
                        if (!this.mIsBeingDragged) {
                            const vscroll = event.getAxisValue(MotionEvent.AXIS_VSCROLL);
                            if (vscroll != 0) {
                                const delta = Math.floor(vscroll * this.getVerticalScrollFactor());
                                const range = this.getScrollRange();
                                let oldScrollY = this.mScrollY;
                                let newScrollY = oldScrollY - delta;
                                if (newScrollY < 0) {
                                    newScrollY = 0;
                                }
                                else if (newScrollY > range) {
                                    newScrollY = range;
                                }
                                if (newScrollY != oldScrollY) {
                                    super.scrollTo(this.mScrollX, newScrollY);
                                    return true;
                                }
                            }
                        }
                    }
                }
                return super.onGenericMotionEvent(event);
            }
            onOverScrolled(scrollX, scrollY, clampedX, clampedY) {
                if (!this.mScroller.isFinished()) {
                    const oldX = this.mScrollX;
                    const oldY = this.mScrollY;
                    this.mScrollX = scrollX;
                    this.mScrollY = scrollY;
                    this.invalidateParentIfNeeded();
                    this.onScrollChanged(this.mScrollX, this.mScrollY, oldX, oldY);
                }
                else {
                    super.scrollTo(scrollX, scrollY);
                }
                if (!this.awakenScrollBars()) {
                    this.postInvalidateOnAnimation();
                }
            }
            getScrollRange() {
                let scrollRange = 0;
                if (this.getChildCount() > 0) {
                    let child = this.getChildAt(0);
                    scrollRange = Math.max(0, child.getHeight() - (this.getHeight() - this.mPaddingBottom - this.mPaddingTop));
                }
                return scrollRange;
            }
            findFocusableViewInBounds(topFocus, top, bottom) {
                return null;
            }
            pageScroll(direction) {
                let down = direction == View.FOCUS_DOWN;
                let height = this.getHeight();
                if (down) {
                    this.mTempRect.top = this.getScrollY() + height;
                    let count = this.getChildCount();
                    if (count > 0) {
                        let view = this.getChildAt(count - 1);
                        if (this.mTempRect.top + height > view.getBottom()) {
                            this.mTempRect.top = view.getBottom() - height;
                        }
                    }
                }
                else {
                    this.mTempRect.top = this.getScrollY() - height;
                    if (this.mTempRect.top < 0) {
                        this.mTempRect.top = 0;
                    }
                }
                this.mTempRect.bottom = this.mTempRect.top + height;
                return this.scrollAndFocus(direction, this.mTempRect.top, this.mTempRect.bottom);
            }
            fullScroll(direction) {
                let down = direction == View.FOCUS_DOWN;
                let height = this.getHeight();
                this.mTempRect.top = 0;
                this.mTempRect.bottom = height;
                if (down) {
                    let count = this.getChildCount();
                    if (count > 0) {
                        let view = this.getChildAt(count - 1);
                        this.mTempRect.bottom = view.getBottom() + this.mPaddingBottom;
                        this.mTempRect.top = this.mTempRect.bottom - height;
                    }
                }
                return this.scrollAndFocus(direction, this.mTempRect.top, this.mTempRect.bottom);
            }
            scrollAndFocus(direction, top, bottom) {
                let handled = true;
                let height = this.getHeight();
                let containerTop = this.getScrollY();
                let containerBottom = containerTop + height;
                let up = direction == View.FOCUS_UP;
                let newFocused = this.findFocusableViewInBounds(up, top, bottom);
                if (newFocused == null) {
                    newFocused = this;
                }
                if (top >= containerTop && bottom <= containerBottom) {
                    handled = false;
                }
                else {
                    let delta = up ? (top - containerTop) : (bottom - containerBottom);
                    this.doScrollY(delta);
                }
                if (newFocused != this.findFocus())
                    newFocused.requestFocus(direction);
                return handled;
            }
            arrowScroll(direction) {
                let currentFocused = this.findFocus();
                if (currentFocused == this)
                    currentFocused = null;
                let nextFocused = null;
                const maxJump = this.getMaxScrollAmount();
                if (nextFocused != null && this.isWithinDeltaOfScreen(nextFocused, maxJump, this.getHeight())) {
                }
                else {
                    let scrollDelta = maxJump;
                    if (direction == View.FOCUS_UP && this.getScrollY() < scrollDelta) {
                        scrollDelta = this.getScrollY();
                    }
                    else if (direction == View.FOCUS_DOWN) {
                        if (this.getChildCount() > 0) {
                            let daBottom = this.getChildAt(0).getBottom();
                            let screenBottom = this.getScrollY() + this.getHeight() - this.mPaddingBottom;
                            if (daBottom - screenBottom < maxJump) {
                                scrollDelta = daBottom - screenBottom;
                            }
                        }
                    }
                    if (scrollDelta == 0) {
                        return false;
                    }
                    this.doScrollY(direction == View.FOCUS_DOWN ? scrollDelta : -scrollDelta);
                }
                if (currentFocused != null && currentFocused.isFocused() && this.isOffScreen(currentFocused)) {
                }
                return true;
            }
            isOffScreen(descendant) {
                return !this.isWithinDeltaOfScreen(descendant, 0, this.getHeight());
            }
            isWithinDeltaOfScreen(descendant, delta, height) {
                descendant.getDrawingRect(this.mTempRect);
                this.offsetDescendantRectToMyCoords(descendant, this.mTempRect);
                return (this.mTempRect.bottom + delta) >= this.getScrollY()
                    && (this.mTempRect.top - delta) <= (this.getScrollY() + height);
            }
            doScrollY(delta) {
                if (delta != 0) {
                    if (this.mSmoothScrollingEnabled) {
                        this.smoothScrollBy(0, delta);
                    }
                    else {
                        this.scrollBy(0, delta);
                    }
                }
            }
            smoothScrollBy(dx, dy) {
                if (this.getChildCount() == 0) {
                    return;
                }
                let duration = SystemClock.uptimeMillis() - this.mLastScroll;
                if (duration > ScrollView.ANIMATED_SCROLL_GAP) {
                    const height = this.getHeight() - this.mPaddingBottom - this.mPaddingTop;
                    const bottom = this.getChildAt(0).getHeight();
                    const maxY = Math.max(0, bottom - height);
                    const scrollY = this.mScrollY;
                    dy = Math.max(0, Math.min(scrollY + dy, maxY)) - scrollY;
                    this.mScroller.startScroll(this.mScrollX, scrollY, 0, dy);
                    this.postInvalidateOnAnimation();
                }
                else {
                    if (!this.mScroller.isFinished()) {
                        this.mScroller.abortAnimation();
                    }
                    this.scrollBy(dx, dy);
                }
                this.mLastScroll = SystemClock.uptimeMillis();
            }
            smoothScrollTo(x, y) {
                this.smoothScrollBy(x - this.mScrollX, y - this.mScrollY);
            }
            computeVerticalScrollRange() {
                const count = this.getChildCount();
                const contentHeight = this.getHeight() - this.mPaddingBottom - this.mPaddingTop;
                if (count == 0) {
                    return contentHeight;
                }
                let scrollRange = this.getChildAt(0).getBottom();
                const scrollY = this.mScrollY;
                const overscrollBottom = Math.max(0, scrollRange - contentHeight);
                if (scrollY < 0) {
                    scrollRange -= scrollY;
                }
                else if (scrollY > overscrollBottom) {
                    scrollRange += scrollY - overscrollBottom;
                }
                return scrollRange;
            }
            computeVerticalScrollOffset() {
                return Math.max(0, super.computeVerticalScrollOffset());
            }
            measureChild(child, parentWidthMeasureSpec, parentHeightMeasureSpec) {
                let lp = child.getLayoutParams();
                lp._measuringParentWidthMeasureSpec = parentWidthMeasureSpec;
                lp._measuringParentHeightMeasureSpec = parentHeightMeasureSpec;
                let childWidthMeasureSpec;
                let childHeightMeasureSpec;
                childWidthMeasureSpec = ViewGroup.getChildMeasureSpec(parentWidthMeasureSpec, this.mPaddingLeft
                    + this.mPaddingRight, lp.width);
                childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
                child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
                lp._measuringParentWidthMeasureSpec = null;
                lp._measuringParentHeightMeasureSpec = null;
            }
            measureChildWithMargins(child, parentWidthMeasureSpec, widthUsed, parentHeightMeasureSpec, heightUsed) {
                const lp = child.getLayoutParams();
                lp._measuringParentWidthMeasureSpec = parentWidthMeasureSpec;
                lp._measuringParentHeightMeasureSpec = parentHeightMeasureSpec;
                const childWidthMeasureSpec = ScrollView.getChildMeasureSpec(parentWidthMeasureSpec, this.mPaddingLeft + this.mPaddingRight + lp.leftMargin + lp.rightMargin
                    + widthUsed, lp.width);
                const childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(lp.topMargin + lp.bottomMargin, MeasureSpec.UNSPECIFIED);
                child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
                lp._measuringParentWidthMeasureSpec = null;
                lp._measuringParentHeightMeasureSpec = null;
            }
            computeScroll() {
                if (this.mScroller.computeScrollOffset()) {
                    let oldX = this.mScrollX;
                    let oldY = this.mScrollY;
                    let x = this.mScroller.getCurrX();
                    let y = this.mScroller.getCurrY();
                    if (oldX != x || oldY != y) {
                        const range = this.getScrollRange();
                        const overscrollMode = this.getOverScrollMode();
                        const canOverscroll = overscrollMode == ScrollView.OVER_SCROLL_ALWAYS ||
                            (overscrollMode == ScrollView.OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
                        this.overScrollBy(x - oldX, y - oldY, oldX, oldY, 0, range, 0, this.mOverflingDistance, false);
                        this.onScrollChanged(this.mScrollX, this.mScrollY, oldX, oldY);
                        if (canOverscroll) {
                            if (y < 0 && oldY >= 0) {
                            }
                            else if (y > range && oldY <= range) {
                            }
                        }
                    }
                    if (!this.awakenScrollBars()) {
                        this.postInvalidateOnAnimation();
                    }
                }
                else {
                }
            }
            scrollToChild(child) {
                child.getDrawingRect(this.mTempRect);
                this.offsetDescendantRectToMyCoords(child, this.mTempRect);
                let scrollDelta = this.computeScrollDeltaToGetChildRectOnScreen(this.mTempRect);
                if (scrollDelta != 0) {
                    this.scrollBy(0, scrollDelta);
                }
            }
            scrollToChildRect(rect, immediate) {
                const delta = this.computeScrollDeltaToGetChildRectOnScreen(rect);
                const scroll = delta != 0;
                if (scroll) {
                    if (immediate) {
                        this.scrollBy(0, delta);
                    }
                    else {
                        this.smoothScrollBy(0, delta);
                    }
                }
                return scroll;
            }
            computeScrollDeltaToGetChildRectOnScreen(rect) {
                if (this.getChildCount() == 0)
                    return 0;
                let height = this.getHeight();
                let screenTop = this.getScrollY();
                let screenBottom = screenTop + height;
                let fadingEdge = this.getVerticalFadingEdgeLength();
                if (rect.top > 0) {
                    screenTop += fadingEdge;
                }
                if (rect.bottom < this.getChildAt(0).getHeight()) {
                    screenBottom -= fadingEdge;
                }
                let scrollYDelta = 0;
                if (rect.bottom > screenBottom && rect.top > screenTop) {
                    if (rect.height() > height) {
                        scrollYDelta += (rect.top - screenTop);
                    }
                    else {
                        scrollYDelta += (rect.bottom - screenBottom);
                    }
                    let bottom = this.getChildAt(0).getBottom();
                    let distanceToBottom = bottom - screenBottom;
                    scrollYDelta = Math.min(scrollYDelta, distanceToBottom);
                }
                else if (rect.top < screenTop && rect.bottom < screenBottom) {
                    if (rect.height() > height) {
                        scrollYDelta -= (screenBottom - rect.bottom);
                    }
                    else {
                        scrollYDelta -= (screenTop - rect.top);
                    }
                    scrollYDelta = Math.max(scrollYDelta, -this.getScrollY());
                }
                return scrollYDelta;
            }
            requestChildFocus(child, focused) {
                if (!this.mIsLayoutDirty) {
                    this.scrollToChild(focused);
                }
                else {
                    this.mChildToScrollTo = focused;
                }
                super.requestChildFocus(child, focused);
            }
            onRequestFocusInDescendants(direction, previouslyFocusedRect) {
                return false;
            }
            requestChildRectangleOnScreen(child, rectangle, immediate) {
                rectangle.offset(child.getLeft() - child.getScrollX(), child.getTop() - child.getScrollY());
                return this.scrollToChildRect(rectangle, immediate);
            }
            requestLayout() {
                this.mIsLayoutDirty = true;
                super.requestLayout();
            }
            onLayout(changed, l, t, r, b) {
                super.onLayout(changed, l, t, r, b);
                this.mIsLayoutDirty = false;
                if (this.mChildToScrollTo != null && ScrollView.isViewDescendantOf(this.mChildToScrollTo, this)) {
                    this.scrollToChild(this.mChildToScrollTo);
                }
                this.mChildToScrollTo = null;
                if (!this.isLaidOut()) {
                    const childHeight = (this.getChildCount() > 0) ? this.getChildAt(0).getMeasuredHeight() : 0;
                    const scrollRange = Math.max(0, childHeight - (b - t - this.mPaddingBottom - this.mPaddingTop));
                    if (this.mScrollY > scrollRange) {
                        this.mScrollY = scrollRange;
                    }
                    else if (this.mScrollY < 0) {
                        this.mScrollY = 0;
                    }
                }
                this.scrollTo(this.mScrollX, this.mScrollY);
            }
            onSizeChanged(w, h, oldw, oldh) {
                super.onSizeChanged(w, h, oldw, oldh);
                let currentFocused = this.findFocus();
                if (null == currentFocused || this == currentFocused)
                    return;
                if (this.isWithinDeltaOfScreen(currentFocused, 0, oldh)) {
                    currentFocused.getDrawingRect(this.mTempRect);
                    this.offsetDescendantRectToMyCoords(currentFocused, this.mTempRect);
                    let scrollDelta = this.computeScrollDeltaToGetChildRectOnScreen(this.mTempRect);
                    this.doScrollY(scrollDelta);
                }
            }
            static isViewDescendantOf(child, parent) {
                if (child == parent) {
                    return true;
                }
                const theParent = child.getParent();
                return (theParent instanceof ViewGroup) && ScrollView.isViewDescendantOf(theParent, parent);
            }
            fling(velocityY) {
                if (this.getChildCount() > 0) {
                    let height = this.getHeight() - this.mPaddingBottom - this.mPaddingTop;
                    let bottom = this.getChildAt(0).getHeight();
                    this.mScroller.fling(this.mScrollX, this.mScrollY, 0, velocityY, 0, 0, 0, Math.max(0, bottom - height), 0, this.mOverflingDistance);
                    this.postInvalidateOnAnimation();
                }
            }
            endDrag() {
                this.mIsBeingDragged = false;
                this.recycleVelocityTracker();
            }
            scrollTo(x, y) {
                if (this.getChildCount() > 0) {
                    let child = this.getChildAt(0);
                    x = ScrollView.clamp(x, this.getWidth() - this.mPaddingRight - this.mPaddingLeft, child.getWidth());
                    y = ScrollView.clamp(y, this.getHeight() - this.mPaddingBottom - this.mPaddingTop, child.getHeight());
                    if (x != this.mScrollX || y != this.mScrollY) {
                        super.scrollTo(x, y);
                    }
                }
            }
            static clamp(n, my, child) {
                if (my >= child || n < 0) {
                    return 0;
                }
                if ((my + n) > child) {
                    return child - my;
                }
                return n;
            }
            canScrollVertically(direction) {
                if (this.getOverScrollMode() === View.OVER_SCROLL_ALWAYS)
                    return true;
                return super.canScrollVertically(direction);
            }
        }
        ScrollView.ANIMATED_SCROLL_GAP = 250;
        ScrollView.MAX_SCROLL_FACTOR = 0.5;
        ScrollView.TAG = "ScrollView";
        ScrollView.INVALID_POINTER = -1;
        widget.ScrollView = ScrollView;
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
///<reference path="../view/Gravity.ts"/>
///<reference path="../view/View.ts"/>
///<reference path="../view/ViewGroup.ts"/>
///<reference path="../graphics/drawable/Drawable.ts"/>
///<reference path="../graphics/Rect.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var Gravity = android.view.Gravity;
        var View = android.view.View;
        var MeasureSpec = View.MeasureSpec;
        var ViewGroup = android.view.ViewGroup;
        class LinearLayout extends ViewGroup {
            constructor(bindElement, rootElement) {
                super(bindElement, rootElement);
                this.mBaselineAligned = true;
                this.mBaselineAlignedChildIndex = -1;
                this.mBaselineChildTop = 0;
                this.mOrientation = 0;
                this.mGravity = Gravity.LEFT | Gravity.TOP;
                this.mTotalLength = 0;
                this.mWeightSum = -1;
                this.mUseLargestChild = false;
                this.mDividerWidth = 0;
                this.mDividerHeight = 0;
                this.mShowDividers = LinearLayout.SHOW_DIVIDER_NONE;
                this.mDividerPadding = 0;
                this._attrBinder.addAttr('orientation', (value) => {
                    if ((value + "").toUpperCase() === 'VERTICAL' || LinearLayout.VERTICAL == value) {
                        this.setOrientation(LinearLayout.VERTICAL);
                    }
                    else if ((value + "").toUpperCase() === 'HORIZONTAL' || LinearLayout.HORIZONTAL == value) {
                        this.setOrientation(LinearLayout.HORIZONTAL);
                    }
                }, () => {
                    return this.mOrientation;
                });
                this._attrBinder.addAttr('gravity', (value) => {
                    this.setGravity(this._attrBinder.parseGravity(value, this.mGravity));
                }, () => {
                    return this.mGravity;
                });
                this._attrBinder.addAttr('baselineAligned', (value) => {
                    if (!this._attrBinder.parseBoolean(value))
                        this.setBaselineAligned(false);
                });
                this._attrBinder.addAttr('weightSum', (value) => {
                    let weightSum = Number.parseFloat(value);
                    if (!Number.isNaN(weightSum) && weightSum != null) {
                        this.setWeightSum(weightSum);
                    }
                }, () => {
                    return this.mWeightSum;
                });
                this._attrBinder.addAttr('baselineAlignedChildIndex', (value) => {
                    value = Number.parseInt(value);
                    if (Number.isSafeInteger(value)) {
                        this.mBaselineAlignedChildIndex = value;
                    }
                });
                this._attrBinder.addAttr('measureWithLargestChild', (value) => {
                    value = Number.parseInt(value);
                    if (Number.isSafeInteger(value)) {
                        this.mUseLargestChild = this._attrBinder.parseBoolean(value, this.mUseLargestChild);
                    }
                });
                this._attrBinder.addAttr('divider', (value) => {
                    this.setDividerDrawable(this._attrBinder.parseDrawable(value));
                });
                this._attrBinder.addAttr('showDividers', (value) => {
                    let fieldName = ('SHOW_DIVIDER_' + value).toUpperCase();
                    if (Number.isInteger(LinearLayout[fieldName])) {
                        this.mShowDividers = LinearLayout[fieldName];
                    }
                });
                this._attrBinder.addAttr('dividerPadding', (value) => {
                    value = Number.parseInt(value);
                    if (Number.isInteger(value)) {
                        this.mDividerPadding = value;
                    }
                });
            }
            setShowDividers(showDividers) {
                if (showDividers != this.mShowDividers) {
                    this.requestLayout();
                }
                this.mShowDividers = showDividers;
            }
            shouldDelayChildPressedState() {
                return false;
            }
            getShowDividers() {
                return this.mShowDividers;
            }
            getDividerDrawable() {
                return this.mDivider;
            }
            setDividerDrawable(divider) {
                if (divider == this.mDivider) {
                    return;
                }
                this.mDivider = divider;
                if (divider != null) {
                    this.mDividerWidth = divider.getIntrinsicWidth();
                    this.mDividerHeight = divider.getIntrinsicHeight();
                }
                else {
                    this.mDividerWidth = 0;
                    this.mDividerHeight = 0;
                }
                this.setWillNotDraw(divider == null);
                this.requestLayout();
            }
            setDividerPadding(padding) {
                this.mDividerPadding = padding;
            }
            getDividerPadding() {
                return this.mDividerPadding;
            }
            getDividerWidth() {
                return this.mDividerWidth;
            }
            onDraw(canvas) {
                if (this.mDivider == null) {
                    return;
                }
                if (this.mOrientation == LinearLayout.VERTICAL) {
                    this.drawDividersVertical(canvas);
                }
                else {
                    this.drawDividersHorizontal(canvas);
                }
            }
            drawDividersVertical(canvas) {
                const count = this.getVirtualChildCount();
                for (let i = 0; i < count; i++) {
                    const child = this.getVirtualChildAt(i);
                    if (child != null && child.getVisibility() != View.GONE) {
                        if (this.hasDividerBeforeChildAt(i)) {
                            const lp = child.getLayoutParams();
                            const top = child.getTop() - lp.topMargin - this.mDividerHeight;
                            this.drawHorizontalDivider(canvas, top);
                        }
                    }
                }
                if (this.hasDividerBeforeChildAt(count)) {
                    const child = this.getVirtualChildAt(count - 1);
                    let bottom = 0;
                    if (child == null) {
                        bottom = this.getHeight() - this.getPaddingBottom() - this.mDividerHeight;
                    }
                    else {
                        const lp = child.getLayoutParams();
                        bottom = child.getBottom() + lp.bottomMargin;
                    }
                    this.drawHorizontalDivider(canvas, bottom);
                }
            }
            drawDividersHorizontal(canvas) {
                const count = this.getVirtualChildCount();
                const isLayoutRtl = this.isLayoutRtl();
                for (let i = 0; i < count; i++) {
                    const child = this.getVirtualChildAt(i);
                    if (child != null && child.getVisibility() != View.GONE) {
                        if (this.hasDividerBeforeChildAt(i)) {
                            const lp = child.getLayoutParams();
                            let position;
                            if (isLayoutRtl) {
                                position = child.getRight() + lp.rightMargin;
                            }
                            else {
                                position = child.getLeft() - lp.leftMargin - this.mDividerWidth;
                            }
                            this.drawVerticalDivider(canvas, position);
                        }
                    }
                }
                if (this.hasDividerBeforeChildAt(count)) {
                    const child = this.getVirtualChildAt(count - 1);
                    let position;
                    if (child == null) {
                        if (isLayoutRtl) {
                            position = this.getPaddingLeft();
                        }
                        else {
                            position = this.getWidth() - this.getPaddingRight() - this.mDividerWidth;
                        }
                    }
                    else {
                        const lp = child.getLayoutParams();
                        if (isLayoutRtl) {
                            position = child.getLeft() - lp.leftMargin - this.mDividerWidth;
                        }
                        else {
                            position = child.getRight() + lp.rightMargin;
                        }
                    }
                    this.drawVerticalDivider(canvas, position);
                }
            }
            drawHorizontalDivider(canvas, top) {
                this.mDivider.setBounds(this.getPaddingLeft() + this.mDividerPadding, top, this.getWidth() - this.getPaddingRight() - this.mDividerPadding, top + this.mDividerHeight);
                this.mDivider.draw(canvas);
            }
            drawVerticalDivider(canvas, left) {
                this.mDivider.setBounds(left, this.getPaddingTop() + this.mDividerPadding, left + this.mDividerWidth, this.getHeight() - this.getPaddingBottom() - this.mDividerPadding);
                this.mDivider.draw(canvas);
            }
            isBaselineAligned() {
                return this.mBaselineAligned;
            }
            setBaselineAligned(baselineAligned) {
                this.mBaselineAligned = baselineAligned;
            }
            isMeasureWithLargestChildEnabled() {
                return this.mUseLargestChild;
            }
            setMeasureWithLargestChildEnabled(enabled) {
                this.mUseLargestChild = enabled;
            }
            getBaseline() {
                if (this.mBaselineAlignedChildIndex < 0) {
                    return super.getBaseline();
                }
                if (this.getChildCount() <= this.mBaselineAlignedChildIndex) {
                    throw new Error("mBaselineAlignedChildIndex of LinearLayout "
                        + "set to an index that is out of bounds.");
                }
                const child = this.getChildAt(this.mBaselineAlignedChildIndex);
                const childBaseline = child.getBaseline();
                if (childBaseline == -1) {
                    if (this.mBaselineAlignedChildIndex == 0) {
                        return -1;
                    }
                    throw new Error("mBaselineAlignedChildIndex of LinearLayout "
                        + "points to a View that doesn't know how to get its baseline.");
                }
                let childTop = this.mBaselineChildTop;
                if (this.mOrientation == LinearLayout.VERTICAL) {
                    const majorGravity = this.mGravity & Gravity.VERTICAL_GRAVITY_MASK;
                    if (majorGravity != Gravity.TOP) {
                        switch (majorGravity) {
                            case Gravity.BOTTOM:
                                childTop = this.mBottom - this.mTop - this.mPaddingBottom - this.mTotalLength;
                                break;
                            case Gravity.CENTER_VERTICAL:
                                childTop += ((this.mBottom - this.mTop - this.mPaddingTop - this.mPaddingBottom) -
                                    this.mTotalLength) / 2;
                                break;
                        }
                    }
                }
                let lp = child.getLayoutParams();
                return childTop + lp.topMargin + childBaseline;
            }
            getBaselineAlignedChildIndex() {
                return this.mBaselineAlignedChildIndex;
            }
            setBaselineAlignedChildIndex(i) {
                if ((i < 0) || (i >= this.getChildCount())) {
                    throw new Error("base aligned child index out "
                        + "of range (0, " + this.getChildCount() + ")");
                }
                this.mBaselineAlignedChildIndex = i;
            }
            getVirtualChildAt(index) {
                return this.getChildAt(index);
            }
            getVirtualChildCount() {
                return this.getChildCount();
            }
            getWeightSum() {
                return this.mWeightSum;
            }
            setWeightSum(weightSum) {
                this.mWeightSum = Math.max(0, weightSum);
            }
            onMeasure(widthMeasureSpec, heightMeasureSpec) {
                if (this.mOrientation == LinearLayout.VERTICAL) {
                    this.measureVertical(widthMeasureSpec, heightMeasureSpec);
                }
                else {
                    this.measureHorizontal(widthMeasureSpec, heightMeasureSpec);
                }
            }
            hasDividerBeforeChildAt(childIndex) {
                if (childIndex == 0) {
                    return (this.mShowDividers & LinearLayout.SHOW_DIVIDER_BEGINNING) != 0;
                }
                else if (childIndex == this.getChildCount()) {
                    return (this.mShowDividers & LinearLayout.SHOW_DIVIDER_END) != 0;
                }
                else if ((this.mShowDividers & LinearLayout.SHOW_DIVIDER_MIDDLE) != 0) {
                    let hasVisibleViewBefore = false;
                    for (let i = childIndex - 1; i >= 0; i--) {
                        if (this.getChildAt(i).getVisibility() != LinearLayout.GONE) {
                            hasVisibleViewBefore = true;
                            break;
                        }
                    }
                    return hasVisibleViewBefore;
                }
                return false;
            }
            measureVertical(widthMeasureSpec, heightMeasureSpec) {
                this.mTotalLength = 0;
                let maxWidth = 0;
                let childState = 0;
                let alternativeMaxWidth = 0;
                let weightedMaxWidth = 0;
                let allFillParent = true;
                let totalWeight = 0;
                const count = this.getVirtualChildCount();
                const widthMode = MeasureSpec.getMode(widthMeasureSpec);
                const heightMode = MeasureSpec.getMode(heightMeasureSpec);
                let matchWidth = false;
                const baselineChildIndex = this.mBaselineAlignedChildIndex;
                const useLargestChild = this.mUseLargestChild;
                let largestChildHeight = Number.MIN_SAFE_INTEGER;
                for (let i = 0; i < count; ++i) {
                    const child = this.getVirtualChildAt(i);
                    if (child == null) {
                        this.mTotalLength += this.measureNullChild(i);
                        continue;
                    }
                    if (child.getVisibility() == View.GONE) {
                        i += this.getChildrenSkipCount(child, i);
                        continue;
                    }
                    if (this.hasDividerBeforeChildAt(i)) {
                        this.mTotalLength += this.mDividerHeight;
                    }
                    let lp = child.getLayoutParams();
                    totalWeight += lp.weight;
                    if (heightMode == MeasureSpec.EXACTLY && lp.height == 0 && lp.weight > 0) {
                        const totalLength = this.mTotalLength;
                        this.mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);
                    }
                    else {
                        let oldHeight = Number.MIN_SAFE_INTEGER;
                        if (lp.height == 0 && lp.weight > 0) {
                            oldHeight = 0;
                            lp.height = LinearLayout.LayoutParams.WRAP_CONTENT;
                        }
                        this.measureChildBeforeLayout(child, i, widthMeasureSpec, 0, heightMeasureSpec, totalWeight == 0 ? this.mTotalLength : 0);
                        if (oldHeight != Number.MIN_SAFE_INTEGER) {
                            lp.height = oldHeight;
                        }
                        const childHeight = child.getMeasuredHeight();
                        const totalLength = this.mTotalLength;
                        this.mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +
                            lp.bottomMargin + this.getNextLocationOffset(child));
                        if (useLargestChild) {
                            largestChildHeight = Math.max(childHeight, largestChildHeight);
                        }
                    }
                    if ((baselineChildIndex >= 0) && (baselineChildIndex == i + 1)) {
                        this.mBaselineChildTop = this.mTotalLength;
                    }
                    if (i < baselineChildIndex && lp.weight > 0) {
                        throw new Error("A child of LinearLayout with index "
                            + "less than mBaselineAlignedChildIndex has weight > 0, which "
                            + "won't work.  Either remove the weight, or don't set "
                            + "mBaselineAlignedChildIndex.");
                    }
                    let matchWidthLocally = false;
                    if (widthMode != MeasureSpec.EXACTLY && lp.width == LinearLayout.LayoutParams.MATCH_PARENT) {
                        matchWidth = true;
                        matchWidthLocally = true;
                    }
                    const margin = lp.leftMargin + lp.rightMargin;
                    const measuredWidth = child.getMeasuredWidth() + margin;
                    maxWidth = Math.max(maxWidth, measuredWidth);
                    childState = LinearLayout.combineMeasuredStates(childState, child.getMeasuredState());
                    allFillParent = allFillParent && lp.width == LinearLayout.LayoutParams.MATCH_PARENT;
                    if (lp.weight > 0) {
                        weightedMaxWidth = Math.max(weightedMaxWidth, matchWidthLocally ? margin : measuredWidth);
                    }
                    else {
                        alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
                    }
                    i += this.getChildrenSkipCount(child, i);
                }
                if (this.mTotalLength > 0 && this.hasDividerBeforeChildAt(count)) {
                    this.mTotalLength += this.mDividerHeight;
                }
                if (useLargestChild &&
                    (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) {
                    this.mTotalLength = 0;
                    for (let i = 0; i < count; ++i) {
                        const child = this.getVirtualChildAt(i);
                        if (child == null) {
                            this.mTotalLength += this.measureNullChild(i);
                            continue;
                        }
                        if (child.getVisibility() == View.GONE) {
                            i += this.getChildrenSkipCount(child, i);
                            continue;
                        }
                        const lp = child.getLayoutParams();
                        const totalLength = this.mTotalLength;
                        this.mTotalLength = Math.max(totalLength, totalLength + largestChildHeight +
                            lp.topMargin + lp.bottomMargin + this.getNextLocationOffset(child));
                    }
                }
                this.mTotalLength += this.mPaddingTop + this.mPaddingBottom;
                let heightSize = this.mTotalLength;
                heightSize = Math.max(heightSize, this.getSuggestedMinimumHeight());
                let heightSizeAndState = LinearLayout.resolveSizeAndState(heightSize, heightMeasureSpec, 0);
                heightSize = heightSizeAndState & View.MEASURED_SIZE_MASK;
                let delta = heightSize - this.mTotalLength;
                if (delta != 0 && totalWeight > 0) {
                    let weightSum = this.mWeightSum > 0 ? this.mWeightSum : totalWeight;
                    this.mTotalLength = 0;
                    for (let i = 0; i < count; ++i) {
                        const child = this.getVirtualChildAt(i);
                        if (child.getVisibility() == View.GONE) {
                            continue;
                        }
                        let lp = child.getLayoutParams();
                        let childExtra = lp.weight;
                        if (childExtra > 0) {
                            let share = (childExtra * delta / weightSum);
                            weightSum -= childExtra;
                            delta -= share;
                            const childWidthMeasureSpec = LinearLayout.getChildMeasureSpec(widthMeasureSpec, this.mPaddingLeft + this.mPaddingRight +
                                lp.leftMargin + lp.rightMargin, lp.width);
                            if ((lp.height != 0) || (heightMode != MeasureSpec.EXACTLY)) {
                                let childHeight = child.getMeasuredHeight() + share;
                                if (childHeight < 0) {
                                    childHeight = 0;
                                }
                                child.measure(childWidthMeasureSpec, MeasureSpec.makeMeasureSpec(childHeight, MeasureSpec.EXACTLY));
                            }
                            else {
                                child.measure(childWidthMeasureSpec, MeasureSpec.makeMeasureSpec(share > 0 ? share : 0, MeasureSpec.EXACTLY));
                            }
                            childState = LinearLayout.combineMeasuredStates(childState, child.getMeasuredState()
                                & (View.MEASURED_STATE_MASK >> View.MEASURED_HEIGHT_STATE_SHIFT));
                        }
                        const margin = lp.leftMargin + lp.rightMargin;
                        const measuredWidth = child.getMeasuredWidth() + margin;
                        maxWidth = Math.max(maxWidth, measuredWidth);
                        let matchWidthLocally = widthMode != MeasureSpec.EXACTLY &&
                            lp.width == LinearLayout.LayoutParams.MATCH_PARENT;
                        alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
                        allFillParent = allFillParent && lp.width == LinearLayout.LayoutParams.MATCH_PARENT;
                        const totalLength = this.mTotalLength;
                        this.mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() +
                            lp.topMargin + lp.bottomMargin + this.getNextLocationOffset(child));
                    }
                    this.mTotalLength += this.mPaddingTop + this.mPaddingBottom;
                }
                else {
                    alternativeMaxWidth = Math.max(alternativeMaxWidth, weightedMaxWidth);
                    if (useLargestChild && heightMode != MeasureSpec.EXACTLY) {
                        for (let i = 0; i < count; i++) {
                            const child = this.getVirtualChildAt(i);
                            if (child == null || child.getVisibility() == View.GONE) {
                                continue;
                            }
                            const lp = child.getLayoutParams();
                            let childExtra = lp.weight;
                            if (childExtra > 0) {
                                child.measure(MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(largestChildHeight, MeasureSpec.EXACTLY));
                            }
                        }
                    }
                }
                if (!allFillParent && widthMode != MeasureSpec.EXACTLY) {
                    maxWidth = alternativeMaxWidth;
                }
                maxWidth += this.mPaddingLeft + this.mPaddingRight;
                maxWidth = Math.max(maxWidth, this.getSuggestedMinimumWidth());
                this.setMeasuredDimension(LinearLayout.resolveSizeAndState(maxWidth, widthMeasureSpec, childState), heightSizeAndState);
                if (matchWidth) {
                    this.forceUniformWidth(count, heightMeasureSpec);
                }
            }
            forceUniformWidth(count, heightMeasureSpec) {
                let uniformMeasureSpec = MeasureSpec.makeMeasureSpec(this.getMeasuredWidth(), MeasureSpec.EXACTLY);
                for (let i = 0; i < count; ++i) {
                    const child = this.getVirtualChildAt(i);
                    if (child.getVisibility() != View.GONE) {
                        let lp = child.getLayoutParams();
                        if (lp.width == LinearLayout.LayoutParams.MATCH_PARENT) {
                            let oldHeight = lp.height;
                            lp.height = child.getMeasuredHeight();
                            this.measureChildWithMargins(child, uniformMeasureSpec, 0, heightMeasureSpec, 0);
                            lp.height = oldHeight;
                        }
                    }
                }
            }
            measureHorizontal(widthMeasureSpec, heightMeasureSpec) {
                this.mTotalLength = 0;
                let maxHeight = 0;
                let childState = 0;
                let alternativeMaxHeight = 0;
                let weightedMaxHeight = 0;
                let allFillParent = true;
                let totalWeight = 0;
                const count = this.getVirtualChildCount();
                const widthMode = MeasureSpec.getMode(widthMeasureSpec);
                const heightMode = MeasureSpec.getMode(heightMeasureSpec);
                let matchHeight = false;
                if (this.mMaxAscent == null || this.mMaxDescent == null) {
                    this.mMaxAscent = new Array(LinearLayout.VERTICAL_GRAVITY_COUNT);
                    this.mMaxDescent = new Array(LinearLayout.VERTICAL_GRAVITY_COUNT);
                }
                let maxAscent = this.mMaxAscent;
                let maxDescent = this.mMaxDescent;
                maxAscent[0] = maxAscent[1] = maxAscent[2] = maxAscent[3] = -1;
                maxDescent[0] = maxDescent[1] = maxDescent[2] = maxDescent[3] = -1;
                const baselineAligned = this.mBaselineAligned;
                const useLargestChild = this.mUseLargestChild;
                const isExactly = widthMode == MeasureSpec.EXACTLY;
                let largestChildWidth = Number.MAX_SAFE_INTEGER;
                for (let i = 0; i < count; ++i) {
                    const child = this.getVirtualChildAt(i);
                    if (child == null) {
                        this.mTotalLength += this.measureNullChild(i);
                        continue;
                    }
                    if (child.getVisibility() == View.GONE) {
                        i += this.getChildrenSkipCount(child, i);
                        continue;
                    }
                    if (this.hasDividerBeforeChildAt(i)) {
                        this.mTotalLength += this.mDividerWidth;
                    }
                    const lp = child.getLayoutParams();
                    totalWeight += lp.weight;
                    if (widthMode == MeasureSpec.EXACTLY && lp.width == 0 && lp.weight > 0) {
                        if (isExactly) {
                            this.mTotalLength += lp.leftMargin + lp.rightMargin;
                        }
                        else {
                            const totalLength = this.mTotalLength;
                            this.mTotalLength = Math.max(totalLength, totalLength +
                                lp.leftMargin + lp.rightMargin);
                        }
                        if (baselineAligned) {
                            const freeSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
                            child.measure(freeSpec, freeSpec);
                        }
                    }
                    else {
                        let oldWidth = Number.MIN_SAFE_INTEGER;
                        if (lp.width == 0 && lp.weight > 0) {
                            oldWidth = 0;
                            lp.width = LinearLayout.LayoutParams.WRAP_CONTENT;
                        }
                        this.measureChildBeforeLayout(child, i, widthMeasureSpec, totalWeight == 0 ? this.mTotalLength : 0, heightMeasureSpec, 0);
                        if (oldWidth != Number.MIN_SAFE_INTEGER) {
                            lp.width = oldWidth;
                        }
                        const childWidth = child.getMeasuredWidth();
                        if (isExactly) {
                            this.mTotalLength += childWidth + lp.leftMargin + lp.rightMargin +
                                this.getNextLocationOffset(child);
                        }
                        else {
                            const totalLength = this.mTotalLength;
                            this.mTotalLength = Math.max(totalLength, totalLength + childWidth + lp.leftMargin +
                                lp.rightMargin + this.getNextLocationOffset(child));
                        }
                        if (useLargestChild) {
                            largestChildWidth = Math.max(childWidth, largestChildWidth);
                        }
                    }
                    let matchHeightLocally = false;
                    if (heightMode != MeasureSpec.EXACTLY && lp.height == LinearLayout.LayoutParams.MATCH_PARENT) {
                        matchHeight = true;
                        matchHeightLocally = true;
                    }
                    const margin = lp.topMargin + lp.bottomMargin;
                    const childHeight = child.getMeasuredHeight() + margin;
                    childState = LinearLayout.combineMeasuredStates(childState, child.getMeasuredState());
                    if (baselineAligned) {
                        const childBaseline = child.getBaseline();
                        if (childBaseline != -1) {
                            const gravity = (lp.gravity < 0 ? this.mGravity : lp.gravity)
                                & Gravity.VERTICAL_GRAVITY_MASK;
                            const index = ((gravity >> Gravity.AXIS_Y_SHIFT)
                                & ~Gravity.AXIS_SPECIFIED) >> 1;
                            maxAscent[index] = Math.max(maxAscent[index], childBaseline);
                            maxDescent[index] = Math.max(maxDescent[index], childHeight - childBaseline);
                        }
                    }
                    maxHeight = Math.max(maxHeight, childHeight);
                    allFillParent = allFillParent && lp.height == LinearLayout.LayoutParams.MATCH_PARENT;
                    if (lp.weight > 0) {
                        weightedMaxHeight = Math.max(weightedMaxHeight, matchHeightLocally ? margin : childHeight);
                    }
                    else {
                        alternativeMaxHeight = Math.max(alternativeMaxHeight, matchHeightLocally ? margin : childHeight);
                    }
                    i += this.getChildrenSkipCount(child, i);
                }
                if (this.mTotalLength > 0 && this.hasDividerBeforeChildAt(count)) {
                    this.mTotalLength += this.mDividerWidth;
                }
                if (maxAscent[LinearLayout.INDEX_TOP] != -1 ||
                    maxAscent[LinearLayout.INDEX_CENTER_VERTICAL] != -1 ||
                    maxAscent[LinearLayout.INDEX_BOTTOM] != -1 ||
                    maxAscent[LinearLayout.INDEX_FILL] != -1) {
                    const ascent = Math.max(maxAscent[LinearLayout.INDEX_FILL], Math.max(maxAscent[LinearLayout.INDEX_CENTER_VERTICAL], Math.max(maxAscent[LinearLayout.INDEX_TOP], maxAscent[LinearLayout.INDEX_BOTTOM])));
                    const descent = Math.max(maxDescent[LinearLayout.INDEX_FILL], Math.max(maxDescent[LinearLayout.INDEX_CENTER_VERTICAL], Math.max(maxDescent[LinearLayout.INDEX_TOP], maxDescent[LinearLayout.INDEX_BOTTOM])));
                    maxHeight = Math.max(maxHeight, ascent + descent);
                }
                if (useLargestChild &&
                    (widthMode == MeasureSpec.AT_MOST || widthMode == MeasureSpec.UNSPECIFIED)) {
                    this.mTotalLength = 0;
                    for (let i = 0; i < count; ++i) {
                        const child = this.getVirtualChildAt(i);
                        if (child == null) {
                            this.mTotalLength += this.measureNullChild(i);
                            continue;
                        }
                        if (child.getVisibility() == View.GONE) {
                            i += this.getChildrenSkipCount(child, i);
                            continue;
                        }
                        const lp = child.getLayoutParams();
                        if (isExactly) {
                            this.mTotalLength += largestChildWidth + lp.leftMargin + lp.rightMargin +
                                this.getNextLocationOffset(child);
                        }
                        else {
                            const totalLength = this.mTotalLength;
                            this.mTotalLength = Math.max(totalLength, totalLength + largestChildWidth +
                                lp.leftMargin + lp.rightMargin + this.getNextLocationOffset(child));
                        }
                    }
                }
                this.mTotalLength += this.mPaddingLeft + this.mPaddingRight;
                let widthSize = this.mTotalLength;
                widthSize = Math.max(widthSize, this.getSuggestedMinimumWidth());
                let widthSizeAndState = LinearLayout.resolveSizeAndState(widthSize, widthMeasureSpec, 0);
                widthSize = widthSizeAndState & View.MEASURED_SIZE_MASK;
                let delta = widthSize - this.mTotalLength;
                if (delta != 0 && totalWeight > 0) {
                    let weightSum = this.mWeightSum > 0 ? this.mWeightSum : totalWeight;
                    maxAscent[0] = maxAscent[1] = maxAscent[2] = maxAscent[3] = -1;
                    maxDescent[0] = maxDescent[1] = maxDescent[2] = maxDescent[3] = -1;
                    maxHeight = -1;
                    this.mTotalLength = 0;
                    for (let i = 0; i < count; ++i) {
                        const child = this.getVirtualChildAt(i);
                        if (child == null || child.getVisibility() == View.GONE) {
                            continue;
                        }
                        const lp = child.getLayoutParams();
                        let childExtra = lp.weight;
                        if (childExtra > 0) {
                            let share = (childExtra * delta / weightSum);
                            weightSum -= childExtra;
                            delta -= share;
                            const childHeightMeasureSpec = LinearLayout.getChildMeasureSpec(heightMeasureSpec, this.mPaddingTop + this.mPaddingBottom + lp.topMargin + lp.bottomMargin, lp.height);
                            if ((lp.width != 0) || (widthMode != MeasureSpec.EXACTLY)) {
                                let childWidth = child.getMeasuredWidth() + share;
                                if (childWidth < 0) {
                                    childWidth = 0;
                                }
                                child.measure(MeasureSpec.makeMeasureSpec(childWidth, MeasureSpec.EXACTLY), childHeightMeasureSpec);
                            }
                            else {
                                child.measure(MeasureSpec.makeMeasureSpec(share > 0 ? share : 0, MeasureSpec.EXACTLY), childHeightMeasureSpec);
                            }
                            childState = LinearLayout.combineMeasuredStates(childState, child.getMeasuredState() & View.MEASURED_STATE_MASK);
                        }
                        if (isExactly) {
                            this.mTotalLength += child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin +
                                this.getNextLocationOffset(child);
                        }
                        else {
                            const totalLength = this.mTotalLength;
                            this.mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredWidth() +
                                lp.leftMargin + lp.rightMargin + this.getNextLocationOffset(child));
                        }
                        let matchHeightLocally = heightMode != MeasureSpec.EXACTLY &&
                            lp.height == LinearLayout.LayoutParams.MATCH_PARENT;
                        const margin = lp.topMargin + lp.bottomMargin;
                        let childHeight = child.getMeasuredHeight() + margin;
                        maxHeight = Math.max(maxHeight, childHeight);
                        alternativeMaxHeight = Math.max(alternativeMaxHeight, matchHeightLocally ? margin : childHeight);
                        allFillParent = allFillParent && lp.height == LinearLayout.LayoutParams.MATCH_PARENT;
                        if (baselineAligned) {
                            const childBaseline = child.getBaseline();
                            if (childBaseline != -1) {
                                const gravity = (lp.gravity < 0 ? this.mGravity : lp.gravity)
                                    & Gravity.VERTICAL_GRAVITY_MASK;
                                const index = ((gravity >> Gravity.AXIS_Y_SHIFT)
                                    & ~Gravity.AXIS_SPECIFIED) >> 1;
                                maxAscent[index] = Math.max(maxAscent[index], childBaseline);
                                maxDescent[index] = Math.max(maxDescent[index], childHeight - childBaseline);
                            }
                        }
                    }
                    this.mTotalLength += this.mPaddingLeft + this.mPaddingRight;
                    if (maxAscent[LinearLayout.INDEX_TOP] != -1 ||
                        maxAscent[LinearLayout.INDEX_CENTER_VERTICAL] != -1 ||
                        maxAscent[LinearLayout.INDEX_BOTTOM] != -1 ||
                        maxAscent[LinearLayout.INDEX_FILL] != -1) {
                        const ascent = Math.max(maxAscent[LinearLayout.INDEX_FILL], Math.max(maxAscent[LinearLayout.INDEX_CENTER_VERTICAL], Math.max(maxAscent[LinearLayout.INDEX_TOP], maxAscent[LinearLayout.INDEX_BOTTOM])));
                        const descent = Math.max(maxDescent[LinearLayout.INDEX_FILL], Math.max(maxDescent[LinearLayout.INDEX_CENTER_VERTICAL], Math.max(maxDescent[LinearLayout.INDEX_TOP], maxDescent[LinearLayout.INDEX_BOTTOM])));
                        maxHeight = Math.max(maxHeight, ascent + descent);
                    }
                }
                else {
                    alternativeMaxHeight = Math.max(alternativeMaxHeight, weightedMaxHeight);
                    if (useLargestChild && widthMode != MeasureSpec.EXACTLY) {
                        for (let i = 0; i < count; i++) {
                            const child = this.getVirtualChildAt(i);
                            if (child == null || child.getVisibility() == View.GONE) {
                                continue;
                            }
                            const lp = child.getLayoutParams();
                            let childExtra = lp.weight;
                            if (childExtra > 0) {
                                child.measure(MeasureSpec.makeMeasureSpec(largestChildWidth, MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(child.getMeasuredHeight(), MeasureSpec.EXACTLY));
                            }
                        }
                    }
                }
                if (!allFillParent && heightMode != MeasureSpec.EXACTLY) {
                    maxHeight = alternativeMaxHeight;
                }
                maxHeight += this.mPaddingTop + this.mPaddingBottom;
                maxHeight = Math.max(maxHeight, this.getSuggestedMinimumHeight());
                this.setMeasuredDimension(widthSizeAndState | (childState & View.MEASURED_STATE_MASK), LinearLayout.resolveSizeAndState(maxHeight, heightMeasureSpec, (childState << View.MEASURED_HEIGHT_STATE_SHIFT)));
                if (matchHeight) {
                    this.forceUniformHeight(count, widthMeasureSpec);
                }
            }
            forceUniformHeight(count, widthMeasureSpec) {
                let uniformMeasureSpec = MeasureSpec.makeMeasureSpec(this.getMeasuredHeight(), MeasureSpec.EXACTLY);
                for (let i = 0; i < count; ++i) {
                    const child = this.getVirtualChildAt(i);
                    if (child.getVisibility() != View.GONE) {
                        let lp = child.getLayoutParams();
                        if (lp.height == LinearLayout.LayoutParams.MATCH_PARENT) {
                            let oldWidth = lp.width;
                            lp.width = child.getMeasuredWidth();
                            this.measureChildWithMargins(child, widthMeasureSpec, 0, uniformMeasureSpec, 0);
                            lp.width = oldWidth;
                        }
                    }
                }
            }
            getChildrenSkipCount(child, index) {
                return 0;
            }
            measureNullChild(childIndex) {
                return 0;
            }
            measureChildBeforeLayout(child, childIndex, widthMeasureSpec, totalWidth, heightMeasureSpec, totalHeight) {
                this.measureChildWithMargins(child, widthMeasureSpec, totalWidth, heightMeasureSpec, totalHeight);
            }
            getLocationOffset(child) {
                return 0;
            }
            getNextLocationOffset(child) {
                return 0;
            }
            onLayout(changed, l, t, r, b) {
                if (this.mOrientation == LinearLayout.VERTICAL) {
                    this.layoutVertical(l, t, r, b);
                }
                else {
                    this.layoutHorizontal(l, t, r, b);
                }
            }
            layoutVertical(left, top, right, bottom) {
                const paddingLeft = this.mPaddingLeft;
                let childTop;
                let childLeft;
                const width = right - left;
                let childRight = width - this.mPaddingRight;
                let childSpace = width - paddingLeft - this.mPaddingRight;
                const count = this.getVirtualChildCount();
                const majorGravity = this.mGravity & Gravity.VERTICAL_GRAVITY_MASK;
                const minorGravity = this.mGravity & Gravity.HORIZONTAL_GRAVITY_MASK;
                switch (majorGravity) {
                    case Gravity.BOTTOM:
                        childTop = this.mPaddingTop + bottom - top - this.mTotalLength;
                        break;
                    case Gravity.CENTER_VERTICAL:
                        childTop = this.mPaddingTop + (bottom - top - this.mTotalLength) / 2;
                        break;
                    case Gravity.TOP:
                    default:
                        childTop = this.mPaddingTop;
                        break;
                }
                for (let i = 0; i < count; i++) {
                    const child = this.getVirtualChildAt(i);
                    if (child == null) {
                        childTop += this.measureNullChild(i);
                    }
                    else if (child.getVisibility() != View.GONE) {
                        const childWidth = child.getMeasuredWidth();
                        const childHeight = child.getMeasuredHeight();
                        const lp = child.getLayoutParams();
                        let gravity = lp.gravity;
                        if (gravity < 0) {
                            gravity = minorGravity;
                        }
                        const absoluteGravity = gravity;
                        switch (absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
                            case Gravity.CENTER_HORIZONTAL:
                                childLeft = paddingLeft + ((childSpace - childWidth) / 2)
                                    + lp.leftMargin - lp.rightMargin;
                                break;
                            case Gravity.RIGHT:
                                childLeft = childRight - childWidth - lp.rightMargin;
                                break;
                            case Gravity.LEFT:
                            default:
                                childLeft = paddingLeft + lp.leftMargin;
                                break;
                        }
                        if (this.hasDividerBeforeChildAt(i)) {
                            childTop += this.mDividerHeight;
                        }
                        childTop += lp.topMargin;
                        this.setChildFrame(child, childLeft, childTop + this.getLocationOffset(child), childWidth, childHeight);
                        childTop += childHeight + lp.bottomMargin + this.getNextLocationOffset(child);
                        i += this.getChildrenSkipCount(child, i);
                    }
                }
            }
            layoutHorizontal(left, top, right, bottom) {
                const isLayoutRtl = this.isLayoutRtl();
                const paddingTop = this.mPaddingTop;
                let childTop;
                let childLeft;
                const height = bottom - top;
                let childBottom = height - this.mPaddingBottom;
                let childSpace = height - paddingTop - this.mPaddingBottom;
                const count = this.getVirtualChildCount();
                const majorGravity = this.mGravity & Gravity.HORIZONTAL_GRAVITY_MASK;
                const minorGravity = this.mGravity & Gravity.VERTICAL_GRAVITY_MASK;
                const baselineAligned = this.mBaselineAligned;
                const maxAscent = this.mMaxAscent;
                const maxDescent = this.mMaxDescent;
                let absoluteGravity = majorGravity;
                switch (absoluteGravity) {
                    case Gravity.RIGHT:
                        childLeft = this.mPaddingLeft + right - left - this.mTotalLength;
                        break;
                    case Gravity.CENTER_HORIZONTAL:
                        childLeft = this.mPaddingLeft + (right - left - this.mTotalLength) / 2;
                        break;
                    case Gravity.LEFT:
                    default:
                        childLeft = this.mPaddingLeft;
                        break;
                }
                let start = 0;
                let dir = 1;
                if (isLayoutRtl) {
                    start = count - 1;
                    dir = -1;
                }
                for (let i = 0; i < count; i++) {
                    let childIndex = start + dir * i;
                    const child = this.getVirtualChildAt(childIndex);
                    if (child == null) {
                        childLeft += this.measureNullChild(childIndex);
                    }
                    else if (child.getVisibility() != View.GONE) {
                        const childWidth = child.getMeasuredWidth();
                        const childHeight = child.getMeasuredHeight();
                        let childBaseline = -1;
                        const lp = child.getLayoutParams();
                        if (baselineAligned && lp.height != LinearLayout.LayoutParams.MATCH_PARENT) {
                            childBaseline = child.getBaseline();
                        }
                        let gravity = lp.gravity;
                        if (gravity < 0) {
                            gravity = minorGravity;
                        }
                        switch (gravity & Gravity.VERTICAL_GRAVITY_MASK) {
                            case Gravity.TOP:
                                childTop = paddingTop + lp.topMargin;
                                if (childBaseline != -1) {
                                    childTop += maxAscent[LinearLayout.INDEX_TOP] - childBaseline;
                                }
                                break;
                            case Gravity.CENTER_VERTICAL:
                                childTop = paddingTop + ((childSpace - childHeight) / 2)
                                    + lp.topMargin - lp.bottomMargin;
                                break;
                            case Gravity.BOTTOM:
                                childTop = childBottom - childHeight - lp.bottomMargin;
                                if (childBaseline != -1) {
                                    let descent = child.getMeasuredHeight() - childBaseline;
                                    childTop -= (maxDescent[LinearLayout.INDEX_BOTTOM] - descent);
                                }
                                break;
                            default:
                                childTop = paddingTop;
                                break;
                        }
                        if (this.hasDividerBeforeChildAt(childIndex)) {
                            childLeft += this.mDividerWidth;
                        }
                        childLeft += lp.leftMargin;
                        this.setChildFrame(child, childLeft + this.getLocationOffset(child), childTop, childWidth, childHeight);
                        childLeft += childWidth + lp.rightMargin +
                            this.getNextLocationOffset(child);
                        i += this.getChildrenSkipCount(child, childIndex);
                    }
                }
            }
            setChildFrame(child, left, top, width, height) {
                child.layout(left, top, left + width, top + height);
            }
            setOrientation(orientation) {
                if (typeof orientation === 'string') {
                    if ('VERTICAL' === (orientation + '').toUpperCase())
                        orientation = LinearLayout.VERTICAL;
                    else if ('HORIZONTAL' === (orientation + '').toUpperCase())
                        orientation = LinearLayout.HORIZONTAL;
                }
                if (this.mOrientation != orientation) {
                    this.mOrientation = orientation;
                    this.requestLayout();
                }
            }
            getOrientation() {
                return this.mOrientation;
            }
            setGravity(gravity) {
                if (this.mGravity != gravity) {
                    if ((gravity & Gravity.HORIZONTAL_GRAVITY_MASK) == 0) {
                        gravity |= Gravity.LEFT;
                    }
                    if ((gravity & Gravity.VERTICAL_GRAVITY_MASK) == 0) {
                        gravity |= Gravity.TOP;
                    }
                    this.mGravity = gravity;
                    this.requestLayout();
                }
            }
            setHorizontalGravity(horizontalGravity) {
                const gravity = horizontalGravity & Gravity.HORIZONTAL_GRAVITY_MASK;
                if ((this.mGravity & Gravity.HORIZONTAL_GRAVITY_MASK) != gravity) {
                    this.mGravity = (this.mGravity & ~Gravity.HORIZONTAL_GRAVITY_MASK) | gravity;
                    this.requestLayout();
                }
            }
            setVerticalGravity(verticalGravity) {
                const gravity = verticalGravity & Gravity.VERTICAL_GRAVITY_MASK;
                if ((this.mGravity & Gravity.VERTICAL_GRAVITY_MASK) != gravity) {
                    this.mGravity = (this.mGravity & ~Gravity.VERTICAL_GRAVITY_MASK) | gravity;
                    this.requestLayout();
                }
            }
            generateDefaultLayoutParams() {
                let LayoutParams = LinearLayout.LayoutParams;
                if (this.mOrientation == LinearLayout.HORIZONTAL) {
                    return new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
                }
                else if (this.mOrientation == LinearLayout.VERTICAL) {
                    return new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
                }
                return super.generateDefaultLayoutParams();
            }
            generateLayoutParams(p) {
                return new LinearLayout.LayoutParams(p);
            }
            checkLayoutParams(p) {
                return p instanceof LinearLayout.LayoutParams;
            }
        }
        LinearLayout.HORIZONTAL = 0;
        LinearLayout.VERTICAL = 1;
        LinearLayout.SHOW_DIVIDER_NONE = 0;
        LinearLayout.SHOW_DIVIDER_BEGINNING = 1;
        LinearLayout.SHOW_DIVIDER_MIDDLE = 2;
        LinearLayout.SHOW_DIVIDER_END = 4;
        LinearLayout.VERTICAL_GRAVITY_COUNT = 4;
        LinearLayout.INDEX_CENTER_VERTICAL = 0;
        LinearLayout.INDEX_TOP = 1;
        LinearLayout.INDEX_BOTTOM = 2;
        LinearLayout.INDEX_FILL = 3;
        widget.LinearLayout = LinearLayout;
        (function (LinearLayout) {
            class LayoutParams extends android.view.ViewGroup.MarginLayoutParams {
                constructor(...args) {
                    super();
                    this.weight = 0;
                    this.gravity = -1;
                    if (args.length === 1) {
                        if (args[0] instanceof LayoutParams) {
                            this.gravity = args[0].gravity;
                        }
                        super(args[0]);
                    }
                    else {
                        let [width, height, weight = 0] = args;
                        super(width, height);
                        this.weight = weight;
                    }
                    this._attrBinder.addAttr('gravity', (value) => {
                        this.gravity = this._attrBinder.parseGravity(value, this.gravity);
                    }, () => {
                        return this.gravity;
                    });
                    this._attrBinder.addAttr('weight', (value) => {
                        value = Number.parseInt(value);
                        if (Number.isInteger(value))
                            this.weight = value;
                    }, () => {
                        return this.weight;
                    });
                }
            }
            LinearLayout.LayoutParams = LayoutParams;
        })(LinearLayout = widget.LinearLayout || (widget.LinearLayout = {}));
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
var android;
(function (android) {
    var R;
    (function (R) {
        class string_ {
            static zh() {
                this.prll_header_state_normal = '下拉以刷新';
                this.prll_header_state_ready = '松开马上刷新';
                this.prll_header_state_loading = '正在刷新...';
                this.prll_header_state_fail = '刷新失败';
                this.prll_footer_state_normal = '点击加载更多';
                this.prll_footer_state_loading = '正在加载...';
                this.prll_footer_state_ready = '松开加载更多';
                this.prll_footer_state_no_more = '加载完毕';
                this.prll_footer_state_fail = '加载失败,点击重试';
            }
        }
        string_.prll_header_state_normal = 'Pull to refresh';
        string_.prll_header_state_ready = 'Release to refresh';
        string_.prll_header_state_loading = 'Loading';
        string_.prll_header_state_fail = 'Refresh fail';
        string_.prll_footer_state_normal = 'Load more';
        string_.prll_footer_state_loading = 'Loading';
        string_.prll_footer_state_ready = 'Pull to load more';
        string_.prll_footer_state_fail = 'Click to reload';
        string_.prll_footer_state_no_more = 'Load Finish';
        R.string_ = string_;
        const lang = navigator.language.split('-')[0].toLowerCase();
        if (typeof string_[lang] === 'function')
            string_[lang].call(string_);
    })(R = android.R || (android.R = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/12/6.
 */
///<reference path="Rect.ts"/>
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        class RectF extends graphics.Rect {
        }
        graphics.RectF = RectF;
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var android;
(function (android) {
    var text;
    (function (text) {
        var style;
        (function (style) {
            var ParagraphStyle;
            (function (ParagraphStyle) {
                ParagraphStyle.type = Symbol();
            })(ParagraphStyle = style.ParagraphStyle || (style.ParagraphStyle = {}));
        })(style = text.style || (text.style = {}));
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var android;
(function (android) {
    var text;
    (function (text) {
        var Spanned;
        (function (Spanned) {
            function isImplements(obj) {
                return obj && obj['getSpans'] && obj['getSpanStart'] && obj['getSpanEnd']
                    && obj['getSpanFlags'] && obj['nextSpanTransition'];
            }
            Spanned.isImplements = isImplements;
            Spanned.SPAN_POINT_MARK_MASK = 0x33;
            Spanned.SPAN_MARK_MARK = 0x11;
            Spanned.SPAN_MARK_POINT = 0x12;
            Spanned.SPAN_POINT_MARK = 0x21;
            Spanned.SPAN_POINT_POINT = 0x22;
            Spanned.SPAN_PARAGRAPH = 0x33;
            Spanned.SPAN_INCLUSIVE_EXCLUSIVE = Spanned.SPAN_MARK_MARK;
            Spanned.SPAN_INCLUSIVE_INCLUSIVE = Spanned.SPAN_MARK_POINT;
            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE = Spanned.SPAN_POINT_MARK;
            Spanned.SPAN_EXCLUSIVE_INCLUSIVE = Spanned.SPAN_POINT_POINT;
            Spanned.SPAN_COMPOSING = 0x100;
            Spanned.SPAN_INTERMEDIATE = 0x200;
            Spanned.SPAN_USER_SHIFT = 24;
            Spanned.SPAN_USER = 0xFFFFFFFF << Spanned.SPAN_USER_SHIFT;
            Spanned.SPAN_PRIORITY_SHIFT = 16;
            Spanned.SPAN_PRIORITY = 0xFF << Spanned.SPAN_PRIORITY_SHIFT;
        })(Spanned = text.Spanned || (text.Spanned = {}));
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/12/5.
 */
///<reference path="../graphics/Paint.ts"/>
var android;
(function (android) {
    var text;
    (function (text) {
        class TextPaint extends android.graphics.Paint {
            constructor(...args) {
                super(...args);
                this.baselineShift = 0;
                this.bgColor = 0;
                this.linkColor = 0;
                this.underlineColor = 0;
                this.underlineThickness = 0;
            }
            set(tp) {
                super.set(tp);
                this.bgColor = tp.bgColor;
                this.baselineShift = tp.baselineShift;
                this.linkColor = tp.linkColor;
                this.underlineColor = tp.underlineColor;
                this.underlineThickness = tp.underlineThickness;
            }
            setUnderlineText(color, thickness) {
                this.underlineColor = color;
                this.underlineThickness = thickness;
            }
        }
        text.TextPaint = TextPaint;
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/text/style/UpdateAppearance.ts"/>
/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/text/style/UpdateLayout.ts"/>
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/text/TextPaint.ts"/>
///<reference path="../../../android/text/style/MetricAffectingSpan.ts"/>
///<reference path="../../../android/text/style/UpdateAppearance.ts"/>
var android;
(function (android) {
    var text;
    (function (text) {
        var style;
        (function (style) {
            var MetricAffectingSpan = android.text.style.MetricAffectingSpan;
            class CharacterStyle {
                constructor() {
                    this.mType = CharacterStyle.type;
                }
                static wrap(cs) {
                    if (cs instanceof MetricAffectingSpan) {
                        return new MetricAffectingSpan.Passthrough_MetricAffectingSpan(cs);
                    }
                    else {
                        return new CharacterStyle.Passthrough_CharacterStyle(cs);
                    }
                }
                getUnderlying() {
                    return this;
                }
            }
            CharacterStyle.type = Symbol();
            style.CharacterStyle = CharacterStyle;
            (function (CharacterStyle) {
                class Passthrough_CharacterStyle extends CharacterStyle {
                    constructor(cs) {
                        super();
                        this.mStyle = cs;
                    }
                    updateDrawState(tp) {
                        this.mStyle.updateDrawState(tp);
                    }
                    getUnderlying() {
                        return this.mStyle.getUnderlying();
                    }
                }
                CharacterStyle.Passthrough_CharacterStyle = Passthrough_CharacterStyle;
            })(CharacterStyle = style.CharacterStyle || (style.CharacterStyle = {}));
        })(style = text.style || (text.style = {}));
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/graphics/Paint.ts"/>
///<reference path="../../../android/text/TextPaint.ts"/>
///<reference path="../../../android/text/style/CharacterStyle.ts"/>
///<reference path="../../../android/text/style/UpdateLayout.ts"/>
var android;
(function (android) {
    var text;
    (function (text) {
        var style;
        (function (style) {
            var CharacterStyle = android.text.style.CharacterStyle;
            class MetricAffectingSpan extends CharacterStyle {
                constructor(...args) {
                    super(...args);
                    this.mType = MetricAffectingSpan.type;
                }
                getUnderlying() {
                    return this;
                }
            }
            MetricAffectingSpan.type = Symbol();
            style.MetricAffectingSpan = MetricAffectingSpan;
            (function (MetricAffectingSpan) {
                class Passthrough_MetricAffectingSpan extends MetricAffectingSpan {
                    constructor(cs) {
                        super();
                        this.mStyle = cs;
                    }
                    updateDrawState(tp) {
                        this.mStyle.updateDrawState(tp);
                    }
                    updateMeasureState(tp) {
                        this.mStyle.updateMeasureState(tp);
                    }
                    getUnderlying() {
                        return this.mStyle.getUnderlying();
                    }
                }
                MetricAffectingSpan.Passthrough_MetricAffectingSpan = Passthrough_MetricAffectingSpan;
            })(MetricAffectingSpan = style.MetricAffectingSpan || (style.MetricAffectingSpan = {}));
        })(style = text.style || (text.style = {}));
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/graphics/Paint.ts"/>
///<reference path="../../../android/graphics/Canvas.ts"/>
///<reference path="../../../android/text/TextPaint.ts"/>
///<reference path="../../../android/text/style/MetricAffectingSpan.ts"/>
var android;
(function (android) {
    var text;
    (function (text_1) {
        var style;
        (function (style) {
            var MetricAffectingSpan = android.text.style.MetricAffectingSpan;
            class ReplacementSpan extends MetricAffectingSpan {
                constructor(...args) {
                    super(...args);
                    this.mType = ReplacementSpan.type;
                }
                updateMeasureState(p) {
                }
                updateDrawState(ds) {
                }
            }
            ReplacementSpan.type = Symbol();
            style.ReplacementSpan = ReplacementSpan;
        })(style = text_1.style || (text_1.style = {}));
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/graphics/Canvas.ts"/>
///<reference path="../../android/graphics/Paint.ts"/>
///<reference path="../../android/text/style/MetricAffectingSpan.ts"/>
///<reference path="../../android/text/style/ReplacementSpan.ts"/>
///<reference path="../../android/util/Log.ts"/>
///<reference path="../../android/text/Layout.ts"/>
///<reference path="../../android/text/Spanned.ts"/>
///<reference path="../../android/text/TextDirectionHeuristic.ts"/>
///<reference path="../../android/text/TextPaint.ts"/>
///<reference path="../../android/text/TextUtils.ts"/>
var android;
(function (android) {
    var text;
    (function (text_2) {
        var Canvas = android.graphics.Canvas;
        var ReplacementSpan = android.text.style.ReplacementSpan;
        var Log = android.util.Log;
        var Spanned = android.text.Spanned;
        var TextPaint = android.text.TextPaint;
        class MeasuredText {
            constructor() {
                this.mTextStart = 0;
                this.mDir = 0;
                this.mLen = 0;
                this.mPos = 0;
                this.mWorkPaint = new TextPaint();
            }
            static obtain() {
                let mt;
                {
                    for (let i = MeasuredText.sCached.length; --i >= 0;) {
                        if (MeasuredText.sCached[i] != null) {
                            mt = MeasuredText.sCached[i];
                            MeasuredText.sCached[i] = null;
                            return mt;
                        }
                    }
                }
                mt = new MeasuredText();
                if (MeasuredText.localLOGV) {
                    Log.v("MEAS", "new: " + mt);
                }
                return mt;
            }
            static recycle(mt) {
                mt.mText = null;
                if (mt.mLen < 1000) {
                    {
                        for (let i = 0; i < MeasuredText.sCached.length; ++i) {
                            if (MeasuredText.sCached[i] == null) {
                                MeasuredText.sCached[i] = mt;
                                mt.mText = null;
                                break;
                            }
                        }
                    }
                }
                return null;
            }
            setPos(pos) {
                this.mPos = pos - this.mTextStart;
            }
            setPara(text, start, end, textDir) {
                this.mText = text;
                this.mTextStart = start;
                let len = end - start;
                this.mLen = len;
                this.mPos = 0;
                if (this.mWidths == null || this.mWidths.length < len) {
                    this.mWidths = new Array(len);
                }
                this.mChars = text.toString().substring(start, end);
                if (Spanned.isImplements(text)) {
                    let spanned = text;
                    let spans = spanned.getSpans(start, end, ReplacementSpan.type);
                    for (let i = 0; i < spans.length; i++) {
                        let startInPara = spanned.getSpanStart(spans[i]) - start;
                        let endInPara = spanned.getSpanEnd(spans[i]) - start;
                        if (startInPara < 0)
                            startInPara = 0;
                        if (endInPara > len)
                            endInPara = len;
                        for (let j = startInPara; j < endInPara; j++) {
                            this.mChars[j] = '￼';
                        }
                    }
                }
                this.mDir = android.text.Layout.DIR_LEFT_TO_RIGHT;
                this.mEasy = true;
            }
            addStyleRun(...args) {
                if (args.length === 3)
                    return this.addStyleRun_3(...args);
                if (args.length === 4)
                    return this.addStyleRun_4(...args);
            }
            addStyleRun_3(paint, len, fm) {
                if (fm != null) {
                    paint.getFontMetricsInt(fm);
                }
                let p = this.mPos;
                this.mPos = p + len;
                if (this.mEasy) {
                    let flags = this.mDir == android.text.Layout.DIR_LEFT_TO_RIGHT ? Canvas.DIRECTION_LTR : Canvas.DIRECTION_RTL;
                    return paint.getTextRunAdvances_count(this.mChars, p, len, p, len, flags, this.mWidths, p);
                }
                let totalAdvance = 0;
                let level = this.mLevels[p];
                for (let q = p, i = p + 1, e = p + len;; ++i) {
                    if (i == e || this.mLevels[i] != level) {
                        let flags = (level & 0x1) == 0 ? Canvas.DIRECTION_LTR : Canvas.DIRECTION_RTL;
                        totalAdvance += paint.getTextRunAdvances_count(this.mChars, q, i - q, q, i - q, flags, this.mWidths, q);
                        if (i == e) {
                            break;
                        }
                        q = i;
                        level = this.mLevels[i];
                    }
                }
                return totalAdvance;
            }
            addStyleRun_4(paint, spans, len, fm) {
                let workPaint = this.mWorkPaint;
                workPaint.set(paint);
                workPaint.baselineShift = 0;
                let replacement = null;
                for (let i = 0; i < spans.length; i++) {
                    let span = spans[i];
                    if (span instanceof ReplacementSpan) {
                        replacement = span;
                    }
                    else {
                        span.updateMeasureState(workPaint);
                    }
                }
                let wid;
                if (replacement == null) {
                    wid = this.addStyleRun(workPaint, len, fm);
                }
                else {
                    wid = replacement.getSize(workPaint, this.mText, this.mTextStart + this.mPos, this.mTextStart + this.mPos + len, fm);
                    let w = this.mWidths;
                    w[this.mPos] = wid;
                    for (let i = this.mPos + 1, e = this.mPos + len; i < e; i++)
                        w[i] = 0;
                    this.mPos += len;
                }
                if (fm != null) {
                    if (workPaint.baselineShift < 0) {
                        fm.ascent += workPaint.baselineShift;
                        fm.top += workPaint.baselineShift;
                    }
                    else {
                        fm.descent += workPaint.baselineShift;
                        fm.bottom += workPaint.baselineShift;
                    }
                }
                return wid;
            }
            breakText(limit, forwards, width) {
                let w = this.mWidths;
                if (forwards) {
                    let i = 0;
                    while (i < limit) {
                        width -= w[i];
                        if (width < 0.0)
                            break;
                        i++;
                    }
                    while (i > 0 && this.mChars[i - 1] == ' ')
                        i--;
                    return i;
                }
                else {
                    let i = limit - 1;
                    while (i >= 0) {
                        width -= w[i];
                        if (width < 0.0)
                            break;
                        i--;
                    }
                    while (i < limit - 1 && this.mChars[i + 1] == ' ')
                        i++;
                    return limit - i - 1;
                }
            }
            measure(start, limit) {
                let width = 0;
                let w = this.mWidths;
                for (let i = start; i < limit; ++i) {
                    width += w[i];
                }
                return width;
            }
        }
        MeasuredText.localLOGV = false;
        MeasuredText.sLock = new Array(0);
        MeasuredText.sCached = new Array(3);
        text_2.MeasuredText = MeasuredText;
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/text/Layout.ts"/>
///<reference path="../../android/text/TextDirectionHeuristic.ts"/>
///<reference path="../../android/text/TextUtils.ts"/>
var android;
(function (android) {
    var text;
    (function (text) {
        class TextDirectionHeuristics {
            static isRtlText(directionality) {
                return TextDirectionHeuristics.STATE_FALSE;
            }
            static isRtlTextOrFormat(directionality) {
                return TextDirectionHeuristics.STATE_FALSE;
            }
        }
        TextDirectionHeuristics.STATE_TRUE = 0;
        TextDirectionHeuristics.STATE_FALSE = 1;
        TextDirectionHeuristics.STATE_UNKNOWN = 2;
        text.TextDirectionHeuristics = TextDirectionHeuristics;
        (function (TextDirectionHeuristics) {
            class TextDirectionHeuristicImpl {
                constructor(algorithm) {
                    this.mAlgorithm = algorithm;
                }
                isRtl(cs, start, count) {
                    if (cs == null || start < 0 || count < 0 || cs.length - count < start) {
                        throw Error(`new IllegalArgumentException()`);
                    }
                    if (this.mAlgorithm == null) {
                        return this.defaultIsRtl();
                    }
                    return this.doCheck(cs, start, count);
                }
                doCheck(cs, start, count) {
                    switch (this.mAlgorithm.checkRtl(cs, start, count)) {
                        case TextDirectionHeuristics.STATE_TRUE:
                            return true;
                        case TextDirectionHeuristics.STATE_FALSE:
                            return false;
                        default:
                            return this.defaultIsRtl();
                    }
                }
            }
            TextDirectionHeuristics.TextDirectionHeuristicImpl = TextDirectionHeuristicImpl;
            class TextDirectionHeuristicInternal extends TextDirectionHeuristics.TextDirectionHeuristicImpl {
                constructor(algorithm, defaultIsRtl) {
                    super(algorithm);
                    this.mDefaultIsRtl = defaultIsRtl;
                }
                defaultIsRtl() {
                    return this.mDefaultIsRtl;
                }
            }
            TextDirectionHeuristics.TextDirectionHeuristicInternal = TextDirectionHeuristicInternal;
            class FirstStrong {
                constructor() {
                }
                checkRtl(cs, start, count) {
                    let result = TextDirectionHeuristics.STATE_UNKNOWN;
                    for (let i = start, e = start + count; i < e && result == TextDirectionHeuristics.STATE_UNKNOWN; ++i) {
                        result = TextDirectionHeuristics.STATE_FALSE;
                    }
                    return result;
                }
            }
            FirstStrong.INSTANCE = new FirstStrong();
            TextDirectionHeuristics.FirstStrong = FirstStrong;
            class AnyStrong {
                constructor(lookForRtl) {
                    this.mLookForRtl = lookForRtl;
                }
                checkRtl(cs, start, count) {
                    let haveUnlookedFor = false;
                    for (let i = start, e = start + count; i < e; ++i) {
                        switch (TextDirectionHeuristics.isRtlText(0)) {
                            case TextDirectionHeuristics.STATE_TRUE:
                                if (this.mLookForRtl) {
                                    return TextDirectionHeuristics.STATE_TRUE;
                                }
                                haveUnlookedFor = true;
                                break;
                            case TextDirectionHeuristics.STATE_FALSE:
                                if (!this.mLookForRtl) {
                                    return TextDirectionHeuristics.STATE_FALSE;
                                }
                                haveUnlookedFor = true;
                                break;
                            default:
                                break;
                        }
                    }
                    if (haveUnlookedFor) {
                        return this.mLookForRtl ? TextDirectionHeuristics.STATE_FALSE : TextDirectionHeuristics.STATE_TRUE;
                    }
                    return TextDirectionHeuristics.STATE_UNKNOWN;
                }
            }
            AnyStrong.INSTANCE_RTL = new AnyStrong(true);
            AnyStrong.INSTANCE_LTR = new AnyStrong(false);
            TextDirectionHeuristics.AnyStrong = AnyStrong;
            class TextDirectionHeuristicLocale extends TextDirectionHeuristics.TextDirectionHeuristicImpl {
                constructor() {
                    super(null);
                }
                defaultIsRtl() {
                    return false;
                }
            }
            TextDirectionHeuristicLocale.INSTANCE = new TextDirectionHeuristicLocale();
            TextDirectionHeuristics.TextDirectionHeuristicLocale = TextDirectionHeuristicLocale;
        })(TextDirectionHeuristics = text.TextDirectionHeuristics || (text.TextDirectionHeuristics = {}));
        TextDirectionHeuristics.LTR = new TextDirectionHeuristics.TextDirectionHeuristicInternal(null, false);
        TextDirectionHeuristics.RTL = new TextDirectionHeuristics.TextDirectionHeuristicInternal(null, true);
        TextDirectionHeuristics.FIRSTSTRONG_LTR = new TextDirectionHeuristics.TextDirectionHeuristicInternal(TextDirectionHeuristics.FirstStrong.INSTANCE, false);
        TextDirectionHeuristics.FIRSTSTRONG_RTL = new TextDirectionHeuristics.TextDirectionHeuristicInternal(TextDirectionHeuristics.FirstStrong.INSTANCE, true);
        TextDirectionHeuristics.ANYRTL_LTR = new TextDirectionHeuristics.TextDirectionHeuristicInternal(TextDirectionHeuristics.AnyStrong.INSTANCE_RTL, false);
        TextDirectionHeuristics.LOCALE = TextDirectionHeuristics.TextDirectionHeuristicLocale.INSTANCE;
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/14.
 */
///<reference path="Spanned.ts"/>
///<reference path="style/ReplacementSpan.ts"/>
///<reference path="../../java/lang/System.ts"/>
///<reference path="../../java/lang/StringBuilder.ts"/>
///<reference path="../../android/text/Layout.ts"/>
///<reference path="../../android/text/MeasuredText.ts"/>
///<reference path="../../android/text/Spanned.ts"/>
///<reference path="../../android/text/style/MetricAffectingSpan.ts"/>
///<reference path="../../android/text/TextDirectionHeuristic.ts"/>
///<reference path="../../android/text/TextDirectionHeuristics.ts"/>
///<reference path="../../android/text/TextPaint.ts"/>
var android;
(function (android) {
    var text;
    (function (text_3) {
        var System = java.lang.System;
        var StringBuilder = java.lang.StringBuilder;
        var MeasuredText = android.text.MeasuredText;
        var Spanned = android.text.Spanned;
        var TextDirectionHeuristics = android.text.TextDirectionHeuristics;
        class TextUtils {
            static isEmpty(str) {
                if (str == null || str.length == 0)
                    return true;
                else
                    return false;
            }
            static getOffsetBefore(text, offset) {
                if (offset == 0)
                    return 0;
                if (offset == 1)
                    return 0;
                let c = text.codePointAt(offset - 1);
                if (c >= '?'.codePointAt(0) && c <= '?'.codePointAt(0)) {
                    let c1 = text.codePointAt(offset - 2);
                    if (c1 >= '?'.codePointAt(0) && c1 <= '?'.codePointAt(0))
                        offset -= 2;
                    else
                        offset -= 1;
                }
                else {
                    offset -= 1;
                }
                if (Spanned.isImplements(text)) {
                    let spans = text.getSpans(offset, offset, android.text.style.ReplacementSpan.type);
                    for (let i = 0; i < spans.length; i++) {
                        let start = text.getSpanStart(spans[i]);
                        let end = text.getSpanEnd(spans[i]);
                        if (start < offset && end > offset)
                            offset = start;
                    }
                }
                return offset;
            }
            static getOffsetAfter(text, offset) {
                let len = text.length;
                if (offset == len)
                    return len;
                if (offset == len - 1)
                    return len;
                let c = text.codePointAt(offset);
                if (c >= '?'.codePointAt(0) && c <= '?'.codePointAt(0)) {
                    let c1 = text.codePointAt(offset + 1);
                    if (c1 >= '?'.codePointAt(0) && c1 <= '?'.codePointAt(0))
                        offset += 2;
                    else
                        offset += 1;
                }
                else {
                    offset += 1;
                }
                if (Spanned.isImplements(text)) {
                    let spans = text.getSpans(offset, offset, android.text.style.ReplacementSpan.type);
                    for (let i = 0; i < spans.length; i++) {
                        let start = text.getSpanStart(spans[i]);
                        let end = text.getSpanEnd(spans[i]);
                        if (start < offset && end > offset)
                            offset = end;
                    }
                }
                return offset;
            }
            static ellipsize(text, paint, avail, where, preserveLength = false, callback = null, textDir = TextDirectionHeuristics.FIRSTSTRONG_LTR, ellipsis = undefined) {
                ellipsis = ellipsis || (where == TextUtils.TruncateAt.END_SMALL ? android.text.Layout.ELLIPSIS_TWO_DOTS[0] : android.text.Layout.ELLIPSIS_NORMAL[0]);
                let len = text.length;
                let mt = MeasuredText.obtain();
                try {
                    let width = TextUtils.setPara(mt, paint, text, 0, text.length, textDir);
                    if (width <= avail) {
                        if (callback != null) {
                            callback.ellipsized(0, 0);
                        }
                        return text;
                    }
                    let ellipsiswid = paint.measureText(ellipsis);
                    avail -= ellipsiswid;
                    let left = 0;
                    let right = len;
                    if (avail < 0) {
                    }
                    else if (where == TextUtils.TruncateAt.START) {
                        right = len - mt.breakText(len, false, avail);
                    }
                    else if (where == TextUtils.TruncateAt.END || where == TextUtils.TruncateAt.END_SMALL) {
                        left = mt.breakText(len, true, avail);
                    }
                    else {
                        right = len - mt.breakText(len, false, avail / 2);
                        avail -= mt.measure(right, len);
                        left = mt.breakText(right, true, avail);
                    }
                    if (callback != null) {
                        callback.ellipsized(left, right);
                    }
                    let buf = mt.mChars.split('');
                    let sp = Spanned.isImplements(text) ? text : null;
                    let remaining = len - (right - left);
                    if (preserveLength) {
                        if (remaining > 0) {
                            buf[left++] = ellipsis.charAt(0);
                        }
                        for (let i = left; i < right; i++) {
                            buf[i] = TextUtils.ZWNBS_CHAR;
                        }
                        let s = buf.join('');
                        return s;
                    }
                    if (remaining == 0) {
                        return "";
                    }
                    let sb = new StringBuilder(remaining + ellipsis.length());
                    sb.append(buf.join('').substr(0, left));
                    sb.append(ellipsis);
                    sb.append(buf.join('').substr(right, len - right));
                    return sb.toString();
                }
                finally {
                    MeasuredText.recycle(mt);
                }
            }
            static setPara(mt, paint, text, start, end, textDir) {
                mt.setPara(text, start, end, textDir);
                let width;
                let sp = Spanned.isImplements(text) ? text : null;
                let len = end - start;
                if (sp == null) {
                    width = mt.addStyleRun(paint, len, null);
                }
                else {
                    width = 0;
                    let spanEnd;
                    for (let spanStart = 0; spanStart < len; spanStart = spanEnd) {
                        spanEnd = sp.nextSpanTransition(spanStart, len, android.text.style.MetricAffectingSpan.type);
                        let spans = sp.getSpans(spanStart, spanEnd, android.text.style.MetricAffectingSpan.type);
                        spans = TextUtils.removeEmptySpans(spans, sp, android.text.style.MetricAffectingSpan.type);
                        width += mt.addStyleRun(paint, spans, spanEnd - spanStart, null);
                    }
                }
                return width;
            }
            static removeEmptySpans(spans, spanned, klass) {
                let copy = null;
                let count = 0;
                for (let i = 0; i < spans.length; i++) {
                    const span = spans[i];
                    const start = spanned.getSpanStart(span);
                    const end = spanned.getSpanEnd(span);
                    if (start == end) {
                        if (copy == null) {
                            copy = new Array(spans.length - 1);
                            System.arraycopy(spans, 0, copy, 0, i);
                            count = i;
                        }
                    }
                    else {
                        if (copy != null) {
                            copy[count] = span;
                            count++;
                        }
                    }
                }
                if (copy != null) {
                    let result = new Array(count);
                    System.arraycopy(copy, 0, result, 0, count);
                    return result;
                }
                else {
                    return spans;
                }
            }
            static packRangeInLong(start, end) {
                return [start, end];
            }
            static unpackRangeStartFromLong(range) {
                return range[0] || 0;
            }
            static unpackRangeEndFromLong(range) {
                return range[1] || 0;
            }
        }
        TextUtils.ALIGNMENT_SPAN = 1;
        TextUtils.FIRST_SPAN = TextUtils.ALIGNMENT_SPAN;
        TextUtils.FOREGROUND_COLOR_SPAN = 2;
        TextUtils.RELATIVE_SIZE_SPAN = 3;
        TextUtils.SCALE_X_SPAN = 4;
        TextUtils.STRIKETHROUGH_SPAN = 5;
        TextUtils.UNDERLINE_SPAN = 6;
        TextUtils.STYLE_SPAN = 7;
        TextUtils.BULLET_SPAN = 8;
        TextUtils.QUOTE_SPAN = 9;
        TextUtils.LEADING_MARGIN_SPAN = 10;
        TextUtils.URL_SPAN = 11;
        TextUtils.BACKGROUND_COLOR_SPAN = 12;
        TextUtils.TYPEFACE_SPAN = 13;
        TextUtils.SUPERSCRIPT_SPAN = 14;
        TextUtils.SUBSCRIPT_SPAN = 15;
        TextUtils.ABSOLUTE_SIZE_SPAN = 16;
        TextUtils.TEXT_APPEARANCE_SPAN = 17;
        TextUtils.ANNOTATION = 18;
        TextUtils.SUGGESTION_SPAN = 19;
        TextUtils.SPELL_CHECK_SPAN = 20;
        TextUtils.SUGGESTION_RANGE_SPAN = 21;
        TextUtils.EASY_EDIT_SPAN = 22;
        TextUtils.LOCALE_SPAN = 23;
        TextUtils.LAST_SPAN = TextUtils.LOCALE_SPAN;
        TextUtils.EMPTY_STRING_ARRAY = [];
        TextUtils.ZWNBS_CHAR = String.fromCodePoint(20);
        TextUtils.ARAB_SCRIPT_SUBTAG = "Arab";
        TextUtils.HEBR_SCRIPT_SUBTAG = "Hebr";
        text_3.TextUtils = TextUtils;
        (function (TextUtils) {
            (function (TruncateAt) {
                TruncateAt[TruncateAt["START"] = 0] = "START";
                TruncateAt[TruncateAt["MIDDLE"] = 1] = "MIDDLE";
                TruncateAt[TruncateAt["END"] = 2] = "END";
                TruncateAt[TruncateAt["MARQUEE"] = 3] = "MARQUEE";
                TruncateAt[TruncateAt["END_SMALL"] = 4] = "END_SMALL";
            })(TextUtils.TruncateAt || (TextUtils.TruncateAt = {}));
            var TruncateAt = TextUtils.TruncateAt;
        })(TextUtils = text_3.TextUtils || (text_3.TextUtils = {}));
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/text/style/ParagraphStyle.ts"/>
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/graphics/Paint.ts"/>
///<reference path="../../../android/graphics/Canvas.ts"/>
///<reference path="../../../android/text/Layout.ts"/>
///<reference path="../../../android/text/TextUtils.ts"/>
///<reference path="../../../android/text/style/ParagraphStyle.ts"/>
///<reference path="../../../android/text/style/WrapTogetherSpan.ts"/>
var android;
(function (android) {
    var text;
    (function (text_4) {
        var style;
        (function (style) {
            var TextUtils = android.text.TextUtils;
            var LeadingMarginSpan;
            (function (LeadingMarginSpan) {
                function isImpl(obj) {
                    return obj && obj['getLeadingMargin'] && obj['drawLeadingMargin'];
                }
                LeadingMarginSpan.isImpl = isImpl;
                LeadingMarginSpan.type = Symbol();
                var LeadingMarginSpan2;
                (function (LeadingMarginSpan2) {
                    function isImpl(obj) {
                        return obj['getLeadingMarginLineCount'];
                    }
                    LeadingMarginSpan2.isImpl = isImpl;
                })(LeadingMarginSpan2 = LeadingMarginSpan.LeadingMarginSpan2 || (LeadingMarginSpan.LeadingMarginSpan2 = {}));
                class Standard {
                    constructor(first, rest = first) {
                        this.mFirst = 0;
                        this.mRest = 0;
                        this.mFirst = first;
                        this.mRest = rest;
                    }
                    getSpanTypeId() {
                        return TextUtils.LEADING_MARGIN_SPAN;
                    }
                    describeContents() {
                        return 0;
                    }
                    getLeadingMargin(first) {
                        return first ? this.mFirst : this.mRest;
                    }
                    drawLeadingMargin(c, p, x, dir, top, baseline, bottom, text, start, end, first, layout) {
                        ;
                    }
                }
                LeadingMarginSpan.Standard = Standard;
            })(LeadingMarginSpan = style.LeadingMarginSpan || (style.LeadingMarginSpan = {}));
        })(style = text_4.style || (text_4.style = {}));
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/graphics/Paint.ts"/>
///<reference path="../../../android/graphics/Canvas.ts"/>
///<reference path="../../../android/text/style/ParagraphStyle.ts"/>
var android;
(function (android) {
    var text;
    (function (text_5) {
        var style;
        (function (style) {
            var LineBackgroundSpan;
            (function (LineBackgroundSpan) {
                LineBackgroundSpan.type = Symbol();
            })(LineBackgroundSpan = style.LineBackgroundSpan || (style.LineBackgroundSpan = {}));
        })(style = text_5.style || (text_5.style = {}));
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/text/style/ParagraphStyle.ts"/>
var android;
(function (android) {
    var text;
    (function (text) {
        var style;
        (function (style) {
            var TabStopSpan;
            (function (TabStopSpan) {
                TabStopSpan.type = Symbol();
                function isImpl(obj) {
                    return obj && obj['getTabStop'];
                }
                TabStopSpan.isImpl = isImpl;
                class Standard {
                    constructor(where) {
                        this.mTab = 0;
                        this.mTab = where;
                    }
                    getTabStop() {
                        return this.mTab;
                    }
                }
                TabStopSpan.Standard = Standard;
            })(TabStopSpan = style.TabStopSpan || (style.TabStopSpan = {}));
        })(style = text.style || (text.style = {}));
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
var java;
(function (java) {
    var util;
    (function (util) {
        class Arrays {
            static sort(a, fromIndex, toIndex) {
                Arrays.rangeCheck(a.length, fromIndex, toIndex);
                var sort = new Array(toIndex - fromIndex);
                for (let i = fromIndex; i < toIndex; i++) {
                    sort[i - fromIndex] = a[i];
                }
                sort.sort((a, b) => {
                    return a > b ? 1 : -1;
                });
                for (let i = fromIndex; i < toIndex; i++) {
                    a[i] = sort[i - fromIndex];
                }
            }
            static rangeCheck(arrayLength, fromIndex, toIndex) {
                if (fromIndex > toIndex) {
                    throw new Error("ArrayIndexOutOfBoundsException:fromIndex(" + fromIndex + ") > toIndex(" + toIndex + ")");
                }
                if (fromIndex < 0) {
                    throw new Error('ArrayIndexOutOfBoundsException:' + fromIndex);
                }
                if (toIndex > arrayLength) {
                    throw new Error('ArrayIndexOutOfBoundsException:' + toIndex);
                }
            }
        }
        util.Arrays = Arrays;
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
var java;
(function (java) {
    var lang;
    (function (lang) {
        class Float {
            static parseFloat(value) {
                return Number.parseFloat(value);
            }
        }
        Float.MIN_VALUE = Number.MIN_VALUE;
        Float.MAX_VALUE = Number.MAX_VALUE;
        lang.Float = Float;
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
/*
 * Copyright (C) 2012 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/text/Spanned.ts"/>
var android;
(function (android) {
    var text;
    (function (text) {
        class SpanSet {
            constructor(type) {
                this.numberOfSpans = 0;
                this.classType = type;
                this.numberOfSpans = 0;
            }
            init(spanned, start, limit) {
                const allSpans = spanned.getSpans(start, limit, this.classType);
                const length = allSpans.length;
                if (length > 0 && (this.spans == null || this.spans.length < length)) {
                    this.spans = new Array(length);
                    this.spanStarts = new Array(length);
                    this.spanEnds = new Array(length);
                    this.spanFlags = new Array(length);
                }
                this.numberOfSpans = 0;
                for (let i = 0; i < length; i++) {
                    const span = allSpans[i];
                    const spanStart = spanned.getSpanStart(span);
                    const spanEnd = spanned.getSpanEnd(span);
                    if (spanStart == spanEnd)
                        continue;
                    const spanFlag = spanned.getSpanFlags(span);
                    this.spans[this.numberOfSpans] = span;
                    this.spanStarts[this.numberOfSpans] = spanStart;
                    this.spanEnds[this.numberOfSpans] = spanEnd;
                    this.spanFlags[this.numberOfSpans] = spanFlag;
                    this.numberOfSpans++;
                }
            }
            hasSpansIntersecting(start, end) {
                for (let i = 0; i < this.numberOfSpans; i++) {
                    if (this.spanStarts[i] >= end || this.spanEnds[i] <= start)
                        continue;
                    return true;
                }
                return false;
            }
            getNextTransition(start, limit) {
                for (let i = 0; i < this.numberOfSpans; i++) {
                    const spanStart = this.spanStarts[i];
                    const spanEnd = this.spanEnds[i];
                    if (spanStart > start && spanStart < limit)
                        limit = spanStart;
                    if (spanEnd > start && spanEnd < limit)
                        limit = spanEnd;
                }
                return limit;
            }
            recycle() {
                for (let i = 0; i < this.numberOfSpans; i++) {
                    this.spans[i] = null;
                }
            }
        }
        text.SpanSet = SpanSet;
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/graphics/Canvas.ts"/>
///<reference path="../../android/graphics/Paint.ts"/>
///<reference path="../../android/graphics/RectF.ts"/>
///<reference path="../../android/text/style/CharacterStyle.ts"/>
///<reference path="../../android/text/style/MetricAffectingSpan.ts"/>
///<reference path="../../android/text/style/ReplacementSpan.ts"/>
///<reference path="../../android/util/Log.ts"/>
///<reference path="../../android/text/Layout.ts"/>
///<reference path="../../android/text/Spanned.ts"/>
///<reference path="../../android/text/SpanSet.ts"/>
///<reference path="../../android/text/TextPaint.ts"/>
///<reference path="../../android/text/TextUtils.ts"/>
var android;
(function (android) {
    var text;
    (function (text_6) {
        var Canvas = android.graphics.Canvas;
        var Paint = android.graphics.Paint;
        var CharacterStyle = android.text.style.CharacterStyle;
        var MetricAffectingSpan = android.text.style.MetricAffectingSpan;
        var ReplacementSpan = android.text.style.ReplacementSpan;
        var Log = android.util.Log;
        var Spanned = android.text.Spanned;
        var SpanSet = android.text.SpanSet;
        var TextPaint = android.text.TextPaint;
        var TextUtils = android.text.TextUtils;
        var Layout = android.text.Layout;
        window.addEventListener('AndroidUILoadFinish', () => {
            eval('Layout = android.text.Layout;');
        });
        class TextLine {
            constructor() {
                this.mStart = 0;
                this.mLen = 0;
                this.mDir = 0;
                this.mWorkPaint = new TextPaint();
                this.mMetricAffectingSpanSpanSet = new SpanSet(MetricAffectingSpan.type);
                this.mCharacterStyleSpanSet = new SpanSet(CharacterStyle.type);
                this.mReplacementSpanSpanSet = new SpanSet(ReplacementSpan.type);
            }
            static obtain() {
                let tl;
                {
                    for (let i = TextLine.sCached.length; --i >= 0;) {
                        if (TextLine.sCached[i] != null) {
                            tl = TextLine.sCached[i];
                            TextLine.sCached[i] = null;
                            return tl;
                        }
                    }
                }
                tl = new TextLine();
                if (TextLine.DEBUG) {
                    Log.v("TLINE", "new: " + tl);
                }
                return tl;
            }
            static recycle(tl) {
                tl.mText = null;
                tl.mPaint = null;
                tl.mDirections = null;
                tl.mMetricAffectingSpanSpanSet.recycle();
                tl.mCharacterStyleSpanSet.recycle();
                tl.mReplacementSpanSpanSet.recycle();
                {
                    for (let i = 0; i < TextLine.sCached.length; ++i) {
                        if (TextLine.sCached[i] == null) {
                            TextLine.sCached[i] = tl;
                            break;
                        }
                    }
                }
                return null;
            }
            set(paint, text, start, limit, dir, directions, hasTabs, tabStops) {
                this.mPaint = paint;
                this.mText = text;
                this.mStart = start;
                this.mLen = limit - start;
                this.mDir = dir;
                this.mDirections = directions;
                if (this.mDirections == null) {
                    throw Error(`new IllegalArgumentException("Directions cannot be null")`);
                }
                this.mHasTabs = hasTabs;
                this.mSpanned = null;
                let hasReplacement = false;
                if (Spanned.isImplements(text)) {
                    this.mSpanned = text;
                    this.mReplacementSpanSpanSet.init(this.mSpanned, start, limit);
                    hasReplacement = this.mReplacementSpanSpanSet.numberOfSpans > 0;
                }
                this.mCharsValid = hasReplacement || hasTabs || directions != Layout.DIRS_ALL_LEFT_TO_RIGHT;
                if (this.mCharsValid) {
                    this.mChars = text;
                    if (hasReplacement) {
                        let chars = this.mChars;
                        for (let i = start, inext; i < limit; i = inext) {
                            inext = this.mReplacementSpanSpanSet.getNextTransition(i, limit);
                            if (this.mReplacementSpanSpanSet.hasSpansIntersecting(i, inext)) {
                                chars[i - start] = '￼';
                                for (let j = i - start + 1, e = inext - start; j < e; ++j) {
                                    chars[j] = '﻿';
                                }
                            }
                        }
                    }
                }
                this.mTabs = tabStops;
            }
            draw(c, x, top, y, bottom) {
                if (!this.mHasTabs) {
                    if (this.mDirections == Layout.DIRS_ALL_LEFT_TO_RIGHT) {
                        this.drawRun(c, 0, this.mLen, false, x, top, y, bottom, false);
                        return;
                    }
                    if (this.mDirections == Layout.DIRS_ALL_RIGHT_TO_LEFT) {
                        this.drawRun(c, 0, this.mLen, true, x, top, y, bottom, false);
                        return;
                    }
                }
                let h = 0;
                let runs = this.mDirections.mDirections;
                let emojiRect = null;
                let lastRunIndex = runs.length - 2;
                for (let i = 0; i < runs.length; i += 2) {
                    let runStart = runs[i];
                    let runLimit = runStart + (runs[i + 1] & Layout.RUN_LENGTH_MASK);
                    if (runLimit > this.mLen) {
                        runLimit = this.mLen;
                    }
                    let runIsRtl = (runs[i + 1] & Layout.RUN_RTL_FLAG) != 0;
                    let segstart = runStart;
                    for (let j = this.mHasTabs ? runStart : runLimit; j <= runLimit; j++) {
                        let codept = 0;
                        if (this.mHasTabs && j < runLimit) {
                            codept = this.mChars.codePointAt(j);
                            if (codept >= 0xd800 && codept < 0xdc00 && j + 1 < runLimit) {
                                codept = this.mChars.codePointAt(j);
                                if (codept > 0xffff) {
                                    ++j;
                                    continue;
                                }
                            }
                        }
                        if (j == runLimit || codept == '\t'.codePointAt(0)) {
                            h += this.drawRun(c, segstart, j, runIsRtl, x + h, top, y, bottom, i != lastRunIndex || j != this.mLen);
                            if (codept == '\t'.codePointAt(0)) {
                                h = this.mDir * this.nextTab(h * this.mDir);
                            }
                            segstart = j + 1;
                        }
                    }
                }
            }
            metrics(fmi) {
                return this.measure(this.mLen, false, fmi);
            }
            measure(offset, trailing, fmi) {
                let target = trailing ? offset - 1 : offset;
                if (target < 0) {
                    return 0;
                }
                let h = 0;
                if (!this.mHasTabs) {
                    if (this.mDirections == Layout.DIRS_ALL_LEFT_TO_RIGHT) {
                        return this.measureRun(0, offset, this.mLen, false, fmi);
                    }
                    if (this.mDirections == Layout.DIRS_ALL_RIGHT_TO_LEFT) {
                        return this.measureRun(0, offset, this.mLen, true, fmi);
                    }
                }
                let chars = this.mChars;
                let runs = this.mDirections.mDirections;
                for (let i = 0; i < runs.length; i += 2) {
                    let runStart = runs[i];
                    let runLimit = runStart + (runs[i + 1] & Layout.RUN_LENGTH_MASK);
                    if (runLimit > this.mLen) {
                        runLimit = this.mLen;
                    }
                    let runIsRtl = (runs[i + 1] & Layout.RUN_RTL_FLAG) != 0;
                    let segstart = runStart;
                    for (let j = this.mHasTabs ? runStart : runLimit; j <= runLimit; j++) {
                        let codept = 0;
                        if (this.mHasTabs && j < runLimit) {
                            codept = chars.codePointAt(j);
                            if (codept >= 0xd800 && codept < 0xdc00 && j + 1 < runLimit) {
                                codept = chars.codePointAt(j);
                                if (codept > 0xffff) {
                                    ++j;
                                    continue;
                                }
                            }
                        }
                        if (j == runLimit || codept == '\t'.codePointAt(0)) {
                            let inSegment = target >= segstart && target < j;
                            let advance = (this.mDir == Layout.DIR_RIGHT_TO_LEFT) == runIsRtl;
                            if (inSegment && advance) {
                                return h += this.measureRun(segstart, offset, j, runIsRtl, fmi);
                            }
                            let w = this.measureRun(segstart, j, j, runIsRtl, fmi);
                            h += advance ? w : -w;
                            if (inSegment) {
                                return h += this.measureRun(segstart, offset, j, runIsRtl, null);
                            }
                            if (codept == '\t'.codePointAt(0)) {
                                if (offset == j) {
                                    return h;
                                }
                                h = this.mDir * this.nextTab(h * this.mDir);
                                if (target == j) {
                                    return h;
                                }
                            }
                            segstart = j + 1;
                        }
                    }
                }
                return h;
            }
            drawRun(c, start, limit, runIsRtl, x, top, y, bottom, needWidth) {
                if ((this.mDir == Layout.DIR_LEFT_TO_RIGHT) == runIsRtl) {
                    let w = -this.measureRun(start, limit, limit, runIsRtl, null);
                    this.handleRun(start, limit, limit, runIsRtl, c, x + w, top, y, bottom, null, false);
                    return w;
                }
                return this.handleRun(start, limit, limit, runIsRtl, c, x, top, y, bottom, null, needWidth);
            }
            measureRun(start, offset, limit, runIsRtl, fmi) {
                return this.handleRun(start, offset, limit, runIsRtl, null, 0, 0, 0, 0, fmi, true);
            }
            getOffsetToLeftRightOf(cursor, toLeft) {
                let lineStart = 0;
                let lineEnd = this.mLen;
                let paraIsRtl = this.mDir == -1;
                let runs = this.mDirections.mDirections;
                let runIndex, runLevel = 0, runStart = lineStart, runLimit = lineEnd, newCaret = -1;
                let trailing = false;
                if (cursor == lineStart) {
                    runIndex = -2;
                }
                else if (cursor == lineEnd) {
                    runIndex = runs.length;
                }
                else {
                    for (runIndex = 0; runIndex < runs.length; runIndex += 2) {
                        runStart = lineStart + runs[runIndex];
                        if (cursor >= runStart) {
                            runLimit = runStart + (runs[runIndex + 1] & Layout.RUN_LENGTH_MASK);
                            if (runLimit > lineEnd) {
                                runLimit = lineEnd;
                            }
                            if (cursor < runLimit) {
                                runLevel = (runs[runIndex + 1] >>> Layout.RUN_LEVEL_SHIFT) & Layout.RUN_LEVEL_MASK;
                                if (cursor == runStart) {
                                    let prevRunIndex, prevRunLevel, prevRunStart, prevRunLimit;
                                    let pos = cursor - 1;
                                    for (prevRunIndex = 0; prevRunIndex < runs.length; prevRunIndex += 2) {
                                        prevRunStart = lineStart + runs[prevRunIndex];
                                        if (pos >= prevRunStart) {
                                            prevRunLimit = prevRunStart + (runs[prevRunIndex + 1] & Layout.RUN_LENGTH_MASK);
                                            if (prevRunLimit > lineEnd) {
                                                prevRunLimit = lineEnd;
                                            }
                                            if (pos < prevRunLimit) {
                                                prevRunLevel = (runs[prevRunIndex + 1] >>> Layout.RUN_LEVEL_SHIFT) & Layout.RUN_LEVEL_MASK;
                                                if (prevRunLevel < runLevel) {
                                                    runIndex = prevRunIndex;
                                                    runLevel = prevRunLevel;
                                                    runStart = prevRunStart;
                                                    runLimit = prevRunLimit;
                                                    trailing = true;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                                break;
                            }
                        }
                    }
                    if (runIndex != runs.length) {
                        let runIsRtl = (runLevel & 0x1) != 0;
                        let advance = toLeft == runIsRtl;
                        if (cursor != (advance ? runLimit : runStart) || advance != trailing) {
                            newCaret = this.getOffsetBeforeAfter(runIndex, runStart, runLimit, runIsRtl, cursor, advance);
                            if (newCaret != (advance ? runLimit : runStart)) {
                                return newCaret;
                            }
                        }
                    }
                }
                while (true) {
                    let advance = toLeft == paraIsRtl;
                    let otherRunIndex = runIndex + (advance ? 2 : -2);
                    if (otherRunIndex >= 0 && otherRunIndex < runs.length) {
                        let otherRunStart = lineStart + runs[otherRunIndex];
                        let otherRunLimit = otherRunStart + (runs[otherRunIndex + 1] & Layout.RUN_LENGTH_MASK);
                        if (otherRunLimit > lineEnd) {
                            otherRunLimit = lineEnd;
                        }
                        let otherRunLevel = (runs[otherRunIndex + 1] >>> Layout.RUN_LEVEL_SHIFT) & Layout.RUN_LEVEL_MASK;
                        let otherRunIsRtl = (otherRunLevel & 1) != 0;
                        advance = toLeft == otherRunIsRtl;
                        if (newCaret == -1) {
                            newCaret = this.getOffsetBeforeAfter(otherRunIndex, otherRunStart, otherRunLimit, otherRunIsRtl, advance ? otherRunStart : otherRunLimit, advance);
                            if (newCaret == (advance ? otherRunLimit : otherRunStart)) {
                                runIndex = otherRunIndex;
                                runLevel = otherRunLevel;
                                continue;
                            }
                            break;
                        }
                        if (otherRunLevel < runLevel) {
                            newCaret = advance ? otherRunStart : otherRunLimit;
                        }
                        break;
                    }
                    if (newCaret == -1) {
                        newCaret = advance ? this.mLen + 1 : -1;
                        break;
                    }
                    if (newCaret <= lineEnd) {
                        newCaret = advance ? lineEnd : lineStart;
                    }
                    break;
                }
                return newCaret;
            }
            getOffsetBeforeAfter(runIndex, runStart, runLimit, runIsRtl, offset, after) {
                if (runIndex < 0 || offset == (after ? this.mLen : 0)) {
                    if (after) {
                        return TextUtils.getOffsetAfter(this.mText, offset + this.mStart) - this.mStart;
                    }
                    return TextUtils.getOffsetBefore(this.mText, offset + this.mStart) - this.mStart;
                }
                let wp = this.mWorkPaint;
                wp.set(this.mPaint);
                let spanStart = runStart;
                let spanLimit;
                if (this.mSpanned == null) {
                    spanLimit = runLimit;
                }
                else {
                    let target = after ? offset + 1 : offset;
                    let limit = this.mStart + runLimit;
                    while (true) {
                        spanLimit = this.mSpanned.nextSpanTransition(this.mStart + spanStart, limit, MetricAffectingSpan.type) - this.mStart;
                        if (spanLimit >= target) {
                            break;
                        }
                        spanStart = spanLimit;
                    }
                    let spans = this.mSpanned.getSpans(this.mStart + spanStart, this.mStart + spanLimit, MetricAffectingSpan.type);
                    spans = TextUtils.removeEmptySpans(spans, this.mSpanned, MetricAffectingSpan.type);
                    if (spans.length > 0) {
                        let replacement = null;
                        for (let j = 0; j < spans.length; j++) {
                            let span = spans[j];
                            if (span instanceof ReplacementSpan) {
                                replacement = span;
                            }
                            else {
                                span.updateMeasureState(wp);
                            }
                        }
                        if (replacement != null) {
                            return after ? spanLimit : spanStart;
                        }
                    }
                }
                let flags = runIsRtl ? Paint.DIRECTION_RTL : Paint.DIRECTION_LTR;
                let cursorOpt = after ? Paint.CURSOR_AFTER : Paint.CURSOR_BEFORE;
                if (this.mCharsValid) {
                    return wp.getTextRunCursor_len(this.mChars.toString(), spanStart, spanLimit - spanStart, flags, offset, cursorOpt);
                }
                else {
                    return wp.getTextRunCursor_end(this.mText.toString(), this.mStart + spanStart, this.mStart + spanLimit, flags, this.mStart + offset, cursorOpt) - this.mStart;
                }
            }
            static expandMetricsFromPaint(fmi, wp) {
                const previousTop = fmi.top;
                const previousAscent = fmi.ascent;
                const previousDescent = fmi.descent;
                const previousBottom = fmi.bottom;
                const previousLeading = fmi.leading;
                wp.getFontMetricsInt(fmi);
                TextLine.updateMetrics(fmi, previousTop, previousAscent, previousDescent, previousBottom, previousLeading);
            }
            static updateMetrics(fmi, previousTop, previousAscent, previousDescent, previousBottom, previousLeading) {
                fmi.top = Math.min(fmi.top, previousTop);
                fmi.ascent = Math.min(fmi.ascent, previousAscent);
                fmi.descent = Math.max(fmi.descent, previousDescent);
                fmi.bottom = Math.max(fmi.bottom, previousBottom);
                fmi.leading = Math.max(fmi.leading, previousLeading);
            }
            handleText(wp, start, end, contextStart, contextEnd, runIsRtl, c, x, top, y, bottom, fmi, needWidth) {
                if (fmi != null) {
                    TextLine.expandMetricsFromPaint(fmi, wp);
                }
                let runLen = end - start;
                if (runLen == 0) {
                    return 0;
                }
                let ret = 0;
                let contextLen = contextEnd - contextStart;
                if (needWidth || (c != null && (wp.bgColor != 0 || wp.underlineColor != 0 || runIsRtl))) {
                    let flags = runIsRtl ? Paint.DIRECTION_RTL : Paint.DIRECTION_LTR;
                    if (this.mCharsValid) {
                        ret = wp.getTextRunAdvances_count(this.mChars.toString(), start, runLen, contextStart, contextLen, flags, null, 0);
                    }
                    else {
                        let delta = this.mStart;
                        ret = wp.getTextRunAdvances_end(this.mText.toString(), delta + start, delta + end, delta + contextStart, delta + contextEnd, flags, null, 0);
                    }
                }
                if (c != null) {
                    if (runIsRtl) {
                        x -= ret;
                    }
                    if (wp.bgColor != 0) {
                        let previousColor = wp.getColor();
                        let previousStyle = wp.getStyle();
                        wp.setColor(wp.bgColor);
                        wp.setStyle(Paint.Style.FILL);
                        c.drawRect(x, top, x + ret, bottom, wp);
                        wp.setStyle(previousStyle);
                        wp.setColor(previousColor);
                    }
                    if (wp.underlineColor != 0) {
                        let underlineTop = y + wp.baselineShift + (1.0 / 9.0) * wp.getTextSize();
                        let previousColor = wp.getColor();
                        let previousStyle = wp.getStyle();
                        let previousAntiAlias = wp.isAntiAlias();
                        wp.setStyle(Paint.Style.FILL);
                        wp.setAntiAlias(true);
                        wp.setColor(wp.underlineColor);
                        c.drawRect(x, underlineTop, x + ret, underlineTop + wp.underlineThickness, wp);
                        wp.setStyle(previousStyle);
                        wp.setColor(previousColor);
                        wp.setAntiAlias(previousAntiAlias);
                    }
                    this.drawTextRun(c, wp, start, end, contextStart, contextEnd, runIsRtl, x, y + wp.baselineShift);
                }
                return runIsRtl ? -ret : ret;
            }
            handleReplacement(replacement, wp, start, limit, runIsRtl, c, x, top, y, bottom, fmi, needWidth) {
                let ret = 0;
                let textStart = this.mStart + start;
                let textLimit = this.mStart + limit;
                if (needWidth || (c != null && runIsRtl)) {
                    let previousTop = 0;
                    let previousAscent = 0;
                    let previousDescent = 0;
                    let previousBottom = 0;
                    let previousLeading = 0;
                    let needUpdateMetrics = (fmi != null);
                    if (needUpdateMetrics) {
                        previousTop = fmi.top;
                        previousAscent = fmi.ascent;
                        previousDescent = fmi.descent;
                        previousBottom = fmi.bottom;
                        previousLeading = fmi.leading;
                    }
                    ret = replacement.getSize(wp, this.mText, textStart, textLimit, fmi);
                    if (needUpdateMetrics) {
                        TextLine.updateMetrics(fmi, previousTop, previousAscent, previousDescent, previousBottom, previousLeading);
                    }
                }
                if (c != null) {
                    if (runIsRtl) {
                        x -= ret;
                    }
                    replacement.draw(c, this.mText, textStart, textLimit, x, top, y, bottom, wp);
                }
                return runIsRtl ? -ret : ret;
            }
            handleRun(start, measureLimit, limit, runIsRtl, c, x, top, y, bottom, fmi, needWidth) {
                if (start == measureLimit) {
                    let wp = this.mWorkPaint;
                    wp.set(this.mPaint);
                    if (fmi != null) {
                        TextLine.expandMetricsFromPaint(fmi, wp);
                    }
                    return 0;
                }
                if (this.mSpanned == null) {
                    let wp = this.mWorkPaint;
                    wp.set(this.mPaint);
                    const mlimit = measureLimit;
                    return this.handleText(wp, start, mlimit, start, limit, runIsRtl, c, x, top, y, bottom, fmi, needWidth || mlimit < measureLimit);
                }
                this.mMetricAffectingSpanSpanSet.init(this.mSpanned, this.mStart + start, this.mStart + limit);
                this.mCharacterStyleSpanSet.init(this.mSpanned, this.mStart + start, this.mStart + limit);
                const originalX = x;
                for (let i = start, inext; i < measureLimit; i = inext) {
                    let wp = this.mWorkPaint;
                    wp.set(this.mPaint);
                    inext = this.mMetricAffectingSpanSpanSet.getNextTransition(this.mStart + i, this.mStart + limit) - this.mStart;
                    let mlimit = Math.min(inext, measureLimit);
                    let replacement = null;
                    for (let j = 0; j < this.mMetricAffectingSpanSpanSet.numberOfSpans; j++) {
                        if ((this.mMetricAffectingSpanSpanSet.spanStarts[j] >= this.mStart + mlimit) || (this.mMetricAffectingSpanSpanSet.spanEnds[j] <= this.mStart + i))
                            continue;
                        let span = this.mMetricAffectingSpanSpanSet.spans[j];
                        if (span instanceof ReplacementSpan) {
                            replacement = span;
                        }
                        else {
                            span.updateDrawState(wp);
                        }
                    }
                    if (replacement != null) {
                        x += this.handleReplacement(replacement, wp, i, mlimit, runIsRtl, c, x, top, y, bottom, fmi, needWidth || mlimit < measureLimit);
                        continue;
                    }
                    for (let j = i, jnext; j < mlimit; j = jnext) {
                        jnext = this.mCharacterStyleSpanSet.getNextTransition(this.mStart + j, this.mStart + mlimit) - this.mStart;
                        wp.set(this.mPaint);
                        for (let k = 0; k < this.mCharacterStyleSpanSet.numberOfSpans; k++) {
                            if ((this.mCharacterStyleSpanSet.spanStarts[k] >= this.mStart + jnext) || (this.mCharacterStyleSpanSet.spanEnds[k] <= this.mStart + j))
                                continue;
                            let span = this.mCharacterStyleSpanSet.spans[k];
                            span.updateDrawState(wp);
                        }
                        x += this.handleText(wp, j, jnext, i, inext, runIsRtl, c, x, top, y, bottom, fmi, needWidth || jnext < measureLimit);
                    }
                }
                return x - originalX;
            }
            drawTextRun(c, wp, start, end, contextStart, contextEnd, runIsRtl, x, y) {
                let flags = runIsRtl ? Canvas.DIRECTION_RTL : Canvas.DIRECTION_LTR;
                if (this.mCharsValid) {
                    let count = end - start;
                    let contextCount = contextEnd - contextStart;
                    c.drawTextRun_count(this.mChars.toString(), start, count, contextStart, contextCount, x, y, flags, wp);
                }
                else {
                    let delta = this.mStart;
                    c.drawTextRun_end(this.mText.toString(), delta + start, delta + end, delta + contextStart, delta + contextEnd, x, y, flags, wp);
                }
            }
            ascent(pos) {
                if (this.mSpanned == null) {
                    return this.mPaint.ascent();
                }
                pos += this.mStart;
                let spans = this.mSpanned.getSpans(pos, pos + 1, MetricAffectingSpan.type);
                if (spans.length == 0) {
                    return this.mPaint.ascent();
                }
                let wp = this.mWorkPaint;
                wp.set(this.mPaint);
                for (let span of spans) {
                    span.updateMeasureState(wp);
                }
                return wp.ascent();
            }
            nextTab(h) {
                if (this.mTabs != null) {
                    return this.mTabs.nextTab(h);
                }
                return Layout.TabStops.nextDefaultStop(h, TextLine.TAB_INCREMENT);
            }
        }
        TextLine.DEBUG = false;
        TextLine.sCached = new Array(3);
        TextLine.TAB_INCREMENT = 20;
        text_6.TextLine = TextLine;
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/graphics/Canvas.ts"/>
///<reference path="../../android/graphics/Paint.ts"/>
///<reference path="../../android/graphics/Rect.ts"/>
///<reference path="../../android/graphics/Path.ts"/>
///<reference path="../../android/text/style/LeadingMarginSpan.ts"/>
///<reference path="../../android/text/style/LineBackgroundSpan.ts"/>
///<reference path="../../android/text/style/ParagraphStyle.ts"/>
///<reference path="../../android/text/style/ReplacementSpan.ts"/>
///<reference path="../../android/text/style/TabStopSpan.ts"/>
///<reference path="../../java/util/Arrays.ts"/>
///<reference path="../../java/lang/Float.ts"/>
///<reference path="../../java/lang/System.ts"/>
///<reference path="../../java/lang/StringBuilder.ts"/>
///<reference path="../../android/text/MeasuredText.ts"/>
///<reference path="../../android/text/Spanned.ts"/>
///<reference path="../../android/text/SpanSet.ts"/>
///<reference path="../../android/text/TextDirectionHeuristic.ts"/>
///<reference path="../../android/text/TextDirectionHeuristics.ts"/>
///<reference path="../../android/text/TextLine.ts"/>
///<reference path="../../android/text/TextPaint.ts"/>
///<reference path="../../android/text/TextUtils.ts"/>
///<reference path="../../android/text/TextWatcher.ts"/>
var android;
(function (android) {
    var text;
    (function (text_7) {
        var Rect = android.graphics.Rect;
        var LeadingMarginSpan = android.text.style.LeadingMarginSpan;
        var LeadingMarginSpan2 = android.text.style.LeadingMarginSpan.LeadingMarginSpan2;
        var LineBackgroundSpan = android.text.style.LineBackgroundSpan;
        var ParagraphStyle = android.text.style.ParagraphStyle;
        var ReplacementSpan = android.text.style.ReplacementSpan;
        var TabStopSpan = android.text.style.TabStopSpan;
        var Arrays = java.util.Arrays;
        var Float = java.lang.Float;
        var System = java.lang.System;
        var MeasuredText = android.text.MeasuredText;
        var Spanned = android.text.Spanned;
        var SpanSet = android.text.SpanSet;
        var TextDirectionHeuristics = android.text.TextDirectionHeuristics;
        var TextLine = android.text.TextLine;
        var TextPaint = android.text.TextPaint;
        var TextUtils = android.text.TextUtils;
        class Layout {
            constructor(text, paint, width, align, textDir = TextDirectionHeuristics.FIRSTSTRONG_LTR, spacingMult = 1, spacingAdd = 0) {
                this.mWidth = 0;
                this.mAlignment = Layout.Alignment.ALIGN_NORMAL;
                this.mSpacingMult = 0;
                this.mSpacingAdd = 0;
                if (width < 0)
                    throw Error(`new IllegalArgumentException("Layout: " + width + " < 0")`);
                if (paint != null) {
                    paint.bgColor = 0;
                    paint.baselineShift = 0;
                }
                this.mText = text;
                this.mPaint = paint;
                this.mWorkPaint = new TextPaint();
                this.mWidth = width;
                this.mAlignment = align;
                this.mSpacingMult = spacingMult;
                this.mSpacingAdd = spacingAdd;
                this.mSpannedText = Spanned.isImplements(text);
                this.mTextDir = textDir;
            }
            static getDesiredWidth(...args) {
                if (args.length == 2)
                    return Layout.getDesiredWidth_2(...args);
                if (args.length == 4)
                    return Layout.getDesiredWidth_4(...args);
            }
            static getDesiredWidth_2(source, paint) {
                return Layout.getDesiredWidth(source, 0, source.length, paint);
            }
            static getDesiredWidth_4(source, start, end, paint) {
                let need = 0;
                let next;
                for (let i = start; i <= end; i = next) {
                    next = source.substring(0, end).indexOf('\n', i);
                    if (next < 0)
                        next = end;
                    let w = Layout.measurePara(paint, source, i, next);
                    if (w > need)
                        need = w;
                    next++;
                }
                return need;
            }
            replaceWith(text, paint, width, align, spacingmult, spacingadd) {
                if (width < 0) {
                    throw Error(`new IllegalArgumentException("Layout: " + width + " < 0")`);
                }
                this.mText = text;
                this.mPaint = paint;
                this.mWidth = width;
                this.mAlignment = align;
                this.mSpacingMult = spacingmult;
                this.mSpacingAdd = spacingadd;
                this.mSpannedText = Spanned.isImplements(text);
            }
            draw(canvas, highlight = null, highlightPaint = null, cursorOffsetVertical = 0) {
                const lineRange = this.getLineRangeForDraw(canvas);
                let firstLine = TextUtils.unpackRangeStartFromLong(lineRange);
                let lastLine = TextUtils.unpackRangeEndFromLong(lineRange);
                if (lastLine < 0)
                    return;
                this.drawBackground(canvas, highlight, highlightPaint, cursorOffsetVertical, firstLine, lastLine);
                this.drawText(canvas, firstLine, lastLine);
            }
            drawText(canvas, firstLine, lastLine) {
                let previousLineBottom = this.getLineTop(firstLine);
                let previousLineEnd = this.getLineStart(firstLine);
                let spans = Layout.NO_PARA_SPANS;
                let spanEnd = 0;
                let paint = this.mPaint;
                let buf = this.mText;
                let paraAlign = this.mAlignment;
                let tabStops = null;
                let tabStopsIsInitialized = false;
                let tl = TextLine.obtain();
                for (let i = firstLine; i <= lastLine; i++) {
                    let start = previousLineEnd;
                    previousLineEnd = this.getLineStart(i + 1);
                    let end = this.getLineVisibleEnd(i, start, previousLineEnd);
                    let ltop = previousLineBottom;
                    let lbottom = this.getLineTop(i + 1);
                    previousLineBottom = lbottom;
                    let lbaseline = lbottom - this.getLineDescent(i);
                    let dir = this.getParagraphDirection(i);
                    let left = 0;
                    let right = this.mWidth;
                    if (this.mSpannedText) {
                        let sp = buf;
                        let textLength = buf.length;
                        let isFirstParaLine = (start == 0 || buf.charAt(start - 1) == '\n');
                        if (start >= spanEnd && (i == firstLine || isFirstParaLine)) {
                            spanEnd = sp.nextSpanTransition(start, textLength, ParagraphStyle.type);
                            spans = Layout.getParagraphSpans(sp, start, spanEnd, ParagraphStyle.type);
                            paraAlign = this.mAlignment;
                            tabStopsIsInitialized = false;
                        }
                        const length = spans.length;
                        for (let n = 0; n < length; n++) {
                            if (LeadingMarginSpan.isImpl(spans[n])) {
                                let margin = spans[n];
                                let useFirstLineMargin = isFirstParaLine;
                                if (LeadingMarginSpan2.isImpl(margin)) {
                                    let count = margin.getLeadingMarginLineCount();
                                    let startLine = this.getLineForOffset(sp.getSpanStart(margin));
                                    useFirstLineMargin = i < startLine + count;
                                }
                                if (dir == Layout.DIR_RIGHT_TO_LEFT) {
                                    margin.drawLeadingMargin(canvas, paint, right, dir, ltop, lbaseline, lbottom, buf, start, end, isFirstParaLine, this);
                                    right -= margin.getLeadingMargin(useFirstLineMargin);
                                }
                                else {
                                    margin.drawLeadingMargin(canvas, paint, left, dir, ltop, lbaseline, lbottom, buf, start, end, isFirstParaLine, this);
                                    left += margin.getLeadingMargin(useFirstLineMargin);
                                }
                            }
                        }
                    }
                    let hasTabOrEmoji = this.getLineContainsTab(i);
                    if (hasTabOrEmoji && !tabStopsIsInitialized) {
                        if (tabStops == null) {
                            tabStops = new Layout.TabStops(Layout.TAB_INCREMENT, spans);
                        }
                        else {
                            tabStops.reset(Layout.TAB_INCREMENT, spans);
                        }
                        tabStopsIsInitialized = true;
                    }
                    let align = paraAlign;
                    if (align == Layout.Alignment.ALIGN_LEFT) {
                        align = (dir == Layout.DIR_LEFT_TO_RIGHT) ? Layout.Alignment.ALIGN_NORMAL : Layout.Alignment.ALIGN_OPPOSITE;
                    }
                    else if (align == Layout.Alignment.ALIGN_RIGHT) {
                        align = (dir == Layout.DIR_LEFT_TO_RIGHT) ? Layout.Alignment.ALIGN_OPPOSITE : Layout.Alignment.ALIGN_NORMAL;
                    }
                    let x;
                    if (align == Layout.Alignment.ALIGN_NORMAL) {
                        if (dir == Layout.DIR_LEFT_TO_RIGHT) {
                            x = left;
                        }
                        else {
                            x = right;
                        }
                    }
                    else {
                        let max = Math.floor(this.getLineExtent(i, tabStops, false));
                        if (align == Layout.Alignment.ALIGN_OPPOSITE) {
                            if (dir == Layout.DIR_LEFT_TO_RIGHT) {
                                x = right - max;
                            }
                            else {
                                x = left - max;
                            }
                        }
                        else {
                            max = max & ~1;
                            x = (right + left - max) >> 1;
                        }
                    }
                    let directions = this.getLineDirections(i);
                    if (directions == Layout.DIRS_ALL_LEFT_TO_RIGHT && !this.mSpannedText && !hasTabOrEmoji) {
                        canvas.drawText_end(buf.toString(), start, end, x, lbaseline, paint);
                    }
                    else {
                        tl.set(paint, buf, start, end, dir, directions, hasTabOrEmoji, tabStops);
                        tl.draw(canvas, x, ltop, lbaseline, lbottom);
                    }
                }
                TextLine.recycle(tl);
            }
            drawBackground(canvas, highlight, highlightPaint, cursorOffsetVertical, firstLine, lastLine) {
                if (this.mSpannedText) {
                    if (this.mLineBackgroundSpans == null) {
                        this.mLineBackgroundSpans = new SpanSet(LineBackgroundSpan.type);
                    }
                    let buffer = this.mText;
                    let textLength = buffer.length;
                    this.mLineBackgroundSpans.init(buffer, 0, textLength);
                    if (this.mLineBackgroundSpans.numberOfSpans > 0) {
                        let previousLineBottom = this.getLineTop(firstLine);
                        let previousLineEnd = this.getLineStart(firstLine);
                        let spans = Layout.NO_PARA_SPANS;
                        let spansLength = 0;
                        let paint = this.mPaint;
                        let spanEnd = 0;
                        const width = this.mWidth;
                        for (let i = firstLine; i <= lastLine; i++) {
                            let start = previousLineEnd;
                            let end = this.getLineStart(i + 1);
                            previousLineEnd = end;
                            let ltop = previousLineBottom;
                            let lbottom = this.getLineTop(i + 1);
                            previousLineBottom = lbottom;
                            let lbaseline = lbottom - this.getLineDescent(i);
                            if (start >= spanEnd) {
                                spanEnd = this.mLineBackgroundSpans.getNextTransition(start, textLength);
                                spansLength = 0;
                                if (start != end || start == 0) {
                                    for (let j = 0; j < this.mLineBackgroundSpans.numberOfSpans; j++) {
                                        if (this.mLineBackgroundSpans.spanStarts[j] >= end || this.mLineBackgroundSpans.spanEnds[j] <= start)
                                            continue;
                                        if (spansLength == spans.length) {
                                            let newSize = (2 * spansLength);
                                            let newSpans = new Array(newSize);
                                            System.arraycopy(spans, 0, newSpans, 0, spansLength);
                                            spans = newSpans;
                                        }
                                        spans[spansLength++] = this.mLineBackgroundSpans.spans[j];
                                    }
                                }
                            }
                            for (let n = 0; n < spansLength; n++) {
                                let lineBackgroundSpan = spans[n];
                                lineBackgroundSpan.drawBackground(canvas, paint, 0, width, ltop, lbaseline, lbottom, buffer, start, end, i);
                            }
                        }
                    }
                    this.mLineBackgroundSpans.recycle();
                }
                if (highlight != null) {
                    if (cursorOffsetVertical != 0)
                        canvas.translate(0, cursorOffsetVertical);
                    canvas.drawPath(highlight, highlightPaint);
                    if (cursorOffsetVertical != 0)
                        canvas.translate(0, -cursorOffsetVertical);
                }
            }
            getLineRangeForDraw(canvas) {
                let dtop, dbottom;
                {
                    if (!canvas.getClipBounds(Layout.sTempRect)) {
                        return TextUtils.packRangeInLong(0, -1);
                    }
                    dtop = Layout.sTempRect.top;
                    dbottom = Layout.sTempRect.bottom;
                }
                const top = Math.max(dtop, 0);
                const bottom = Math.min(this.getLineTop(this.getLineCount()), dbottom);
                if (top >= bottom)
                    return TextUtils.packRangeInLong(0, -1);
                return TextUtils.packRangeInLong(this.getLineForVertical(top), this.getLineForVertical(bottom));
            }
            getLineStartPos(line, left, right) {
                let align = this.getParagraphAlignment(line);
                let dir = this.getParagraphDirection(line);
                if (align == Layout.Alignment.ALIGN_LEFT) {
                    align = (dir == Layout.DIR_LEFT_TO_RIGHT) ? Layout.Alignment.ALIGN_NORMAL : Layout.Alignment.ALIGN_OPPOSITE;
                }
                else if (align == Layout.Alignment.ALIGN_RIGHT) {
                    align = (dir == Layout.DIR_LEFT_TO_RIGHT) ? Layout.Alignment.ALIGN_OPPOSITE : Layout.Alignment.ALIGN_NORMAL;
                }
                let x;
                if (align == Layout.Alignment.ALIGN_NORMAL) {
                    if (dir == Layout.DIR_LEFT_TO_RIGHT) {
                        x = left;
                    }
                    else {
                        x = right;
                    }
                }
                else {
                    let tabStops = null;
                    if (this.mSpannedText && this.getLineContainsTab(line)) {
                        let spanned = this.mText;
                        let start = this.getLineStart(line);
                        let spanEnd = spanned.nextSpanTransition(start, spanned.length, TabStopSpan.type);
                        let tabSpans = Layout.getParagraphSpans(spanned, start, spanEnd, TabStopSpan.type);
                        if (tabSpans.length > 0) {
                            tabStops = new Layout.TabStops(Layout.TAB_INCREMENT, tabSpans);
                        }
                    }
                    let max = Math.floor(this.getLineExtent(line, tabStops, false));
                    if (align == Layout.Alignment.ALIGN_OPPOSITE) {
                        if (dir == Layout.DIR_LEFT_TO_RIGHT) {
                            x = right - max;
                        }
                        else {
                            x = left - max;
                        }
                    }
                    else {
                        max = max & ~1;
                        x = (left + right - max) >> 1;
                    }
                }
                return x;
            }
            getText() {
                return this.mText;
            }
            getPaint() {
                return this.mPaint;
            }
            getWidth() {
                return this.mWidth;
            }
            getEllipsizedWidth() {
                return this.mWidth;
            }
            increaseWidthTo(wid) {
                if (wid < this.mWidth) {
                    throw Error(`new RuntimeException("attempted to reduce Layout width")`);
                }
                this.mWidth = wid;
            }
            getHeight() {
                return this.getLineTop(this.getLineCount());
            }
            getAlignment() {
                return this.mAlignment;
            }
            getSpacingMultiplier() {
                return this.mSpacingMult;
            }
            getSpacingAdd() {
                return this.mSpacingAdd;
            }
            getTextDirectionHeuristic() {
                return this.mTextDir;
            }
            getLineBounds(line, bounds) {
                if (bounds != null) {
                    bounds.left = 0;
                    bounds.top = this.getLineTop(line);
                    bounds.right = this.mWidth;
                    bounds.bottom = this.getLineTop(line + 1);
                }
                return this.getLineBaseline(line);
            }
            isLevelBoundary(offset) {
                let line = this.getLineForOffset(offset);
                let dirs = this.getLineDirections(line);
                if (dirs == Layout.DIRS_ALL_LEFT_TO_RIGHT || dirs == Layout.DIRS_ALL_RIGHT_TO_LEFT) {
                    return false;
                }
                let runs = dirs.mDirections;
                let lineStart = this.getLineStart(line);
                let lineEnd = this.getLineEnd(line);
                if (offset == lineStart || offset == lineEnd) {
                    let paraLevel = this.getParagraphDirection(line) == 1 ? 0 : 1;
                    let runIndex = offset == lineStart ? 0 : runs.length - 2;
                    return ((runs[runIndex + 1] >>> Layout.RUN_LEVEL_SHIFT) & Layout.RUN_LEVEL_MASK) != paraLevel;
                }
                offset -= lineStart;
                for (let i = 0; i < runs.length; i += 2) {
                    if (offset == runs[i]) {
                        return true;
                    }
                }
                return false;
            }
            isRtlCharAt(offset) {
                let line = this.getLineForOffset(offset);
                let dirs = this.getLineDirections(line);
                if (dirs == Layout.DIRS_ALL_LEFT_TO_RIGHT) {
                    return false;
                }
                if (dirs == Layout.DIRS_ALL_RIGHT_TO_LEFT) {
                    return true;
                }
                let runs = dirs.mDirections;
                let lineStart = this.getLineStart(line);
                for (let i = 0; i < runs.length; i += 2) {
                    let start = lineStart + (runs[i] & Layout.RUN_LENGTH_MASK);
                    if (offset >= start) {
                        let level = (runs[i + 1] >>> Layout.RUN_LEVEL_SHIFT) & Layout.RUN_LEVEL_MASK;
                        return ((level & 1) != 0);
                    }
                }
                return false;
            }
            primaryIsTrailingPrevious(offset) {
                let line = this.getLineForOffset(offset);
                let lineStart = this.getLineStart(line);
                let lineEnd = this.getLineEnd(line);
                let runs = this.getLineDirections(line).mDirections;
                let levelAt = -1;
                for (let i = 0; i < runs.length; i += 2) {
                    let start = lineStart + runs[i];
                    let limit = start + (runs[i + 1] & Layout.RUN_LENGTH_MASK);
                    if (limit > lineEnd) {
                        limit = lineEnd;
                    }
                    if (offset >= start && offset < limit) {
                        if (offset > start) {
                            return false;
                        }
                        levelAt = (runs[i + 1] >>> Layout.RUN_LEVEL_SHIFT) & Layout.RUN_LEVEL_MASK;
                        break;
                    }
                }
                if (levelAt == -1) {
                    levelAt = this.getParagraphDirection(line) == 1 ? 0 : 1;
                }
                let levelBefore = -1;
                if (offset == lineStart) {
                    levelBefore = this.getParagraphDirection(line) == 1 ? 0 : 1;
                }
                else {
                    offset -= 1;
                    for (let i = 0; i < runs.length; i += 2) {
                        let start = lineStart + runs[i];
                        let limit = start + (runs[i + 1] & Layout.RUN_LENGTH_MASK);
                        if (limit > lineEnd) {
                            limit = lineEnd;
                        }
                        if (offset >= start && offset < limit) {
                            levelBefore = (runs[i + 1] >>> Layout.RUN_LEVEL_SHIFT) & Layout.RUN_LEVEL_MASK;
                            break;
                        }
                    }
                }
                return levelBefore < levelAt;
            }
            getPrimaryHorizontal(offset, clamped = false) {
                let trailing = this.primaryIsTrailingPrevious(offset);
                return this.getHorizontal(offset, trailing, clamped);
            }
            getSecondaryHorizontal(offset, clamped = false) {
                let trailing = this.primaryIsTrailingPrevious(offset);
                return this.getHorizontal(offset, !trailing, clamped);
            }
            getHorizontal(offset, trailing, clamped) {
                let line = this.getLineForOffset(offset);
                return this.getHorizontal_4(offset, trailing, line, clamped);
            }
            getHorizontal_4(offset, trailing, line, clamped) {
                let start = this.getLineStart(line);
                let end = this.getLineEnd(line);
                let dir = this.getParagraphDirection(line);
                let hasTabOrEmoji = this.getLineContainsTab(line);
                let directions = this.getLineDirections(line);
                let tabStops = null;
                if (hasTabOrEmoji && Spanned.isImplements(this.mText)) {
                    let tabs = Layout.getParagraphSpans(this.mText, start, end, TabStopSpan.type);
                    if (tabs.length > 0) {
                        tabStops = new Layout.TabStops(Layout.TAB_INCREMENT, tabs);
                    }
                }
                let tl = TextLine.obtain();
                tl.set(this.mPaint, this.mText, start, end, dir, directions, hasTabOrEmoji, tabStops);
                let wid = tl.measure(offset - start, trailing, null);
                TextLine.recycle(tl);
                if (clamped && wid > this.mWidth) {
                    wid = this.mWidth;
                }
                let left = this.getParagraphLeft(line);
                let right = this.getParagraphRight(line);
                return this.getLineStartPos(line, left, right) + wid;
            }
            getLineLeft(line) {
                let dir = this.getParagraphDirection(line);
                let align = this.getParagraphAlignment(line);
                if (align == Layout.Alignment.ALIGN_LEFT) {
                    return 0;
                }
                else if (align == Layout.Alignment.ALIGN_NORMAL) {
                    if (dir == Layout.DIR_RIGHT_TO_LEFT)
                        return this.getParagraphRight(line) - this.getLineMax(line);
                    else
                        return 0;
                }
                else if (align == Layout.Alignment.ALIGN_RIGHT) {
                    return this.mWidth - this.getLineMax(line);
                }
                else if (align == Layout.Alignment.ALIGN_OPPOSITE) {
                    if (dir == Layout.DIR_RIGHT_TO_LEFT)
                        return 0;
                    else
                        return this.mWidth - this.getLineMax(line);
                }
                else {
                    let left = this.getParagraphLeft(line);
                    let right = this.getParagraphRight(line);
                    let max = (Math.floor(this.getLineMax(line))) & ~1;
                    return left + ((right - left) - max) / 2;
                }
            }
            getLineRight(line) {
                let dir = this.getParagraphDirection(line);
                let align = this.getParagraphAlignment(line);
                if (align == Layout.Alignment.ALIGN_LEFT) {
                    return this.getParagraphLeft(line) + this.getLineMax(line);
                }
                else if (align == Layout.Alignment.ALIGN_NORMAL) {
                    if (dir == Layout.DIR_RIGHT_TO_LEFT)
                        return this.mWidth;
                    else
                        return this.getParagraphLeft(line) + this.getLineMax(line);
                }
                else if (align == Layout.Alignment.ALIGN_RIGHT) {
                    return this.mWidth;
                }
                else if (align == Layout.Alignment.ALIGN_OPPOSITE) {
                    if (dir == Layout.DIR_RIGHT_TO_LEFT)
                        return this.getLineMax(line);
                    else
                        return this.mWidth;
                }
                else {
                    let left = this.getParagraphLeft(line);
                    let right = this.getParagraphRight(line);
                    let max = (Math.floor(this.getLineMax(line))) & ~1;
                    return right - ((right - left) - max) / 2;
                }
            }
            getLineMax(line) {
                let margin = this.getParagraphLeadingMargin(line);
                let signedExtent = this.getLineExtent(line, false);
                return margin + signedExtent >= 0 ? signedExtent : -signedExtent;
            }
            getLineWidth(line) {
                let margin = this.getParagraphLeadingMargin(line);
                let signedExtent = this.getLineExtent(line, true);
                return margin + signedExtent >= 0 ? signedExtent : -signedExtent;
            }
            getLineExtent(...args) {
                if (args.length === 2)
                    return this.getLineExtent_2(...args);
                if (args.length === 3)
                    return this.getLineExtent_3(...args);
            }
            getLineExtent_2(line, full) {
                let start = this.getLineStart(line);
                let end = full ? this.getLineEnd(line) : this.getLineVisibleEnd(line);
                let hasTabsOrEmoji = this.getLineContainsTab(line);
                let tabStops = null;
                if (hasTabsOrEmoji && Spanned.isImplements(this.mText)) {
                    let tabs = Layout.getParagraphSpans(this.mText, start, end, TabStopSpan.type);
                    if (tabs.length > 0) {
                        tabStops = new Layout.TabStops(Layout.TAB_INCREMENT, tabs);
                    }
                }
                let directions = this.getLineDirections(line);
                if (directions == null) {
                    return 0;
                }
                let dir = this.getParagraphDirection(line);
                let tl = TextLine.obtain();
                tl.set(this.mPaint, this.mText, start, end, dir, directions, hasTabsOrEmoji, tabStops);
                let width = tl.metrics(null);
                TextLine.recycle(tl);
                return width;
            }
            getLineExtent_3(line, tabStops, full) {
                let start = this.getLineStart(line);
                let end = full ? this.getLineEnd(line) : this.getLineVisibleEnd(line);
                let hasTabsOrEmoji = this.getLineContainsTab(line);
                let directions = this.getLineDirections(line);
                let dir = this.getParagraphDirection(line);
                let tl = TextLine.obtain();
                tl.set(this.mPaint, this.mText, start, end, dir, directions, hasTabsOrEmoji, tabStops);
                let width = tl.metrics(null);
                TextLine.recycle(tl);
                return width;
            }
            getLineForVertical(vertical) {
                let high = this.getLineCount(), low = -1, guess;
                while (high - low > 1) {
                    guess = Math.floor((high + low) / 2);
                    if (this.getLineTop(guess) > vertical)
                        high = guess;
                    else
                        low = guess;
                }
                if (low < 0)
                    return 0;
                else
                    return low;
            }
            getLineForOffset(offset) {
                let high = this.getLineCount(), low = -1, guess;
                while (high - low > 1) {
                    guess = Math.floor((high + low) / 2);
                    if (this.getLineStart(guess) > offset)
                        high = guess;
                    else
                        low = guess;
                }
                if (low < 0)
                    return 0;
                else
                    return low;
            }
            getOffsetForHorizontal(line, horiz) {
                let max = this.getLineEnd(line) - 1;
                let min = this.getLineStart(line);
                let dirs = this.getLineDirections(line);
                if (line == this.getLineCount() - 1)
                    max++;
                let best = min;
                let bestdist = Math.abs(this.getPrimaryHorizontal(best) - horiz);
                for (let i = 0; i < dirs.mDirections.length; i += 2) {
                    let here = min + dirs.mDirections[i];
                    let there = here + (dirs.mDirections[i + 1] & Layout.RUN_LENGTH_MASK);
                    let swap = (dirs.mDirections[i + 1] & Layout.RUN_RTL_FLAG) != 0 ? -1 : 1;
                    if (there > max)
                        there = max;
                    let high = there - 1 + 1, low = here + 1 - 1, guess;
                    while (high - low > 1) {
                        guess = Math.floor((high + low) / 2);
                        let adguess = this.getOffsetAtStartOf(guess);
                        if (this.getPrimaryHorizontal(adguess) * swap >= horiz * swap)
                            high = guess;
                        else
                            low = guess;
                    }
                    if (low < here + 1)
                        low = here + 1;
                    if (low < there) {
                        low = this.getOffsetAtStartOf(low);
                        let dist = Math.abs(this.getPrimaryHorizontal(low) - horiz);
                        let aft = TextUtils.getOffsetAfter(this.mText, low);
                        if (aft < there) {
                            let other = Math.abs(this.getPrimaryHorizontal(aft) - horiz);
                            if (other < dist) {
                                dist = other;
                                low = aft;
                            }
                        }
                        if (dist < bestdist) {
                            bestdist = dist;
                            best = low;
                        }
                    }
                    let dist = Math.abs(this.getPrimaryHorizontal(here) - horiz);
                    if (dist < bestdist) {
                        bestdist = dist;
                        best = here;
                    }
                }
                let dist = Math.abs(this.getPrimaryHorizontal(max) - horiz);
                if (dist <= bestdist) {
                    bestdist = dist;
                    best = max;
                }
                return best;
            }
            getLineEnd(line) {
                return this.getLineStart(line + 1);
            }
            getLineVisibleEnd(line, start = this.getLineStart(line), end = this.getLineStart(line + 1)) {
                let text = this.mText;
                let ch;
                if (line == this.getLineCount() - 1) {
                    return end;
                }
                for (; end > start; end--) {
                    ch = text.charAt(end - 1);
                    if (ch == '\n') {
                        return end - 1;
                    }
                    if (ch != ' ' && ch != '\t') {
                        break;
                    }
                }
                return end;
            }
            getLineBottom(line) {
                return this.getLineTop(line + 1);
            }
            getLineBaseline(line) {
                return this.getLineTop(line + 1) - this.getLineDescent(line);
            }
            getLineAscent(line) {
                return this.getLineTop(line) - (this.getLineTop(line + 1) - this.getLineDescent(line));
            }
            getOffsetToLeftOf(offset) {
                return this.getOffsetToLeftRightOf(offset, true);
            }
            getOffsetToRightOf(offset) {
                return this.getOffsetToLeftRightOf(offset, false);
            }
            getOffsetToLeftRightOf(caret, toLeft) {
                let line = this.getLineForOffset(caret);
                let lineStart = this.getLineStart(line);
                let lineEnd = this.getLineEnd(line);
                let lineDir = this.getParagraphDirection(line);
                let lineChanged = false;
                let advance = toLeft == (lineDir == Layout.DIR_RIGHT_TO_LEFT);
                if (advance) {
                    if (caret == lineEnd) {
                        if (line < this.getLineCount() - 1) {
                            lineChanged = true;
                            ++line;
                        }
                        else {
                            return caret;
                        }
                    }
                }
                else {
                    if (caret == lineStart) {
                        if (line > 0) {
                            lineChanged = true;
                            --line;
                        }
                        else {
                            return caret;
                        }
                    }
                }
                if (lineChanged) {
                    lineStart = this.getLineStart(line);
                    lineEnd = this.getLineEnd(line);
                    let newDir = this.getParagraphDirection(line);
                    if (newDir != lineDir) {
                        toLeft = !toLeft;
                        lineDir = newDir;
                    }
                }
                let directions = this.getLineDirections(line);
                let tl = TextLine.obtain();
                tl.set(this.mPaint, this.mText, lineStart, lineEnd, lineDir, directions, false, null);
                caret = lineStart + tl.getOffsetToLeftRightOf(caret - lineStart, toLeft);
                tl = TextLine.recycle(tl);
                return caret;
            }
            getOffsetAtStartOf(offset) {
                if (offset == 0)
                    return 0;
                let text = this.mText;
                let c = text.codePointAt(offset);
                let questionMark = '?'.codePointAt(0);
                if (c >= questionMark && c <= questionMark) {
                    let c1 = text.codePointAt(offset - 1);
                    if (c1 >= questionMark && c1 <= questionMark)
                        offset -= 1;
                }
                if (this.mSpannedText) {
                    let spans = text.getSpans(offset, offset, ReplacementSpan.type);
                    for (let i = 0; i < spans.length; i++) {
                        let start = text.getSpanStart(spans[i]);
                        let end = text.getSpanEnd(spans[i]);
                        if (start < offset && end > offset)
                            offset = start;
                    }
                }
                return offset;
            }
            shouldClampCursor(line) {
                switch (this.getParagraphAlignment(line)) {
                    case Layout.Alignment.ALIGN_LEFT:
                        return true;
                    case Layout.Alignment.ALIGN_NORMAL:
                        return this.getParagraphDirection(line) > 0;
                    default:
                        return false;
                }
            }
            getCursorPath(point, dest, editingBuffer) {
                dest.reset();
            }
            addSelection(line, start, end, top, bottom, dest) {
            }
            getSelectionPath(start, end, dest) {
                dest.reset();
            }
            getParagraphAlignment(line) {
                let align = this.mAlignment;
                return align;
            }
            getParagraphLeft(line) {
                let left = 0;
                let dir = this.getParagraphDirection(line);
                if (dir == Layout.DIR_RIGHT_TO_LEFT || !this.mSpannedText) {
                    return left;
                }
                return this.getParagraphLeadingMargin(line);
            }
            getParagraphRight(line) {
                let right = this.mWidth;
                let dir = this.getParagraphDirection(line);
                if (dir == Layout.DIR_LEFT_TO_RIGHT || !this.mSpannedText) {
                    return right;
                }
                return right - this.getParagraphLeadingMargin(line);
            }
            getParagraphLeadingMargin(line) {
                if (!this.mSpannedText) {
                    return 0;
                }
                let spanned = this.mText;
                let lineStart = this.getLineStart(line);
                let lineEnd = this.getLineEnd(line);
                let spanEnd = spanned.nextSpanTransition(lineStart, lineEnd, LeadingMarginSpan.type);
                let spans = Layout.getParagraphSpans(spanned, lineStart, spanEnd, LeadingMarginSpan.type);
                if (spans.length == 0) {
                    return 0;
                }
                let margin = 0;
                let isFirstParaLine = lineStart == 0 || spanned.charAt(lineStart - 1) == '\n';
                for (let i = 0; i < spans.length; i++) {
                    let span = spans[i];
                    let useFirstLineMargin = isFirstParaLine;
                    if (LeadingMarginSpan2.isImpl(span)) {
                        let spStart = spanned.getSpanStart(span);
                        let spanLine = this.getLineForOffset(spStart);
                        let count = span.getLeadingMarginLineCount();
                        useFirstLineMargin = line < spanLine + count;
                    }
                    margin += span.getLeadingMargin(useFirstLineMargin);
                }
                return margin;
            }
            static measurePara(paint, text, start, end) {
                let mt = MeasuredText.obtain();
                let tl = TextLine.obtain();
                try {
                    mt.setPara(text, start, end, TextDirectionHeuristics.LTR);
                    let directions;
                    let dir;
                    directions = Layout.DIRS_ALL_LEFT_TO_RIGHT;
                    dir = Layout.DIR_LEFT_TO_RIGHT;
                    let chars = mt.mChars;
                    let len = mt.mLen;
                    let hasTabs = false;
                    let tabStops = null;
                    for (let i = 0; i < len; ++i) {
                        if (chars[i] == '\t') {
                            hasTabs = true;
                            if (Spanned.isImplements(text)) {
                                let spanned = text;
                                let spanEnd = spanned.nextSpanTransition(start, end, TabStopSpan.type);
                                let spans = Layout.getParagraphSpans(spanned, start, spanEnd, TabStopSpan.type);
                                if (spans.length > 0) {
                                    tabStops = new Layout.TabStops(Layout.TAB_INCREMENT, spans);
                                }
                            }
                            break;
                        }
                    }
                    tl.set(paint, text, start, end, dir, directions, hasTabs, tabStops);
                    return tl.metrics(null);
                }
                finally {
                    TextLine.recycle(tl);
                    MeasuredText.recycle(mt);
                }
            }
            static nextTab(text, start, end, h, tabs) {
                let nh = Float.MAX_VALUE;
                let alltabs = false;
                if (Spanned.isImplements(text)) {
                    if (tabs == null) {
                        tabs = Layout.getParagraphSpans(text, start, end, TabStopSpan.type);
                        alltabs = true;
                    }
                    for (let i = 0; i < tabs.length; i++) {
                        if (!alltabs) {
                            if (!(TabStopSpan.isImpl(tabs[i])))
                                continue;
                        }
                        let where = tabs[i].getTabStop();
                        if (where < nh && where > h)
                            nh = where;
                    }
                    if (nh != Float.MAX_VALUE)
                        return nh;
                }
                return (Math.floor(((h + Layout.TAB_INCREMENT) / Layout.TAB_INCREMENT))) * Layout.TAB_INCREMENT;
            }
            isSpanned() {
                return this.mSpannedText;
            }
            static getParagraphSpans(text, start, end, type) {
                if (start == end && start > 0) {
                    return [];
                }
                return text.getSpans(start, end, type);
            }
            getEllipsisChar(method) {
                return (method == TextUtils.TruncateAt.END_SMALL) ? Layout.ELLIPSIS_TWO_DOTS[0] : Layout.ELLIPSIS_NORMAL[0];
            }
            ellipsize(start, end, line, dest, destoff, method) {
                let ellipsisCount = this.getEllipsisCount(line);
                if (ellipsisCount == 0) {
                    return;
                }
                let ellipsisStart = this.getEllipsisStart(line);
                let linestart = this.getLineStart(line);
                for (let i = ellipsisStart; i < ellipsisStart + ellipsisCount; i++) {
                    let c;
                    if (i == ellipsisStart) {
                        c = this.getEllipsisChar(method);
                    }
                    else {
                        c = String.fromCharCode(20);
                    }
                    let a = i + linestart;
                    if (a >= start && a < end) {
                        dest[destoff + a - start] = c;
                    }
                }
            }
        }
        Layout.NO_PARA_SPANS = [];
        Layout.sTempRect = new Rect();
        Layout.DIR_LEFT_TO_RIGHT = 1;
        Layout.DIR_RIGHT_TO_LEFT = -1;
        Layout.DIR_REQUEST_LTR = 1;
        Layout.DIR_REQUEST_RTL = -1;
        Layout.DIR_REQUEST_DEFAULT_LTR = 2;
        Layout.DIR_REQUEST_DEFAULT_RTL = -2;
        Layout.RUN_LENGTH_MASK = 0x03ffffff;
        Layout.RUN_LEVEL_SHIFT = 26;
        Layout.RUN_LEVEL_MASK = 0x3f;
        Layout.RUN_RTL_FLAG = 1 << Layout.RUN_LEVEL_SHIFT;
        Layout.TAB_INCREMENT = 20;
        Layout.ELLIPSIS_NORMAL = ['…'];
        Layout.ELLIPSIS_TWO_DOTS = ['‥'];
        text_7.Layout = Layout;
        (function (Layout) {
            class TabStops {
                constructor(increment, spans) {
                    this.mNumStops = 0;
                    this.mIncrement = 0;
                    this.reset(increment, spans);
                }
                reset(increment, spans) {
                    this.mIncrement = increment;
                    let ns = 0;
                    if (spans != null) {
                        let stops = this.mStops;
                        for (let o of spans) {
                            if (TabStopSpan.isImpl(o)) {
                                if (stops == null) {
                                    stops = new Array(10);
                                }
                                else if (ns == stops.length) {
                                    let nstops = new Array(ns * 2);
                                    for (let i = 0; i < ns; ++i) {
                                        nstops[i] = stops[i];
                                    }
                                    stops = nstops;
                                }
                                stops[ns++] = o.getTabStop();
                            }
                        }
                        if (ns > 1) {
                            Arrays.sort(stops, 0, ns);
                        }
                        if (stops != this.mStops) {
                            this.mStops = stops;
                        }
                    }
                    this.mNumStops = ns;
                }
                nextTab(h) {
                    let ns = this.mNumStops;
                    if (ns > 0) {
                        let stops = this.mStops;
                        for (let i = 0; i < ns; ++i) {
                            let stop = stops[i];
                            if (stop > h) {
                                return stop;
                            }
                        }
                    }
                    return TabStops.nextDefaultStop(h, this.mIncrement);
                }
                static nextDefaultStop(h, inc) {
                    return (Math.floor(((h + inc) / inc))) * inc;
                }
            }
            Layout.TabStops = TabStops;
            class Directions {
                constructor(dirs) {
                    this.mDirections = dirs;
                }
            }
            Layout.Directions = Directions;
            class Ellipsizer extends String {
                constructor(s) {
                    super(s);
                    this.mWidth = 0;
                    this.mText = s;
                }
                toString() {
                    let line1 = this.mLayout.getLineForOffset(0);
                    let line2 = this.mLayout.getLineForOffset(this.mText.length);
                    let dest = this.mText.split('');
                    for (let i = line1; i <= line2; i++) {
                        this.mLayout.ellipsize(0, this.mText.length, i, dest, 0, this.mMethod);
                    }
                    return dest.join('');
                }
            }
            Layout.Ellipsizer = Ellipsizer;
            class SpannedEllipsizer extends Layout.Ellipsizer {
                constructor(display) {
                    super(display);
                    this.mSpanned = display;
                }
                getSpans(start, end, type) {
                    return this.mSpanned.getSpans(start, end, type);
                }
                getSpanStart(tag) {
                    return this.mSpanned.getSpanStart(tag);
                }
                getSpanEnd(tag) {
                    return this.mSpanned.getSpanEnd(tag);
                }
                getSpanFlags(tag) {
                    return this.mSpanned.getSpanFlags(tag);
                }
                nextSpanTransition(start, limit, type) {
                    return this.mSpanned.nextSpanTransition(start, limit, type);
                }
            }
            Layout.SpannedEllipsizer = SpannedEllipsizer;
            (function (Alignment) {
                Alignment[Alignment["ALIGN_NORMAL"] = 0] = "ALIGN_NORMAL";
                Alignment[Alignment["ALIGN_OPPOSITE"] = 1] = "ALIGN_OPPOSITE";
                Alignment[Alignment["ALIGN_CENTER"] = 2] = "ALIGN_CENTER";
                Alignment[Alignment["ALIGN_LEFT"] = 3] = "ALIGN_LEFT";
                Alignment[Alignment["ALIGN_RIGHT"] = 4] = "ALIGN_RIGHT";
            })(Layout.Alignment || (Layout.Alignment = {}));
            var Alignment = Layout.Alignment;
        })(Layout = text_7.Layout || (text_7.Layout = {}));
        Layout.DIRS_ALL_LEFT_TO_RIGHT = new Layout.Directions([0, Layout.RUN_LENGTH_MASK]);
        Layout.DIRS_ALL_RIGHT_TO_LEFT = new Layout.Directions([0, Layout.RUN_LENGTH_MASK | Layout.RUN_RTL_FLAG]);
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/graphics/Canvas.ts"/>
///<reference path="../../android/graphics/Paint.ts"/>
///<reference path="../../android/graphics/Path.ts"/>
///<reference path="../../android/text/style/ParagraphStyle.ts"/>
///<reference path="../../android/text/Layout.ts"/>
///<reference path="../../android/text/Spanned.ts"/>
///<reference path="../../android/text/TextDirectionHeuristic.ts"/>
///<reference path="../../android/text/TextDirectionHeuristics.ts"/>
///<reference path="../../android/text/TextLine.ts"/>
///<reference path="../../android/text/TextPaint.ts"/>
///<reference path="../../android/text/TextUtils.ts"/>
var android;
(function (android) {
    var text;
    (function (text_8) {
        var Paint = android.graphics.Paint;
        var ParagraphStyle = android.text.style.ParagraphStyle;
        var Layout = android.text.Layout;
        var Spanned = android.text.Spanned;
        var TextDirectionHeuristics = android.text.TextDirectionHeuristics;
        var TextLine = android.text.TextLine;
        var TextPaint = android.text.TextPaint;
        var TextUtils = android.text.TextUtils;
        class BoringLayout extends Layout {
            constructor(source, paint, outerwidth, align, spacingmult, spacingadd, metrics, includepad, ellipsize = null, ellipsizedWidth = outerwidth) {
                super(source, paint, outerwidth, align, TextDirectionHeuristics.FIRSTSTRONG_LTR, spacingmult, spacingadd);
                this.mBottom = 0;
                this.mDesc = 0;
                this.mTopPadding = 0;
                this.mBottomPadding = 0;
                this.mMax = 0;
                this.mEllipsizedWidth = 0;
                this.mEllipsizedStart = 0;
                this.mEllipsizedCount = 0;
                let trust;
                if (ellipsize == null || ellipsize == TextUtils.TruncateAt.MARQUEE) {
                    this.mEllipsizedWidth = outerwidth;
                    this.mEllipsizedStart = 0;
                    this.mEllipsizedCount = 0;
                    trust = true;
                }
                else {
                    this.replaceWith(TextUtils.ellipsize(source, paint, ellipsizedWidth, ellipsize, true, this), paint, outerwidth, align, spacingmult, spacingadd);
                    this.mEllipsizedWidth = ellipsizedWidth;
                    trust = false;
                }
                this.init(this.getText(), paint, outerwidth, align, spacingmult, spacingadd, metrics, includepad, trust);
            }
            static make(source, paint, outerwidth, align, spacingmult, spacingadd, metrics, includepad, ellipsize = null, ellipsizedWidth = outerwidth) {
                return new BoringLayout(source, paint, outerwidth, align, spacingmult, spacingadd, metrics, includepad, ellipsize, ellipsizedWidth);
            }
            replaceOrMake(source, paint, outerwidth, align, spacingmult, spacingadd, metrics, includepad, ellipsize = null, ellipsizedWidth = outerwidth) {
                let trust;
                if (ellipsize == null || ellipsize == TextUtils.TruncateAt.MARQUEE) {
                    this.replaceWith(source, paint, outerwidth, align, spacingmult, spacingadd);
                    this.mEllipsizedWidth = outerwidth;
                    this.mEllipsizedStart = 0;
                    this.mEllipsizedCount = 0;
                    trust = true;
                }
                else {
                    this.replaceWith(TextUtils.ellipsize(source, paint, ellipsizedWidth, ellipsize, true, this), paint, outerwidth, align, spacingmult, spacingadd);
                    this.mEllipsizedWidth = ellipsizedWidth;
                    trust = false;
                }
                this.init(this.getText(), paint, outerwidth, align, spacingmult, spacingadd, metrics, includepad, trust);
                return this;
            }
            init(source, paint, outerwidth, align, spacingmult, spacingadd, metrics, includepad, trustWidth) {
                let spacing;
                if (Object.getPrototypeOf(source) === String.prototype && align == Layout.Alignment.ALIGN_NORMAL) {
                    this.mDirect = source.toString();
                }
                else {
                    this.mDirect = null;
                }
                this.mPaint = paint;
                if (includepad) {
                    spacing = metrics.bottom - metrics.top;
                }
                else {
                    spacing = metrics.descent - metrics.ascent;
                }
                if (spacingmult != 1 || spacingadd != 0) {
                    spacing = Math.floor((spacing * spacingmult + spacingadd + 0.5));
                }
                this.mBottom = spacing;
                if (includepad) {
                    this.mDesc = spacing + metrics.top;
                }
                else {
                    this.mDesc = spacing + metrics.ascent;
                }
                if (trustWidth) {
                    this.mMax = metrics.width;
                }
                else {
                    let line = TextLine.obtain();
                    line.set(paint, source, 0, source.length, Layout.DIR_LEFT_TO_RIGHT, Layout.DIRS_ALL_LEFT_TO_RIGHT, false, null);
                    this.mMax = Math.floor(Math.ceil(line.metrics(null)));
                    TextLine.recycle(line);
                }
                if (includepad) {
                    this.mTopPadding = metrics.top - metrics.ascent;
                    this.mBottomPadding = metrics.bottom - metrics.descent;
                }
            }
            static isBoring(text, paint, textDir = TextDirectionHeuristics.FIRSTSTRONG_LTR, metrics = null) {
                let temp;
                let length = text.length;
                let boring = true;
                outer: for (let i = 0; i < length; i += 500) {
                    let j = i + 500;
                    if (j > length)
                        j = length;
                    temp = text.substring(i, j);
                    let n = j - i;
                    for (let a = 0; a < n; a++) {
                        let c = temp[a];
                        if (c == '\n' || c == '\t') {
                            boring = false;
                            break outer;
                        }
                    }
                    if (textDir != null && textDir.isRtl(temp, 0, n)) {
                        boring = false;
                        break outer;
                    }
                }
                if (boring && Spanned.isImplements(text)) {
                    let sp = text;
                    let styles = sp.getSpans(0, length, ParagraphStyle.type);
                    if (styles.length > 0) {
                        boring = false;
                    }
                }
                if (boring) {
                    let fm = metrics;
                    if (fm == null) {
                        fm = new BoringLayout.Metrics();
                    }
                    let line = TextLine.obtain();
                    line.set(paint, text, 0, length, Layout.DIR_LEFT_TO_RIGHT, Layout.DIRS_ALL_LEFT_TO_RIGHT, false, null);
                    fm.width = Math.floor(Math.ceil(line.metrics(fm)));
                    TextLine.recycle(line);
                    return fm;
                }
                else {
                    return null;
                }
            }
            getHeight() {
                return this.mBottom;
            }
            getLineCount() {
                return 1;
            }
            getLineTop(line) {
                if (line == 0)
                    return 0;
                else
                    return this.mBottom;
            }
            getLineDescent(line) {
                return this.mDesc;
            }
            getLineStart(line) {
                if (line == 0)
                    return 0;
                else
                    return this.getText().length;
            }
            getParagraphDirection(line) {
                return BoringLayout.DIR_LEFT_TO_RIGHT;
            }
            getLineContainsTab(line) {
                return false;
            }
            getLineMax(line) {
                return this.mMax;
            }
            getLineDirections(line) {
                return Layout.DIRS_ALL_LEFT_TO_RIGHT;
            }
            getTopPadding() {
                return this.mTopPadding;
            }
            getBottomPadding() {
                return this.mBottomPadding;
            }
            getEllipsisCount(line) {
                return this.mEllipsizedCount;
            }
            getEllipsisStart(line) {
                return this.mEllipsizedStart;
            }
            getEllipsizedWidth() {
                return this.mEllipsizedWidth;
            }
            draw(c, highlight, highlightpaint, cursorOffset) {
                if (this.mDirect != null && highlight == null) {
                    c.drawText(this.mDirect, 0, this.mBottom - this.mDesc, this.mPaint);
                }
                else {
                    super.draw(c, highlight, highlightpaint, cursorOffset);
                }
            }
            ellipsized(start, end) {
                this.mEllipsizedStart = start;
                this.mEllipsizedCount = end - start;
            }
        }
        BoringLayout.FIRST_RIGHT_TO_LEFT = '֐'.codePointAt(0);
        BoringLayout.sTemp = new TextPaint();
        text_8.BoringLayout = BoringLayout;
        (function (BoringLayout) {
            class Metrics extends Paint.FontMetricsInt {
                constructor(...args) {
                    super(...args);
                    this.width = 0;
                }
                toString() {
                    return super.toString() + " width=" + this.width;
                }
            }
            BoringLayout.Metrics = Metrics;
        })(BoringLayout = text_8.BoringLayout || (text_8.BoringLayout = {}));
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../java/lang/System.ts"/>
var android;
(function (android) {
    var text;
    (function (text) {
        var System = java.lang.System;
        class PackedIntVector {
            constructor(columns) {
                this.mColumns = 0;
                this.mRows = 0;
                this.mRowGapStart = 0;
                this.mRowGapLength = 0;
                this.mColumns = columns;
                this.mRows = 0;
                this.mRowGapStart = 0;
                this.mRowGapLength = this.mRows;
                this.mValues = null;
                this.mValueGap = new Array(2 * columns);
            }
            getValue(row, column) {
                const columns = this.mColumns;
                if (((row | column) < 0) || (row >= this.size()) || (column >= columns)) {
                    throw Error(`new IndexOutOfBoundsException(row + ", " + column)`);
                }
                if (row >= this.mRowGapStart) {
                    row += this.mRowGapLength;
                }
                let value = this.mValues[row * columns + column];
                let valuegap = this.mValueGap;
                if (row >= valuegap[column]) {
                    value += valuegap[column + columns];
                }
                return value;
            }
            setValue(row, column, value) {
                if (((row | column) < 0) || (row >= this.size()) || (column >= this.mColumns)) {
                    throw Error(`new IndexOutOfBoundsException(row + ", " + column)`);
                }
                if (row >= this.mRowGapStart) {
                    row += this.mRowGapLength;
                }
                let valuegap = this.mValueGap;
                if (row >= valuegap[column]) {
                    value -= valuegap[column + this.mColumns];
                }
                this.mValues[row * this.mColumns + column] = value;
            }
            setValueInternal(row, column, value) {
                if (row >= this.mRowGapStart) {
                    row += this.mRowGapLength;
                }
                let valuegap = this.mValueGap;
                if (row >= valuegap[column]) {
                    value -= valuegap[column + this.mColumns];
                }
                this.mValues[row * this.mColumns + column] = value;
            }
            adjustValuesBelow(startRow, column, delta) {
                if (((startRow | column) < 0) || (startRow > this.size()) || (column >= this.width())) {
                    throw Error(`new IndexOutOfBoundsException(startRow + ", " + column)`);
                }
                if (startRow >= this.mRowGapStart) {
                    startRow += this.mRowGapLength;
                }
                this.moveValueGapTo(column, startRow);
                this.mValueGap[column + this.mColumns] += delta;
            }
            insertAt(row, values) {
                if ((row < 0) || (row > this.size())) {
                    throw Error(`new IndexOutOfBoundsException("row " + row)`);
                }
                if ((values != null) && (values.length < this.width())) {
                    throw Error(`new IndexOutOfBoundsException("value count " + values.length)`);
                }
                this.moveRowGapTo(row);
                if (this.mRowGapLength == 0) {
                    this.growBuffer();
                }
                this.mRowGapStart++;
                this.mRowGapLength--;
                if (values == null) {
                    for (let i = this.mColumns - 1; i >= 0; i--) {
                        this.setValueInternal(row, i, 0);
                    }
                }
                else {
                    for (let i = this.mColumns - 1; i >= 0; i--) {
                        this.setValueInternal(row, i, values[i]);
                    }
                }
            }
            deleteAt(row, count) {
                if (((row | count) < 0) || (row + count > this.size())) {
                    throw Error(`new IndexOutOfBoundsException(row + ", " + count)`);
                }
                this.moveRowGapTo(row + count);
                this.mRowGapStart -= count;
                this.mRowGapLength += count;
            }
            size() {
                return this.mRows - this.mRowGapLength;
            }
            width() {
                return this.mColumns;
            }
            growBuffer() {
                const columns = this.mColumns;
                let newsize = this.size() + 1;
                newsize = (newsize * columns) / columns;
                let newvalues = new Array(newsize * columns);
                const valuegap = this.mValueGap;
                const rowgapstart = this.mRowGapStart;
                let after = this.mRows - (rowgapstart + this.mRowGapLength);
                if (this.mValues != null) {
                    System.arraycopy(this.mValues, 0, newvalues, 0, columns * rowgapstart);
                    System.arraycopy(this.mValues, (this.mRows - after) * columns, newvalues, (newsize - after) * columns, after * columns);
                }
                for (let i = 0; i < columns; i++) {
                    if (valuegap[i] >= rowgapstart) {
                        valuegap[i] += newsize - this.mRows;
                        if (valuegap[i] < rowgapstart) {
                            valuegap[i] = rowgapstart;
                        }
                    }
                }
                this.mRowGapLength += newsize - this.mRows;
                this.mRows = newsize;
                this.mValues = newvalues;
            }
            moveValueGapTo(column, where) {
                const valuegap = this.mValueGap;
                const values = this.mValues;
                const columns = this.mColumns;
                if (where == valuegap[column]) {
                    return;
                }
                else if (where > valuegap[column]) {
                    for (let i = valuegap[column]; i < where; i++) {
                        values[i * columns + column] += valuegap[column + columns];
                    }
                }
                else {
                    for (let i = where; i < valuegap[column]; i++) {
                        values[i * columns + column] -= valuegap[column + columns];
                    }
                }
                valuegap[column] = where;
            }
            moveRowGapTo(where) {
                if (where == this.mRowGapStart) {
                    return;
                }
                else if (where > this.mRowGapStart) {
                    let moving = where + this.mRowGapLength - (this.mRowGapStart + this.mRowGapLength);
                    const columns = this.mColumns;
                    const valuegap = this.mValueGap;
                    const values = this.mValues;
                    const gapend = this.mRowGapStart + this.mRowGapLength;
                    for (let i = gapend; i < gapend + moving; i++) {
                        let destrow = i - gapend + this.mRowGapStart;
                        for (let j = 0; j < columns; j++) {
                            let val = values[i * columns + j];
                            if (i >= valuegap[j]) {
                                val += valuegap[j + columns];
                            }
                            if (destrow >= valuegap[j]) {
                                val -= valuegap[j + columns];
                            }
                            values[destrow * columns + j] = val;
                        }
                    }
                }
                else {
                    let moving = this.mRowGapStart - where;
                    const columns = this.mColumns;
                    const valuegap = this.mValueGap;
                    const values = this.mValues;
                    const gapend = this.mRowGapStart + this.mRowGapLength;
                    for (let i = where + moving - 1; i >= where; i--) {
                        let destrow = i - where + gapend - moving;
                        for (let j = 0; j < columns; j++) {
                            let val = values[i * columns + j];
                            if (i >= valuegap[j]) {
                                val += valuegap[j + columns];
                            }
                            if (destrow >= valuegap[j]) {
                                val -= valuegap[j + columns];
                            }
                            values[destrow * columns + j] = val;
                        }
                    }
                }
                this.mRowGapStart = where;
            }
        }
        text.PackedIntVector = PackedIntVector;
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../java/lang/System.ts"/>
var android;
(function (android) {
    var text;
    (function (text) {
        var System = java.lang.System;
        class PackedObjectVector {
            constructor(columns) {
                this.mColumns = 0;
                this.mRows = 0;
                this.mRowGapStart = 0;
                this.mRowGapLength = 0;
                this.mColumns = columns;
                this.mRows = 1;
                this.mRowGapStart = 0;
                this.mRowGapLength = this.mRows;
                this.mValues = new Array(this.mRows * this.mColumns);
            }
            getValue(row, column) {
                if (row >= this.mRowGapStart)
                    row += this.mRowGapLength;
                let value = this.mValues[row * this.mColumns + column];
                return value;
            }
            setValue(row, column, value) {
                if (row >= this.mRowGapStart)
                    row += this.mRowGapLength;
                this.mValues[row * this.mColumns + column] = value;
            }
            insertAt(row, values) {
                this.moveRowGapTo(row);
                if (this.mRowGapLength == 0)
                    this.growBuffer();
                this.mRowGapStart++;
                this.mRowGapLength--;
                if (values == null)
                    for (let i = 0; i < this.mColumns; i++)
                        this.setValue(row, i, null);
                else
                    for (let i = 0; i < this.mColumns; i++)
                        this.setValue(row, i, values[i]);
            }
            deleteAt(row, count) {
                this.moveRowGapTo(row + count);
                this.mRowGapStart -= count;
                this.mRowGapLength += count;
                if (this.mRowGapLength > this.size() * 2) {
                }
            }
            size() {
                return this.mRows - this.mRowGapLength;
            }
            width() {
                return this.mColumns;
            }
            growBuffer() {
                let newsize = this.size() + 1;
                newsize = (newsize * this.mColumns) / this.mColumns;
                let newvalues = new Array(newsize * this.mColumns);
                let after = this.mRows - (this.mRowGapStart + this.mRowGapLength);
                System.arraycopy(this.mValues, 0, newvalues, 0, this.mColumns * this.mRowGapStart);
                System.arraycopy(this.mValues, (this.mRows - after) * this.mColumns, newvalues, (newsize - after) * this.mColumns, after * this.mColumns);
                this.mRowGapLength += newsize - this.mRows;
                this.mRows = newsize;
                this.mValues = newvalues;
            }
            moveRowGapTo(where) {
                if (where == this.mRowGapStart)
                    return;
                if (where > this.mRowGapStart) {
                    let moving = where + this.mRowGapLength - (this.mRowGapStart + this.mRowGapLength);
                    for (let i = this.mRowGapStart + this.mRowGapLength; i < this.mRowGapStart + this.mRowGapLength + moving; i++) {
                        let destrow = i - (this.mRowGapStart + this.mRowGapLength) + this.mRowGapStart;
                        for (let j = 0; j < this.mColumns; j++) {
                            let val = this.mValues[i * this.mColumns + j];
                            this.mValues[destrow * this.mColumns + j] = val;
                        }
                    }
                }
                else {
                    let moving = this.mRowGapStart - where;
                    for (let i = where + moving - 1; i >= where; i--) {
                        let destrow = i - where + this.mRowGapStart + this.mRowGapLength - moving;
                        for (let j = 0; j < this.mColumns; j++) {
                            let val = this.mValues[i * this.mColumns + j];
                            this.mValues[destrow * this.mColumns + j] = val;
                        }
                    }
                }
                this.mRowGapStart = where;
            }
            dump() {
                for (let i = 0; i < this.mRows; i++) {
                    for (let j = 0; j < this.mColumns; j++) {
                        let val = this.mValues[i * this.mColumns + j];
                        if (i < this.mRowGapStart || i >= this.mRowGapStart + this.mRowGapLength)
                            System.out.print(val + " ");
                        else
                            System.out.print("(" + val + ") ");
                    }
                    System.out.print(" << \n");
                }
                System.out.print("-----\n\n");
            }
        }
        text.PackedObjectVector = PackedObjectVector;
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/text/Spanned.ts"/>
///<reference path="../../android/text/TextWatcher.ts"/>
var android;
(function (android) {
    var text;
    (function (text) {
        var Spannable;
        (function (Spannable) {
            function isImpl(obj) {
                return obj && obj['setSpan'] && obj['removeSpan'];
            }
            Spannable.isImpl = isImpl;
            class Factory {
                static getInstance() {
                    return Factory.sInstance;
                }
                newSpannable(source) {
                    return source;
                }
            }
            Factory.sInstance = new Factory();
            Spannable.Factory = Factory;
        })(Spannable = text.Spannable || (text.Spannable = {}));
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/graphics/Paint.ts"/>
///<reference path="../../../android/graphics/Canvas.ts"/>
///<reference path="../../../android/text/Layout.ts"/>
///<reference path="../../../android/text/TextPaint.ts"/>
///<reference path="../../../android/text/style/ParagraphStyle.ts"/>
///<reference path="../../../android/text/style/WrapTogetherSpan.ts"/>
var android;
(function (android) {
    var text;
    (function (text_9) {
        var style;
        (function (style) {
            var LineHeightSpan;
            (function (LineHeightSpan) {
                LineHeightSpan.type = Symbol();
            })(LineHeightSpan = style.LineHeightSpan || (style.LineHeightSpan = {}));
        })(style = text_9.style || (text_9.style = {}));
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
var java;
(function (java) {
    var lang;
    (function (lang) {
        class Integer {
            static parseInt(value) {
                return Number.parseInt(value);
            }
        }
        Integer.MIN_VALUE = Number.MIN_SAFE_INTEGER;
        Integer.MAX_VALUE = Number.MAX_SAFE_INTEGER;
        lang.Integer = Integer;
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/graphics/Paint.ts"/>
///<reference path="../../android/text/style/LeadingMarginSpan.ts"/>
///<reference path="../../android/text/style/LineHeightSpan.ts"/>
///<reference path="../../android/text/style/MetricAffectingSpan.ts"/>
///<reference path="../../android/text/style/TabStopSpan.ts"/>
///<reference path="../../android/util/Log.ts"/>
///<reference path="../../java/lang/Integer.ts"/>
///<reference path="../../java/lang/System.ts"/>
///<reference path="../../android/text/Layout.ts"/>
///<reference path="../../android/text/MeasuredText.ts"/>
///<reference path="../../android/text/Spanned.ts"/>
///<reference path="../../android/text/TextDirectionHeuristic.ts"/>
///<reference path="../../android/text/TextDirectionHeuristics.ts"/>
///<reference path="../../android/text/TextPaint.ts"/>
///<reference path="../../android/text/TextUtils.ts"/>
var android;
(function (android) {
    var text;
    (function (text_10) {
        var Paint = android.graphics.Paint;
        var LeadingMarginSpan = android.text.style.LeadingMarginSpan;
        var LeadingMarginSpan2 = android.text.style.LeadingMarginSpan.LeadingMarginSpan2;
        var LineHeightSpan = android.text.style.LineHeightSpan;
        var MetricAffectingSpan = android.text.style.MetricAffectingSpan;
        var TabStopSpan = android.text.style.TabStopSpan;
        var Integer = java.lang.Integer;
        var System = java.lang.System;
        var Layout = android.text.Layout;
        var MeasuredText = android.text.MeasuredText;
        var Spanned = android.text.Spanned;
        var TextUtils = android.text.TextUtils;
        class StaticLayout extends Layout {
            constructor(source, bufstart, bufend, paint, outerwidth, align, textDir, spacingmult, spacingadd, includepad, ellipsize = null, ellipsizedWidth = 0, maxLines = Integer.MAX_VALUE) {
                super((ellipsize == null) ? source : (Spanned.isImplements(source)) ? new Layout.SpannedEllipsizer(source) : new Layout.Ellipsizer(source), paint, outerwidth, align, textDir, spacingmult, spacingadd);
                this.mLineCount = 0;
                this.mTopPadding = 0;
                this.mBottomPadding = 0;
                this.mColumns = 0;
                this.mEllipsizedWidth = 0;
                this.mMaximumVisibleLineCount = Integer.MAX_VALUE;
                this.mFontMetricsInt = new Paint.FontMetricsInt();
                if (source == null) {
                    this.mColumns = StaticLayout.COLUMNS_ELLIPSIZE;
                    this.mLines = new Array((2 * this.mColumns));
                    this.mLineDirections = new Array((2 * this.mColumns));
                    this.mMeasured = MeasuredText.obtain();
                    return;
                }
                if (ellipsize != null) {
                    let e = this.getText();
                    e.mLayout = this;
                    e.mWidth = ellipsizedWidth;
                    e.mMethod = ellipsize;
                    this.mEllipsizedWidth = ellipsizedWidth;
                    this.mColumns = StaticLayout.COLUMNS_ELLIPSIZE;
                }
                else {
                    this.mColumns = StaticLayout.COLUMNS_NORMAL;
                    this.mEllipsizedWidth = outerwidth;
                }
                this.mLines = new Array(2 * this.mColumns);
                this.mLineDirections = new Array(2 * this.mColumns);
                this.mMaximumVisibleLineCount = maxLines;
                this.mMeasured = MeasuredText.obtain();
                this.generate(source, bufstart, bufend, paint, outerwidth, textDir, spacingmult, spacingadd, includepad, includepad, ellipsizedWidth, ellipsize);
                this.mMeasured = MeasuredText.recycle(this.mMeasured);
                this.mFontMetricsInt = null;
            }
            generate(source, bufStart, bufEnd, paint, outerWidth, textDir, spacingmult, spacingadd, includepad, trackpad, ellipsizedWidth, ellipsize) {
                this.mLineCount = 0;
                let v = 0;
                let needMultiply = (spacingmult != 1 || spacingadd != 0);
                let fm = this.mFontMetricsInt;
                let chooseHtv = null;
                let measured = this.mMeasured;
                let spanned = null;
                if (Spanned.isImplements(source))
                    spanned = source;
                let DEFAULT_DIR = StaticLayout.DIR_LEFT_TO_RIGHT;
                let paraEnd;
                for (let paraStart = bufStart; paraStart <= bufEnd; paraStart = paraEnd) {
                    paraEnd = source.substring(0, bufEnd).indexOf(StaticLayout.CHAR_NEW_LINE, paraStart);
                    if (paraEnd < 0)
                        paraEnd = bufEnd;
                    else
                        paraEnd++;
                    let firstWidthLineLimit = this.mLineCount + 1;
                    let firstWidth = outerWidth;
                    let restWidth = outerWidth;
                    let chooseHt = null;
                    if (spanned != null) {
                        let sp = StaticLayout.getParagraphSpans(spanned, paraStart, paraEnd, LeadingMarginSpan.type);
                        for (let i = 0; i < sp.length; i++) {
                            let lms = sp[i];
                            firstWidth -= sp[i].getLeadingMargin(true);
                            restWidth -= sp[i].getLeadingMargin(false);
                            if (LeadingMarginSpan2.isImpl(lms)) {
                                let lms2 = lms;
                                let lmsFirstLine = this.getLineForOffset(spanned.getSpanStart(lms2));
                                firstWidthLineLimit = lmsFirstLine + lms2.getLeadingMarginLineCount();
                            }
                        }
                        chooseHt = StaticLayout.getParagraphSpans(spanned, paraStart, paraEnd, LineHeightSpan.type);
                        if (chooseHt.length != 0) {
                            if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
                                chooseHtv = new Array(chooseHt.length);
                            }
                            for (let i = 0; i < chooseHt.length; i++) {
                                let o = spanned.getSpanStart(chooseHt[i]);
                                if (o < paraStart) {
                                    chooseHtv[i] = this.getLineTop(this.getLineForOffset(o));
                                }
                                else {
                                    chooseHtv[i] = v;
                                }
                            }
                        }
                    }
                    measured.setPara(source, paraStart, paraEnd, textDir);
                    let chs = measured.mChars;
                    let widths = measured.mWidths;
                    let chdirs = measured.mLevels;
                    let dir = measured.mDir;
                    let easy = measured.mEasy;
                    let width = firstWidth;
                    let w = 0;
                    let here = paraStart;
                    let ok = paraStart;
                    let okWidth = w;
                    let okAscent = 0, okDescent = 0, okTop = 0, okBottom = 0;
                    let fit = paraStart;
                    let fitWidth = w;
                    let fitAscent = 0, fitDescent = 0, fitTop = 0, fitBottom = 0;
                    let hasTabOrEmoji = false;
                    let hasTab = false;
                    let tabStops = null;
                    for (let spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
                        if (spanned == null) {
                            spanEnd = paraEnd;
                            let spanLen = spanEnd - spanStart;
                            measured.addStyleRun(paint, spanLen, fm);
                        }
                        else {
                            spanEnd = spanned.nextSpanTransition(spanStart, paraEnd, MetricAffectingSpan.type);
                            let spanLen = spanEnd - spanStart;
                            let spans = spanned.getSpans(spanStart, spanEnd, MetricAffectingSpan.type);
                            spans = TextUtils.removeEmptySpans(spans, spanned, MetricAffectingSpan.type);
                            measured.addStyleRun(paint, spans, spanLen, fm);
                        }
                        let fmTop = fm.top;
                        let fmBottom = fm.bottom;
                        let fmAscent = fm.ascent;
                        let fmDescent = fm.descent;
                        for (let j = spanStart; j < spanEnd; j++) {
                            let c = chs[j - paraStart];
                            if (c == StaticLayout.CHAR_NEW_LINE) {
                            }
                            else if (c == StaticLayout.CHAR_TAB) {
                                if (hasTab == false) {
                                    hasTab = true;
                                    hasTabOrEmoji = true;
                                    if (spanned != null) {
                                        let spans = StaticLayout.getParagraphSpans(spanned, paraStart, paraEnd, TabStopSpan.type);
                                        if (spans.length > 0) {
                                            tabStops = new Layout.TabStops(StaticLayout.TAB_INCREMENT, spans);
                                        }
                                    }
                                }
                                if (tabStops != null) {
                                    w = tabStops.nextTab(w);
                                }
                                else {
                                    w = StaticLayout.TabStops.nextDefaultStop(w, StaticLayout.TAB_INCREMENT);
                                }
                            }
                            else if (c.codePointAt(0) >= StaticLayout.CHAR_FIRST_HIGH_SURROGATE
                                && c.codePointAt(0) <= StaticLayout.CHAR_LAST_LOW_SURROGATE && j + 1 < spanEnd) {
                                let emoji = chs.codePointAt(j - paraStart);
                                w += widths[j - paraStart];
                            }
                            else {
                                w += widths[j - paraStart];
                            }
                            let isSpaceOrTab = c == StaticLayout.CHAR_SPACE || c == StaticLayout.CHAR_TAB || c == StaticLayout.CHAR_ZWSP;
                            if (w <= width || isSpaceOrTab) {
                                fitWidth = w;
                                fit = j + 1;
                                if (fmTop < fitTop)
                                    fitTop = fmTop;
                                if (fmAscent < fitAscent)
                                    fitAscent = fmAscent;
                                if (fmDescent > fitDescent)
                                    fitDescent = fmDescent;
                                if (fmBottom > fitBottom)
                                    fitBottom = fmBottom;
                                let isLineBreak = isSpaceOrTab ||
                                    ((c == StaticLayout.CHAR_SLASH || c == StaticLayout.CHAR_HYPHEN) && (j + 1 >= spanEnd ||
                                        !Number.isInteger(Number.parseInt(chs[j + 1 - paraStart])))) ||
                                    (c.codePointAt(0) >= StaticLayout.CHAR_FIRST_CJK.codePointAt(0) && StaticLayout.isIdeographic(c, true) && j + 1 < spanEnd && StaticLayout.isIdeographic(chs[j + 1 - paraStart], false));
                                if (isLineBreak) {
                                    okWidth = w;
                                    ok = j + 1;
                                    if (fitTop < okTop)
                                        okTop = fitTop;
                                    if (fitAscent < okAscent)
                                        okAscent = fitAscent;
                                    if (fitDescent > okDescent)
                                        okDescent = fitDescent;
                                    if (fitBottom > okBottom)
                                        okBottom = fitBottom;
                                }
                            }
                            else {
                                const moreChars = (j + 1 < spanEnd);
                                let endPos;
                                let above, below, top, bottom;
                                let currentTextWidth;
                                if (ok != here) {
                                    endPos = ok;
                                    above = okAscent;
                                    below = okDescent;
                                    top = okTop;
                                    bottom = okBottom;
                                    currentTextWidth = okWidth;
                                }
                                else if (fit != here) {
                                    endPos = fit;
                                    above = fitAscent;
                                    below = fitDescent;
                                    top = fitTop;
                                    bottom = fitBottom;
                                    currentTextWidth = fitWidth;
                                }
                                else {
                                    endPos = here + 1;
                                    above = fm.ascent;
                                    below = fm.descent;
                                    top = fm.top;
                                    bottom = fm.bottom;
                                    currentTextWidth = widths[here - paraStart];
                                }
                                v = this.out(source, here, endPos, above, below, top, bottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, hasTabOrEmoji, needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, currentTextWidth, paint, moreChars);
                                here = endPos;
                                j = here - 1;
                                ok = fit = here;
                                w = 0;
                                fitAscent = fitDescent = fitTop = fitBottom = 0;
                                okAscent = okDescent = okTop = okBottom = 0;
                                if (--firstWidthLineLimit <= 0) {
                                    width = restWidth;
                                }
                                if (here < spanStart) {
                                    measured.setPos(here);
                                    spanEnd = here;
                                    break;
                                }
                                if (this.mLineCount >= this.mMaximumVisibleLineCount) {
                                    break;
                                }
                            }
                        }
                    }
                    if (paraEnd != here && this.mLineCount < this.mMaximumVisibleLineCount) {
                        if ((fitTop | fitBottom | fitDescent | fitAscent) == 0) {
                            paint.getFontMetricsInt(fm);
                            fitTop = fm.top;
                            fitBottom = fm.bottom;
                            fitAscent = fm.ascent;
                            fitDescent = fm.descent;
                        }
                        v = this.out(source, here, paraEnd, fitAscent, fitDescent, fitTop, fitBottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, hasTabOrEmoji, needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, w, paint, paraEnd != bufEnd);
                    }
                    paraStart = paraEnd;
                    if (paraEnd == bufEnd)
                        break;
                }
                if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == StaticLayout.CHAR_NEW_LINE) && this.mLineCount < this.mMaximumVisibleLineCount) {
                    measured.setPara(source, bufStart, bufEnd, textDir);
                    paint.getFontMetricsInt(fm);
                    v = this.out(source, bufEnd, bufEnd, fm.ascent, fm.descent, fm.top, fm.bottom, v, spacingmult, spacingadd, null, null, fm, false, needMultiply, measured.mLevels, measured.mDir, measured.mEasy, bufEnd, includepad, trackpad, null, null, bufStart, ellipsize, ellipsizedWidth, 0, paint, false);
                }
            }
            static isIdeographic(c, includeNonStarters) {
                let code = c.codePointAt(0);
                if (code >= '⺀'.codePointAt(0) && code <= '⿿'.codePointAt(0)) {
                    return true;
                }
                if (c == '　') {
                    return true;
                }
                if (code >= '぀'.codePointAt(0) && code <= 'ゟ'.codePointAt(0)) {
                    if (!includeNonStarters) {
                        switch (c) {
                            case 'ぁ':
                            case 'ぃ':
                            case 'ぅ':
                            case 'ぇ':
                            case 'ぉ':
                            case 'っ':
                            case 'ゃ':
                            case 'ゅ':
                            case 'ょ':
                            case 'ゎ':
                            case 'ゕ':
                            case 'ゖ':
                            case '゛':
                            case '゜':
                            case 'ゝ':
                            case 'ゞ':
                                return false;
                        }
                    }
                    return true;
                }
                if (code >= '゠'.codePointAt(0) && code <= 'ヿ'.codePointAt(0)) {
                    if (!includeNonStarters) {
                        switch (c) {
                            case '゠':
                            case 'ァ':
                            case 'ィ':
                            case 'ゥ':
                            case 'ェ':
                            case 'ォ':
                            case 'ッ':
                            case 'ャ':
                            case 'ュ':
                            case 'ョ':
                            case 'ヮ':
                            case 'ヵ':
                            case 'ヶ':
                            case '・':
                            case 'ー':
                            case 'ヽ':
                            case 'ヾ':
                                return false;
                        }
                    }
                    return true;
                }
                if (code >= '㐀'.codePointAt(0) && code <= '䶵'.codePointAt(0)) {
                    return true;
                }
                if (code >= '一'.codePointAt(0) && code <= '龻'.codePointAt(0)) {
                    return true;
                }
                if (code >= '豈'.codePointAt(0) && code <= '龎'.codePointAt(0)) {
                    return true;
                }
                if (code >= 'ꀀ'.codePointAt(0) && code <= '꒏'.codePointAt(0)) {
                    return true;
                }
                if (code >= '꒐'.codePointAt(0) && code <= '꓏'.codePointAt(0)) {
                    return true;
                }
                if (code >= '﹢'.codePointAt(0) && code <= '﹦'.codePointAt(0)) {
                    return true;
                }
                if (code >= '０'.codePointAt(0) && code <= '９'.codePointAt(0)) {
                    return true;
                }
                return false;
            }
            out(text, start, end, above, below, top, bottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, hasTabOrEmoji, needMultiply, chdirs, dir, easy, bufEnd, includePad, trackPad, chs, widths, widthStart, ellipsize, ellipsisWidth, textWidth, paint, moreChars) {
                let j = this.mLineCount;
                let off = j * this.mColumns;
                let want = off + this.mColumns + StaticLayout.TOP;
                let lines = this.mLines;
                if (want >= lines.length) {
                    let nlen = (want + 1);
                    let grow = new Array(nlen);
                    System.arraycopy(lines, 0, grow, 0, lines.length);
                    this.mLines = grow;
                    lines = grow;
                    let grow2 = new Array(nlen);
                    System.arraycopy(this.mLineDirections, 0, grow2, 0, this.mLineDirections.length);
                    this.mLineDirections = grow2;
                }
                if (chooseHt != null) {
                    fm.ascent = above;
                    fm.descent = below;
                    fm.top = top;
                    fm.bottom = bottom;
                    for (let i = 0; i < chooseHt.length; i++) {
                        chooseHt[i].chooseHeight(text, start, end, chooseHtv[i], v, fm, paint);
                    }
                    above = fm.ascent;
                    below = fm.descent;
                    top = fm.top;
                    bottom = fm.bottom;
                }
                if (j == 0) {
                    if (trackPad) {
                        this.mTopPadding = top - above;
                    }
                    if (includePad) {
                        above = top;
                    }
                }
                if (end == bufEnd) {
                    if (trackPad) {
                        this.mBottomPadding = bottom - below;
                    }
                    if (includePad) {
                        below = bottom;
                    }
                }
                let extra;
                if (needMultiply) {
                    let ex = (below - above) * (spacingmult - 1) + spacingadd;
                    if (ex >= 0) {
                        extra = Math.floor((ex + StaticLayout.EXTRA_ROUNDING));
                    }
                    else {
                        extra = -Math.floor((-ex + StaticLayout.EXTRA_ROUNDING));
                    }
                }
                else {
                    extra = 0;
                }
                lines[off + StaticLayout.START] = start;
                lines[off + StaticLayout.TOP] = v;
                lines[off + StaticLayout.DESCENT] = below + extra;
                v += (below - above) + extra;
                lines[off + this.mColumns + StaticLayout.START] = end;
                lines[off + this.mColumns + StaticLayout.TOP] = v;
                if (hasTabOrEmoji)
                    lines[off + StaticLayout.TAB] |= StaticLayout.TAB_MASK;
                lines[off + StaticLayout.DIR] |= dir << StaticLayout.DIR_SHIFT;
                let linedirs = StaticLayout.DIRS_ALL_LEFT_TO_RIGHT;
                this.mLineDirections[j] = linedirs;
                if (ellipsize != null) {
                    let firstLine = (j == 0);
                    let currentLineIsTheLastVisibleOne = (j + 1 == this.mMaximumVisibleLineCount);
                    let forceEllipsis = moreChars && (this.mLineCount + 1 == this.mMaximumVisibleLineCount);
                    let doEllipsis = (((this.mMaximumVisibleLineCount == 1 && moreChars) || (firstLine && !moreChars)) && ellipsize != TextUtils.TruncateAt.MARQUEE) || (!firstLine && (currentLineIsTheLastVisibleOne || !moreChars) && ellipsize == TextUtils.TruncateAt.END);
                    if (doEllipsis) {
                        this.calculateEllipsis(start, end, widths, widthStart, ellipsisWidth, ellipsize, j, textWidth, paint, forceEllipsis);
                    }
                }
                this.mLineCount++;
                return v;
            }
            calculateEllipsis(lineStart, lineEnd, widths, widthStart, avail, where, line, textWidth, paint, forceEllipsis) {
                if (textWidth <= avail && !forceEllipsis) {
                    this.mLines[this.mColumns * line + StaticLayout.ELLIPSIS_START] = 0;
                    this.mLines[this.mColumns * line + StaticLayout.ELLIPSIS_COUNT] = 0;
                    return;
                }
                let ellipsisWidth = paint.measureText((where == TextUtils.TruncateAt.END_SMALL) ? StaticLayout.ELLIPSIS_TWO_DOTS[0] : StaticLayout.ELLIPSIS_NORMAL[0], 0, 1);
                let ellipsisStart = 0;
                let ellipsisCount = 0;
                let len = lineEnd - lineStart;
                if (where == TextUtils.TruncateAt.START) {
                    if (this.mMaximumVisibleLineCount == 1) {
                        let sum = 0;
                        let i;
                        for (i = len; i >= 0; i--) {
                            let w = widths[i - 1 + lineStart - widthStart];
                            if (w + sum + ellipsisWidth > avail) {
                                break;
                            }
                            sum += w;
                        }
                        ellipsisStart = 0;
                        ellipsisCount = i;
                    }
                    else {
                    }
                }
                else if (where == TextUtils.TruncateAt.END || where == TextUtils.TruncateAt.MARQUEE || where == TextUtils.TruncateAt.END_SMALL) {
                    let sum = 0;
                    let i;
                    for (i = 0; i < len; i++) {
                        let w = widths[i + lineStart - widthStart];
                        if (w + sum + ellipsisWidth > avail) {
                            break;
                        }
                        sum += w;
                    }
                    ellipsisStart = i;
                    ellipsisCount = len - i;
                    if (forceEllipsis && ellipsisCount == 0 && len > 0) {
                        ellipsisStart = len - 1;
                        ellipsisCount = 1;
                    }
                }
                else {
                    if (this.mMaximumVisibleLineCount == 1) {
                        let lsum = 0, rsum = 0;
                        let left = 0, right = len;
                        let ravail = (avail - ellipsisWidth) / 2;
                        for (right = len; right >= 0; right--) {
                            let w = widths[right - 1 + lineStart - widthStart];
                            if (w + rsum > ravail) {
                                break;
                            }
                            rsum += w;
                        }
                        let lavail = avail - ellipsisWidth - rsum;
                        for (left = 0; left < right; left++) {
                            let w = widths[left + lineStart - widthStart];
                            if (w + lsum > lavail) {
                                break;
                            }
                            lsum += w;
                        }
                        ellipsisStart = left;
                        ellipsisCount = right - left;
                    }
                    else {
                    }
                }
                this.mLines[this.mColumns * line + StaticLayout.ELLIPSIS_START] = ellipsisStart;
                this.mLines[this.mColumns * line + StaticLayout.ELLIPSIS_COUNT] = ellipsisCount;
            }
            getLineForVertical(vertical) {
                let high = this.mLineCount;
                let low = -1;
                let guess;
                let lines = this.mLines;
                while (high - low > 1) {
                    guess = (high + low) >> 1;
                    if (lines[this.mColumns * guess + StaticLayout.TOP] > vertical) {
                        high = guess;
                    }
                    else {
                        low = guess;
                    }
                }
                if (low < 0) {
                    return 0;
                }
                else {
                    return low;
                }
            }
            getLineCount() {
                return this.mLineCount;
            }
            getLineTop(line) {
                let top = this.mLines[this.mColumns * line + StaticLayout.TOP];
                if (this.mMaximumVisibleLineCount > 0 && line >= this.mMaximumVisibleLineCount && line != this.mLineCount) {
                    top += this.getBottomPadding();
                }
                return top;
            }
            getLineDescent(line) {
                let descent = this.mLines[this.mColumns * line + StaticLayout.DESCENT];
                if (this.mMaximumVisibleLineCount > 0 && line >= this.mMaximumVisibleLineCount - 1 && line != this.mLineCount) {
                    descent += this.getBottomPadding();
                }
                return descent;
            }
            getLineStart(line) {
                return this.mLines[this.mColumns * line + StaticLayout.START] & StaticLayout.START_MASK;
            }
            getParagraphDirection(line) {
                return this.mLines[this.mColumns * line + StaticLayout.DIR] >> StaticLayout.DIR_SHIFT;
            }
            getLineContainsTab(line) {
                return (this.mLines[this.mColumns * line + StaticLayout.TAB] & StaticLayout.TAB_MASK) != 0;
            }
            getLineDirections(line) {
                return this.mLineDirections[line];
            }
            getTopPadding() {
                return this.mTopPadding;
            }
            getBottomPadding() {
                return this.mBottomPadding;
            }
            getEllipsisCount(line) {
                if (this.mColumns < StaticLayout.COLUMNS_ELLIPSIZE) {
                    return 0;
                }
                return this.mLines[this.mColumns * line + StaticLayout.ELLIPSIS_COUNT];
            }
            getEllipsisStart(line) {
                if (this.mColumns < StaticLayout.COLUMNS_ELLIPSIZE) {
                    return 0;
                }
                return this.mLines[this.mColumns * line + StaticLayout.ELLIPSIS_START];
            }
            getEllipsizedWidth() {
                return this.mEllipsizedWidth;
            }
            prepare() {
                this.mMeasured = MeasuredText.obtain();
            }
            finish() {
                this.mMeasured = MeasuredText.recycle(this.mMeasured);
            }
        }
        StaticLayout.TAG = "StaticLayout";
        StaticLayout.COLUMNS_NORMAL = 3;
        StaticLayout.COLUMNS_ELLIPSIZE = 5;
        StaticLayout.START = 0;
        StaticLayout.DIR = StaticLayout.START;
        StaticLayout.TAB = StaticLayout.START;
        StaticLayout.TOP = 1;
        StaticLayout.DESCENT = 2;
        StaticLayout.ELLIPSIS_START = 3;
        StaticLayout.ELLIPSIS_COUNT = 4;
        StaticLayout.START_MASK = 0x1FFFFFFF;
        StaticLayout.DIR_SHIFT = 30;
        StaticLayout.TAB_MASK = 0x20000000;
        StaticLayout.CHAR_FIRST_CJK = '⺀';
        StaticLayout.CHAR_NEW_LINE = '\n';
        StaticLayout.CHAR_TAB = '\t';
        StaticLayout.CHAR_SPACE = ' ';
        StaticLayout.CHAR_SLASH = '/';
        StaticLayout.CHAR_HYPHEN = '-';
        StaticLayout.CHAR_ZWSP = '​';
        StaticLayout.EXTRA_ROUNDING = 0.5;
        StaticLayout.CHAR_FIRST_HIGH_SURROGATE = 0xD800;
        StaticLayout.CHAR_LAST_LOW_SURROGATE = 0xDFFF;
        text_10.StaticLayout = StaticLayout;
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/graphics/Paint.ts"/>
///<reference path="../../android/text/style/UpdateLayout.ts"/>
///<reference path="../../android/text/style/WrapTogetherSpan.ts"/>
///<reference path="../../java/lang/ref/WeakReference.ts"/>
///<reference path="../../java/lang/System.ts"/>
///<reference path="../../android/text/Layout.ts"/>
///<reference path="../../android/text/PackedIntVector.ts"/>
///<reference path="../../android/text/PackedObjectVector.ts"/>
///<reference path="../../android/text/Spannable.ts"/>
///<reference path="../../android/text/Spanned.ts"/>
///<reference path="../../android/text/StaticLayout.ts"/>
///<reference path="../../android/text/TextDirectionHeuristic.ts"/>
///<reference path="../../android/text/TextDirectionHeuristics.ts"/>
///<reference path="../../android/text/TextPaint.ts"/>
///<reference path="../../android/text/TextUtils.ts"/>
///<reference path="../../android/text/TextWatcher.ts"/>
var android;
(function (android) {
    var text;
    (function (text_11) {
        var Paint = android.graphics.Paint;
        var System = java.lang.System;
        var Layout = android.text.Layout;
        var PackedIntVector = android.text.PackedIntVector;
        var PackedObjectVector = android.text.PackedObjectVector;
        var Spanned = android.text.Spanned;
        var StaticLayout = android.text.StaticLayout;
        class DynamicLayout extends Layout {
            constructor(base, display, paint, width, align, textDir, spacingmult, spacingadd, includepad, ellipsize = null, ellipsizedWidth = 0) {
                super((ellipsize == null) ? display : (Spanned.isImplements(display)) ? new Layout.SpannedEllipsizer(display) : new Layout.Ellipsizer(display), paint, width, align, textDir, spacingmult, spacingadd);
                this.mEllipsizedWidth = 0;
                this.mNumberOfBlocks = 0;
                this.mIndexFirstChangedBlock = 0;
                this.mTopPadding = 0;
                this.mBottomPadding = 0;
                this.mBase = base;
                this.mDisplay = display;
                if (ellipsize != null) {
                    this.mInts = new PackedIntVector(DynamicLayout.COLUMNS_ELLIPSIZE);
                    this.mEllipsizedWidth = ellipsizedWidth;
                    this.mEllipsizeAt = ellipsize;
                }
                else {
                    this.mInts = new PackedIntVector(DynamicLayout.COLUMNS_NORMAL);
                    this.mEllipsizedWidth = width;
                    this.mEllipsizeAt = null;
                }
                this.mObjects = new PackedObjectVector(1);
                this.mIncludePad = includepad;
                if (ellipsize != null) {
                    let e = this.getText();
                    e.mLayout = this;
                    e.mWidth = ellipsizedWidth;
                    e.mMethod = ellipsize;
                    this.mEllipsize = true;
                }
                let start;
                if (ellipsize != null) {
                    start = new Array(DynamicLayout.COLUMNS_ELLIPSIZE);
                    start[DynamicLayout.ELLIPSIS_START] = DynamicLayout.ELLIPSIS_UNDEFINED;
                }
                else {
                    start = new Array(DynamicLayout.COLUMNS_NORMAL);
                }
                let dirs = [DynamicLayout.DIRS_ALL_LEFT_TO_RIGHT];
                let fm = new Paint.FontMetricsInt();
                paint.getFontMetricsInt(fm);
                let asc = fm.ascent;
                let desc = fm.descent;
                start[DynamicLayout.DIR] = DynamicLayout.DIR_LEFT_TO_RIGHT << DynamicLayout.DIR_SHIFT;
                start[DynamicLayout.TOP] = 0;
                start[DynamicLayout.DESCENT] = desc;
                this.mInts.insertAt(0, start);
                start[DynamicLayout.TOP] = desc - asc;
                this.mInts.insertAt(1, start);
                this.mObjects.insertAt(0, dirs);
                this.reflow(base, 0, 0, base.length);
            }
            reflow(s, where, before, after) {
                if (s != this.mBase)
                    return;
                let text = this.mDisplay;
                let len = text.length;
                let find = text.lastIndexOf('\n', where - 1);
                if (find < 0)
                    find = 0;
                else
                    find = find + 1;
                {
                    let diff = where - find;
                    before += diff;
                    after += diff;
                    where -= diff;
                }
                let look = text.indexOf('\n', where + after);
                if (look < 0)
                    look = len;
                else
                    look++;
                let change = look - (where + after);
                before += change;
                after += change;
                let startline = this.getLineForOffset(where);
                let startv = this.getLineTop(startline);
                let endline = this.getLineForOffset(where + before);
                if (where + after == len)
                    endline = this.getLineCount();
                let endv = this.getLineTop(endline);
                let islast = (endline == this.getLineCount());
                let reflowed;
                {
                    reflowed = DynamicLayout.sStaticLayout;
                    DynamicLayout.sStaticLayout = null;
                }
                if (reflowed == null) {
                    reflowed = new StaticLayout(null, 0, 0, null, 0, null, null, 0, 1, true);
                }
                else {
                    reflowed.prepare();
                }
                reflowed.generate(text, where, where + after, this.getPaint(), this.getWidth(), this.getTextDirectionHeuristic(), this.getSpacingMultiplier(), this.getSpacingAdd(), false, true, this.mEllipsizedWidth, this.mEllipsizeAt);
                let n = reflowed.getLineCount();
                if (where + after != len && reflowed.getLineStart(n - 1) == where + after)
                    n--;
                this.mInts.deleteAt(startline, endline - startline);
                this.mObjects.deleteAt(startline, endline - startline);
                let ht = reflowed.getLineTop(n);
                let toppad = 0, botpad = 0;
                if (this.mIncludePad && startline == 0) {
                    toppad = reflowed.getTopPadding();
                    this.mTopPadding = toppad;
                    ht -= toppad;
                }
                if (this.mIncludePad && islast) {
                    botpad = reflowed.getBottomPadding();
                    this.mBottomPadding = botpad;
                    ht += botpad;
                }
                this.mInts.adjustValuesBelow(startline, DynamicLayout.START, after - before);
                this.mInts.adjustValuesBelow(startline, DynamicLayout.TOP, startv - endv + ht);
                let ints;
                if (this.mEllipsize) {
                    ints = new Array(DynamicLayout.COLUMNS_ELLIPSIZE);
                    ints[DynamicLayout.ELLIPSIS_START] = DynamicLayout.ELLIPSIS_UNDEFINED;
                }
                else {
                    ints = new Array(DynamicLayout.COLUMNS_NORMAL);
                }
                let objects = new Array(1);
                for (let i = 0; i < n; i++) {
                    ints[DynamicLayout.START] = reflowed.getLineStart(i) | (reflowed.getParagraphDirection(i) << DynamicLayout.DIR_SHIFT) | (reflowed.getLineContainsTab(i) ? DynamicLayout.TAB_MASK : 0);
                    let top = reflowed.getLineTop(i) + startv;
                    if (i > 0)
                        top -= toppad;
                    ints[DynamicLayout.TOP] = top;
                    let desc = reflowed.getLineDescent(i);
                    if (i == n - 1)
                        desc += botpad;
                    ints[DynamicLayout.DESCENT] = desc;
                    objects[0] = reflowed.getLineDirections(i);
                    if (this.mEllipsize) {
                        ints[DynamicLayout.ELLIPSIS_START] = reflowed.getEllipsisStart(i);
                        ints[DynamicLayout.ELLIPSIS_COUNT] = reflowed.getEllipsisCount(i);
                    }
                    this.mInts.insertAt(startline + i, ints);
                    this.mObjects.insertAt(startline + i, objects);
                }
                this.updateBlocks(startline, endline - 1, n);
                {
                    DynamicLayout.sStaticLayout = reflowed;
                    reflowed.finish();
                }
            }
            createBlocks() {
                let offset = DynamicLayout.BLOCK_MINIMUM_CHARACTER_LENGTH;
                this.mNumberOfBlocks = 0;
                const text = this.mDisplay;
                while (true) {
                    offset = text.indexOf('\n', offset);
                    if (offset < 0) {
                        this.addBlockAtOffset(text.length);
                        break;
                    }
                    else {
                        this.addBlockAtOffset(offset);
                        offset += DynamicLayout.BLOCK_MINIMUM_CHARACTER_LENGTH;
                    }
                }
                this.mBlockIndices = new Array(this.mBlockEndLines.length);
                for (let i = 0; i < this.mBlockEndLines.length; i++) {
                    this.mBlockIndices[i] = DynamicLayout.INVALID_BLOCK_INDEX;
                }
            }
            addBlockAtOffset(offset) {
                const line = this.getLineForOffset(offset);
                if (this.mBlockEndLines == null) {
                    this.mBlockEndLines = new Array((1));
                    this.mBlockEndLines[this.mNumberOfBlocks] = line;
                    this.mNumberOfBlocks++;
                    return;
                }
                const previousBlockEndLine = this.mBlockEndLines[this.mNumberOfBlocks - 1];
                if (line > previousBlockEndLine) {
                    if (this.mNumberOfBlocks == this.mBlockEndLines.length) {
                        let blockEndLines = new Array((this.mNumberOfBlocks + 1));
                        System.arraycopy(this.mBlockEndLines, 0, blockEndLines, 0, this.mNumberOfBlocks);
                        this.mBlockEndLines = blockEndLines;
                    }
                    this.mBlockEndLines[this.mNumberOfBlocks] = line;
                    this.mNumberOfBlocks++;
                }
            }
            updateBlocks(startLine, endLine, newLineCount) {
                if (this.mBlockEndLines == null) {
                    this.createBlocks();
                    return;
                }
                let firstBlock = -1;
                let lastBlock = -1;
                for (let i = 0; i < this.mNumberOfBlocks; i++) {
                    if (this.mBlockEndLines[i] >= startLine) {
                        firstBlock = i;
                        break;
                    }
                }
                for (let i = firstBlock; i < this.mNumberOfBlocks; i++) {
                    if (this.mBlockEndLines[i] >= endLine) {
                        lastBlock = i;
                        break;
                    }
                }
                const lastBlockEndLine = this.mBlockEndLines[lastBlock];
                let createBlockBefore = startLine > (firstBlock == 0 ? 0 : this.mBlockEndLines[firstBlock - 1] + 1);
                let createBlock = newLineCount > 0;
                let createBlockAfter = endLine < this.mBlockEndLines[lastBlock];
                let numAddedBlocks = 0;
                if (createBlockBefore)
                    numAddedBlocks++;
                if (createBlock)
                    numAddedBlocks++;
                if (createBlockAfter)
                    numAddedBlocks++;
                const numRemovedBlocks = lastBlock - firstBlock + 1;
                const newNumberOfBlocks = this.mNumberOfBlocks + numAddedBlocks - numRemovedBlocks;
                if (newNumberOfBlocks == 0) {
                    this.mBlockEndLines[0] = 0;
                    this.mBlockIndices[0] = DynamicLayout.INVALID_BLOCK_INDEX;
                    this.mNumberOfBlocks = 1;
                    return;
                }
                if (newNumberOfBlocks > this.mBlockEndLines.length) {
                    const newSize = (newNumberOfBlocks);
                    let blockEndLines = new Array(newSize);
                    let blockIndices = new Array(newSize);
                    System.arraycopy(this.mBlockEndLines, 0, blockEndLines, 0, firstBlock);
                    System.arraycopy(this.mBlockIndices, 0, blockIndices, 0, firstBlock);
                    System.arraycopy(this.mBlockEndLines, lastBlock + 1, blockEndLines, firstBlock + numAddedBlocks, this.mNumberOfBlocks - lastBlock - 1);
                    System.arraycopy(this.mBlockIndices, lastBlock + 1, blockIndices, firstBlock + numAddedBlocks, this.mNumberOfBlocks - lastBlock - 1);
                    this.mBlockEndLines = blockEndLines;
                    this.mBlockIndices = blockIndices;
                }
                else {
                    System.arraycopy(this.mBlockEndLines, lastBlock + 1, this.mBlockEndLines, firstBlock + numAddedBlocks, this.mNumberOfBlocks - lastBlock - 1);
                    System.arraycopy(this.mBlockIndices, lastBlock + 1, this.mBlockIndices, firstBlock + numAddedBlocks, this.mNumberOfBlocks - lastBlock - 1);
                }
                this.mNumberOfBlocks = newNumberOfBlocks;
                let newFirstChangedBlock;
                const deltaLines = newLineCount - (endLine - startLine + 1);
                if (deltaLines != 0) {
                    newFirstChangedBlock = firstBlock + numAddedBlocks;
                    for (let i = newFirstChangedBlock; i < this.mNumberOfBlocks; i++) {
                        this.mBlockEndLines[i] += deltaLines;
                    }
                }
                else {
                    newFirstChangedBlock = this.mNumberOfBlocks;
                }
                this.mIndexFirstChangedBlock = Math.min(this.mIndexFirstChangedBlock, newFirstChangedBlock);
                let blockIndex = firstBlock;
                if (createBlockBefore) {
                    this.mBlockEndLines[blockIndex] = startLine - 1;
                    this.mBlockIndices[blockIndex] = DynamicLayout.INVALID_BLOCK_INDEX;
                    blockIndex++;
                }
                if (createBlock) {
                    this.mBlockEndLines[blockIndex] = startLine + newLineCount - 1;
                    this.mBlockIndices[blockIndex] = DynamicLayout.INVALID_BLOCK_INDEX;
                    blockIndex++;
                }
                if (createBlockAfter) {
                    this.mBlockEndLines[blockIndex] = lastBlockEndLine + deltaLines;
                    this.mBlockIndices[blockIndex] = DynamicLayout.INVALID_BLOCK_INDEX;
                }
            }
            setBlocksDataForTest(blockEndLines, blockIndices, numberOfBlocks) {
                this.mBlockEndLines = new Array(blockEndLines.length);
                this.mBlockIndices = new Array(blockIndices.length);
                System.arraycopy(blockEndLines, 0, this.mBlockEndLines, 0, blockEndLines.length);
                System.arraycopy(blockIndices, 0, this.mBlockIndices, 0, blockIndices.length);
                this.mNumberOfBlocks = numberOfBlocks;
            }
            getBlockEndLines() {
                return this.mBlockEndLines;
            }
            getBlockIndices() {
                return this.mBlockIndices;
            }
            getNumberOfBlocks() {
                return this.mNumberOfBlocks;
            }
            getIndexFirstChangedBlock() {
                return this.mIndexFirstChangedBlock;
            }
            setIndexFirstChangedBlock(i) {
                this.mIndexFirstChangedBlock = i;
            }
            getLineCount() {
                return this.mInts.size() - 1;
            }
            getLineTop(line) {
                return this.mInts.getValue(line, DynamicLayout.TOP);
            }
            getLineDescent(line) {
                return this.mInts.getValue(line, DynamicLayout.DESCENT);
            }
            getLineStart(line) {
                return this.mInts.getValue(line, DynamicLayout.START) & DynamicLayout.START_MASK;
            }
            getLineContainsTab(line) {
                return (this.mInts.getValue(line, DynamicLayout.TAB) & DynamicLayout.TAB_MASK) != 0;
            }
            getParagraphDirection(line) {
                return this.mInts.getValue(line, DynamicLayout.DIR) >> DynamicLayout.DIR_SHIFT;
            }
            getLineDirections(line) {
                return this.mObjects.getValue(line, 0);
            }
            getTopPadding() {
                return this.mTopPadding;
            }
            getBottomPadding() {
                return this.mBottomPadding;
            }
            getEllipsizedWidth() {
                return this.mEllipsizedWidth;
            }
            getEllipsisStart(line) {
                if (this.mEllipsizeAt == null) {
                    return 0;
                }
                return this.mInts.getValue(line, DynamicLayout.ELLIPSIS_START);
            }
            getEllipsisCount(line) {
                if (this.mEllipsizeAt == null) {
                    return 0;
                }
                return this.mInts.getValue(line, DynamicLayout.ELLIPSIS_COUNT);
            }
        }
        DynamicLayout.PRIORITY = 128;
        DynamicLayout.BLOCK_MINIMUM_CHARACTER_LENGTH = 400;
        DynamicLayout.INVALID_BLOCK_INDEX = -1;
        DynamicLayout.sStaticLayout = new StaticLayout(null, 0, 0, null, 0, null, null, 1, 0, true);
        DynamicLayout.sLock = new Array(0);
        DynamicLayout.START = 0;
        DynamicLayout.DIR = DynamicLayout.START;
        DynamicLayout.TAB = DynamicLayout.START;
        DynamicLayout.TOP = 1;
        DynamicLayout.DESCENT = 2;
        DynamicLayout.COLUMNS_NORMAL = 3;
        DynamicLayout.ELLIPSIS_START = 3;
        DynamicLayout.ELLIPSIS_COUNT = 4;
        DynamicLayout.COLUMNS_ELLIPSIZE = 5;
        DynamicLayout.START_MASK = 0x1FFFFFFF;
        DynamicLayout.DIR_SHIFT = 30;
        DynamicLayout.TAB_MASK = 0x20000000;
        DynamicLayout.ELLIPSIS_UNDEFINED = 0x80000000;
        text_11.DynamicLayout = DynamicLayout;
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var android;
(function (android) {
    var text;
    (function (text) {
        class InputType {
        }
        InputType.TYPE_MASK_CLASS = 0x0000000f;
        InputType.TYPE_MASK_VARIATION = 0x00000ff0;
        InputType.TYPE_MASK_FLAGS = 0x00fff000;
        InputType.TYPE_NULL = 0x00000000;
        InputType.TYPE_CLASS_TEXT = 0x00000001;
        InputType.TYPE_TEXT_FLAG_CAP_CHARACTERS = 0x00001000;
        InputType.TYPE_TEXT_FLAG_CAP_WORDS = 0x00002000;
        InputType.TYPE_TEXT_FLAG_CAP_SENTENCES = 0x00004000;
        InputType.TYPE_TEXT_FLAG_AUTO_CORRECT = 0x00008000;
        InputType.TYPE_TEXT_FLAG_AUTO_COMPLETE = 0x00010000;
        InputType.TYPE_TEXT_FLAG_MULTI_LINE = 0x00020000;
        InputType.TYPE_TEXT_FLAG_IME_MULTI_LINE = 0x00040000;
        InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS = 0x00080000;
        InputType.TYPE_TEXT_VARIATION_NORMAL = 0x00000000;
        InputType.TYPE_TEXT_VARIATION_URI = 0x00000010;
        InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS = 0x00000020;
        InputType.TYPE_TEXT_VARIATION_EMAIL_SUBJECT = 0x00000030;
        InputType.TYPE_TEXT_VARIATION_SHORT_MESSAGE = 0x00000040;
        InputType.TYPE_TEXT_VARIATION_LONG_MESSAGE = 0x00000050;
        InputType.TYPE_TEXT_VARIATION_PERSON_NAME = 0x00000060;
        InputType.TYPE_TEXT_VARIATION_POSTAL_ADDRESS = 0x00000070;
        InputType.TYPE_TEXT_VARIATION_PASSWORD = 0x00000080;
        InputType.TYPE_TEXT_VARIATION_VISIBLE_PASSWORD = 0x00000090;
        InputType.TYPE_TEXT_VARIATION_WEB_EDIT_TEXT = 0x000000a0;
        InputType.TYPE_TEXT_VARIATION_FILTER = 0x000000b0;
        InputType.TYPE_TEXT_VARIATION_PHONETIC = 0x000000c0;
        InputType.TYPE_TEXT_VARIATION_WEB_EMAIL_ADDRESS = 0x000000d0;
        InputType.TYPE_TEXT_VARIATION_WEB_PASSWORD = 0x000000e0;
        InputType.TYPE_CLASS_NUMBER = 0x00000002;
        InputType.TYPE_NUMBER_FLAG_SIGNED = 0x00001000;
        InputType.TYPE_NUMBER_FLAG_DECIMAL = 0x00002000;
        InputType.TYPE_NUMBER_VARIATION_NORMAL = 0x00000000;
        InputType.TYPE_NUMBER_VARIATION_PASSWORD = 0x00000010;
        InputType.TYPE_CLASS_PHONE = 0x00000003;
        InputType.TYPE_CLASS_DATETIME = 0x00000004;
        InputType.TYPE_DATETIME_VARIATION_NORMAL = 0x00000000;
        InputType.TYPE_DATETIME_VARIATION_DATE = 0x00000010;
        InputType.TYPE_DATETIME_VARIATION_TIME = 0x00000020;
        text.InputType = InputType;
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/text/Spannable.ts"/>
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/graphics/Rect.ts"/>
///<reference path="../../../android/view/View.ts"/>
var android;
(function (android) {
    var text;
    (function (text) {
        var method;
        (function (method) {
            var TransformationMethod;
            (function (TransformationMethod) {
                function isImpl(obj) {
                    return obj['getTransformation'] && obj['onFocusChanged'];
                }
                TransformationMethod.isImpl = isImpl;
            })(TransformationMethod = method.TransformationMethod || (method.TransformationMethod = {}));
        })(method = text.method || (text.method = {}));
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/text/method/TransformationMethod.ts"/>
var android;
(function (android) {
    var text;
    (function (text) {
        var method;
        (function (method) {
            var TransformationMethod = android.text.method.TransformationMethod;
            var TransformationMethod2;
            (function (TransformationMethod2) {
                function isImpl(obj) {
                    return TransformationMethod.isImpl(obj) && obj['setLengthChangesAllowed'];
                }
                TransformationMethod2.isImpl = isImpl;
            })(TransformationMethod2 = method.TransformationMethod2 || (method.TransformationMethod2 = {}));
        })(method = text.method || (text.method = {}));
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/graphics/Rect.ts"/>
///<reference path="../../../android/util/Log.ts"/>
///<reference path="../../../android/view/View.ts"/>
///<reference path="../../../android/text/method/TransformationMethod.ts"/>
///<reference path="../../../android/text/method/TransformationMethod2.ts"/>
var android;
(function (android) {
    var text;
    (function (text) {
        var method;
        (function (method) {
            var Log = android.util.Log;
            class AllCapsTransformationMethod {
                constructor(context) {
                }
                getTransformation(source, view) {
                    if (this.mEnabled) {
                        return source != null ? source.toLocaleUpperCase() : null;
                    }
                    Log.w(AllCapsTransformationMethod.TAG, "Caller did not enable length changes; not transforming text");
                    return source;
                }
                onFocusChanged(view, sourceText, focused, direction, previouslyFocusedRect) {
                }
                setLengthChangesAllowed(allowLengthChanges) {
                    this.mEnabled = allowLengthChanges;
                }
            }
            AllCapsTransformationMethod.TAG = "AllCapsTransformationMethod";
            method.AllCapsTransformationMethod = AllCapsTransformationMethod;
        })(method = text.method || (text.method = {}));
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/widget/TextView.ts"/>
///<reference path="../../../android/view/KeyEvent.ts"/>
///<reference path="../../../android/view/MotionEvent.ts"/>
///<reference path="../../../android/text/Spannable.ts"/>
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/graphics/Rect.ts"/>
///<reference path="../../../android/text/Spannable.ts"/>
///<reference path="../../../android/text/Spanned.ts"/>
///<reference path="../../../android/text/TextUtils.ts"/>
///<reference path="../../../android/view/View.ts"/>
///<reference path="../../../android/text/method/TransformationMethod.ts"/>
var android;
(function (android) {
    var text;
    (function (text) {
        var method;
        (function (method) {
            class ReplacementTransformationMethod {
                getTransformation(source, v) {
                    let original = this.getOriginal();
                    let replacement = this.getReplacement();
                    let doNothing = true;
                    let n = original.length;
                    for (let i = 0; i < n; i++) {
                        if (source.indexOf(original[i]) >= 0) {
                            doNothing = false;
                            break;
                        }
                    }
                    if (doNothing) {
                        return source;
                    }
                    return new ReplacementTransformationMethod.ReplacementCharSequence(source, original, replacement).toString();
                    return new ReplacementTransformationMethod.ReplacementCharSequence(source, original, replacement);
                }
                onFocusChanged(view, sourceText, focused, direction, previouslyFocusedRect) {
                }
            }
            method.ReplacementTransformationMethod = ReplacementTransformationMethod;
            (function (ReplacementTransformationMethod) {
                class ReplacementCharSequence extends String {
                    constructor(source, original, replacement) {
                        super(source);
                        this.mSource = source;
                        this.mOriginal = original;
                        this.mReplacement = replacement;
                    }
                    charAt(i) {
                        let c = this.mSource.charAt(i);
                        let n = this.mOriginal.length;
                        for (let j = 0; j < n; j++) {
                            if (c == this.mOriginal[j]) {
                                c = this.mReplacement[j];
                            }
                        }
                        return c;
                    }
                    toString() {
                        return this.startReplace(0, this.length);
                    }
                    substr(from, length) {
                        return this.startReplace(from, from + length);
                    }
                    substring(start, end) {
                        return this.startReplace(start, end);
                    }
                    startReplace(start, end) {
                        let dest = this.mSource.substring(start, end).split('');
                        let offend = end - start;
                        let n = this.mOriginal.length;
                        for (let i = 0; i < offend; i++) {
                            let c = dest[i];
                            for (let j = 0; j < n; j++) {
                                if (c == this.mOriginal[j]) {
                                    dest[i] = this.mReplacement[j];
                                }
                            }
                        }
                        return dest.join('');
                    }
                }
                ReplacementTransformationMethod.ReplacementCharSequence = ReplacementCharSequence;
            })(ReplacementTransformationMethod = method.ReplacementTransformationMethod || (method.ReplacementTransformationMethod = {}));
        })(method = text.method || (text.method = {}));
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../android/graphics/Rect.ts"/>
///<reference path="../../../android/text/Spannable.ts"/>
///<reference path="../../../android/text/Spanned.ts"/>
///<reference path="../../../android/text/TextUtils.ts"/>
///<reference path="../../../android/view/View.ts"/>
///<reference path="../../../android/text/method/ReplacementTransformationMethod.ts"/>
///<reference path="../../../android/text/method/TransformationMethod.ts"/>
var android;
(function (android) {
    var text;
    (function (text) {
        var method;
        (function (method) {
            var ReplacementTransformationMethod = android.text.method.ReplacementTransformationMethod;
            class SingleLineTransformationMethod extends ReplacementTransformationMethod {
                getOriginal() {
                    return SingleLineTransformationMethod.ORIGINAL;
                }
                getReplacement() {
                    return SingleLineTransformationMethod.REPLACEMENT;
                }
                static getInstance() {
                    if (SingleLineTransformationMethod.sInstance != null)
                        return SingleLineTransformationMethod.sInstance;
                    SingleLineTransformationMethod.sInstance = new SingleLineTransformationMethod();
                    return SingleLineTransformationMethod.sInstance;
                }
            }
            SingleLineTransformationMethod.ORIGINAL = ['\n', '\r'];
            SingleLineTransformationMethod.REPLACEMENT = [' ', '﻿'];
            method.SingleLineTransformationMethod = SingleLineTransformationMethod;
        })(method = text.method || (text.method = {}));
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/view/View.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        class HapticFeedbackConstants {
        }
        HapticFeedbackConstants.LONG_PRESS = 0;
        HapticFeedbackConstants.VIRTUAL_KEY = 1;
        HapticFeedbackConstants.KEYBOARD_TAP = 3;
        HapticFeedbackConstants.SAFE_MODE_DISABLED = 10000;
        HapticFeedbackConstants.SAFE_MODE_ENABLED = 10001;
        HapticFeedbackConstants.FLAG_IGNORE_VIEW_SETTING = 0x0001;
        HapticFeedbackConstants.FLAG_IGNORE_GLOBAL_SETTING = 0x0002;
        view.HapticFeedbackConstants = HapticFeedbackConstants;
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/R/attr.ts"/>
///<reference path="../../android/R/color.ts"/>
///<reference path="../../android/R/drawable.ts"/>
///<reference path="../../android/R/string.ts"/>
///<reference path="../../android/content/res/ColorStateList.ts"/>
///<reference path="../../android/content/res/Resources.ts"/>
///<reference path="../../android/graphics/Canvas.ts"/>
///<reference path="../../android/graphics/Paint.ts"/>
///<reference path="../../android/graphics/Path.ts"/>
///<reference path="../../android/graphics/Rect.ts"/>
///<reference path="../../android/graphics/RectF.ts"/>
///<reference path="../../android/graphics/drawable/Drawable.ts"/>
///<reference path="../../android/os/Handler.ts"/>
///<reference path="../../android/os/Message.ts"/>
///<reference path="../../android/os/SystemClock.ts"/>
///<reference path="../../android/text/BoringLayout.ts"/>
///<reference path="../../android/text/DynamicLayout.ts"/>
///<reference path="../../android/text/InputType.ts"/>
///<reference path="../../android/text/Layout.ts"/>
///<reference path="../../android/text/SpanWatcher.ts"/>
///<reference path="../../android/text/Spannable.ts"/>
///<reference path="../../android/text/Spanned.ts"/>
///<reference path="../../android/text/StaticLayout.ts"/>
///<reference path="../../android/text/TextDirectionHeuristic.ts"/>
///<reference path="../../android/text/TextDirectionHeuristics.ts"/>
///<reference path="../../android/text/TextPaint.ts"/>
///<reference path="../../android/text/TextUtils.ts"/>
///<reference path="../../android/text/TextWatcher.ts"/>
///<reference path="../../android/text/method/AllCapsTransformationMethod.ts"/>
///<reference path="../../android/text/method/MovementMethod.ts"/>
///<reference path="../../android/text/method/SingleLineTransformationMethod.ts"/>
///<reference path="../../android/text/method/TransformationMethod.ts"/>
///<reference path="../../android/text/method/TransformationMethod2.ts"/>
///<reference path="../../android/text/style/CharacterStyle.ts"/>
///<reference path="../../android/text/style/ParagraphStyle.ts"/>
///<reference path="../../android/text/style/UpdateAppearance.ts"/>
///<reference path="../../android/util/Log.ts"/>
///<reference path="../../android/util/TypedValue.ts"/>
///<reference path="../../android/view/Gravity.ts"/>
///<reference path="../../android/view/HapticFeedbackConstants.ts"/>
///<reference path="../../android/view/KeyEvent.ts"/>
///<reference path="../../android/view/MotionEvent.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewConfiguration.ts"/>
///<reference path="../../android/view/ViewRootImpl.ts"/>
///<reference path="../../android/view/ViewTreeObserver.ts"/>
///<reference path="../../android/view/animation/AnimationUtils.ts"/>
///<reference path="../../java/lang/ref/WeakReference.ts"/>
///<reference path="../../java/util/ArrayList.ts"/>
///<reference path="../../java/lang/Integer.ts"/>
///<reference path="../../java/lang/System.ts"/>
///<reference path="../../java/lang/Runnable.ts"/>
///<reference path="../../android/widget/OverScroller.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var ColorStateList = android.content.res.ColorStateList;
        var Paint = android.graphics.Paint;
        var Path = android.graphics.Path;
        var Rect = android.graphics.Rect;
        var RectF = android.graphics.RectF;
        var Handler = android.os.Handler;
        var BoringLayout = android.text.BoringLayout;
        var DynamicLayout = android.text.DynamicLayout;
        var Layout = android.text.Layout;
        var Spannable = android.text.Spannable;
        var Spanned = android.text.Spanned;
        var StaticLayout = android.text.StaticLayout;
        var TextDirectionHeuristics = android.text.TextDirectionHeuristics;
        var TextPaint = android.text.TextPaint;
        var TextUtils = android.text.TextUtils;
        var TruncateAt = android.text.TextUtils.TruncateAt;
        var AllCapsTransformationMethod = android.text.method.AllCapsTransformationMethod;
        var SingleLineTransformationMethod = android.text.method.SingleLineTransformationMethod;
        var TransformationMethod2 = android.text.method.TransformationMethod2;
        var Log = android.util.Log;
        var TypedValue = android.util.TypedValue;
        var Gravity = android.view.Gravity;
        var HapticFeedbackConstants = android.view.HapticFeedbackConstants;
        var MotionEvent = android.view.MotionEvent;
        var View = android.view.View;
        var LayoutParams = android.view.ViewGroup.LayoutParams;
        var AnimationUtils = android.view.animation.AnimationUtils;
        var WeakReference = java.lang.ref.WeakReference;
        var ArrayList = java.util.ArrayList;
        var Integer = java.lang.Integer;
        var System = java.lang.System;
        class TextView extends View {
            constructor(bindElement, rootElement) {
                super(bindElement, rootElement);
                this.mCurTextColor = 0;
                this.mCurHintTextColor = 0;
                this.mSpannableFactory = Spannable.Factory.getInstance();
                this.mShadowRadius = 0;
                this.mShadowDx = 0;
                this.mShadowDy = 0;
                this.mMarqueeRepeatLimit = 3;
                this.mLastLayoutDirection = -1;
                this.mMarqueeFadeMode = TextView.MARQUEE_FADE_NORMAL;
                this.mBufferType = TextView.BufferType.NORMAL;
                this.mGravity = Gravity.TOP | Gravity.LEFT;
                this.mAutoLinkMask = 0;
                this.mLinksClickable = true;
                this.mSpacingMult = 1.0;
                this.mSpacingAdd = 0.0;
                this.mMaximum = Integer.MAX_VALUE;
                this.mMaxMode = TextView.LINES;
                this.mMinimum = 0;
                this.mMinMode = TextView.LINES;
                this.mOldMaximum = this.mMaximum;
                this.mOldMaxMode = this.mMaxMode;
                this.mMaxWidthValue = Integer.MAX_VALUE;
                this.mMaxWidthMode = TextView.PIXELS;
                this.mMinWidthValue = 0;
                this.mMinWidthMode = TextView.PIXELS;
                this.mDesiredHeightAtMeasure = -1;
                this.mIncludePad = true;
                this.mDeferScroll = -1;
                this.mLastScroll = 0;
                this.mFilters = TextView.NO_FILTERS;
                this.mHighlightColor = 0x6633B5E5;
                this.mHighlightPathBogus = true;
                this.mCursorDrawableRes = 0;
                this.mTextSelectHandleLeftRes = 0;
                this.mTextSelectHandleRightRes = 0;
                this.mTextSelectHandleRes = 0;
                this.mTextEditSuggestionItemLayout = 0;
                this.mText = "";
                const res = this.getResources();
                this.mTextPaint = new TextPaint(Paint.ANTI_ALIAS_FLAG);
                this.mHighlightPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
                this.mMovement = this.getDefaultMovementMethod();
                this.mTransformation = null;
                this._attrBinder.addAttr('textColorHighlight', (value) => {
                    this.setHighlightColor(this._attrBinder.parseColor(value, this.mHighlightColor));
                });
                this._attrBinder.addAttr('textColor', (value) => {
                    let color = this._attrBinder.parseColorList(value);
                    if (color)
                        this.setTextColor(color);
                }, () => {
                    return this.mTextColor;
                });
                this._attrBinder.addAttr('textColorHint', (value) => {
                    let color = this._attrBinder.parseColorList(value);
                    if (color)
                        this.setHintTextColor(color);
                }, () => {
                    return this.mHintTextColor;
                });
                this._attrBinder.addAttr('textSize', (value) => {
                    let size = this._attrBinder.parseNumber(value, this.mTextPaint.getTextSize());
                    this.setTextSize(TypedValue.COMPLEX_UNIT_PX, size);
                }, () => {
                    return this.mTextPaint.getTextSize();
                });
                this._attrBinder.addAttr('textAllCaps', (value) => {
                    this.setAllCaps(this._attrBinder.parseBoolean(value, true));
                });
                this._attrBinder.addAttr('shadowColor', (value) => {
                    this.setShadowLayer(this.mShadowRadius, this.mShadowDx, this.mShadowDy, this._attrBinder.parseColor(value, this.mTextPaint.shadowColor));
                });
                this._attrBinder.addAttr('shadowDx', (value) => {
                    let dx = this._attrBinder.parseNumber(value, this.mShadowDx);
                    this.setShadowLayer(this.mShadowRadius, dx, this.mShadowDy, this.mTextPaint.shadowColor);
                });
                this._attrBinder.addAttr('shadowDy', (value) => {
                    let dy = this._attrBinder.parseNumber(value, this.mShadowDy);
                    this.setShadowLayer(this.mShadowRadius, this.mShadowDx, dy, this.mTextPaint.shadowColor);
                });
                this._attrBinder.addAttr('shadowRadius', (value) => {
                    let radius = this._attrBinder.parseNumber(value, this.mShadowRadius);
                    this.setShadowLayer(radius, this.mShadowDx, this.mShadowDy, this.mTextPaint.shadowColor);
                });
                this._attrBinder.addAttr('drawableLeft', (value) => {
                    let drawable = this._attrBinder.parseDrawable(value);
                    this.setCompoundDrawablesWithIntrinsicBounds(drawable, this.mDrawables.mDrawableTop, this.mDrawables.mDrawableRight, this.mDrawables.mDrawableBottom);
                });
                this._attrBinder.addAttr('drawableTop', (value) => {
                    let drawable = this._attrBinder.parseDrawable(value);
                    this.setCompoundDrawablesWithIntrinsicBounds(this.mDrawables.mDrawableLeft, drawable, this.mDrawables.mDrawableRight, this.mDrawables.mDrawableBottom);
                });
                this._attrBinder.addAttr('drawableRight', (value) => {
                    let drawable = this._attrBinder.parseDrawable(value);
                    this.setCompoundDrawablesWithIntrinsicBounds(this.mDrawables.mDrawableLeft, this.mDrawables.mDrawableTop, drawable, this.mDrawables.mDrawableBottom);
                });
                this._attrBinder.addAttr('drawableBottom', (value) => {
                    let drawable = this._attrBinder.parseDrawable(value);
                    this.setCompoundDrawablesWithIntrinsicBounds(this.mDrawables.mDrawableLeft, this.mDrawables.mDrawableTop, this.mDrawables.mDrawableRight, drawable);
                });
                this._attrBinder.addAttr('drawablePadding', (value) => {
                    let drawablePadding = this._attrBinder.parseNumber(value, this.mDrawables.mDrawablePadding);
                    if (drawablePadding !== this.mDrawables.mDrawablePadding) {
                        this.setCompoundDrawablePadding(drawablePadding);
                    }
                });
                this._attrBinder.addAttr('maxLines', (value) => {
                    value = Number.parseInt(value);
                    if (Number.isInteger(value))
                        this.setMaxLines(value);
                }, () => {
                    return this.getMaxLines();
                });
                this._attrBinder.addAttr('maxHeight', (value) => {
                    this.setMaxHeight(this._attrBinder.parseNumber(value, this.getMaxHeight()));
                }, () => {
                    return this.getMaxHeight();
                });
                this._attrBinder.addAttr('lines', (value) => {
                    value = Number.parseInt(value);
                    if (Number.isInteger(value))
                        this.setLines(value);
                }, () => {
                    if (this.getMaxLines() === this.getMinLines())
                        return this.getMaxLines();
                    return null;
                });
                this._attrBinder.addAttr('height', (value) => {
                    value = this._attrBinder.parseNumber(value, -1);
                    if (value >= 0)
                        this.setHeight(value);
                }, () => {
                    if (this.getMaxHeight() === this.getMinimumHeight())
                        return this.getMaxHeight();
                    return null;
                });
                this._attrBinder.addAttr('minLines', (value) => {
                    this.setMinLines(this._attrBinder.parseNumber(value, this.getMinLines()));
                }, () => {
                    return this.getMinLines();
                });
                this._attrBinder.addAttr('minHeight', (value) => {
                    this.setMinHeight(this._attrBinder.parseNumber(value, this.getMinHeight()));
                }, () => {
                    return this.getMinHeight();
                });
                this._attrBinder.addAttr('maxEms', (value) => {
                    this.setMaxEms(this._attrBinder.parseNumber(value, this.getMaxEms()));
                }, () => {
                    return this.getMaxEms();
                });
                this._attrBinder.addAttr('maxWidth', (value) => {
                    this.setMaxWidth(this._attrBinder.parseNumber(value, this.getMaxWidth()));
                }, () => {
                    return this.getMaxWidth();
                });
                this._attrBinder.addAttr('ems', (value) => {
                    let ems = this._attrBinder.parseNumber(value, null);
                    if (ems != null)
                        this.setEms(ems);
                }, () => {
                    if (this.getMinEms() === this.getMaxEms())
                        return this.getMaxEms();
                    return null;
                });
                this._attrBinder.addAttr('width', (value) => {
                    value = this._attrBinder.parseNumber(value, -1);
                    if (value >= 0)
                        this.setWidth(value);
                }, () => {
                    if (this.getMinWidth() === this.getMaxWidth())
                        return this.getMinWidth();
                    return null;
                });
                this._attrBinder.addAttr('minEms', (value) => {
                    this.setMinEms(this._attrBinder.parseNumber(value, this.getMinEms()));
                }, () => {
                    return this.getMinEms();
                });
                this._attrBinder.addAttr('minWidth', (value) => {
                    this.setMinWidth(this._attrBinder.parseNumber(value, this.getMinWidth()));
                }, () => {
                    return this.getMinWidth();
                });
                this._attrBinder.addAttr('gravity', (value) => {
                    this.setGravity(this._attrBinder.parseGravity(value, this.mGravity));
                }, () => {
                    return this.mGravity;
                });
                this._attrBinder.addAttr('hint', (value) => {
                    this.setHint(value);
                }, () => {
                    return this.getHint();
                });
                this._attrBinder.addAttr('text', (value) => {
                    this.setText(value);
                }, () => {
                    return this.getText();
                });
                this._attrBinder.addAttr('scrollHorizontally', (value) => {
                    this.setHorizontallyScrolling(this._attrBinder.parseBoolean(value, false));
                });
                this._attrBinder.addAttr('singleLine', (value) => {
                    this.setSingleLine(this._attrBinder.parseBoolean(value, false));
                });
                this._attrBinder.addAttr('ellipsize', (value) => {
                    let ellipsize = TextUtils.TruncateAt[(value + '').toUpperCase()];
                    if (ellipsize)
                        this.setEllipsize(ellipsize);
                });
                this._attrBinder.addAttr('marqueeRepeatLimit', (value) => {
                    let marqueeRepeatLimit = this._attrBinder.parseNumber(value, -1);
                    if (marqueeRepeatLimit >= 0)
                        this.setMarqueeRepeatLimit(marqueeRepeatLimit);
                });
                this._attrBinder.addAttr('includeFontPadding', (value) => {
                    this.setIncludeFontPadding(this._attrBinder.parseBoolean(value, false));
                });
                this._attrBinder.addAttr('enabled', (value) => {
                    this.setEnabled(this._attrBinder.parseBoolean(value, this.isEnabled()));
                });
                this._attrBinder.addAttr('lineSpacingExtra', (value) => {
                    this.setLineSpacing(this._attrBinder.parseNumber(value, this.mSpacingAdd), this.mSpacingMult);
                }, () => {
                    return this.mSpacingAdd;
                });
                this._attrBinder.addAttr('lineSpacingMultiplier', (value) => {
                    this.setLineSpacing(this.mSpacingAdd, this._attrBinder.parseNumber(value, this.mSpacingMult));
                }, () => {
                    return this.mSpacingMult;
                });
                this.applyDefaultAttributes(android.R.attr.textViewStyle);
                this.bindElement.innerHTML = this.bindElement.innerHTML.trim();
                let text = this.mText || this.bindElement.innerText;
                this.bindElement.innerHTML = '';
                this.setText(text, this.mBufferType);
            }
            setTypefaceFromAttrs(familyName, typefaceIndex, styleIndex) {
            }
            setRelativeDrawablesIfNeeded(start, end) {
                let hasRelativeDrawables = (start != null) || (end != null);
                if (hasRelativeDrawables) {
                    let dr = this.mDrawables;
                    if (dr == null) {
                        this.mDrawables = dr = new TextView.Drawables();
                    }
                    this.mDrawables.mOverride = true;
                    const compoundRect = dr.mCompoundRect;
                    let state = this.getDrawableState();
                    if (start != null) {
                        start.setBounds(0, 0, start.getIntrinsicWidth(), start.getIntrinsicHeight());
                        start.setState(state);
                        start.copyBounds(compoundRect);
                        start.setCallback(this);
                        dr.mDrawableStart = start;
                        dr.mDrawableSizeStart = compoundRect.width();
                        dr.mDrawableHeightStart = compoundRect.height();
                    }
                    else {
                        dr.mDrawableSizeStart = dr.mDrawableHeightStart = 0;
                    }
                    if (end != null) {
                        end.setBounds(0, 0, end.getIntrinsicWidth(), end.getIntrinsicHeight());
                        end.setState(state);
                        end.copyBounds(compoundRect);
                        end.setCallback(this);
                        dr.mDrawableEnd = end;
                        dr.mDrawableSizeEnd = compoundRect.width();
                        dr.mDrawableHeightEnd = compoundRect.height();
                    }
                    else {
                        dr.mDrawableSizeEnd = dr.mDrawableHeightEnd = 0;
                    }
                    this.resetResolvedDrawables();
                    this.resolveDrawables();
                }
            }
            setEnabled(enabled) {
                if (enabled == this.isEnabled()) {
                    return;
                }
                super.setEnabled(enabled);
            }
            setTypeface(tf, style) {
            }
            getDefaultEditable() {
                return false;
            }
            getDefaultMovementMethod() {
                return null;
            }
            getText() {
                return this.mText;
            }
            length() {
                return this.mText.length;
            }
            getEditableText() {
                return null;
            }
            getLineHeight() {
                return Math.round(this.mTextPaint.getFontMetricsInt(null) * this.mSpacingMult + this.mSpacingAdd);
            }
            getLayout() {
                return this.mLayout;
            }
            getHintLayout() {
                return this.mHintLayout;
            }
            getUndoManager() {
                return null;
            }
            setUndoManager(undoManager, tag) {
            }
            getKeyListener() {
                return null;
            }
            setKeyListener(input) {
            }
            setKeyListenerOnly(input) {
            }
            getMovementMethod() {
                return this.mMovement;
            }
            setMovementMethod(movement) {
                if (this.mMovement != movement) {
                    this.mMovement = movement;
                    if (movement != null && !Spannable.isImpl(this.mText)) {
                        this.setText(this.mText);
                    }
                    this.fixFocusableAndClickableSettings();
                }
            }
            fixFocusableAndClickableSettings() {
                if (this.mMovement != null) {
                    this.setFocusable(true);
                    this.setClickable(true);
                    this.setLongClickable(true);
                }
                else {
                    this.setFocusable(false);
                    this.setClickable(false);
                    this.setLongClickable(false);
                }
            }
            getTransformationMethod() {
                return this.mTransformation;
            }
            setTransformationMethod(method) {
                if (method == this.mTransformation) {
                    return;
                }
                if (this.mTransformation != null) {
                    if (Spannable.isImpl(this.mText)) {
                        this.mText.removeSpan(this.mTransformation);
                    }
                }
                this.mTransformation = method;
                if (TransformationMethod2.isImpl(method)) {
                    let method2 = method;
                    this.mAllowTransformationLengthChange = !this.isTextSelectable();
                    method2.setLengthChangesAllowed(this.mAllowTransformationLengthChange);
                }
                else {
                    this.mAllowTransformationLengthChange = false;
                }
                this.setText(this.mText);
            }
            getCompoundPaddingTop() {
                const dr = this.mDrawables;
                if (dr == null || dr.mDrawableTop == null) {
                    return this.mPaddingTop;
                }
                else {
                    return this.mPaddingTop + dr.mDrawablePadding + dr.mDrawableSizeTop;
                }
            }
            getCompoundPaddingBottom() {
                const dr = this.mDrawables;
                if (dr == null || dr.mDrawableBottom == null) {
                    return this.mPaddingBottom;
                }
                else {
                    return this.mPaddingBottom + dr.mDrawablePadding + dr.mDrawableSizeBottom;
                }
            }
            getCompoundPaddingLeft() {
                const dr = this.mDrawables;
                if (dr == null || dr.mDrawableLeft == null) {
                    return this.mPaddingLeft;
                }
                else {
                    return this.mPaddingLeft + dr.mDrawablePadding + dr.mDrawableSizeLeft;
                }
            }
            getCompoundPaddingRight() {
                const dr = this.mDrawables;
                if (dr == null || dr.mDrawableRight == null) {
                    return this.mPaddingRight;
                }
                else {
                    return this.mPaddingRight + dr.mDrawablePadding + dr.mDrawableSizeRight;
                }
            }
            getCompoundPaddingStart() {
                this.resolveDrawables();
                return this.getCompoundPaddingLeft();
            }
            getCompoundPaddingEnd() {
                this.resolveDrawables();
                return this.getCompoundPaddingRight();
            }
            getExtendedPaddingTop() {
                if (this.mMaxMode != TextView.LINES) {
                    return this.getCompoundPaddingTop();
                }
                if (this.mLayout.getLineCount() <= this.mMaximum) {
                    return this.getCompoundPaddingTop();
                }
                let top = this.getCompoundPaddingTop();
                let bottom = this.getCompoundPaddingBottom();
                let viewht = this.getHeight() - top - bottom;
                let layoutht = this.mLayout.getLineTop(this.mMaximum);
                if (layoutht >= viewht) {
                    return top;
                }
                const gravity = this.mGravity & Gravity.VERTICAL_GRAVITY_MASK;
                if (gravity == Gravity.TOP) {
                    return top;
                }
                else if (gravity == Gravity.BOTTOM) {
                    return top + viewht - layoutht;
                }
                else {
                    return top + (viewht - layoutht) / 2;
                }
            }
            getExtendedPaddingBottom() {
                if (this.mMaxMode != TextView.LINES) {
                    return this.getCompoundPaddingBottom();
                }
                if (this.mLayout.getLineCount() <= this.mMaximum) {
                    return this.getCompoundPaddingBottom();
                }
                let top = this.getCompoundPaddingTop();
                let bottom = this.getCompoundPaddingBottom();
                let viewht = this.getHeight() - top - bottom;
                let layoutht = this.mLayout.getLineTop(this.mMaximum);
                if (layoutht >= viewht) {
                    return bottom;
                }
                const gravity = this.mGravity & Gravity.VERTICAL_GRAVITY_MASK;
                if (gravity == Gravity.TOP) {
                    return bottom + viewht - layoutht;
                }
                else if (gravity == Gravity.BOTTOM) {
                    return bottom;
                }
                else {
                    return bottom + (viewht - layoutht) / 2;
                }
            }
            getTotalPaddingLeft() {
                return this.getCompoundPaddingLeft();
            }
            getTotalPaddingRight() {
                return this.getCompoundPaddingRight();
            }
            getTotalPaddingStart() {
                return this.getCompoundPaddingStart();
            }
            getTotalPaddingEnd() {
                return this.getCompoundPaddingEnd();
            }
            getTotalPaddingTop() {
                return this.getExtendedPaddingTop() + this.getVerticalOffset(true);
            }
            getTotalPaddingBottom() {
                return this.getExtendedPaddingBottom() + this.getBottomVerticalOffset(true);
            }
            setCompoundDrawables(left, top, right, bottom) {
                let dr = this.mDrawables;
                const drawables = left != null || top != null || right != null || bottom != null;
                if (!drawables) {
                    if (dr != null) {
                        if (dr.mDrawablePadding == 0) {
                            this.mDrawables = null;
                        }
                        else {
                            if (dr.mDrawableLeft != null)
                                dr.mDrawableLeft.setCallback(null);
                            dr.mDrawableLeft = null;
                            if (dr.mDrawableTop != null)
                                dr.mDrawableTop.setCallback(null);
                            dr.mDrawableTop = null;
                            if (dr.mDrawableRight != null)
                                dr.mDrawableRight.setCallback(null);
                            dr.mDrawableRight = null;
                            if (dr.mDrawableBottom != null)
                                dr.mDrawableBottom.setCallback(null);
                            dr.mDrawableBottom = null;
                            dr.mDrawableSizeLeft = dr.mDrawableHeightLeft = 0;
                            dr.mDrawableSizeRight = dr.mDrawableHeightRight = 0;
                            dr.mDrawableSizeTop = dr.mDrawableWidthTop = 0;
                            dr.mDrawableSizeBottom = dr.mDrawableWidthBottom = 0;
                        }
                    }
                }
                else {
                    if (dr == null) {
                        this.mDrawables = dr = new TextView.Drawables();
                    }
                    this.mDrawables.mOverride = false;
                    if (dr.mDrawableLeft != left && dr.mDrawableLeft != null) {
                        dr.mDrawableLeft.setCallback(null);
                    }
                    dr.mDrawableLeft = left;
                    if (dr.mDrawableTop != top && dr.mDrawableTop != null) {
                        dr.mDrawableTop.setCallback(null);
                    }
                    dr.mDrawableTop = top;
                    if (dr.mDrawableRight != right && dr.mDrawableRight != null) {
                        dr.mDrawableRight.setCallback(null);
                    }
                    dr.mDrawableRight = right;
                    if (dr.mDrawableBottom != bottom && dr.mDrawableBottom != null) {
                        dr.mDrawableBottom.setCallback(null);
                    }
                    dr.mDrawableBottom = bottom;
                    const compoundRect = dr.mCompoundRect;
                    let state;
                    state = this.getDrawableState();
                    if (left != null) {
                        left.setState(state);
                        left.copyBounds(compoundRect);
                        left.setCallback(this);
                        dr.mDrawableSizeLeft = compoundRect.width();
                        dr.mDrawableHeightLeft = compoundRect.height();
                    }
                    else {
                        dr.mDrawableSizeLeft = dr.mDrawableHeightLeft = 0;
                    }
                    if (right != null) {
                        right.setState(state);
                        right.copyBounds(compoundRect);
                        right.setCallback(this);
                        dr.mDrawableSizeRight = compoundRect.width();
                        dr.mDrawableHeightRight = compoundRect.height();
                    }
                    else {
                        dr.mDrawableSizeRight = dr.mDrawableHeightRight = 0;
                    }
                    if (top != null) {
                        top.setState(state);
                        top.copyBounds(compoundRect);
                        top.setCallback(this);
                        dr.mDrawableSizeTop = compoundRect.height();
                        dr.mDrawableWidthTop = compoundRect.width();
                    }
                    else {
                        dr.mDrawableSizeTop = dr.mDrawableWidthTop = 0;
                    }
                    if (bottom != null) {
                        bottom.setState(state);
                        bottom.copyBounds(compoundRect);
                        bottom.setCallback(this);
                        dr.mDrawableSizeBottom = compoundRect.height();
                        dr.mDrawableWidthBottom = compoundRect.width();
                    }
                    else {
                        dr.mDrawableSizeBottom = dr.mDrawableWidthBottom = 0;
                    }
                }
                if (dr != null) {
                    dr.mDrawableLeftInitial = left;
                    dr.mDrawableRightInitial = right;
                }
                this.resetResolvedDrawables();
                this.resolveDrawables();
                this.invalidate();
                this.requestLayout();
            }
            setCompoundDrawablesWithIntrinsicBounds(left, top, right, bottom) {
                if (left != null) {
                    left.setBounds(0, 0, left.getIntrinsicWidth(), left.getIntrinsicHeight());
                }
                if (right != null) {
                    right.setBounds(0, 0, right.getIntrinsicWidth(), right.getIntrinsicHeight());
                }
                if (top != null) {
                    top.setBounds(0, 0, top.getIntrinsicWidth(), top.getIntrinsicHeight());
                }
                if (bottom != null) {
                    bottom.setBounds(0, 0, bottom.getIntrinsicWidth(), bottom.getIntrinsicHeight());
                }
                this.setCompoundDrawables(left, top, right, bottom);
            }
            setCompoundDrawablesRelative(start, top, end, bottom) {
                let dr = this.mDrawables;
                const drawables = start != null || top != null || end != null || bottom != null;
                if (!drawables) {
                    if (dr != null) {
                        if (dr.mDrawablePadding == 0) {
                            this.mDrawables = null;
                        }
                        else {
                            if (dr.mDrawableStart != null)
                                dr.mDrawableStart.setCallback(null);
                            dr.mDrawableStart = null;
                            if (dr.mDrawableTop != null)
                                dr.mDrawableTop.setCallback(null);
                            dr.mDrawableTop = null;
                            if (dr.mDrawableEnd != null)
                                dr.mDrawableEnd.setCallback(null);
                            dr.mDrawableEnd = null;
                            if (dr.mDrawableBottom != null)
                                dr.mDrawableBottom.setCallback(null);
                            dr.mDrawableBottom = null;
                            dr.mDrawableSizeStart = dr.mDrawableHeightStart = 0;
                            dr.mDrawableSizeEnd = dr.mDrawableHeightEnd = 0;
                            dr.mDrawableSizeTop = dr.mDrawableWidthTop = 0;
                            dr.mDrawableSizeBottom = dr.mDrawableWidthBottom = 0;
                        }
                    }
                }
                else {
                    if (dr == null) {
                        this.mDrawables = dr = new TextView.Drawables();
                    }
                    this.mDrawables.mOverride = true;
                    if (dr.mDrawableStart != start && dr.mDrawableStart != null) {
                        dr.mDrawableStart.setCallback(null);
                    }
                    dr.mDrawableStart = start;
                    if (dr.mDrawableTop != top && dr.mDrawableTop != null) {
                        dr.mDrawableTop.setCallback(null);
                    }
                    dr.mDrawableTop = top;
                    if (dr.mDrawableEnd != end && dr.mDrawableEnd != null) {
                        dr.mDrawableEnd.setCallback(null);
                    }
                    dr.mDrawableEnd = end;
                    if (dr.mDrawableBottom != bottom && dr.mDrawableBottom != null) {
                        dr.mDrawableBottom.setCallback(null);
                    }
                    dr.mDrawableBottom = bottom;
                    const compoundRect = dr.mCompoundRect;
                    let state;
                    state = this.getDrawableState();
                    if (start != null) {
                        start.setState(state);
                        start.copyBounds(compoundRect);
                        start.setCallback(this);
                        dr.mDrawableSizeStart = compoundRect.width();
                        dr.mDrawableHeightStart = compoundRect.height();
                    }
                    else {
                        dr.mDrawableSizeStart = dr.mDrawableHeightStart = 0;
                    }
                    if (end != null) {
                        end.setState(state);
                        end.copyBounds(compoundRect);
                        end.setCallback(this);
                        dr.mDrawableSizeEnd = compoundRect.width();
                        dr.mDrawableHeightEnd = compoundRect.height();
                    }
                    else {
                        dr.mDrawableSizeEnd = dr.mDrawableHeightEnd = 0;
                    }
                    if (top != null) {
                        top.setState(state);
                        top.copyBounds(compoundRect);
                        top.setCallback(this);
                        dr.mDrawableSizeTop = compoundRect.height();
                        dr.mDrawableWidthTop = compoundRect.width();
                    }
                    else {
                        dr.mDrawableSizeTop = dr.mDrawableWidthTop = 0;
                    }
                    if (bottom != null) {
                        bottom.setState(state);
                        bottom.copyBounds(compoundRect);
                        bottom.setCallback(this);
                        dr.mDrawableSizeBottom = compoundRect.height();
                        dr.mDrawableWidthBottom = compoundRect.width();
                    }
                    else {
                        dr.mDrawableSizeBottom = dr.mDrawableWidthBottom = 0;
                    }
                }
                this.resetResolvedDrawables();
                this.resolveDrawables();
                this.invalidate();
                this.requestLayout();
            }
            setCompoundDrawablesRelativeWithIntrinsicBounds(start, top, end, bottom) {
                if (start != null) {
                    start.setBounds(0, 0, start.getIntrinsicWidth(), start.getIntrinsicHeight());
                }
                if (end != null) {
                    end.setBounds(0, 0, end.getIntrinsicWidth(), end.getIntrinsicHeight());
                }
                if (top != null) {
                    top.setBounds(0, 0, top.getIntrinsicWidth(), top.getIntrinsicHeight());
                }
                if (bottom != null) {
                    bottom.setBounds(0, 0, bottom.getIntrinsicWidth(), bottom.getIntrinsicHeight());
                }
                this.setCompoundDrawablesRelative(start, top, end, bottom);
            }
            getCompoundDrawables() {
                const dr = this.mDrawables;
                if (dr != null) {
                    return [dr.mDrawableLeft, dr.mDrawableTop, dr.mDrawableRight, dr.mDrawableBottom];
                }
                else {
                    return [null, null, null, null];
                }
            }
            getCompoundDrawablesRelative() {
                const dr = this.mDrawables;
                if (dr != null) {
                    return [dr.mDrawableStart, dr.mDrawableTop, dr.mDrawableEnd, dr.mDrawableBottom];
                }
                else {
                    return [null, null, null, null];
                }
            }
            setCompoundDrawablePadding(pad) {
                let dr = this.mDrawables;
                if (pad == 0) {
                    if (dr != null) {
                        dr.mDrawablePadding = pad;
                    }
                }
                else {
                    if (dr == null) {
                        this.mDrawables = dr = new TextView.Drawables();
                    }
                    dr.mDrawablePadding = pad;
                }
                this.invalidate();
                this.requestLayout();
            }
            getCompoundDrawablePadding() {
                const dr = this.mDrawables;
                return dr != null ? dr.mDrawablePadding : 0;
            }
            setPadding(left, top, right, bottom) {
                if (left != this.mPaddingLeft || right != this.mPaddingRight || top != this.mPaddingTop || bottom != this.mPaddingBottom) {
                    this.nullLayouts();
                }
                super.setPadding(left, top, right, bottom);
                this.invalidate();
            }
            getAutoLinkMask() {
                return this.mAutoLinkMask;
            }
            getTextLocale() {
                return null;
            }
            setTextLocale(locale) {
            }
            getTextSize() {
                return this.mTextPaint.getTextSize();
            }
            setTextSize(...args) {
                if (args.length == 1) {
                    this.setTextSize(TypedValue.COMPLEX_UNIT_SP, args[0]);
                    return;
                }
                let [unit, size] = args;
                this.setRawTextSize(TypedValue.applyDimension(unit, size, this.getResources().getDisplayMetrics()));
            }
            setRawTextSize(size) {
                if (size != this.mTextPaint.getTextSize()) {
                    this.mTextPaint.setTextSize(size);
                    if (this.mLayout != null) {
                        this.nullLayouts();
                        this.requestLayout();
                        this.invalidate();
                    }
                }
            }
            getTextScaleX() {
                return 1;
            }
            setTextScaleX(size) {
            }
            getTypeface() {
                return null;
            }
            setTextColor(colors) {
                if (typeof colors === 'number') {
                    colors = ColorStateList.valueOf(colors);
                }
                if (colors == null) {
                    throw Error(`new NullPointerException()`);
                }
                this.mTextColor = colors;
                this.updateTextColors();
            }
            getTextColors() {
                return this.mTextColor;
            }
            getCurrentTextColor() {
                return this.mCurTextColor;
            }
            setHighlightColor(color) {
                if (this.mHighlightColor != color) {
                    this.mHighlightColor = color;
                    this.invalidate();
                }
            }
            getHighlightColor() {
                return this.mHighlightColor;
            }
            setShowSoftInputOnFocus(show) {
                this.createEditorIfNeeded();
            }
            getShowSoftInputOnFocus() {
                return false;
            }
            setShadowLayer(radius, dx, dy, color) {
                this.mTextPaint.setShadowLayer(radius, dx, dy, color);
                this.mShadowRadius = radius;
                this.mShadowDx = dx;
                this.mShadowDy = dy;
                this.invalidate();
            }
            getShadowRadius() {
                return this.mShadowRadius;
            }
            getShadowDx() {
                return this.mShadowDx;
            }
            getShadowDy() {
                return this.mShadowDy;
            }
            getShadowColor() {
                return this.mTextPaint.shadowColor;
            }
            getPaint() {
                return this.mTextPaint;
            }
            setAutoLinkMask(mask) {
                this.mAutoLinkMask = mask;
            }
            setLinksClickable(whether) {
                this.mLinksClickable = whether;
            }
            getLinksClickable() {
                return this.mLinksClickable;
            }
            getUrls() {
                return new Array(0);
            }
            setHintTextColor(colors) {
                if (typeof colors === 'number') {
                    colors = ColorStateList.valueOf(colors);
                }
                this.mHintTextColor = colors;
                this.updateTextColors();
            }
            getHintTextColors() {
                return this.mHintTextColor;
            }
            getCurrentHintTextColor() {
                return this.mHintTextColor != null ? this.mCurHintTextColor : this.mCurTextColor;
            }
            setGravity(gravity) {
                if ((gravity & Gravity.HORIZONTAL_GRAVITY_MASK) == 0) {
                    gravity |= Gravity.LEFT;
                }
                if ((gravity & Gravity.VERTICAL_GRAVITY_MASK) == 0) {
                    gravity |= Gravity.TOP;
                }
                let newLayout = false;
                if ((gravity & Gravity.HORIZONTAL_GRAVITY_MASK) != (this.mGravity & Gravity.HORIZONTAL_GRAVITY_MASK)) {
                    newLayout = true;
                }
                if (gravity != this.mGravity) {
                    this.invalidate();
                }
                this.mGravity = gravity;
                if (this.mLayout != null && newLayout) {
                    let want = this.mLayout.getWidth();
                    let hintWant = this.mHintLayout == null ? 0 : this.mHintLayout.getWidth();
                    this.makeNewLayout(want, hintWant, TextView.UNKNOWN_BORING, TextView.UNKNOWN_BORING, this.mRight - this.mLeft - this.getCompoundPaddingLeft() - this.getCompoundPaddingRight(), true);
                }
            }
            getGravity() {
                return this.mGravity;
            }
            getPaintFlags() {
                return this.mTextPaint.getFlags();
            }
            setPaintFlags(flags) {
                if (this.mTextPaint.getFlags() != flags) {
                    this.mTextPaint.setFlags(flags);
                    if (this.mLayout != null) {
                        this.nullLayouts();
                        this.requestLayout();
                        this.invalidate();
                    }
                }
            }
            setHorizontallyScrolling(whether) {
                if (this.mHorizontallyScrolling != whether) {
                    this.mHorizontallyScrolling = whether;
                    if (this.mLayout != null) {
                        this.nullLayouts();
                        this.requestLayout();
                        this.invalidate();
                    }
                }
            }
            getHorizontallyScrolling() {
                return this.mHorizontallyScrolling;
            }
            setMinLines(minlines) {
                this.mMinimum = minlines;
                this.mMinMode = TextView.LINES;
                this.requestLayout();
                this.invalidate();
            }
            getMinLines() {
                return this.mMinMode == TextView.LINES ? this.mMinimum : -1;
            }
            setMinHeight(minHeight) {
                this.mMinimum = minHeight;
                this.mMinMode = TextView.PIXELS;
                this.requestLayout();
                this.invalidate();
            }
            getMinHeight() {
                return this.mMinMode == TextView.PIXELS ? this.mMinimum : -1;
            }
            setMaxLines(maxlines) {
                this.mMaximum = maxlines;
                this.mMaxMode = TextView.LINES;
                this.requestLayout();
                this.invalidate();
            }
            getMaxLines() {
                return this.mMaxMode == TextView.LINES ? this.mMaximum : -1;
            }
            setMaxHeight(maxHeight) {
                this.mMaximum = maxHeight;
                this.mMaxMode = TextView.PIXELS;
                this.requestLayout();
                this.invalidate();
            }
            getMaxHeight() {
                return this.mMaxMode == TextView.PIXELS ? this.mMaximum : -1;
            }
            setLines(lines) {
                this.mMaximum = this.mMinimum = lines;
                this.mMaxMode = this.mMinMode = TextView.LINES;
                this.requestLayout();
                this.invalidate();
            }
            setHeight(pixels) {
                this.mMaximum = this.mMinimum = pixels;
                this.mMaxMode = this.mMinMode = TextView.PIXELS;
                this.requestLayout();
                this.invalidate();
            }
            setMinEms(minems) {
                this.mMinWidthValue = minems;
                this.mMinWidthMode = TextView.EMS;
                this.requestLayout();
                this.invalidate();
            }
            getMinEms() {
                return this.mMinWidthMode == TextView.EMS ? this.mMinWidthValue : -1;
            }
            setMinWidth(minpixels) {
                this.mMinWidthValue = minpixels;
                this.mMinWidthMode = TextView.PIXELS;
                this.requestLayout();
                this.invalidate();
            }
            getMinWidth() {
                return this.mMinWidthMode == TextView.PIXELS ? this.mMinWidthValue : -1;
            }
            setMaxEms(maxems) {
                this.mMaxWidthValue = maxems;
                this.mMaxWidthMode = TextView.EMS;
                this.requestLayout();
                this.invalidate();
            }
            getMaxEms() {
                return this.mMaxWidthMode == TextView.EMS ? this.mMaxWidthValue : -1;
            }
            setMaxWidth(maxpixels) {
                this.mMaxWidthValue = maxpixels;
                this.mMaxWidthMode = TextView.PIXELS;
                this.requestLayout();
                this.invalidate();
            }
            getMaxWidth() {
                return this.mMaxWidthMode == TextView.PIXELS ? this.mMaxWidthValue : -1;
            }
            setEms(ems) {
                this.mMaxWidthValue = this.mMinWidthValue = ems;
                this.mMaxWidthMode = this.mMinWidthMode = TextView.EMS;
                this.requestLayout();
                this.invalidate();
            }
            setWidth(pixels) {
                this.mMaxWidthValue = this.mMinWidthValue = pixels;
                this.mMaxWidthMode = this.mMinWidthMode = TextView.PIXELS;
                this.requestLayout();
                this.invalidate();
            }
            setLineSpacing(add, mult) {
                if (this.mSpacingAdd != add || this.mSpacingMult != mult) {
                    this.mSpacingAdd = add;
                    this.mSpacingMult = mult;
                    if (this.mLayout != null) {
                        this.nullLayouts();
                        this.requestLayout();
                        this.invalidate();
                    }
                }
            }
            getLineSpacingMultiplier() {
                return this.mSpacingMult;
            }
            getLineSpacingExtra() {
                return this.mSpacingAdd;
            }
            updateTextColors() {
                let inval = false;
                let color = this.mTextColor.getColorForState(this.getDrawableState(), 0);
                if (color != this.mCurTextColor) {
                    this.mCurTextColor = color;
                    inval = true;
                }
                if (this.mLinkTextColor != null) {
                    color = this.mLinkTextColor.getColorForState(this.getDrawableState(), 0);
                    if (color != this.mTextPaint.linkColor) {
                        this.mTextPaint.linkColor = color;
                        inval = true;
                    }
                }
                if (this.mHintTextColor != null) {
                    color = this.mHintTextColor.getColorForState(this.getDrawableState(), 0);
                    if (color != this.mCurHintTextColor && this.mText.length == 0) {
                        this.mCurHintTextColor = color;
                        inval = true;
                    }
                }
                if (inval) {
                    this.invalidate();
                }
            }
            drawableStateChanged() {
                super.drawableStateChanged();
                if (this.mTextColor != null && this.mTextColor.isStateful() || (this.mHintTextColor != null && this.mHintTextColor.isStateful()) || (this.mLinkTextColor != null && this.mLinkTextColor.isStateful())) {
                    this.updateTextColors();
                }
                const dr = this.mDrawables;
                if (dr != null) {
                    let state = this.getDrawableState();
                    if (dr.mDrawableTop != null && dr.mDrawableTop.isStateful()) {
                        dr.mDrawableTop.setState(state);
                    }
                    if (dr.mDrawableBottom != null && dr.mDrawableBottom.isStateful()) {
                        dr.mDrawableBottom.setState(state);
                    }
                    if (dr.mDrawableLeft != null && dr.mDrawableLeft.isStateful()) {
                        dr.mDrawableLeft.setState(state);
                    }
                    if (dr.mDrawableRight != null && dr.mDrawableRight.isStateful()) {
                        dr.mDrawableRight.setState(state);
                    }
                    if (dr.mDrawableStart != null && dr.mDrawableStart.isStateful()) {
                        dr.mDrawableStart.setState(state);
                    }
                    if (dr.mDrawableEnd != null && dr.mDrawableEnd.isStateful()) {
                        dr.mDrawableEnd.setState(state);
                    }
                }
            }
            removeMisspelledSpans(spannable) {
            }
            setFreezesText(freezesText) {
                this.mFreezesText = freezesText;
            }
            getFreezesText() {
                return this.mFreezesText;
            }
            setSpannableFactory(factory) {
                this.mSpannableFactory = factory;
                this.setText(this.mText);
            }
            setText(text, type = this.mBufferType, notifyBefore = true, oldlen = 0) {
                if (text == null) {
                    text = "";
                }
                if (!this.isSuggestionsEnabled()) {
                    text = this.removeSuggestionSpans(text);
                }
                if (Spanned.isImplements(text) && text.getSpanStart(TextUtils.TruncateAt.MARQUEE) >= 0) {
                    this.setHorizontalFadingEdgeEnabled(true);
                    this.mMarqueeFadeMode = TextView.MARQUEE_FADE_NORMAL;
                    this.setEllipsize(TextUtils.TruncateAt.MARQUEE);
                }
                if (notifyBefore) {
                    if (this.mText != null) {
                        oldlen = this.mText.length;
                        this.sendBeforeTextChanged(this.mText, 0, oldlen, text.length);
                    }
                    else {
                        this.sendBeforeTextChanged("", 0, 0, text.length);
                    }
                }
                let needEditableForNotification = false;
                if (this.mListeners != null && this.mListeners.size() != 0) {
                    needEditableForNotification = true;
                }
                if (type == TextView.BufferType.SPANNABLE || this.mMovement != null) {
                    text = this.mSpannableFactory.newSpannable(text);
                }
                this.mBufferType = type;
                this.mText = text;
                if (this.mTransformation == null) {
                    this.mTransformed = text;
                }
                else {
                    this.mTransformed = this.mTransformation.getTransformation(text, this);
                }
                const textLength = text.length;
                if (this.mLayout != null) {
                    this.checkForRelayout();
                }
                this.sendOnTextChanged(text, 0, oldlen, textLength);
                this.onTextChanged(text, 0, oldlen, textLength);
            }
            setHint(hint) {
                this.mHint = hint;
                if (this.mLayout != null) {
                    this.checkForRelayout();
                }
                if (this.mText.length == 0) {
                    this.invalidate();
                }
            }
            getHint() {
                return this.mHint;
            }
            isSingleLine() {
                return this.mSingleLine;
            }
            static isMultilineInputType(type) {
                return true;
            }
            removeSuggestionSpans(text) {
                return text;
            }
            hasPasswordTransformationMethod() {
                return false;
            }
            static isPasswordInputType(inputType) {
                return false;
            }
            static isVisiblePasswordInputType(inputType) {
                return true;
            }
            setRawInputType(type) {
            }
            setInputType(type, direct = false) {
            }
            getInputType() {
                return 0;
            }
            setImeOptions(imeOptions) {
            }
            getImeOptions() {
                return -1;
            }
            setImeActionLabel(label, actionId) {
                this.createEditorIfNeeded();
            }
            getImeActionLabel() {
                return '';
            }
            getImeActionId() {
                return 0;
            }
            setOnEditorActionListener(l) {
                this.createEditorIfNeeded();
            }
            setFrame(l, t, r, b) {
                let result = super.setFrame(l, t, r, b);
                this.restartMarqueeIfNeeded();
                return result;
            }
            restartMarqueeIfNeeded() {
                if (this.mRestartMarquee && this.mEllipsize == TextUtils.TruncateAt.MARQUEE) {
                    this.mRestartMarquee = false;
                    this.startMarquee();
                }
            }
            setFilters(...args) {
            }
            getFilters() {
                return this.mFilters;
            }
            getBoxHeight(l) {
                let padding = (l == this.mHintLayout) ? this.getCompoundPaddingTop() + this.getCompoundPaddingBottom() : this.getExtendedPaddingTop() + this.getExtendedPaddingBottom();
                return this.getMeasuredHeight() - padding;
            }
            getVerticalOffset(forceNormal) {
                let voffset = 0;
                const gravity = this.mGravity & Gravity.VERTICAL_GRAVITY_MASK;
                let l = this.mLayout;
                if (!forceNormal && this.mText.length == 0 && this.mHintLayout != null) {
                    l = this.mHintLayout;
                }
                if (gravity != Gravity.TOP) {
                    let boxht = this.getBoxHeight(l);
                    let textht = l.getHeight();
                    if (textht < boxht) {
                        if (gravity == Gravity.BOTTOM)
                            voffset = boxht - textht;
                        else
                            voffset = (boxht - textht) >> 1;
                    }
                }
                return voffset;
            }
            getBottomVerticalOffset(forceNormal) {
                let voffset = 0;
                const gravity = this.mGravity & Gravity.VERTICAL_GRAVITY_MASK;
                let l = this.mLayout;
                if (!forceNormal && this.mText.length == 0 && this.mHintLayout != null) {
                    l = this.mHintLayout;
                }
                if (gravity != Gravity.BOTTOM) {
                    let boxht = this.getBoxHeight(l);
                    let textht = l.getHeight();
                    if (textht < boxht) {
                        if (gravity == Gravity.TOP)
                            voffset = boxht - textht;
                        else
                            voffset = (boxht - textht) >> 1;
                    }
                }
                return voffset;
            }
            invalidateRegion(start, end, invalidateCursor) {
                if (this.mLayout == null) {
                    this.invalidate();
                }
                else {
                    let lineStart = this.mLayout.getLineForOffset(start);
                    let top = this.mLayout.getLineTop(lineStart);
                    if (lineStart > 0) {
                        top -= this.mLayout.getLineDescent(lineStart - 1);
                    }
                    let lineEnd;
                    if (start == end)
                        lineEnd = lineStart;
                    else
                        lineEnd = this.mLayout.getLineForOffset(end);
                    let bottom = this.mLayout.getLineBottom(lineEnd);
                    const compoundPaddingLeft = this.getCompoundPaddingLeft();
                    const verticalPadding = this.getExtendedPaddingTop() + this.getVerticalOffset(true);
                    let left, right;
                    if (lineStart == lineEnd && !invalidateCursor) {
                        left = Math.floor(this.mLayout.getPrimaryHorizontal(start));
                        right = Math.floor((this.mLayout.getPrimaryHorizontal(end) + 1.0));
                        left += compoundPaddingLeft;
                        right += compoundPaddingLeft;
                    }
                    else {
                        left = compoundPaddingLeft;
                        right = this.getWidth() - this.getCompoundPaddingRight();
                    }
                    this.invalidate(this.mScrollX + left, verticalPadding + top, this.mScrollX + right, verticalPadding + bottom);
                }
            }
            registerForPreDraw() {
                if (!this.mPreDrawRegistered) {
                    this.getViewTreeObserver().addOnPreDrawListener(this);
                    this.mPreDrawRegistered = true;
                }
            }
            onPreDraw() {
                if (this.mLayout == null) {
                    this.assumeLayout();
                }
                if (this.mMovement != null) {
                    let curs = this.getSelectionEnd();
                    if (curs < 0 && (this.mGravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.BOTTOM) {
                        curs = this.mText.length;
                    }
                    if (curs >= 0) {
                        this.bringPointIntoView(curs);
                    }
                }
                else {
                    this.bringTextIntoView();
                }
                this.getViewTreeObserver().removeOnPreDrawListener(this);
                this.mPreDrawRegistered = false;
                return true;
            }
            onAttachedToWindow() {
                super.onAttachedToWindow();
                this.mTemporaryDetach = false;
            }
            onDetachedFromWindow() {
                super.onDetachedFromWindow();
                if (this.mPreDrawRegistered) {
                    this.getViewTreeObserver().removeOnPreDrawListener(this);
                    this.mPreDrawRegistered = false;
                }
                this.resetResolvedDrawables();
            }
            isPaddingOffsetRequired() {
                return this.mShadowRadius != 0 || this.mDrawables != null;
            }
            getLeftPaddingOffset() {
                return this.getCompoundPaddingLeft() - this.mPaddingLeft + Math.floor(Math.min(0, this.mShadowDx - this.mShadowRadius));
            }
            getTopPaddingOffset() {
                return Math.floor(Math.min(0, this.mShadowDy - this.mShadowRadius));
            }
            getBottomPaddingOffset() {
                return Math.floor(Math.max(0, this.mShadowDy + this.mShadowRadius));
            }
            getRightPaddingOffset() {
                return -(this.getCompoundPaddingRight() - this.mPaddingRight) + Math.floor(Math.max(0, this.mShadowDx + this.mShadowRadius));
            }
            verifyDrawable(who) {
                const verified = super.verifyDrawable(who);
                if (!verified && this.mDrawables != null) {
                    return who == this.mDrawables.mDrawableLeft || who == this.mDrawables.mDrawableTop || who == this.mDrawables.mDrawableRight || who == this.mDrawables.mDrawableBottom || who == this.mDrawables.mDrawableStart || who == this.mDrawables.mDrawableEnd;
                }
                return verified;
            }
            jumpDrawablesToCurrentState() {
                super.jumpDrawablesToCurrentState();
                if (this.mDrawables != null) {
                    if (this.mDrawables.mDrawableLeft != null) {
                        this.mDrawables.mDrawableLeft.jumpToCurrentState();
                    }
                    if (this.mDrawables.mDrawableTop != null) {
                        this.mDrawables.mDrawableTop.jumpToCurrentState();
                    }
                    if (this.mDrawables.mDrawableRight != null) {
                        this.mDrawables.mDrawableRight.jumpToCurrentState();
                    }
                    if (this.mDrawables.mDrawableBottom != null) {
                        this.mDrawables.mDrawableBottom.jumpToCurrentState();
                    }
                    if (this.mDrawables.mDrawableStart != null) {
                        this.mDrawables.mDrawableStart.jumpToCurrentState();
                    }
                    if (this.mDrawables.mDrawableEnd != null) {
                        this.mDrawables.mDrawableEnd.jumpToCurrentState();
                    }
                }
            }
            invalidateDrawable(drawable) {
                if (this.verifyDrawable(drawable)) {
                    const dirty = drawable.getBounds();
                    let scrollX = this.mScrollX;
                    let scrollY = this.mScrollY;
                    const drawables = this.mDrawables;
                    if (drawables != null) {
                        if (drawable == drawables.mDrawableLeft) {
                            const compoundPaddingTop = this.getCompoundPaddingTop();
                            const compoundPaddingBottom = this.getCompoundPaddingBottom();
                            const vspace = this.mBottom - this.mTop - compoundPaddingBottom - compoundPaddingTop;
                            scrollX += this.mPaddingLeft;
                            scrollY += compoundPaddingTop + (vspace - drawables.mDrawableHeightLeft) / 2;
                        }
                        else if (drawable == drawables.mDrawableRight) {
                            const compoundPaddingTop = this.getCompoundPaddingTop();
                            const compoundPaddingBottom = this.getCompoundPaddingBottom();
                            const vspace = this.mBottom - this.mTop - compoundPaddingBottom - compoundPaddingTop;
                            scrollX += (this.mRight - this.mLeft - this.mPaddingRight - drawables.mDrawableSizeRight);
                            scrollY += compoundPaddingTop + (vspace - drawables.mDrawableHeightRight) / 2;
                        }
                        else if (drawable == drawables.mDrawableTop) {
                            const compoundPaddingLeft = this.getCompoundPaddingLeft();
                            const compoundPaddingRight = this.getCompoundPaddingRight();
                            const hspace = this.mRight - this.mLeft - compoundPaddingRight - compoundPaddingLeft;
                            scrollX += compoundPaddingLeft + (hspace - drawables.mDrawableWidthTop) / 2;
                            scrollY += this.mPaddingTop;
                        }
                        else if (drawable == drawables.mDrawableBottom) {
                            const compoundPaddingLeft = this.getCompoundPaddingLeft();
                            const compoundPaddingRight = this.getCompoundPaddingRight();
                            const hspace = this.mRight - this.mLeft - compoundPaddingRight - compoundPaddingLeft;
                            scrollX += compoundPaddingLeft + (hspace - drawables.mDrawableWidthBottom) / 2;
                            scrollY += (this.mBottom - this.mTop - this.mPaddingBottom - drawables.mDrawableSizeBottom);
                        }
                    }
                    this.invalidate(dirty.left + scrollX, dirty.top + scrollY, dirty.right + scrollX, dirty.bottom + scrollY);
                }
            }
            isTextSelectable() {
                return false;
            }
            setTextIsSelectable(selectable) {
            }
            onCreateDrawableState(extraSpace) {
                let drawableState;
                if (this.mSingleLine) {
                    drawableState = super.onCreateDrawableState(extraSpace);
                }
                else {
                    drawableState = super.onCreateDrawableState(extraSpace + 1);
                    TextView.mergeDrawableStates(drawableState, TextView.MULTILINE_STATE_SET);
                }
                if (this.isTextSelectable()) {
                    const length = drawableState.length;
                    for (let i = 0; i < length; i++) {
                        if (drawableState[i] == View.VIEW_STATE_PRESSED) {
                            const nonPressedState = new Array(length - 1);
                            System.arraycopy(drawableState, 0, nonPressedState, 0, i);
                            System.arraycopy(drawableState, i + 1, nonPressedState, i, length - i - 1);
                            return nonPressedState;
                        }
                    }
                }
                return drawableState;
            }
            getUpdatedHighlightPath() {
                let highlight = null;
                let highlightPaint = this.mHighlightPaint;
                const selStart = this.getSelectionStart();
                const selEnd = this.getSelectionEnd();
                if (this.mMovement != null && (this.isFocused() || this.isPressed()) && selStart >= 0) {
                    if (selStart == selEnd) {
                    }
                    else {
                        if (this.mHighlightPathBogus) {
                            if (this.mHighlightPath == null)
                                this.mHighlightPath = new Path();
                            this.mHighlightPath.reset();
                            this.mLayout.getSelectionPath(selStart, selEnd, this.mHighlightPath);
                            this.mHighlightPathBogus = false;
                        }
                        highlightPaint.setColor(this.mHighlightColor);
                        highlightPaint.setStyle(Paint.Style.FILL);
                        highlight = this.mHighlightPath;
                    }
                }
                return highlight;
            }
            getHorizontalOffsetForDrawables() {
                return 0;
            }
            onDraw(canvas) {
                this.restartMarqueeIfNeeded();
                super.onDraw(canvas);
                const compoundPaddingLeft = this.getCompoundPaddingLeft();
                const compoundPaddingTop = this.getCompoundPaddingTop();
                const compoundPaddingRight = this.getCompoundPaddingRight();
                const compoundPaddingBottom = this.getCompoundPaddingBottom();
                const scrollX = this.mScrollX;
                const scrollY = this.mScrollY;
                const right = this.mRight;
                const left = this.mLeft;
                const bottom = this.mBottom;
                const top = this.mTop;
                const isLayoutRtl = this.isLayoutRtl();
                const offset = this.getHorizontalOffsetForDrawables();
                const leftOffset = isLayoutRtl ? 0 : offset;
                const rightOffset = isLayoutRtl ? offset : 0;
                const dr = this.mDrawables;
                if (dr != null) {
                    let vspace = bottom - top - compoundPaddingBottom - compoundPaddingTop;
                    let hspace = right - left - compoundPaddingRight - compoundPaddingLeft;
                    if (dr.mDrawableLeft != null) {
                        canvas.save();
                        canvas.translate(scrollX + this.mPaddingLeft + leftOffset, scrollY + compoundPaddingTop + (vspace - dr.mDrawableHeightLeft) / 2);
                        dr.mDrawableLeft.draw(canvas);
                        canvas.restore();
                    }
                    if (dr.mDrawableRight != null) {
                        canvas.save();
                        canvas.translate(scrollX + right - left - this.mPaddingRight - dr.mDrawableSizeRight - rightOffset, scrollY + compoundPaddingTop + (vspace - dr.mDrawableHeightRight) / 2);
                        dr.mDrawableRight.draw(canvas);
                        canvas.restore();
                    }
                    if (dr.mDrawableTop != null) {
                        canvas.save();
                        canvas.translate(scrollX + compoundPaddingLeft + (hspace - dr.mDrawableWidthTop) / 2, scrollY + this.mPaddingTop);
                        dr.mDrawableTop.draw(canvas);
                        canvas.restore();
                    }
                    if (dr.mDrawableBottom != null) {
                        canvas.save();
                        canvas.translate(scrollX + compoundPaddingLeft + (hspace - dr.mDrawableWidthBottom) / 2, scrollY + bottom - top - this.mPaddingBottom - dr.mDrawableSizeBottom);
                        dr.mDrawableBottom.draw(canvas);
                        canvas.restore();
                    }
                }
                let color = this.mCurTextColor;
                if (this.mLayout == null) {
                    this.assumeLayout();
                }
                let layout = this.mLayout;
                if (this.mHint != null && this.mText.length == 0) {
                    if (this.mHintTextColor != null) {
                        color = this.mCurHintTextColor;
                    }
                    layout = this.mHintLayout;
                }
                this.mTextPaint.setColor(color);
                this.mTextPaint.drawableState = this.getDrawableState();
                canvas.save();
                let extendedPaddingTop = this.getExtendedPaddingTop();
                let extendedPaddingBottom = this.getExtendedPaddingBottom();
                const vspace = this.mBottom - this.mTop - compoundPaddingBottom - compoundPaddingTop;
                const maxScrollY = this.mLayout.getHeight() - vspace;
                let clipLeft = compoundPaddingLeft + scrollX;
                let clipTop = (scrollY == 0) ? 0 : extendedPaddingTop + scrollY;
                let clipRight = right - left - compoundPaddingRight + scrollX;
                let clipBottom = bottom - top + scrollY - ((scrollY == maxScrollY) ? 0 : extendedPaddingBottom);
                if (this.mShadowRadius != 0) {
                    clipLeft += Math.min(0, this.mShadowDx - this.mShadowRadius);
                    clipRight += Math.max(0, this.mShadowDx + this.mShadowRadius);
                    clipTop += Math.min(0, this.mShadowDy - this.mShadowRadius);
                    clipBottom += Math.max(0, this.mShadowDy + this.mShadowRadius);
                }
                canvas.clipRect(clipLeft, clipTop, clipRight, clipBottom);
                let voffsetText = 0;
                let voffsetCursor = 0;
                if ((this.mGravity & Gravity.VERTICAL_GRAVITY_MASK) != Gravity.TOP) {
                    voffsetText = this.getVerticalOffset(false);
                    voffsetCursor = this.getVerticalOffset(true);
                }
                canvas.translate(compoundPaddingLeft, extendedPaddingTop + voffsetText);
                const absoluteGravity = this.mGravity;
                if (this.mEllipsize == TextUtils.TruncateAt.MARQUEE && this.mMarqueeFadeMode != TextView.MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) {
                    if (!this.mSingleLine && this.getLineCount() == 1 && this.canMarquee() && (absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) != Gravity.LEFT) {
                        const width = this.mRight - this.mLeft;
                        const padding = this.getCompoundPaddingLeft() + this.getCompoundPaddingRight();
                        const dx = this.mLayout.getLineRight(0) - (width - padding);
                        canvas.translate(isLayoutRtl ? -dx : +dx, 0.0);
                    }
                    if (this.mMarquee != null && this.mMarquee.isRunning()) {
                        const dx = -this.mMarquee.getScroll();
                        canvas.translate(isLayoutRtl ? -dx : +dx, 0.0);
                    }
                }
                const cursorOffsetVertical = voffsetCursor - voffsetText;
                let highlight = this.getUpdatedHighlightPath();
                layout.draw(canvas, highlight, this.mHighlightPaint, cursorOffsetVertical);
                if (this.mMarquee != null && this.mMarquee.shouldDrawGhost()) {
                    const dx = Math.floor(this.mMarquee.getGhostOffset());
                    canvas.translate(isLayoutRtl ? -dx : dx, 0.0);
                    layout.draw(canvas, highlight, this.mHighlightPaint, cursorOffsetVertical);
                }
                canvas.restore();
            }
            getFocusedRect(r) {
                if (this.mLayout == null) {
                    super.getFocusedRect(r);
                    return;
                }
                let selEnd = this.getSelectionEnd();
                if (selEnd < 0) {
                    super.getFocusedRect(r);
                    return;
                }
            }
            getLineCount() {
                return this.mLayout != null ? this.mLayout.getLineCount() : 0;
            }
            getLineBounds(line, bounds) {
                if (this.mLayout == null) {
                    if (bounds != null) {
                        bounds.set(0, 0, 0, 0);
                    }
                    return 0;
                }
                else {
                    let baseline = this.mLayout.getLineBounds(line, bounds);
                    let voffset = this.getExtendedPaddingTop();
                    if ((this.mGravity & Gravity.VERTICAL_GRAVITY_MASK) != Gravity.TOP) {
                        voffset += this.getVerticalOffset(true);
                    }
                    if (bounds != null) {
                        bounds.offset(this.getCompoundPaddingLeft(), voffset);
                    }
                    return baseline + voffset;
                }
            }
            getBaseline() {
                if (this.mLayout == null) {
                    return super.getBaseline();
                }
                let voffset = 0;
                if ((this.mGravity & Gravity.VERTICAL_GRAVITY_MASK) != Gravity.TOP) {
                    voffset = this.getVerticalOffset(true);
                }
                return this.getExtendedPaddingTop() + voffset + this.mLayout.getLineBaseline(0);
            }
            getFadeTop(offsetRequired) {
                if (this.mLayout == null)
                    return 0;
                let voffset = 0;
                if ((this.mGravity & Gravity.VERTICAL_GRAVITY_MASK) != Gravity.TOP) {
                    voffset = this.getVerticalOffset(true);
                }
                if (offsetRequired)
                    voffset += this.getTopPaddingOffset();
                return this.getExtendedPaddingTop() + voffset;
            }
            getFadeHeight(offsetRequired) {
                return this.mLayout != null ? this.mLayout.getHeight() : 0;
            }
            onKeyDown(keyCode, event) {
                let which = this.doKeyDown(keyCode, event, null);
                if (which == 0) {
                    return super.onKeyDown(keyCode, event);
                }
                return true;
            }
            shouldAdvanceFocusOnEnter() {
                if (this.getKeyListener() == null) {
                    return false;
                }
                if (this.mSingleLine) {
                    return true;
                }
                return false;
            }
            shouldAdvanceFocusOnTab() {
                return true;
            }
            doKeyDown(keyCode, event, otherEvent) {
                return 0;
            }
            resetErrorChangedFlag() {
            }
            hideErrorIfUnchanged() {
            }
            onKeyUp(keyCode, event) {
                return super.onKeyUp(keyCode, event);
            }
            onCheckIsTextEditor() {
                return false;
            }
            nullLayouts() {
                if (this.mLayout instanceof BoringLayout && this.mSavedLayout == null) {
                    this.mSavedLayout = this.mLayout;
                }
                if (this.mHintLayout instanceof BoringLayout && this.mSavedHintLayout == null) {
                    this.mSavedHintLayout = this.mHintLayout;
                }
                this.mSavedMarqueeModeLayout = this.mLayout = this.mHintLayout = null;
                this.mBoring = this.mHintBoring = null;
            }
            assumeLayout() {
                let width = this.mRight - this.mLeft - this.getCompoundPaddingLeft() - this.getCompoundPaddingRight();
                if (width < 1) {
                    width = 0;
                }
                let physicalWidth = width;
                if (this.mHorizontallyScrolling) {
                    width = TextView.VERY_WIDE;
                }
                this.makeNewLayout(width, physicalWidth, TextView.UNKNOWN_BORING, TextView.UNKNOWN_BORING, physicalWidth, false);
            }
            getLayoutAlignment() {
                let alignment;
                switch (this.mGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
                    case Gravity.LEFT:
                        alignment = Layout.Alignment.ALIGN_LEFT;
                        break;
                    case Gravity.RIGHT:
                        alignment = Layout.Alignment.ALIGN_RIGHT;
                        break;
                    case Gravity.CENTER_HORIZONTAL:
                        alignment = Layout.Alignment.ALIGN_CENTER;
                        break;
                    default:
                        alignment = Layout.Alignment.ALIGN_NORMAL;
                        break;
                }
                return alignment;
            }
            makeNewLayout(wantWidth, hintWidth, boring, hintBoring, ellipsisWidth, bringIntoView) {
                this.stopMarquee();
                this.mOldMaximum = this.mMaximum;
                this.mOldMaxMode = this.mMaxMode;
                this.mHighlightPathBogus = true;
                if (wantWidth < 0) {
                    wantWidth = 0;
                }
                if (hintWidth < 0) {
                    hintWidth = 0;
                }
                let alignment = this.getLayoutAlignment();
                const testDirChange = this.mSingleLine && this.mLayout != null && (alignment == Layout.Alignment.ALIGN_NORMAL || alignment == Layout.Alignment.ALIGN_OPPOSITE);
                let oldDir = 0;
                if (testDirChange)
                    oldDir = this.mLayout.getParagraphDirection(0);
                let shouldEllipsize = this.mEllipsize != null && this.getKeyListener() == null;
                const switchEllipsize = this.mEllipsize == TruncateAt.MARQUEE && this.mMarqueeFadeMode != TextView.MARQUEE_FADE_NORMAL;
                let effectiveEllipsize = this.mEllipsize;
                if (this.mEllipsize == TruncateAt.MARQUEE && this.mMarqueeFadeMode == TextView.MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) {
                    effectiveEllipsize = TruncateAt.END_SMALL;
                }
                if (this.mTextDir == null) {
                    this.mTextDir = this.getTextDirectionHeuristic();
                }
                this.mLayout = this.makeSingleLayout(wantWidth, boring, ellipsisWidth, alignment, shouldEllipsize, effectiveEllipsize, effectiveEllipsize == this.mEllipsize);
                if (switchEllipsize) {
                    let oppositeEllipsize = effectiveEllipsize == TruncateAt.MARQUEE ? TruncateAt.END : TruncateAt.MARQUEE;
                    this.mSavedMarqueeModeLayout = this.makeSingleLayout(wantWidth, boring, ellipsisWidth, alignment, shouldEllipsize, oppositeEllipsize, effectiveEllipsize != this.mEllipsize);
                }
                shouldEllipsize = this.mEllipsize != null;
                this.mHintLayout = null;
                if (this.mHint != null) {
                    if (shouldEllipsize)
                        hintWidth = wantWidth;
                    if (hintBoring == TextView.UNKNOWN_BORING) {
                        hintBoring = BoringLayout.isBoring(this.mHint, this.mTextPaint, this.mTextDir, this.mHintBoring);
                        if (hintBoring != null) {
                            this.mHintBoring = hintBoring;
                        }
                    }
                    if (hintBoring != null) {
                        if (hintBoring.width <= hintWidth && (!shouldEllipsize || hintBoring.width <= ellipsisWidth)) {
                            if (this.mSavedHintLayout != null) {
                                this.mHintLayout = this.mSavedHintLayout.replaceOrMake(this.mHint, this.mTextPaint, hintWidth, alignment, this.mSpacingMult, this.mSpacingAdd, hintBoring, this.mIncludePad);
                            }
                            else {
                                this.mHintLayout = BoringLayout.make(this.mHint, this.mTextPaint, hintWidth, alignment, this.mSpacingMult, this.mSpacingAdd, hintBoring, this.mIncludePad);
                            }
                            this.mSavedHintLayout = this.mHintLayout;
                        }
                        else if (shouldEllipsize && hintBoring.width <= hintWidth) {
                            if (this.mSavedHintLayout != null) {
                                this.mHintLayout = this.mSavedHintLayout.replaceOrMake(this.mHint, this.mTextPaint, hintWidth, alignment, this.mSpacingMult, this.mSpacingAdd, hintBoring, this.mIncludePad, this.mEllipsize, ellipsisWidth);
                            }
                            else {
                                this.mHintLayout = BoringLayout.make(this.mHint, this.mTextPaint, hintWidth, alignment, this.mSpacingMult, this.mSpacingAdd, hintBoring, this.mIncludePad, this.mEllipsize, ellipsisWidth);
                            }
                        }
                        else if (shouldEllipsize) {
                            this.mHintLayout = new StaticLayout(this.mHint, 0, this.mHint.length, this.mTextPaint, hintWidth, alignment, this.mTextDir, this.mSpacingMult, this.mSpacingAdd, this.mIncludePad, this.mEllipsize, ellipsisWidth, this.mMaxMode == TextView.LINES ? this.mMaximum : Integer.MAX_VALUE);
                        }
                        else {
                            this.mHintLayout = new StaticLayout(this.mHint, 0, this.mHint.length, this.mTextPaint, hintWidth, alignment, this.mTextDir, this.mSpacingMult, this.mSpacingAdd, this.mIncludePad);
                        }
                    }
                    else if (shouldEllipsize) {
                        this.mHintLayout = new StaticLayout(this.mHint, 0, this.mHint.length, this.mTextPaint, hintWidth, alignment, this.mTextDir, this.mSpacingMult, this.mSpacingAdd, this.mIncludePad, this.mEllipsize, ellipsisWidth, this.mMaxMode == TextView.LINES ? this.mMaximum : Integer.MAX_VALUE);
                    }
                    else {
                        this.mHintLayout = new StaticLayout(this.mHint, 0, this.mHint.length, this.mTextPaint, hintWidth, alignment, this.mTextDir, this.mSpacingMult, this.mSpacingAdd, this.mIncludePad);
                    }
                }
                if (bringIntoView || (testDirChange && oldDir != this.mLayout.getParagraphDirection(0))) {
                    this.registerForPreDraw();
                }
                if (this.mEllipsize == TextUtils.TruncateAt.MARQUEE) {
                    if (!this.compressText(ellipsisWidth)) {
                        const height = this.mLayoutParams.height;
                        if (height != LayoutParams.WRAP_CONTENT && height != LayoutParams.MATCH_PARENT) {
                            this.startMarquee();
                        }
                        else {
                            this.mRestartMarquee = true;
                        }
                    }
                }
            }
            makeSingleLayout(wantWidth, boring, ellipsisWidth, alignment, shouldEllipsize, effectiveEllipsize, useSaved) {
                let result = null;
                if (Spannable.isImpl(this.mText)) {
                    result = new DynamicLayout(this.mText, this.mTransformed, this.mTextPaint, wantWidth, alignment, this.mTextDir, this.mSpacingMult, this.mSpacingAdd, this.mIncludePad, this.getKeyListener() == null ? effectiveEllipsize : null, ellipsisWidth);
                }
                else {
                    if (boring == TextView.UNKNOWN_BORING) {
                        boring = BoringLayout.isBoring(this.mTransformed, this.mTextPaint, this.mTextDir, this.mBoring);
                        if (boring != null) {
                            this.mBoring = boring;
                        }
                    }
                    if (boring != null) {
                        if (boring.width <= wantWidth && (effectiveEllipsize == null || boring.width <= ellipsisWidth)) {
                            if (useSaved && this.mSavedLayout != null) {
                                result = this.mSavedLayout.replaceOrMake(this.mTransformed, this.mTextPaint, wantWidth, alignment, this.mSpacingMult, this.mSpacingAdd, boring, this.mIncludePad);
                            }
                            else {
                                result = BoringLayout.make(this.mTransformed, this.mTextPaint, wantWidth, alignment, this.mSpacingMult, this.mSpacingAdd, boring, this.mIncludePad);
                            }
                            if (useSaved) {
                                this.mSavedLayout = result;
                            }
                        }
                        else if (shouldEllipsize && boring.width <= wantWidth) {
                            if (useSaved && this.mSavedLayout != null) {
                                result = this.mSavedLayout.replaceOrMake(this.mTransformed, this.mTextPaint, wantWidth, alignment, this.mSpacingMult, this.mSpacingAdd, boring, this.mIncludePad, effectiveEllipsize, ellipsisWidth);
                            }
                            else {
                                result = BoringLayout.make(this.mTransformed, this.mTextPaint, wantWidth, alignment, this.mSpacingMult, this.mSpacingAdd, boring, this.mIncludePad, effectiveEllipsize, ellipsisWidth);
                            }
                        }
                        else if (shouldEllipsize) {
                            result = new StaticLayout(this.mTransformed, 0, this.mTransformed.length, this.mTextPaint, wantWidth, alignment, this.mTextDir, this.mSpacingMult, this.mSpacingAdd, this.mIncludePad, effectiveEllipsize, ellipsisWidth, this.mMaxMode == TextView.LINES ? this.mMaximum : Integer.MAX_VALUE);
                        }
                        else {
                            result = new StaticLayout(this.mTransformed, 0, this.mTransformed.length, this.mTextPaint, wantWidth, alignment, this.mTextDir, this.mSpacingMult, this.mSpacingAdd, this.mIncludePad);
                        }
                    }
                    else if (shouldEllipsize) {
                        result = new StaticLayout(this.mTransformed, 0, this.mTransformed.length, this.mTextPaint, wantWidth, alignment, this.mTextDir, this.mSpacingMult, this.mSpacingAdd, this.mIncludePad, effectiveEllipsize, ellipsisWidth, this.mMaxMode == TextView.LINES ? this.mMaximum : Integer.MAX_VALUE);
                    }
                    else {
                        result = new StaticLayout(this.mTransformed, 0, this.mTransformed.length, this.mTextPaint, wantWidth, alignment, this.mTextDir, this.mSpacingMult, this.mSpacingAdd, this.mIncludePad);
                    }
                }
                return result;
            }
            compressText(width) {
                if (this.isHardwareAccelerated())
                    return false;
                if (width > 0.0 && this.mLayout != null && this.getLineCount() == 1 && !this.mUserSetTextScaleX && this.mTextPaint.getTextScaleX() == 1.0) {
                    const textWidth = this.mLayout.getLineWidth(0);
                    const overflow = (textWidth + 1.0 - width) / width;
                    if (overflow > 0.0 && overflow <= TextView.Marquee.MARQUEE_DELTA_MAX) {
                        this.mTextPaint.setTextScaleX(1.0 - overflow - 0.005);
                        this.post((() => {
                            const _this = this;
                            class _Inner {
                                run() {
                                    _this.requestLayout();
                                }
                            }
                            return new _Inner();
                        })());
                        return true;
                    }
                }
                return false;
            }
            static desired(layout) {
                let n = layout.getLineCount();
                let text = layout.getText();
                let max = 0;
                for (let i = 0; i < n - 1; i++) {
                    if (text.charAt(layout.getLineEnd(i) - 1) != '\n')
                        return -1;
                }
                for (let i = 0; i < n; i++) {
                    max = Math.max(max, layout.getLineWidth(i));
                }
                return Math.floor(Math.ceil(max));
            }
            setIncludeFontPadding(includepad) {
                if (this.mIncludePad != includepad) {
                    this.mIncludePad = includepad;
                    if (this.mLayout != null) {
                        this.nullLayouts();
                        this.requestLayout();
                        this.invalidate();
                    }
                }
            }
            getIncludeFontPadding() {
                return this.mIncludePad;
            }
            onMeasure(widthMeasureSpec, heightMeasureSpec) {
                let widthMode = TextView.MeasureSpec.getMode(widthMeasureSpec);
                let heightMode = TextView.MeasureSpec.getMode(heightMeasureSpec);
                let widthSize = TextView.MeasureSpec.getSize(widthMeasureSpec);
                let heightSize = TextView.MeasureSpec.getSize(heightMeasureSpec);
                let width;
                let height;
                let boring = TextView.UNKNOWN_BORING;
                let hintBoring = TextView.UNKNOWN_BORING;
                if (this.mTextDir == null) {
                    this.mTextDir = this.getTextDirectionHeuristic();
                }
                let des = -1;
                let fromexisting = false;
                if (widthMode == TextView.MeasureSpec.EXACTLY) {
                    width = widthSize;
                }
                else {
                    if (this.mLayout != null && this.mEllipsize == null) {
                        des = TextView.desired(this.mLayout);
                    }
                    if (des < 0) {
                        boring = BoringLayout.isBoring(this.mTransformed, this.mTextPaint, this.mTextDir, this.mBoring);
                        if (boring != null) {
                            this.mBoring = boring;
                        }
                    }
                    else {
                        fromexisting = true;
                    }
                    if (boring == null || boring == TextView.UNKNOWN_BORING) {
                        if (des < 0) {
                            des = Math.floor(Math.ceil(Layout.getDesiredWidth(this.mTransformed, this.mTextPaint)));
                        }
                        width = des;
                    }
                    else {
                        width = boring.width;
                    }
                    const dr = this.mDrawables;
                    if (dr != null) {
                        width = Math.max(width, dr.mDrawableWidthTop);
                        width = Math.max(width, dr.mDrawableWidthBottom);
                    }
                    if (this.mHint != null) {
                        let hintDes = -1;
                        let hintWidth;
                        if (this.mHintLayout != null && this.mEllipsize == null) {
                            hintDes = TextView.desired(this.mHintLayout);
                        }
                        if (hintDes < 0) {
                            hintBoring = BoringLayout.isBoring(this.mHint, this.mTextPaint, this.mTextDir, this.mHintBoring);
                            if (hintBoring != null) {
                                this.mHintBoring = hintBoring;
                            }
                        }
                        if (hintBoring == null || hintBoring == TextView.UNKNOWN_BORING) {
                            if (hintDes < 0) {
                                hintDes = Math.floor(Math.ceil(Layout.getDesiredWidth(this.mHint, this.mTextPaint)));
                            }
                            hintWidth = hintDes;
                        }
                        else {
                            hintWidth = hintBoring.width;
                        }
                        if (hintWidth > width) {
                            width = hintWidth;
                        }
                    }
                    width += this.getCompoundPaddingLeft() + this.getCompoundPaddingRight();
                    if (this.mMaxWidthMode == TextView.EMS) {
                        width = Math.min(width, this.mMaxWidthValue * this.getLineHeight());
                    }
                    else {
                        width = Math.min(width, this.mMaxWidthValue);
                    }
                    if (this.mMinWidthMode == TextView.EMS) {
                        width = Math.max(width, this.mMinWidthValue * this.getLineHeight());
                    }
                    else {
                        width = Math.max(width, this.mMinWidthValue);
                    }
                    width = Math.max(width, this.getSuggestedMinimumWidth());
                    if (widthMode == TextView.MeasureSpec.AT_MOST) {
                        width = Math.min(widthSize, width);
                    }
                }
                let want = width - this.getCompoundPaddingLeft() - this.getCompoundPaddingRight();
                let unpaddedWidth = want;
                if (this.mHorizontallyScrolling)
                    want = TextView.VERY_WIDE;
                let hintWant = want;
                let hintWidth = (this.mHintLayout == null) ? hintWant : this.mHintLayout.getWidth();
                if (this.mLayout == null) {
                    this.makeNewLayout(want, hintWant, boring, hintBoring, width - this.getCompoundPaddingLeft() - this.getCompoundPaddingRight(), false);
                }
                else {
                    const layoutChanged = (this.mLayout.getWidth() != want) || (hintWidth != hintWant) || (this.mLayout.getEllipsizedWidth() != width - this.getCompoundPaddingLeft() - this.getCompoundPaddingRight());
                    const widthChanged = (this.mHint == null) && (this.mEllipsize == null) && (want > this.mLayout.getWidth()) && (this.mLayout instanceof BoringLayout || (fromexisting && des >= 0 && des <= want));
                    const maximumChanged = (this.mMaxMode != this.mOldMaxMode) || (this.mMaximum != this.mOldMaximum);
                    if (layoutChanged || maximumChanged) {
                        if (!maximumChanged && widthChanged) {
                            this.mLayout.increaseWidthTo(want);
                        }
                        else {
                            this.makeNewLayout(want, hintWant, boring, hintBoring, width - this.getCompoundPaddingLeft() - this.getCompoundPaddingRight(), false);
                        }
                    }
                    else {
                    }
                }
                if (heightMode == TextView.MeasureSpec.EXACTLY) {
                    height = heightSize;
                    this.mDesiredHeightAtMeasure = -1;
                }
                else {
                    let desired = this.getDesiredHeight();
                    height = desired;
                    this.mDesiredHeightAtMeasure = desired;
                    if (heightMode == TextView.MeasureSpec.AT_MOST) {
                        height = Math.min(desired, heightSize);
                    }
                }
                let unpaddedHeight = height - this.getCompoundPaddingTop() - this.getCompoundPaddingBottom();
                if (this.mMaxMode == TextView.LINES && this.mLayout.getLineCount() > this.mMaximum) {
                    unpaddedHeight = Math.min(unpaddedHeight, this.mLayout.getLineTop(this.mMaximum));
                }
                if (this.mMovement != null || this.mLayout.getWidth() > unpaddedWidth || this.mLayout.getHeight() > unpaddedHeight) {
                    this.registerForPreDraw();
                }
                else {
                    this.scrollTo(0, 0);
                }
                this.setMeasuredDimension(width, height);
            }
            getDesiredHeight(layout, cap = true) {
                if (arguments.length === 0) {
                    return Math.max(this.getDesiredHeight(this.mLayout, true), this.getDesiredHeight(this.mHintLayout, this.mEllipsize != null));
                }
                if (layout == null) {
                    return 0;
                }
                let linecount = layout.getLineCount();
                let pad = this.getCompoundPaddingTop() + this.getCompoundPaddingBottom();
                let desired = layout.getLineTop(linecount);
                const dr = this.mDrawables;
                if (dr != null) {
                    desired = Math.max(desired, dr.mDrawableHeightLeft);
                    desired = Math.max(desired, dr.mDrawableHeightRight);
                }
                desired += pad;
                if (this.mMaxMode == TextView.LINES) {
                    if (cap) {
                        if (linecount > this.mMaximum) {
                            desired = layout.getLineTop(this.mMaximum);
                            if (dr != null) {
                                desired = Math.max(desired, dr.mDrawableHeightLeft);
                                desired = Math.max(desired, dr.mDrawableHeightRight);
                            }
                            desired += pad;
                            linecount = this.mMaximum;
                        }
                    }
                }
                else {
                    desired = Math.min(desired, this.mMaximum);
                }
                if (this.mMinMode == TextView.LINES) {
                    if (linecount < this.mMinimum) {
                        desired += this.getLineHeight() * (this.mMinimum - linecount);
                    }
                }
                else {
                    desired = Math.max(desired, this.mMinimum);
                }
                desired = Math.max(desired, this.getSuggestedMinimumHeight());
                return desired;
            }
            checkForResize() {
                let sizeChanged = false;
                if (this.mLayout != null) {
                    if (this.mLayoutParams.width == LayoutParams.WRAP_CONTENT) {
                        sizeChanged = true;
                        this.invalidate();
                    }
                    if (this.mLayoutParams.height == LayoutParams.WRAP_CONTENT) {
                        let desiredHeight = this.getDesiredHeight();
                        if (desiredHeight != this.getHeight()) {
                            sizeChanged = true;
                        }
                    }
                    else if (this.mLayoutParams.height == LayoutParams.MATCH_PARENT) {
                        if (this.mDesiredHeightAtMeasure >= 0) {
                            let desiredHeight = this.getDesiredHeight();
                            if (desiredHeight != this.mDesiredHeightAtMeasure) {
                                sizeChanged = true;
                            }
                        }
                    }
                }
                if (sizeChanged) {
                    this.requestLayout();
                }
            }
            checkForRelayout() {
                if ((this.mLayoutParams.width != LayoutParams.WRAP_CONTENT || (this.mMaxWidthMode == this.mMinWidthMode && this.mMaxWidthValue == this.mMinWidthValue)) && (this.mHint == null || this.mHintLayout != null) && (this.mRight - this.mLeft - this.getCompoundPaddingLeft() - this.getCompoundPaddingRight() > 0)) {
                    let oldht = this.mLayout.getHeight();
                    let want = this.mLayout.getWidth();
                    let hintWant = this.mHintLayout == null ? 0 : this.mHintLayout.getWidth();
                    this.makeNewLayout(want, hintWant, TextView.UNKNOWN_BORING, TextView.UNKNOWN_BORING, this.mRight - this.mLeft - this.getCompoundPaddingLeft() - this.getCompoundPaddingRight(), false);
                    if (this.mEllipsize != TextUtils.TruncateAt.MARQUEE) {
                        if (this.mLayoutParams.height != LayoutParams.WRAP_CONTENT && this.mLayoutParams.height != LayoutParams.MATCH_PARENT) {
                            this.invalidate();
                            return;
                        }
                        if (this.mLayout.getHeight() == oldht && (this.mHintLayout == null || this.mHintLayout.getHeight() == oldht)) {
                            this.invalidate();
                            return;
                        }
                    }
                    this.requestLayout();
                    this.invalidate();
                }
                else {
                    this.nullLayouts();
                    this.requestLayout();
                    this.invalidate();
                }
            }
            onLayout(changed, left, top, right, bottom) {
                super.onLayout(changed, left, top, right, bottom);
                if (this.mDeferScroll >= 0) {
                    let curs = this.mDeferScroll;
                    this.mDeferScroll = -1;
                    this.bringPointIntoView(Math.min(curs, this.mText.length));
                }
            }
            isShowingHint() {
                return TextUtils.isEmpty(this.mText) && !TextUtils.isEmpty(this.mHint);
            }
            bringTextIntoView() {
                let layout = this.isShowingHint() ? this.mHintLayout : this.mLayout;
                let line = 0;
                if ((this.mGravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.BOTTOM) {
                    line = layout.getLineCount() - 1;
                }
                let a = layout.getParagraphAlignment(line);
                let dir = layout.getParagraphDirection(line);
                let hspace = this.mRight - this.mLeft - this.getCompoundPaddingLeft() - this.getCompoundPaddingRight();
                let vspace = this.mBottom - this.mTop - this.getExtendedPaddingTop() - this.getExtendedPaddingBottom();
                let ht = layout.getHeight();
                let scrollx, scrolly;
                if (a == Layout.Alignment.ALIGN_NORMAL) {
                    a = dir == Layout.DIR_LEFT_TO_RIGHT ? Layout.Alignment.ALIGN_LEFT : Layout.Alignment.ALIGN_RIGHT;
                }
                else if (a == Layout.Alignment.ALIGN_OPPOSITE) {
                    a = dir == Layout.DIR_LEFT_TO_RIGHT ? Layout.Alignment.ALIGN_RIGHT : Layout.Alignment.ALIGN_LEFT;
                }
                if (a == Layout.Alignment.ALIGN_CENTER) {
                    let left = Math.floor(Math.floor(layout.getLineLeft(line)));
                    let right = Math.floor(Math.ceil(layout.getLineRight(line)));
                    if (right - left < hspace) {
                        scrollx = (right + left) / 2 - hspace / 2;
                    }
                    else {
                        if (dir < 0) {
                            scrollx = right - hspace;
                        }
                        else {
                            scrollx = left;
                        }
                    }
                }
                else if (a == Layout.Alignment.ALIGN_RIGHT) {
                    let right = Math.floor(Math.ceil(layout.getLineRight(line)));
                    scrollx = right - hspace;
                }
                else {
                    scrollx = Math.floor(Math.floor(layout.getLineLeft(line)));
                }
                if (ht < vspace) {
                    scrolly = 0;
                }
                else {
                    if ((this.mGravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.BOTTOM) {
                        scrolly = ht - vspace;
                    }
                    else {
                        scrolly = 0;
                    }
                }
                if (scrollx != this.mScrollX || scrolly != this.mScrollY) {
                    this.scrollTo(scrollx, scrolly);
                    return true;
                }
                else {
                    return false;
                }
            }
            bringPointIntoView(offset) {
                if (this.isLayoutRequested()) {
                    this.mDeferScroll = offset;
                    return false;
                }
                let changed = false;
                let layout = this.isShowingHint() ? this.mHintLayout : this.mLayout;
                if (layout == null)
                    return changed;
                let line = layout.getLineForOffset(offset);
                let grav;
                switch (layout.getParagraphAlignment(line)) {
                    case Layout.Alignment.ALIGN_LEFT:
                        grav = 1;
                        break;
                    case Layout.Alignment.ALIGN_RIGHT:
                        grav = -1;
                        break;
                    case Layout.Alignment.ALIGN_NORMAL:
                        grav = layout.getParagraphDirection(line);
                        break;
                    case Layout.Alignment.ALIGN_OPPOSITE:
                        grav = -layout.getParagraphDirection(line);
                        break;
                    case Layout.Alignment.ALIGN_CENTER:
                    default:
                        grav = 0;
                        break;
                }
                const clamped = grav > 0;
                const x = Math.floor(layout.getPrimaryHorizontal(offset, clamped));
                const top = layout.getLineTop(line);
                const bottom = layout.getLineTop(line + 1);
                let left = Math.floor(Math.floor(layout.getLineLeft(line)));
                let right = Math.floor(Math.ceil(layout.getLineRight(line)));
                let ht = layout.getHeight();
                let hspace = this.mRight - this.mLeft - this.getCompoundPaddingLeft() - this.getCompoundPaddingRight();
                let vspace = this.mBottom - this.mTop - this.getExtendedPaddingTop() - this.getExtendedPaddingBottom();
                if (!this.mHorizontallyScrolling && right - left > hspace && right > x) {
                    right = Math.max(x, left + hspace);
                }
                let hslack = (bottom - top) / 2;
                let vslack = hslack;
                if (vslack > vspace / 4)
                    vslack = vspace / 4;
                if (hslack > hspace / 4)
                    hslack = hspace / 4;
                let hs = this.mScrollX;
                let vs = this.mScrollY;
                if (top - vs < vslack)
                    vs = top - vslack;
                if (bottom - vs > vspace - vslack)
                    vs = bottom - (vspace - vslack);
                if (ht - vs < vspace)
                    vs = ht - vspace;
                if (0 - vs > 0)
                    vs = 0;
                if (grav != 0) {
                    if (x - hs < hslack) {
                        hs = x - hslack;
                    }
                    if (x - hs > hspace - hslack) {
                        hs = x - (hspace - hslack);
                    }
                }
                if (grav < 0) {
                    if (left - hs > 0)
                        hs = left;
                    if (right - hs < hspace)
                        hs = right - hspace;
                }
                else if (grav > 0) {
                    if (right - hs < hspace)
                        hs = right - hspace;
                    if (left - hs > 0)
                        hs = left;
                }
                else {
                    if (right - left <= hspace) {
                        hs = left - (hspace - (right - left)) / 2;
                    }
                    else if (x > right - hslack) {
                        hs = right - hspace;
                    }
                    else if (x < left + hslack) {
                        hs = left;
                    }
                    else if (left > hs) {
                        hs = left;
                    }
                    else if (right < hs + hspace) {
                        hs = right - hspace;
                    }
                    else {
                        if (x - hs < hslack) {
                            hs = x - hslack;
                        }
                        if (x - hs > hspace - hslack) {
                            hs = x - (hspace - hslack);
                        }
                    }
                }
                if (hs != this.mScrollX || vs != this.mScrollY) {
                    if (this.mScroller == null) {
                        this.scrollTo(hs, vs);
                    }
                    else {
                        let duration = AnimationUtils.currentAnimationTimeMillis() - this.mLastScroll;
                        let dx = hs - this.mScrollX;
                        let dy = vs - this.mScrollY;
                        if (duration > TextView.ANIMATED_SCROLL_GAP) {
                            this.mScroller.startScroll(this.mScrollX, this.mScrollY, dx, dy);
                            this.awakenScrollBars(this.mScroller.getDuration());
                            this.invalidate();
                        }
                        else {
                            if (!this.mScroller.isFinished()) {
                                this.mScroller.abortAnimation();
                            }
                            this.scrollBy(dx, dy);
                        }
                        this.mLastScroll = AnimationUtils.currentAnimationTimeMillis();
                    }
                    changed = true;
                }
                if (this.isFocused()) {
                    if (this.mTempRect == null)
                        this.mTempRect = new Rect();
                    this.mTempRect.set(x - 2, top, x + 2, bottom);
                    this.getInterestingRect(this.mTempRect, line);
                    this.mTempRect.offset(this.mScrollX, this.mScrollY);
                }
                return changed;
            }
            moveCursorToVisibleOffset() {
                return false;
            }
            computeScroll() {
                if (this.mScroller != null) {
                    if (this.mScroller.computeScrollOffset()) {
                        this.mScrollX = this.mScroller.getCurrX();
                        this.mScrollY = this.mScroller.getCurrY();
                        this.invalidateParentCaches();
                        this.postInvalidate();
                    }
                }
            }
            getInterestingRect(r, line) {
                this.convertFromViewportToContentCoordinates(r);
                if (line == 0)
                    r.top -= this.getExtendedPaddingTop();
                if (line == this.mLayout.getLineCount() - 1)
                    r.bottom += this.getExtendedPaddingBottom();
            }
            convertFromViewportToContentCoordinates(r) {
                const horizontalOffset = this.viewportToContentHorizontalOffset();
                r.left += horizontalOffset;
                r.right += horizontalOffset;
                const verticalOffset = this.viewportToContentVerticalOffset();
                r.top += verticalOffset;
                r.bottom += verticalOffset;
            }
            viewportToContentHorizontalOffset() {
                return this.getCompoundPaddingLeft() - this.mScrollX;
            }
            viewportToContentVerticalOffset() {
                let offset = this.getExtendedPaddingTop() - this.mScrollY;
                if ((this.mGravity & Gravity.VERTICAL_GRAVITY_MASK) != Gravity.TOP) {
                    offset += this.getVerticalOffset(false);
                }
                return offset;
            }
            getSelectionStart() {
                return -1;
            }
            getSelectionEnd() {
                return -1;
            }
            hasSelection() {
                const selectionStart = this.getSelectionStart();
                const selectionEnd = this.getSelectionEnd();
                return selectionStart >= 0 && selectionStart != selectionEnd;
            }
            setAllCaps(allCaps) {
                if (allCaps) {
                    this.setTransformationMethod(new AllCapsTransformationMethod());
                }
                else {
                    this.setTransformationMethod(null);
                }
            }
            setSingleLine(singleLine = true) {
                this.setInputTypeSingleLine(singleLine);
                this.applySingleLine(singleLine, true, true);
            }
            setInputTypeSingleLine(singleLine) {
            }
            applySingleLine(singleLine, applyTransformation, changeMaxLines) {
                this.mSingleLine = singleLine;
                if (singleLine) {
                    this.setLines(1);
                    this.setHorizontallyScrolling(true);
                    if (applyTransformation) {
                        this.setTransformationMethod(SingleLineTransformationMethod.getInstance());
                    }
                }
                else {
                    if (changeMaxLines) {
                        this.setMaxLines(Integer.MAX_VALUE);
                    }
                    this.setHorizontallyScrolling(false);
                    if (applyTransformation) {
                        this.setTransformationMethod(null);
                    }
                }
            }
            setEllipsize(where) {
                if (this.mEllipsize != where) {
                    this.mEllipsize = where;
                    if (this.mLayout != null) {
                        this.nullLayouts();
                        this.requestLayout();
                        this.invalidate();
                    }
                }
            }
            setMarqueeRepeatLimit(marqueeLimit) {
                this.mMarqueeRepeatLimit = marqueeLimit;
            }
            getMarqueeRepeatLimit() {
                return this.mMarqueeRepeatLimit;
            }
            getEllipsize() {
                return this.mEllipsize;
            }
            setSelectAllOnFocus(selectAllOnFocus) {
                this.createEditorIfNeeded();
                this.mEditor.mSelectAllOnFocus = selectAllOnFocus;
                if (selectAllOnFocus && !Spannable.isImpl(this.mText)) {
                    this.setText(this.mText, TextView.BufferType.SPANNABLE);
                }
            }
            setCursorVisible(visible) {
            }
            isCursorVisible() {
                return null;
            }
            canMarquee() {
                let width = (this.mRight - this.mLeft - this.getCompoundPaddingLeft() - this.getCompoundPaddingRight());
                return width > 0 && (this.mLayout.getLineWidth(0) > width || (this.mMarqueeFadeMode != TextView.MARQUEE_FADE_NORMAL && this.mSavedMarqueeModeLayout != null && this.mSavedMarqueeModeLayout.getLineWidth(0) > width));
            }
            startMarquee() {
                if (this.getKeyListener() != null)
                    return;
                if (this.compressText(this.getWidth() - this.getCompoundPaddingLeft() - this.getCompoundPaddingRight())) {
                    return;
                }
                if ((this.mMarquee == null || this.mMarquee.isStopped()) && (this.isFocused() || this.isSelected()) && this.getLineCount() == 1 && this.canMarquee()) {
                    if (this.mMarqueeFadeMode == TextView.MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) {
                        this.mMarqueeFadeMode = TextView.MARQUEE_FADE_SWITCH_SHOW_FADE;
                        const tmp = this.mLayout;
                        this.mLayout = this.mSavedMarqueeModeLayout;
                        this.mSavedMarqueeModeLayout = tmp;
                        this.setHorizontalFadingEdgeEnabled(true);
                        this.requestLayout();
                        this.invalidate();
                    }
                    if (this.mMarquee == null)
                        this.mMarquee = new TextView.Marquee(this);
                    this.mMarquee.start(this.mMarqueeRepeatLimit);
                }
            }
            stopMarquee() {
                if (this.mMarquee != null && !this.mMarquee.isStopped()) {
                    this.mMarquee.stop();
                }
                if (this.mMarqueeFadeMode == TextView.MARQUEE_FADE_SWITCH_SHOW_FADE) {
                    this.mMarqueeFadeMode = TextView.MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS;
                    const tmp = this.mSavedMarqueeModeLayout;
                    this.mSavedMarqueeModeLayout = this.mLayout;
                    this.mLayout = tmp;
                    this.setHorizontalFadingEdgeEnabled(false);
                    this.requestLayout();
                    this.invalidate();
                }
            }
            startStopMarquee(start) {
                if (this.mEllipsize == TextUtils.TruncateAt.MARQUEE) {
                    if (start) {
                        this.startMarquee();
                    }
                    else {
                        this.stopMarquee();
                    }
                }
            }
            onTextChanged(text, start, lengthBefore, lengthAfter) {
            }
            onSelectionChanged(selStart, selEnd) {
            }
            addTextChangedListener(watcher) {
                if (this.mListeners == null) {
                    this.mListeners = new ArrayList();
                }
                this.mListeners.add(watcher);
            }
            removeTextChangedListener(watcher) {
                if (this.mListeners != null) {
                    let i = this.mListeners.indexOf(watcher);
                    if (i >= 0) {
                        this.mListeners.remove(i);
                    }
                }
            }
            sendBeforeTextChanged(text, start, before, after) {
                if (this.mListeners != null) {
                    const list = this.mListeners;
                    const count = list.size();
                    for (let i = 0; i < count; i++) {
                        list.get(i).beforeTextChanged(text, start, before, after);
                    }
                }
            }
            removeAdjacentSuggestionSpans(pos) {
            }
            sendOnTextChanged(text, start, before, after) {
                if (this.mListeners != null) {
                    const list = this.mListeners;
                    const count = list.size();
                    for (let i = 0; i < count; i++) {
                        list.get(i).onTextChanged(text, start, before, after);
                    }
                }
            }
            sendAfterTextChanged(text) {
                if (this.mListeners != null) {
                    const list = this.mListeners;
                    const count = list.size();
                    for (let i = 0; i < count; i++) {
                        list.get(i).afterTextChanged(text + '');
                    }
                }
            }
            updateAfterEdit() {
                this.invalidate();
                let curs = this.getSelectionStart();
                if (curs >= 0 || (this.mGravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.BOTTOM) {
                    this.registerForPreDraw();
                }
                this.checkForResize();
                if (curs >= 0) {
                    this.mHighlightPathBogus = true;
                    this.bringPointIntoView(curs);
                }
            }
            handleTextChanged(buffer, start, before, after) {
                this.updateAfterEdit();
                this.sendOnTextChanged(buffer, start, before, after);
                this.onTextChanged(buffer, start, before, after);
            }
            spanChange(buf, what, oldStart, newStart, oldEnd, newEnd) {
                let selChanged = false;
                let newSelStart = -1, newSelEnd = -1;
                this.invalidate();
                this.mHighlightPathBogus = true;
                this.checkForResize();
            }
            dispatchFinishTemporaryDetach() {
                this.mDispatchTemporaryDetach = true;
                super.dispatchFinishTemporaryDetach();
                this.mDispatchTemporaryDetach = false;
            }
            onStartTemporaryDetach() {
                super.onStartTemporaryDetach();
                if (!this.mDispatchTemporaryDetach)
                    this.mTemporaryDetach = true;
            }
            onFinishTemporaryDetach() {
                super.onFinishTemporaryDetach();
                if (!this.mDispatchTemporaryDetach)
                    this.mTemporaryDetach = false;
            }
            onFocusChanged(focused, direction, previouslyFocusedRect) {
                if (this.mTemporaryDetach) {
                    super.onFocusChanged(focused, direction, previouslyFocusedRect);
                    return;
                }
                this.startStopMarquee(focused);
                if (this.mTransformation != null) {
                    this.mTransformation.onFocusChanged(this, this.mText, focused, direction, previouslyFocusedRect);
                }
                super.onFocusChanged(focused, direction, previouslyFocusedRect);
            }
            onWindowFocusChanged(hasWindowFocus) {
                super.onWindowFocusChanged(hasWindowFocus);
                this.startStopMarquee(hasWindowFocus);
            }
            onVisibilityChanged(changedView, visibility) {
                super.onVisibilityChanged(changedView, visibility);
            }
            clearComposingText() {
            }
            setSelected(selected) {
                let wasSelected = this.isSelected();
                super.setSelected(selected);
                if (selected != wasSelected && this.mEllipsize == TextUtils.TruncateAt.MARQUEE) {
                    if (selected) {
                        this.startMarquee();
                    }
                    else {
                        this.stopMarquee();
                    }
                }
            }
            onTouchEvent(event) {
                const action = event.getActionMasked();
                const superResult = super.onTouchEvent(event);
                const touchIsFinished = (action == MotionEvent.ACTION_UP)
                    && this.isFocused();
                if ((this.mMovement != null || this.onCheckIsTextEditor()) && this.isEnabled() && Spannable.isImpl(this.mText) && this.mLayout != null) {
                    let handled = false;
                    if (this.mMovement != null) {
                        handled = this.mMovement.onTouchEvent(this, this.mText, event) || handled;
                    }
                    if (handled) {
                        return true;
                    }
                }
                return superResult;
            }
            onGenericMotionEvent(event) {
                if (this.mMovement != null && Spannable.isImpl(this.mText) && this.mLayout != null) {
                    try {
                        if (this.mMovement.onGenericMotionEvent(this, this.mText, event)) {
                            return true;
                        }
                    }
                    catch (e) {
                    }
                }
                return super.onGenericMotionEvent(event);
            }
            isTextEditable() {
                return false;
            }
            didTouchFocusSelect() {
                return false;
            }
            cancelLongPress() {
                super.cancelLongPress();
            }
            setScroller(s) {
                this.mScroller = s;
            }
            getLeftFadingEdgeStrength() {
                if (this.mEllipsize == TextUtils.TruncateAt.MARQUEE && this.mMarqueeFadeMode != TextView.MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) {
                    if (this.mMarquee != null && !this.mMarquee.isStopped()) {
                        const marquee = this.mMarquee;
                        if (marquee.shouldDrawLeftFade()) {
                            const scroll = marquee.getScroll();
                            return scroll / this.getHorizontalFadingEdgeLength();
                        }
                        else {
                            return 0.0;
                        }
                    }
                    else if (this.getLineCount() == 1) {
                        const absoluteGravity = this.mGravity;
                        switch (absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
                            case Gravity.LEFT:
                                return 0.0;
                            case Gravity.RIGHT:
                                return (this.mLayout.getLineRight(0) - (this.mRight - this.mLeft) - this.getCompoundPaddingLeft() - this.getCompoundPaddingRight() - this.mLayout.getLineLeft(0)) / this.getHorizontalFadingEdgeLength();
                            case Gravity.CENTER_HORIZONTAL:
                            case Gravity.FILL_HORIZONTAL:
                                const textDirection = this.mLayout.getParagraphDirection(0);
                                if (textDirection == Layout.DIR_LEFT_TO_RIGHT) {
                                    return 0.0;
                                }
                                else {
                                    return (this.mLayout.getLineRight(0) - (this.mRight - this.mLeft) - this.getCompoundPaddingLeft() - this.getCompoundPaddingRight() - this.mLayout.getLineLeft(0)) / this.getHorizontalFadingEdgeLength();
                                }
                        }
                    }
                }
                return super.getLeftFadingEdgeStrength();
            }
            getRightFadingEdgeStrength() {
                if (this.mEllipsize == TextUtils.TruncateAt.MARQUEE && this.mMarqueeFadeMode != TextView.MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) {
                    if (this.mMarquee != null && !this.mMarquee.isStopped()) {
                        const marquee = this.mMarquee;
                        const maxFadeScroll = marquee.getMaxFadeScroll();
                        const scroll = marquee.getScroll();
                        return (maxFadeScroll - scroll) / this.getHorizontalFadingEdgeLength();
                    }
                    else if (this.getLineCount() == 1) {
                        const absoluteGravity = this.mGravity;
                        switch (absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
                            case Gravity.LEFT:
                                const textWidth = (this.mRight - this.mLeft) - this.getCompoundPaddingLeft() - this.getCompoundPaddingRight();
                                const lineWidth = this.mLayout.getLineWidth(0);
                                return (lineWidth - textWidth) / this.getHorizontalFadingEdgeLength();
                            case Gravity.RIGHT:
                                return 0.0;
                            case Gravity.CENTER_HORIZONTAL:
                            case Gravity.FILL_HORIZONTAL:
                                const textDirection = this.mLayout.getParagraphDirection(0);
                                if (textDirection == Layout.DIR_RIGHT_TO_LEFT) {
                                    return 0.0;
                                }
                                else {
                                    return (this.mLayout.getLineWidth(0) - ((this.mRight - this.mLeft) - this.getCompoundPaddingLeft() - this.getCompoundPaddingRight())) / this.getHorizontalFadingEdgeLength();
                                }
                        }
                    }
                }
                return super.getRightFadingEdgeStrength();
            }
            computeHorizontalScrollRange() {
                if (this.mLayout != null) {
                    return this.mSingleLine && (this.mGravity & Gravity.HORIZONTAL_GRAVITY_MASK) == Gravity.LEFT ? Math.floor(this.mLayout.getLineWidth(0)) : this.mLayout.getWidth();
                }
                return super.computeHorizontalScrollRange();
            }
            computeVerticalScrollRange() {
                if (this.mLayout != null)
                    return this.mLayout.getHeight();
                return super.computeVerticalScrollRange();
            }
            computeVerticalScrollExtent() {
                return this.getHeight() - this.getCompoundPaddingTop() - this.getCompoundPaddingBottom();
            }
            static getTextColors() {
                return android.R.attr.textViewStyle.textColor;
            }
            static getTextColor(def) {
                let colors = this.getTextColors();
                if (colors == null) {
                    return def;
                }
                else {
                    return colors.getDefaultColor();
                }
            }
            canSelectText() {
                return false;
            }
            textCanBeSelected() {
                return false;
            }
            getTransformedText(start, end) {
                return this.removeSuggestionSpans(this.mTransformed.substring(start, end));
            }
            performLongClick() {
                let handled = false;
                if (super.performLongClick()) {
                    handled = true;
                }
                if (handled) {
                    this.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
                }
                return handled;
            }
            isSuggestionsEnabled() {
                return false;
            }
            setCustomSelectionActionModeCallback(actionModeCallback) {
                this.createEditorIfNeeded();
            }
            getCustomSelectionActionModeCallback() {
                return null;
            }
            stopSelectionActionMode() {
            }
            canCut() {
                return false;
            }
            canCopy() {
                return true;
            }
            canPaste() {
                return false;
            }
            selectAllText() {
                return false;
            }
            getOffsetForPosition(x, y) {
                if (this.getLayout() == null)
                    return -1;
                const line = this.getLineAtCoordinate(y);
                const offset = this.getOffsetAtCoordinate(line, x);
                return offset;
            }
            convertToLocalHorizontalCoordinate(x) {
                x -= this.getTotalPaddingLeft();
                x = Math.max(0.0, x);
                x = Math.min(this.getWidth() - this.getTotalPaddingRight() - 1, x);
                x += this.getScrollX();
                return x;
            }
            getLineAtCoordinate(y) {
                y -= this.getTotalPaddingTop();
                y = Math.max(0.0, y);
                y = Math.min(this.getHeight() - this.getTotalPaddingBottom() - 1, y);
                y += this.getScrollY();
                return this.getLayout().getLineForVertical(Math.floor(y));
            }
            getOffsetAtCoordinate(line, x) {
                x = this.convertToLocalHorizontalCoordinate(x);
                return this.getLayout().getOffsetForHorizontal(line, x);
            }
            isInBatchEditMode() {
                return false;
            }
            getTextDirectionHeuristic() {
                return TextDirectionHeuristics.LTR;
            }
            onResolveDrawables(layoutDirection) {
                if (this.mLastLayoutDirection == layoutDirection) {
                    return;
                }
                this.mLastLayoutDirection = layoutDirection;
                if (this.mDrawables != null) {
                    this.mDrawables.resolveWithLayoutDirection(layoutDirection);
                }
            }
            resetResolvedDrawables() {
                this.mLastLayoutDirection = -1;
            }
            deleteText_internal(start, end) {
            }
            replaceText_internal(start, end, text) {
            }
            setSpan_internal(span, start, end, flags) {
            }
            setCursorPosition_internal(start, end) {
            }
            createEditorIfNeeded() {
            }
        }
        TextView.LOG_TAG = "TextView";
        TextView.DEBUG_EXTRACT = false;
        TextView.SANS = 1;
        TextView.SERIF = 2;
        TextView.MONOSPACE = 3;
        TextView.SIGNED = 2;
        TextView.DECIMAL = 4;
        TextView.MARQUEE_FADE_NORMAL = 0;
        TextView.MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS = 1;
        TextView.MARQUEE_FADE_SWITCH_SHOW_FADE = 2;
        TextView.LINES = 1;
        TextView.EMS = TextView.LINES;
        TextView.PIXELS = 2;
        TextView.TEMP_RECTF = new RectF();
        TextView.VERY_WIDE = 1024 * 1024;
        TextView.ANIMATED_SCROLL_GAP = 250;
        TextView.NO_FILTERS = new Array(0);
        TextView.CHANGE_WATCHER_PRIORITY = 100;
        TextView.MULTILINE_STATE_SET = [1 << 10];
        TextView.LAST_CUT_OR_COPY_TIME = 0;
        TextView.UNKNOWN_BORING = new BoringLayout.Metrics();
        widget.TextView = TextView;
        (function (TextView) {
            class Drawables {
                constructor(context) {
                    this.mCompoundRect = new Rect();
                    this.mDrawableSizeTop = 0;
                    this.mDrawableSizeBottom = 0;
                    this.mDrawableSizeLeft = 0;
                    this.mDrawableSizeRight = 0;
                    this.mDrawableSizeStart = 0;
                    this.mDrawableSizeEnd = 0;
                    this.mDrawableSizeError = 0;
                    this.mDrawableSizeTemp = 0;
                    this.mDrawableWidthTop = 0;
                    this.mDrawableWidthBottom = 0;
                    this.mDrawableHeightLeft = 0;
                    this.mDrawableHeightRight = 0;
                    this.mDrawableHeightStart = 0;
                    this.mDrawableHeightEnd = 0;
                    this.mDrawableHeightError = 0;
                    this.mDrawableHeightTemp = 0;
                    this.mDrawablePadding = 0;
                    this.mDrawableSaved = Drawables.DRAWABLE_NONE;
                    this.mIsRtlCompatibilityMode = false;
                    this.mOverride = false;
                }
                resolveWithLayoutDirection(layoutDirection) {
                    this.mDrawableLeft = this.mDrawableLeftInitial;
                    this.mDrawableRight = this.mDrawableRightInitial;
                    if (this.mOverride) {
                        this.mDrawableLeft = this.mDrawableStart;
                        this.mDrawableSizeLeft = this.mDrawableSizeStart;
                        this.mDrawableHeightLeft = this.mDrawableHeightStart;
                        this.mDrawableRight = this.mDrawableEnd;
                        this.mDrawableSizeRight = this.mDrawableSizeEnd;
                        this.mDrawableHeightRight = this.mDrawableHeightEnd;
                    }
                    this.applyErrorDrawableIfNeeded(layoutDirection);
                    this.updateDrawablesLayoutDirection(layoutDirection);
                }
                updateDrawablesLayoutDirection(layoutDirection) {
                }
                setErrorDrawable(dr, tv) {
                    if (this.mDrawableError != dr && this.mDrawableError != null) {
                        this.mDrawableError.setCallback(null);
                    }
                    this.mDrawableError = dr;
                    const compoundRect = this.mCompoundRect;
                    let state = tv.getDrawableState();
                    if (this.mDrawableError != null) {
                        this.mDrawableError.setState(state);
                        this.mDrawableError.copyBounds(compoundRect);
                        this.mDrawableError.setCallback(tv);
                        this.mDrawableSizeError = compoundRect.width();
                        this.mDrawableHeightError = compoundRect.height();
                    }
                    else {
                        this.mDrawableSizeError = this.mDrawableHeightError = 0;
                    }
                }
                applyErrorDrawableIfNeeded(layoutDirection) {
                    switch (this.mDrawableSaved) {
                        case Drawables.DRAWABLE_LEFT:
                            this.mDrawableLeft = this.mDrawableTemp;
                            this.mDrawableSizeLeft = this.mDrawableSizeTemp;
                            this.mDrawableHeightLeft = this.mDrawableHeightTemp;
                            break;
                        case Drawables.DRAWABLE_RIGHT:
                            this.mDrawableRight = this.mDrawableTemp;
                            this.mDrawableSizeRight = this.mDrawableSizeTemp;
                            this.mDrawableHeightRight = this.mDrawableHeightTemp;
                            break;
                        case Drawables.DRAWABLE_NONE:
                        default:
                    }
                    this.mDrawableSaved = Drawables.DRAWABLE_RIGHT;
                    this.mDrawableTemp = this.mDrawableRight;
                    this.mDrawableSizeTemp = this.mDrawableSizeRight;
                    this.mDrawableHeightTemp = this.mDrawableHeightRight;
                    this.mDrawableRight = this.mDrawableError;
                    this.mDrawableSizeRight = this.mDrawableSizeError;
                    this.mDrawableHeightRight = this.mDrawableHeightError;
                }
            }
            Drawables.DRAWABLE_NONE = -1;
            Drawables.DRAWABLE_RIGHT = 0;
            Drawables.DRAWABLE_LEFT = 1;
            TextView.Drawables = Drawables;
            class Marquee extends Handler {
                constructor(v) {
                    super();
                    this.mStatus = Marquee.MARQUEE_STOPPED;
                    this.mScrollUnit = 0;
                    this.mMaxScroll = 0;
                    this.mMaxFadeScroll = 0;
                    this.mGhostStart = 0;
                    this.mGhostOffset = 0;
                    this.mFadeStop = 0;
                    this.mRepeatLimit = 0;
                    this.mScroll = 0;
                    const density = v.getResources().getDisplayMetrics().density;
                    this.mScrollUnit = (Marquee.MARQUEE_PIXELS_PER_SECOND * density) / Marquee.MARQUEE_RESOLUTION;
                    this.mView = new WeakReference(v);
                }
                handleMessage(msg) {
                    switch (msg.what) {
                        case Marquee.MESSAGE_START:
                            this.mStatus = Marquee.MARQUEE_RUNNING;
                            this.tick();
                            break;
                        case Marquee.MESSAGE_TICK:
                            this.tick();
                            break;
                        case Marquee.MESSAGE_RESTART:
                            if (this.mStatus == Marquee.MARQUEE_RUNNING) {
                                if (this.mRepeatLimit >= 0) {
                                    this.mRepeatLimit--;
                                }
                                this.start(this.mRepeatLimit);
                            }
                            break;
                    }
                }
                tick() {
                    if (this.mStatus != Marquee.MARQUEE_RUNNING) {
                        return;
                    }
                    this.removeMessages(Marquee.MESSAGE_TICK);
                    const textView = this.mView.get();
                    if (textView != null && (textView.isFocused() || textView.isSelected())) {
                        this.mScroll += this.mScrollUnit;
                        if (this.mScroll > this.mMaxScroll) {
                            this.mScroll = this.mMaxScroll;
                            this.sendEmptyMessageDelayed(Marquee.MESSAGE_RESTART, Marquee.MARQUEE_RESTART_DELAY);
                        }
                        else {
                            this.sendEmptyMessageDelayed(Marquee.MESSAGE_TICK, Marquee.MARQUEE_RESOLUTION);
                        }
                        textView.invalidate();
                    }
                }
                stop() {
                    this.mStatus = Marquee.MARQUEE_STOPPED;
                    this.removeMessages(Marquee.MESSAGE_START);
                    this.removeMessages(Marquee.MESSAGE_RESTART);
                    this.removeMessages(Marquee.MESSAGE_TICK);
                    this.resetScroll();
                }
                resetScroll() {
                    this.mScroll = 0.0;
                    const textView = this.mView.get();
                    if (textView != null)
                        textView.invalidate();
                }
                start(repeatLimit) {
                    if (repeatLimit == 0) {
                        this.stop();
                        return;
                    }
                    this.mRepeatLimit = repeatLimit;
                    const textView = this.mView.get();
                    if (textView != null && textView.mLayout != null) {
                        this.mStatus = Marquee.MARQUEE_STARTING;
                        this.mScroll = 0.0;
                        const textWidth = textView.getWidth() - textView.getCompoundPaddingLeft() - textView.getCompoundPaddingRight();
                        const lineWidth = textView.mLayout.getLineWidth(0);
                        const gap = textWidth / 3.0;
                        this.mGhostStart = lineWidth - textWidth + gap;
                        this.mMaxScroll = this.mGhostStart + textWidth;
                        this.mGhostOffset = lineWidth + gap;
                        this.mFadeStop = lineWidth + textWidth / 6.0;
                        this.mMaxFadeScroll = this.mGhostStart + lineWidth + lineWidth;
                        textView.invalidate();
                        this.sendEmptyMessageDelayed(Marquee.MESSAGE_START, Marquee.MARQUEE_DELAY);
                    }
                }
                getGhostOffset() {
                    return this.mGhostOffset;
                }
                getScroll() {
                    return this.mScroll;
                }
                getMaxFadeScroll() {
                    return this.mMaxFadeScroll;
                }
                shouldDrawLeftFade() {
                    return this.mScroll <= this.mFadeStop;
                }
                shouldDrawGhost() {
                    return this.mStatus == Marquee.MARQUEE_RUNNING && this.mScroll > this.mGhostStart;
                }
                isRunning() {
                    return this.mStatus == Marquee.MARQUEE_RUNNING;
                }
                isStopped() {
                    return this.mStatus == Marquee.MARQUEE_STOPPED;
                }
            }
            Marquee.MARQUEE_DELTA_MAX = 0.07;
            Marquee.MARQUEE_DELAY = 1200;
            Marquee.MARQUEE_RESTART_DELAY = 1200;
            Marquee.MARQUEE_RESOLUTION = 1000 / 30;
            Marquee.MARQUEE_PIXELS_PER_SECOND = 30;
            Marquee.MARQUEE_STOPPED = 0x0;
            Marquee.MARQUEE_STARTING = 0x1;
            Marquee.MARQUEE_RUNNING = 0x2;
            Marquee.MESSAGE_START = 0x1;
            Marquee.MESSAGE_TICK = 0x2;
            Marquee.MESSAGE_RESTART = 0x3;
            TextView.Marquee = Marquee;
            class ChangeWatcher {
                constructor(arg) {
                    this._TextView_this = arg;
                }
                beforeTextChanged(buffer, start, before, after) {
                    if (TextView.DEBUG_EXTRACT)
                        Log.v(TextView.LOG_TAG, "beforeTextChanged start=" + start + " before=" + before + " after=" + after + ": " + buffer);
                    this._TextView_this.sendBeforeTextChanged(buffer, start, before, after);
                }
                onTextChanged(buffer, start, before, after) {
                    if (TextView.DEBUG_EXTRACT)
                        Log.v(TextView.LOG_TAG, "onTextChanged start=" + start + " before=" + before + " after=" + after + ": " + buffer);
                    this._TextView_this.handleTextChanged(buffer, start, before, after);
                }
                afterTextChanged(buffer) {
                    if (TextView.DEBUG_EXTRACT)
                        Log.v(TextView.LOG_TAG, "afterTextChanged: " + buffer);
                    this._TextView_this.sendAfterTextChanged(buffer);
                }
                onSpanChanged(buf, what, s, e, st, en) {
                    if (TextView.DEBUG_EXTRACT)
                        Log.v(TextView.LOG_TAG, "onSpanChanged s=" + s + " e=" + e + " st=" + st + " en=" + en + " what=" + what + ": " + buf);
                    this._TextView_this.spanChange(buf, what, s, st, e, en);
                }
                onSpanAdded(buf, what, s, e) {
                    if (TextView.DEBUG_EXTRACT)
                        Log.v(TextView.LOG_TAG, "onSpanAdded s=" + s + " e=" + e + " what=" + what + ": " + buf);
                    this._TextView_this.spanChange(buf, what, -1, s, -1, e);
                }
                onSpanRemoved(buf, what, s, e) {
                    if (TextView.DEBUG_EXTRACT)
                        Log.v(TextView.LOG_TAG, "onSpanRemoved s=" + s + " e=" + e + " what=" + what + ": " + buf);
                    this._TextView_this.spanChange(buf, what, s, -1, e, -1);
                }
            }
            TextView.ChangeWatcher = ChangeWatcher;
            (function (BufferType) {
                BufferType[BufferType["NORMAL"] = 0] = "NORMAL";
                BufferType[BufferType["SPANNABLE"] = 1] = "SPANNABLE";
                BufferType[BufferType["EDITABLE"] = 2] = "EDITABLE";
            })(TextView.BufferType || (TextView.BufferType = {}));
            var BufferType = TextView.BufferType;
        })(TextView = widget.TextView || (widget.TextView = {}));
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/2.
 */
///<reference path="TextView.ts"/>
///<reference path="../view/View.ts"/>
///<reference path="../R/attr.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        class Button extends widget.TextView {
            constructor(bindElement, rootElement) {
                super(bindElement, rootElement);
                this.applyDefaultAttributes(android.R.attr.buttonStyle);
            }
        }
        widget.Button = Button;
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/7.
 */
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/widget/ImageView.ts"/>
var androidui;
(function (androidui) {
    var widget;
    (function (widget) {
        var View = android.view.View;
        var MeasureSpec = View.MeasureSpec;
        var ImageView = android.widget.ImageView;
        window.addEventListener('AndroidUILoadFinish', () => {
            eval('ImageView = android.widget.ImageView;');
        });
        class HtmlImageView extends View {
            constructor(bindElement, rootElement) {
                super(bindElement, rootElement);
                this.mHaveFrame = false;
                this.mAdjustViewBounds = false;
                this.mMaxWidth = Number.MAX_SAFE_INTEGER;
                this.mMaxHeight = Number.MAX_SAFE_INTEGER;
                this.mAlpha = 255;
                this.mDrawableWidth = 0;
                this.mDrawableHeight = 0;
                this.mAdjustViewBoundsCompat = false;
                this.initImageView();
                this._attrBinder.addAttr('src', (value) => {
                    this.setImageURI(value);
                }, () => {
                    return this.mImgElement.src;
                });
                this._attrBinder.addAttr('adjustViewBounds', (value) => {
                    this.setAdjustViewBounds(this._attrBinder.parseBoolean(value, false));
                });
                this._attrBinder.addAttr('maxWidth', (value) => {
                    let baseValue = this.getParent() instanceof View ? this.getParent().getWidth() : 0;
                    this.setMaxWidth(this._attrBinder.parseNumber(value, this.mMaxWidth, baseValue));
                }, () => {
                    return this.mMaxWidth;
                });
                this._attrBinder.addAttr('maxHeight', (value) => {
                    let baseValue = this.getParent() instanceof View ? this.getParent().getHeight() : 0;
                    this.setMaxHeight(this._attrBinder.parseNumber(value, this.mMaxHeight, baseValue));
                }, () => {
                    return this.mMaxHeight;
                });
                this._attrBinder.addAttr('scaleType', (value) => {
                    this.setScaleType(ImageView.ScaleType.parseScaleType(value, this.mScaleType));
                }, () => {
                    return this.mScaleType.toString();
                });
            }
            initImageView() {
                this.mScaleType = ImageView.ScaleType.FIT_CENTER;
                this.mImgElement = document.createElement('img');
                this.mImgElement.style.position = "absolute";
                this.mImgElement.onload = (() => {
                    this.mImgElement.style.left = 0 + 'px';
                    this.mImgElement.style.top = 0 + 'px';
                    this.mImgElement.style.width = '';
                    this.mImgElement.style.height = '';
                    this.mDrawableWidth = this.mImgElement.width;
                    this.mDrawableHeight = this.mImgElement.height;
                    this.mImgElement.style.display = 'none';
                    this.mImgElement.style.opacity = '';
                    this.requestLayout();
                });
                this.bindElement.appendChild(this.mImgElement);
            }
            getAdjustViewBounds() {
                return this.mAdjustViewBounds;
            }
            setAdjustViewBounds(adjustViewBounds) {
                this.mAdjustViewBounds = adjustViewBounds;
                if (adjustViewBounds) {
                    this.setScaleType(ImageView.ScaleType.FIT_CENTER);
                }
            }
            getMaxWidth() {
                return this.mMaxWidth;
            }
            setMaxWidth(maxWidth) {
                this.mMaxWidth = maxWidth;
            }
            getMaxHeight() {
                return this.mMaxHeight;
            }
            setMaxHeight(maxHeight) {
                this.mMaxHeight = maxHeight;
            }
            setImageURI(uri) {
                this.mDrawableWidth = -1;
                this.mDrawableHeight = -1;
                this.mImgElement.style.opacity = '0';
                this.mImgElement.src = uri;
            }
            setScaleType(scaleType) {
                if (scaleType == null) {
                    throw new Error('NullPointerException');
                }
                if (this.mScaleType != scaleType) {
                    this.mScaleType = scaleType;
                    this.setWillNotCacheDrawing(scaleType == ImageView.ScaleType.CENTER);
                    this.requestLayout();
                    this.invalidate();
                }
            }
            getScaleType() {
                return this.mScaleType;
            }
            onMeasure(widthMeasureSpec, heightMeasureSpec) {
                let w;
                let h;
                let desiredAspect = 0.0;
                let resizeWidth = false;
                let resizeHeight = false;
                const widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);
                const heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);
                if (!this.mImgElement.src || !this.mImgElement.complete) {
                    this.mDrawableWidth = -1;
                    this.mDrawableHeight = -1;
                    w = h = 0;
                }
                else {
                    w = this.mDrawableWidth;
                    h = this.mDrawableHeight;
                    if (w <= 0)
                        w = 1;
                    if (h <= 0)
                        h = 1;
                    if (this.mAdjustViewBounds) {
                        resizeWidth = widthSpecMode != MeasureSpec.EXACTLY;
                        resizeHeight = heightSpecMode != MeasureSpec.EXACTLY;
                        desiredAspect = w / h;
                    }
                }
                let pleft = this.mPaddingLeft;
                let pright = this.mPaddingRight;
                let ptop = this.mPaddingTop;
                let pbottom = this.mPaddingBottom;
                let widthSize;
                let heightSize;
                if (resizeWidth || resizeHeight) {
                    widthSize = this.resolveAdjustedSize(w + pleft + pright, this.mMaxWidth, widthMeasureSpec);
                    heightSize = this.resolveAdjustedSize(h + ptop + pbottom, this.mMaxHeight, heightMeasureSpec);
                    if (desiredAspect != 0) {
                        let actualAspect = (widthSize - pleft - pright) / (heightSize - ptop - pbottom);
                        if (Math.abs(actualAspect - desiredAspect) > 0.0000001) {
                            let done = false;
                            if (resizeWidth) {
                                let newWidth = Math.floor(desiredAspect * (heightSize - ptop - pbottom)) +
                                    pleft + pright;
                                if (!resizeHeight && !this.mAdjustViewBoundsCompat) {
                                    widthSize = this.resolveAdjustedSize(newWidth, this.mMaxWidth, widthMeasureSpec);
                                }
                                if (newWidth <= widthSize) {
                                    widthSize = newWidth;
                                    done = true;
                                }
                            }
                            if (!done && resizeHeight) {
                                let newHeight = Math.floor((widthSize - pleft - pright) / desiredAspect) +
                                    ptop + pbottom;
                                if (!resizeWidth && !this.mAdjustViewBoundsCompat) {
                                    heightSize = this.resolveAdjustedSize(newHeight, this.mMaxHeight, heightMeasureSpec);
                                }
                                if (newHeight <= heightSize) {
                                    heightSize = newHeight;
                                }
                            }
                        }
                    }
                }
                else {
                    w += pleft + pright;
                    h += ptop + pbottom;
                    w = Math.max(w, this.getSuggestedMinimumWidth());
                    h = Math.max(h, this.getSuggestedMinimumHeight());
                    widthSize = HtmlImageView.resolveSizeAndState(w, widthMeasureSpec, 0);
                    heightSize = HtmlImageView.resolveSizeAndState(h, heightMeasureSpec, 0);
                }
                this.setMeasuredDimension(widthSize, heightSize);
            }
            resolveAdjustedSize(desiredSize, maxSize, measureSpec) {
                let result = desiredSize;
                let specMode = MeasureSpec.getMode(measureSpec);
                let specSize = MeasureSpec.getSize(measureSpec);
                switch (specMode) {
                    case MeasureSpec.UNSPECIFIED:
                        result = Math.min(desiredSize, maxSize);
                        break;
                    case MeasureSpec.AT_MOST:
                        result = Math.min(Math.min(desiredSize, specSize), maxSize);
                        break;
                    case MeasureSpec.EXACTLY:
                        result = specSize;
                        break;
                }
                return result;
            }
            setFrame(left, top, right, bottom) {
                let changed = super.setFrame(left, top, right, bottom);
                this.mHaveFrame = true;
                this.configureBounds();
                this.mImgElement.style.display = '';
                return changed;
            }
            configureBounds() {
                let dwidth = this.mDrawableWidth;
                let dheight = this.mDrawableHeight;
                let vwidth = this.getWidth() - this.mPaddingLeft - this.mPaddingRight;
                let vheight = this.getHeight() - this.mPaddingTop - this.mPaddingBottom;
                let fits = (dwidth < 0 || vwidth == dwidth) && (dheight < 0 || vheight == dheight);
                this.mImgElement.style.left = 0 + 'px';
                this.mImgElement.style.top = 0 + 'px';
                this.mImgElement.style.width = '';
                this.mImgElement.style.height = '';
                if (dwidth <= 0 || dheight <= 0) {
                    return;
                }
                if (this.mScaleType === ImageView.ScaleType.FIT_XY) {
                    this.mImgElement.style.width = vwidth + 'px';
                    this.mImgElement.style.height = vheight + 'px';
                    return;
                }
                this.mImgElement.style.width = dwidth + 'px';
                this.mImgElement.style.height = dheight + 'px';
                if (ImageView.ScaleType.MATRIX === this.mScaleType) {
                }
                else if (fits) {
                }
                else if (ImageView.ScaleType.CENTER === this.mScaleType) {
                    let left = Math.round((vwidth - dwidth) * 0.5);
                    let top = Math.round((vheight - dheight) * 0.5);
                    this.mImgElement.style.left = left + 'px';
                    this.mImgElement.style.top = top + 'px';
                }
                else if (ImageView.ScaleType.CENTER_CROP === this.mScaleType) {
                    let scale;
                    let dx = 0, dy = 0;
                    if (dwidth * vheight > vwidth * dheight) {
                        scale = vheight / dheight;
                        dx = (vwidth - dwidth * scale) * 0.5;
                        this.mImgElement.style.width = 'auto';
                        this.mImgElement.style.height = vheight + 'px';
                        this.mImgElement.style.left = Math.round(dx) + 'px';
                        this.mImgElement.style.top = '0px';
                    }
                    else {
                        scale = vwidth / dwidth;
                        dy = (vheight - dheight * scale) * 0.5;
                        this.mImgElement.style.width = vwidth + 'px';
                        this.mImgElement.style.height = 'auto';
                        this.mImgElement.style.left = '0px';
                        this.mImgElement.style.top = Math.round(dy) + 'px';
                    }
                }
                else if (ImageView.ScaleType.CENTER_INSIDE === this.mScaleType) {
                    let scale = 1;
                    if (dwidth <= vwidth && dheight <= vheight) {
                    }
                    else {
                        let wScale = vwidth / dwidth;
                        let hScale = vheight / dheight;
                        if (wScale < hScale) {
                            this.mImgElement.style.width = vwidth + 'px';
                            this.mImgElement.style.height = 'auto';
                        }
                        else {
                            this.mImgElement.style.width = 'auto';
                            this.mImgElement.style.height = vheight + 'px';
                        }
                        scale = Math.min(wScale, hScale);
                    }
                    let dx = Math.round((vwidth - dwidth * scale) * 0.5);
                    let dy = Math.round((vheight - dheight * scale) * 0.5);
                    this.mImgElement.style.left = dx + 'px';
                    this.mImgElement.style.top = dy + 'px';
                }
                else {
                    let wScale = vwidth / dwidth;
                    let hScale = vheight / dheight;
                    if (wScale < hScale) {
                        this.mImgElement.style.width = vwidth + 'px';
                        this.mImgElement.style.height = 'auto';
                    }
                    else {
                        this.mImgElement.style.width = 'auto';
                        this.mImgElement.style.height = vheight + 'px';
                    }
                    let scale = Math.min(wScale, hScale);
                    if (ImageView.ScaleType.FIT_CENTER === this.mScaleType) {
                        let dx = Math.round((vwidth - dwidth * scale) * 0.5);
                        let dy = Math.round((vheight - dheight * scale) * 0.5);
                        this.mImgElement.style.left = dx + 'px';
                        this.mImgElement.style.top = dy + 'px';
                    }
                    else if (ImageView.ScaleType.FIT_END === this.mScaleType) {
                        let dx = Math.round((vwidth - dwidth * scale));
                        let dy = Math.round((vheight - dheight * scale));
                        this.mImgElement.style.left = dx + 'px';
                        this.mImgElement.style.top = dy + 'px';
                    }
                    else if (ImageView.ScaleType.FIT_START === this.mScaleType) {
                    }
                }
            }
            getImageAlpha() {
                return this.mAlpha;
            }
            setImageAlpha(alpha) {
                this.setAlpha(alpha);
            }
        }
        widget.HtmlImageView = HtmlImageView;
    })(widget = androidui.widget || (androidui.widget = {}));
})(androidui || (androidui = {}));
///<reference path="../view/View.ts"/>
///<reference path="../../androidui/widget/HtmlImageView.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        class ImageView extends androidui.widget.HtmlImageView {
        }
        widget.ImageView = ImageView;
        (function (ImageView) {
            class ScaleType {
                constructor(type) {
                    this.mType = type;
                }
                toString() {
                    return this.mType;
                }
                static parseScaleType(s, defaultType) {
                    if (s == null)
                        return defaultType;
                    if (s.toLowerCase() === ScaleType.MATRIX.mType.toLowerCase())
                        return ScaleType.MATRIX;
                    if (s.toLowerCase() === ScaleType.FIT_XY.mType.toLowerCase())
                        return ScaleType.FIT_XY;
                    if (s.toLowerCase() === ScaleType.FIT_START.mType.toLowerCase())
                        return ScaleType.FIT_START;
                    if (s.toLowerCase() === ScaleType.FIT_CENTER.mType.toLowerCase())
                        return ScaleType.FIT_CENTER;
                    if (s.toLowerCase() === ScaleType.FIT_END.mType.toLowerCase())
                        return ScaleType.FIT_END;
                    if (s.toLowerCase() === ScaleType.CENTER.mType.toLowerCase())
                        return ScaleType.CENTER;
                    if (s.toLowerCase() === ScaleType.CENTER_CROP.mType.toLowerCase())
                        return ScaleType.CENTER_CROP;
                    if (s.toLowerCase() === ScaleType.CENTER_INSIDE.mType.toLowerCase())
                        return ScaleType.CENTER_INSIDE;
                    return defaultType;
                }
            }
            ScaleType.MATRIX = new ScaleType("matrix");
            ScaleType.FIT_XY = new ScaleType("fitXY");
            ScaleType.FIT_START = new ScaleType("fitStart");
            ScaleType.FIT_CENTER = new ScaleType("fitCenter");
            ScaleType.FIT_END = new ScaleType("fitEnd");
            ScaleType.CENTER = new ScaleType("center");
            ScaleType.CENTER_CROP = new ScaleType("centerCrop");
            ScaleType.CENTER_INSIDE = new ScaleType("centerInside");
            ImageView.ScaleType = ScaleType;
        })(ImageView = widget.ImageView || (widget.ImageView = {}));
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/28.
 */
///<reference path="ImageView.ts"/>
///<reference path="../view/View.ts"/>
///<reference path="../R/attr.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        class ImageButton extends widget.ImageView {
            constructor(bindElement, rootElement) {
                super(bindElement, rootElement);
                this.applyDefaultAttributes(android.R.attr.imageButtonStyle);
            }
        }
        widget.ImageButton = ImageButton;
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var android;
(function (android) {
    var util;
    (function (util) {
        class MathUtils {
            constructor() {
            }
            static abs(v) {
                return v > 0 ? v : -v;
            }
            static constrain(amount, low, high) {
                return amount < low ? low : (amount > high ? high : amount);
            }
            static log(a) {
                return Math.log(a);
            }
            static exp(a) {
                return Math.exp(a);
            }
            static pow(a, b) {
                return Math.pow(a, b);
            }
            static max(a, b, c) {
                if (c == null)
                    return a > b ? a : b;
                return a > b ? (a > c ? a : c) : (b > c ? b : c);
            }
            static min(a, b, c) {
                if (c == null)
                    return a < b ? a : b;
                return a < b ? (a < c ? a : c) : (b < c ? b : c);
            }
            static dist(x1, y1, x2, y2) {
                const x = (x2 - x1);
                const y = (y2 - y1);
                return Math.sqrt(x * x + y * y);
            }
            static dist3(x1, y1, z1, x2, y2, z2) {
                const x = (x2 - x1);
                const y = (y2 - y1);
                const z = (z2 - z1);
                return Math.sqrt(x * x + y * y + z * z);
            }
            static mag(a, b, c) {
                if (c == null)
                    return Math.sqrt(a * a + b * b);
                return Math.sqrt(a * a + b * b + c * c);
            }
            static sq(v) {
                return v * v;
            }
            static radians(degrees) {
                return degrees * MathUtils.DEG_TO_RAD;
            }
            static degrees(radians) {
                return radians * MathUtils.RAD_TO_DEG;
            }
            static acos(value) {
                return Math.acos(value);
            }
            static asin(value) {
                return Math.asin(value);
            }
            static atan(value) {
                return Math.atan(value);
            }
            static atan2(a, b) {
                return Math.atan2(a, b);
            }
            static tan(angle) {
                return Math.tan(angle);
            }
            static lerp(start, stop, amount) {
                return start + (stop - start) * amount;
            }
            static norm(start, stop, value) {
                return (value - start) / (stop - start);
            }
            static map(minStart, minStop, maxStart, maxStop, value) {
                return maxStart + (maxStart - maxStop) * ((value - minStart) / (minStop - minStart));
            }
            static random(...args) {
                if (args.length == 1)
                    return Math.random() * args[0];
                let [howsmall, howbig] = args;
                if (howsmall >= howbig)
                    return howsmall;
                return Math.random() * (howbig - howsmall) + howsmall;
            }
        }
        MathUtils.DEG_TO_RAD = 3.1415926 / 180.0;
        MathUtils.RAD_TO_DEG = 180.0 / 3.1415926;
        util.MathUtils = MathUtils;
    })(util = android.util || (android.util = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/3.
 */
///<reference path="SparseArray.ts"/>
var android;
(function (android) {
    var util;
    (function (util) {
        class SparseBooleanArray extends util.SparseArray {
        }
        util.SparseBooleanArray = SparseBooleanArray;
    })(util = android.util || (android.util = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="View.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        class SoundEffectConstants {
            static getContantForFocusDirection(direction) {
                switch (direction) {
                    case view.View.FOCUS_RIGHT:
                        return SoundEffectConstants.NAVIGATION_RIGHT;
                    case view.View.FOCUS_FORWARD:
                    case view.View.FOCUS_DOWN:
                        return SoundEffectConstants.NAVIGATION_DOWN;
                    case view.View.FOCUS_LEFT:
                        return SoundEffectConstants.NAVIGATION_LEFT;
                    case view.View.FOCUS_BACKWARD:
                    case view.View.FOCUS_UP:
                        return SoundEffectConstants.NAVIGATION_UP;
                }
                throw Error(`new IllegalArgumentException("direction must be one of " + "{FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT, FOCUS_FORWARD, FOCUS_BACKWARD}.")`);
            }
        }
        SoundEffectConstants.CLICK = 0;
        SoundEffectConstants.NAVIGATION_LEFT = 1;
        SoundEffectConstants.NAVIGATION_UP = 2;
        SoundEffectConstants.NAVIGATION_RIGHT = 3;
        SoundEffectConstants.NAVIGATION_DOWN = 4;
        view.SoundEffectConstants = SoundEffectConstants;
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2012 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/util/Log.ts"/>
var android;
(function (android) {
    var os;
    (function (os) {
        class Trace {
            static nativeGetEnabledTags() {
                return Trace.TRACE_TAG_ALWAYS;
            }
            static nativeTraceCounter(tag, name, value) {
            }
            static nativeTraceBegin(tag, name) { }
            static nativeTraceEnd(tag) { }
            static nativeAsyncTraceBegin(tag, name, cookie) { }
            static nativeAsyncTraceEnd(tag, name, cookie) { }
            static nativeSetAppTracingAllowed(allowed) { }
            static nativeSetTracingEnabled(allowed) { }
            static cacheEnabledTags() {
                let tags = Trace.nativeGetEnabledTags();
                Trace.sEnabledTags = tags;
                return tags;
            }
            static isTagEnabled(traceTag) {
                let tags = Trace.sEnabledTags;
                if (tags == Trace.TRACE_TAG_NOT_READY) {
                    tags = Trace.cacheEnabledTags();
                }
                return (tags & traceTag) != 0;
            }
            static traceCounter(traceTag, counterName, counterValue) {
                if (Trace.isTagEnabled(traceTag)) {
                    Trace.nativeTraceCounter(traceTag, counterName, counterValue);
                }
            }
            static setAppTracingAllowed(allowed) {
                Trace.nativeSetAppTracingAllowed(allowed);
                Trace.cacheEnabledTags();
            }
            static setTracingEnabled(enabled) {
                Trace.nativeSetTracingEnabled(enabled);
                Trace.cacheEnabledTags();
            }
            static traceBegin(traceTag, methodName) {
                if (Trace.isTagEnabled(traceTag)) {
                    Trace.nativeTraceBegin(traceTag, methodName);
                }
            }
            static traceEnd(traceTag) {
                if (Trace.isTagEnabled(traceTag)) {
                    Trace.nativeTraceEnd(traceTag);
                }
            }
            static asyncTraceBegin(traceTag, methodName, cookie) {
                if (Trace.isTagEnabled(traceTag)) {
                    Trace.nativeAsyncTraceBegin(traceTag, methodName, cookie);
                }
            }
            static asyncTraceEnd(traceTag, methodName, cookie) {
                if (Trace.isTagEnabled(traceTag)) {
                    Trace.nativeAsyncTraceEnd(traceTag, methodName, cookie);
                }
            }
            static beginSection(sectionName) {
                if (Trace.isTagEnabled(Trace.TRACE_TAG_APP)) {
                    if (sectionName.length > Trace.MAX_SECTION_NAME_LEN) {
                        throw Error(`new IllegalArgumentException("sectionName is too long")`);
                    }
                    Trace.nativeTraceBegin(Trace.TRACE_TAG_APP, sectionName);
                }
            }
            static endSection() {
                if (Trace.isTagEnabled(Trace.TRACE_TAG_APP)) {
                    Trace.nativeTraceEnd(Trace.TRACE_TAG_APP);
                }
            }
        }
        Trace.TAG = "Trace";
        Trace.TRACE_TAG_NEVER = 0;
        Trace.TRACE_TAG_ALWAYS = 1 << 0;
        Trace.TRACE_TAG_GRAPHICS = 1 << 1;
        Trace.TRACE_TAG_INPUT = 1 << 2;
        Trace.TRACE_TAG_VIEW = 1 << 3;
        Trace.TRACE_TAG_WEBVIEW = 1 << 4;
        Trace.TRACE_TAG_WINDOW_MANAGER = 1 << 5;
        Trace.TRACE_TAG_ACTIVITY_MANAGER = 1 << 6;
        Trace.TRACE_TAG_SYNC_MANAGER = 1 << 7;
        Trace.TRACE_TAG_AUDIO = 1 << 8;
        Trace.TRACE_TAG_VIDEO = 1 << 9;
        Trace.TRACE_TAG_CAMERA = 1 << 10;
        Trace.TRACE_TAG_HAL = 1 << 11;
        Trace.TRACE_TAG_APP = 1 << 12;
        Trace.TRACE_TAG_RESOURCES = 1 << 13;
        Trace.TRACE_TAG_DALVIK = 1 << 14;
        Trace.TRACE_TAG_RS = 1 << 15;
        Trace.TRACE_TAG_NOT_READY = 1 << 63;
        Trace.MAX_SECTION_NAME_LEN = 127;
        Trace.sEnabledTags = Trace.TRACE_TAG_NOT_READY;
        os.Trace = Trace;
    })(os = android.os || (android.os = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/3.
 */
///<reference path="SparseArray.ts"/>
var android;
(function (android) {
    var util;
    (function (util) {
        class LongSparseArray extends util.SparseArray {
        }
        util.LongSparseArray = LongSparseArray;
    })(util = android.util || (android.util = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/5.
 */
var android;
(function (android) {
    var database;
    (function (database) {
        class DataSetObserver {
            onChanged() { }
            onInvalidated() { }
        }
        database.DataSetObserver = DataSetObserver;
    })(database = android.database || (android.database = {}));
})(android || (android = {}));
var java;
(function (java) {
    var lang;
    (function (lang) {
        class Long {
        }
        Long.MIN_VALUE = Number.MIN_SAFE_INTEGER;
        Long.MAX_VALUE = Number.MAX_SAFE_INTEGER;
        lang.Long = Long;
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/database/DataSetObserver.ts"/>
///<reference path="../../android/os/SystemClock.ts"/>
///<reference path="../../android/util/SparseArray.ts"/>
///<reference path="../../android/view/SoundEffectConstants.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../java/lang/Long.ts"/>
///<reference path="Adapter.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var DataSetObserver = android.database.DataSetObserver;
        var SystemClock = android.os.SystemClock;
        var SoundEffectConstants = android.view.SoundEffectConstants;
        var View = android.view.View;
        var ViewGroup = android.view.ViewGroup;
        var Long = java.lang.Long;
        class AdapterView extends ViewGroup {
            constructor(...args) {
                super(...args);
                this.mFirstPosition = 0;
                this.mSpecificTop = 0;
                this.mSyncPosition = 0;
                this.mSyncRowId = AdapterView.INVALID_ROW_ID;
                this.mSyncHeight = 0;
                this.mNeedSync = false;
                this.mSyncMode = 0;
                this.mLayoutHeight = 0;
                this.mInLayout = false;
                this.mNextSelectedPosition = AdapterView.INVALID_POSITION;
                this.mNextSelectedRowId = AdapterView.INVALID_ROW_ID;
                this.mSelectedPosition = AdapterView.INVALID_POSITION;
                this.mSelectedRowId = AdapterView.INVALID_ROW_ID;
                this.mItemCount = 0;
                this.mOldItemCount = 0;
                this.mOldSelectedPosition = AdapterView.INVALID_POSITION;
                this.mOldSelectedRowId = AdapterView.INVALID_ROW_ID;
                this.mBlockLayoutRequests = false;
            }
            setOnItemClickListener(listener) {
                this.mOnItemClickListener = listener;
            }
            getOnItemClickListener() {
                return this.mOnItemClickListener;
            }
            performItemClick(view, position, id) {
                if (this.mOnItemClickListener != null) {
                    this.playSoundEffect(SoundEffectConstants.CLICK);
                    this.mOnItemClickListener.onItemClick(this, view, position, id);
                    return true;
                }
                return false;
            }
            setOnItemLongClickListener(listener) {
                if (!this.isLongClickable()) {
                    this.setLongClickable(true);
                }
                this.mOnItemLongClickListener = listener;
            }
            getOnItemLongClickListener() {
                return this.mOnItemLongClickListener;
            }
            setOnItemSelectedListener(listener) {
                this.mOnItemSelectedListener = listener;
            }
            getOnItemSelectedListener() {
                return this.mOnItemSelectedListener;
            }
            addView(...args) {
                throw Error(`new UnsupportedOperationException("addView() is not supported in AdapterView")`);
            }
            removeView(child) {
                throw Error(`new UnsupportedOperationException("removeView(View) is not supported in AdapterView")`);
            }
            removeViewAt(index) {
                throw Error(`new UnsupportedOperationException("removeViewAt(int) is not supported in AdapterView")`);
            }
            removeAllViews() {
                throw Error(`new UnsupportedOperationException("removeAllViews() is not supported in AdapterView")`);
            }
            onLayout(changed, left, top, right, bottom) {
                this.mLayoutHeight = this.getHeight();
            }
            getSelectedItemPosition() {
                return this.mNextSelectedPosition;
            }
            getSelectedItemId() {
                return this.mNextSelectedRowId;
            }
            getSelectedItem() {
                let adapter = this.getAdapter();
                let selection = this.getSelectedItemPosition();
                if (adapter != null && adapter.getCount() > 0 && selection >= 0) {
                    return adapter.getItem(selection);
                }
                else {
                    return null;
                }
            }
            getCount() {
                return this.mItemCount;
            }
            getPositionForView(view) {
                let listItem = view;
                try {
                    let v;
                    while (!((v = listItem.getParent()) == (this))) {
                        listItem = v;
                    }
                }
                catch (e) {
                    return AdapterView.INVALID_POSITION;
                }
                const childCount = this.getChildCount();
                for (let i = 0; i < childCount; i++) {
                    if (this.getChildAt(i) == (listItem)) {
                        return this.mFirstPosition + i;
                    }
                }
                return AdapterView.INVALID_POSITION;
            }
            getFirstVisiblePosition() {
                return this.mFirstPosition;
            }
            getLastVisiblePosition() {
                return this.mFirstPosition + this.getChildCount() - 1;
            }
            setEmptyView(emptyView) {
                this.mEmptyView = emptyView;
                const adapter = this.getAdapter();
                const empty = ((adapter == null) || adapter.isEmpty());
                this.updateEmptyStatus(empty);
            }
            getEmptyView() {
                return this.mEmptyView;
            }
            isInFilterMode() {
                return false;
            }
            setFocusable(focusable) {
                const adapter = this.getAdapter();
                const empty = adapter == null || adapter.getCount() == 0;
                this.mDesiredFocusableState = focusable;
                if (!focusable) {
                    this.mDesiredFocusableInTouchModeState = false;
                }
                super.setFocusable(focusable && (!empty || this.isInFilterMode()));
            }
            setFocusableInTouchMode(focusable) {
                const adapter = this.getAdapter();
                const empty = adapter == null || adapter.getCount() == 0;
                this.mDesiredFocusableInTouchModeState = focusable;
                if (focusable) {
                    this.mDesiredFocusableState = true;
                }
                super.setFocusableInTouchMode(focusable && (!empty || this.isInFilterMode()));
            }
            checkFocus() {
                const adapter = this.getAdapter();
                const empty = adapter == null || adapter.getCount() == 0;
                const focusable = !empty || this.isInFilterMode();
                super.setFocusableInTouchMode(focusable && this.mDesiredFocusableInTouchModeState);
                super.setFocusable(focusable && this.mDesiredFocusableState);
                if (this.mEmptyView != null) {
                    this.updateEmptyStatus((adapter == null) || adapter.isEmpty());
                }
            }
            updateEmptyStatus(empty) {
                if (this.isInFilterMode()) {
                    empty = false;
                }
                if (empty) {
                    if (this.mEmptyView != null) {
                        this.mEmptyView.setVisibility(View.VISIBLE);
                        this.setVisibility(View.GONE);
                    }
                    else {
                        this.setVisibility(View.VISIBLE);
                    }
                    if (this.mDataChanged) {
                        this.onLayout(false, this.mLeft, this.mTop, this.mRight, this.mBottom);
                    }
                }
                else {
                    if (this.mEmptyView != null)
                        this.mEmptyView.setVisibility(View.GONE);
                    this.setVisibility(View.VISIBLE);
                }
            }
            getItemAtPosition(position) {
                let adapter = this.getAdapter();
                return (adapter == null || position < 0) ? null : adapter.getItem(position);
            }
            getItemIdAtPosition(position) {
                let adapter = this.getAdapter();
                return (adapter == null || position < 0) ? AdapterView.INVALID_ROW_ID : adapter.getItemId(position);
            }
            setOnClickListener(l) {
                throw Error(`new RuntimeException("Don't call setOnClickListener for an AdapterView. " + "You probably want setOnItemClickListener instead")`);
            }
            onDetachedFromWindow() {
                super.onDetachedFromWindow();
                this.removeCallbacks(this.mSelectionNotifier);
            }
            selectionChanged() {
                if (this.mOnItemSelectedListener != null) {
                    if (this.mInLayout || this.mBlockLayoutRequests) {
                        if (this.mSelectionNotifier == null) {
                            this.mSelectionNotifier = new SelectionNotifier(this);
                        }
                        this.post(this.mSelectionNotifier);
                    }
                    else {
                        this.fireOnSelected();
                        this.performAccessibilityActionsOnSelected();
                    }
                }
            }
            fireOnSelected() {
                if (this.mOnItemSelectedListener == null) {
                    return;
                }
                const selection = this.getSelectedItemPosition();
                if (selection >= 0) {
                    let v = this.getSelectedView();
                    this.mOnItemSelectedListener.onItemSelected(this, v, selection, this.getAdapter().getItemId(selection));
                }
                else {
                    this.mOnItemSelectedListener.onNothingSelected(this);
                }
            }
            performAccessibilityActionsOnSelected() {
            }
            isScrollableForAccessibility() {
                let adapter = this.getAdapter();
                if (adapter != null) {
                    const itemCount = adapter.getCount();
                    return itemCount > 0 && (this.getFirstVisiblePosition() > 0 || this.getLastVisiblePosition() < itemCount - 1);
                }
                return false;
            }
            canAnimate() {
                return super.canAnimate() && this.mItemCount > 0;
            }
            handleDataChanged() {
                const count = this.mItemCount;
                let found = false;
                if (count > 0) {
                    let newPos;
                    if (this.mNeedSync) {
                        this.mNeedSync = false;
                        newPos = this.findSyncPosition();
                        if (newPos >= 0) {
                            let selectablePos = this.lookForSelectablePosition(newPos, true);
                            if (selectablePos == newPos) {
                                this.setNextSelectedPositionInt(newPos);
                                found = true;
                            }
                        }
                    }
                    if (!found) {
                        newPos = this.getSelectedItemPosition();
                        if (newPos >= count) {
                            newPos = count - 1;
                        }
                        if (newPos < 0) {
                            newPos = 0;
                        }
                        let selectablePos = this.lookForSelectablePosition(newPos, true);
                        if (selectablePos < 0) {
                            selectablePos = this.lookForSelectablePosition(newPos, false);
                        }
                        if (selectablePos >= 0) {
                            this.setNextSelectedPositionInt(selectablePos);
                            this.checkSelectionChanged();
                            found = true;
                        }
                    }
                }
                if (!found) {
                    this.mSelectedPosition = AdapterView.INVALID_POSITION;
                    this.mSelectedRowId = AdapterView.INVALID_ROW_ID;
                    this.mNextSelectedPosition = AdapterView.INVALID_POSITION;
                    this.mNextSelectedRowId = AdapterView.INVALID_ROW_ID;
                    this.mNeedSync = false;
                    this.checkSelectionChanged();
                }
            }
            checkSelectionChanged() {
                if ((this.mSelectedPosition != this.mOldSelectedPosition) || (this.mSelectedRowId != this.mOldSelectedRowId)) {
                    this.selectionChanged();
                    this.mOldSelectedPosition = this.mSelectedPosition;
                    this.mOldSelectedRowId = this.mSelectedRowId;
                }
            }
            findSyncPosition() {
                let count = this.mItemCount;
                if (count == 0) {
                    return AdapterView.INVALID_POSITION;
                }
                let idToMatch = this.mSyncRowId;
                let seed = this.mSyncPosition;
                if (idToMatch == AdapterView.INVALID_ROW_ID) {
                    return AdapterView.INVALID_POSITION;
                }
                seed = Math.max(0, seed);
                seed = Math.min(count - 1, seed);
                let endTime = SystemClock.uptimeMillis() + AdapterView.SYNC_MAX_DURATION_MILLIS;
                let rowId;
                let first = seed;
                let last = seed;
                let next = false;
                let hitFirst;
                let hitLast;
                let adapter = this.getAdapter();
                if (adapter == null) {
                    return AdapterView.INVALID_POSITION;
                }
                while (SystemClock.uptimeMillis() <= endTime) {
                    rowId = adapter.getItemId(seed);
                    if (rowId == idToMatch) {
                        return seed;
                    }
                    hitLast = last == count - 1;
                    hitFirst = first == 0;
                    if (hitLast && hitFirst) {
                        break;
                    }
                    if (hitFirst || (next && !hitLast)) {
                        last++;
                        seed = last;
                        next = false;
                    }
                    else if (hitLast || (!next && !hitFirst)) {
                        first--;
                        seed = first;
                        next = true;
                    }
                }
                return AdapterView.INVALID_POSITION;
            }
            lookForSelectablePosition(position, lookDown) {
                return position;
            }
            setSelectedPositionInt(position) {
                this.mSelectedPosition = position;
                this.mSelectedRowId = this.getItemIdAtPosition(position);
            }
            setNextSelectedPositionInt(position) {
                this.mNextSelectedPosition = position;
                this.mNextSelectedRowId = this.getItemIdAtPosition(position);
                if (this.mNeedSync && this.mSyncMode == AdapterView.SYNC_SELECTED_POSITION && position >= 0) {
                    this.mSyncPosition = position;
                    this.mSyncRowId = this.mNextSelectedRowId;
                }
            }
            rememberSyncState() {
                if (this.getChildCount() > 0) {
                    this.mNeedSync = true;
                    this.mSyncHeight = this.mLayoutHeight;
                    if (this.mSelectedPosition >= 0) {
                        let v = this.getChildAt(this.mSelectedPosition - this.mFirstPosition);
                        this.mSyncRowId = this.mNextSelectedRowId;
                        this.mSyncPosition = this.mNextSelectedPosition;
                        if (v != null) {
                            this.mSpecificTop = v.getTop();
                        }
                        this.mSyncMode = AdapterView.SYNC_SELECTED_POSITION;
                    }
                    else {
                        let v = this.getChildAt(0);
                        let adapter = this.getAdapter();
                        if (this.mFirstPosition >= 0 && this.mFirstPosition < adapter.getCount()) {
                            this.mSyncRowId = adapter.getItemId(this.mFirstPosition);
                        }
                        else {
                            this.mSyncRowId = AdapterView.NO_ID;
                        }
                        this.mSyncPosition = this.mFirstPosition;
                        if (v != null) {
                            this.mSpecificTop = v.getTop();
                        }
                        this.mSyncMode = AdapterView.SYNC_FIRST_POSITION;
                    }
                }
            }
        }
        AdapterView.ITEM_VIEW_TYPE_IGNORE = -1;
        AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER = -2;
        AdapterView.SYNC_SELECTED_POSITION = 0;
        AdapterView.SYNC_FIRST_POSITION = 1;
        AdapterView.SYNC_MAX_DURATION_MILLIS = 100;
        AdapterView.INVALID_POSITION = -1;
        AdapterView.INVALID_ROW_ID = Long.MIN_VALUE;
        widget.AdapterView = AdapterView;
        (function (AdapterView) {
            class AdapterDataSetObserver extends DataSetObserver {
                constructor(AdapterView_this) {
                    super();
                    this.AdapterView_this = AdapterView_this;
                }
                onChanged() {
                    this.AdapterView_this.mDataChanged = true;
                    this.AdapterView_this.mOldItemCount = this.AdapterView_this.mItemCount;
                    this.AdapterView_this.mItemCount = this.AdapterView_this.getAdapter().getCount();
                    this.AdapterView_this.rememberSyncState();
                    this.AdapterView_this.checkFocus();
                    this.AdapterView_this.requestLayout();
                }
                onInvalidated() {
                    this.AdapterView_this.mDataChanged = true;
                    this.AdapterView_this.mOldItemCount = this.AdapterView_this.mItemCount;
                    this.AdapterView_this.mItemCount = 0;
                    this.AdapterView_this.mSelectedPosition = AdapterView.INVALID_POSITION;
                    this.AdapterView_this.mSelectedRowId = AdapterView.INVALID_ROW_ID;
                    this.AdapterView_this.mNextSelectedPosition = AdapterView.INVALID_POSITION;
                    this.AdapterView_this.mNextSelectedRowId = AdapterView.INVALID_ROW_ID;
                    this.AdapterView_this.mNeedSync = false;
                    this.AdapterView_this.checkFocus();
                    this.AdapterView_this.requestLayout();
                }
                clearSavedState() {
                }
            }
            AdapterView.AdapterDataSetObserver = AdapterDataSetObserver;
        })(AdapterView = widget.AdapterView || (widget.AdapterView = {}));
        class SelectionNotifier {
            constructor(AdapterView_this) {
                this.AdapterView_this = AdapterView_this;
            }
            run() {
                if (this.AdapterView_this.mDataChanged) {
                    if (this.AdapterView_this.getAdapter() != null) {
                        this.AdapterView_this.post(this);
                    }
                }
                else {
                    this.AdapterView_this.fireOnSelected();
                    this.AdapterView_this.performAccessibilityActionsOnSelected();
                }
            }
        }
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/database/DataSetObserver.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../java/lang/Integer.ts"/>
///<reference path="AdapterView.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var Integer = java.lang.Integer;
        var Adapter;
        (function (Adapter) {
            Adapter.IGNORE_ITEM_VIEW_TYPE = widget.AdapterView.ITEM_VIEW_TYPE_IGNORE;
            Adapter.NO_SELECTION = Integer.MIN_VALUE;
        })(Adapter = widget.Adapter || (widget.Adapter = {}));
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/widget/Adapter.ts"/>
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/graphics/Canvas.ts"/>
///<reference path="../../android/graphics/Rect.ts"/>
///<reference path="../../android/graphics/drawable/Drawable.ts"/>
///<reference path="../../android/text/InputType.ts"/>
///<reference path="../../android/text/TextUtils.ts"/>
///<reference path="../../android/util/Log.ts"/>
///<reference path="../../android/util/LongSparseArray.ts"/>
///<reference path="../../android/util/SparseArray.ts"/>
///<reference path="../../android/util/SparseBooleanArray.ts"/>
///<reference path="../../android/util/StateSet.ts"/>
///<reference path="../../android/view/Gravity.ts"/>
///<reference path="../../android/view/HapticFeedbackConstants.ts"/>
///<reference path="../../android/view/KeyEvent.ts"/>
///<reference path="../../android/view/MotionEvent.ts"/>
///<reference path="../../android/view/VelocityTracker.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewConfiguration.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../android/view/ViewParent.ts"/>
///<reference path="../../android/view/ViewTreeObserver.ts"/>
///<reference path="../../android/view/animation/Interpolator.ts"/>
///<reference path="../../android/view/animation/LinearInterpolator.ts"/>
///<reference path="../../java/util/ArrayList.ts"/>
///<reference path="../../java/util/List.ts"/>
///<reference path="../../java/lang/Integer.ts"/>
///<reference path="../../java/lang/Runnable.ts"/>
///<reference path="../../java/lang/System.ts"/>
///<reference path="../../android/widget/Adapter.ts"/>
///<reference path="../../android/widget/AdapterView.ts"/>
///<reference path="../../android/widget/Button.ts"/>
///<reference path="../../android/widget/Checkable.ts"/>
///<reference path="../../android/widget/ListAdapter.ts"/>
///<reference path="../../android/widget/OverScroller.ts"/>
///<reference path="../../android/R/drawable.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var Rect = android.graphics.Rect;
        var Log = android.util.Log;
        var LongSparseArray = android.util.LongSparseArray;
        var SparseArray = android.util.SparseArray;
        var SparseBooleanArray = android.util.SparseBooleanArray;
        var StateSet = android.util.StateSet;
        var HapticFeedbackConstants = android.view.HapticFeedbackConstants;
        var KeyEvent = android.view.KeyEvent;
        var MotionEvent = android.view.MotionEvent;
        var VelocityTracker = android.view.VelocityTracker;
        var View = android.view.View;
        var ViewConfiguration = android.view.ViewConfiguration;
        var ViewGroup = android.view.ViewGroup;
        var LinearInterpolator = android.view.animation.LinearInterpolator;
        var ArrayList = java.util.ArrayList;
        var Integer = java.lang.Integer;
        var System = java.lang.System;
        var AdapterView = android.widget.AdapterView;
        var OverScroller = android.widget.OverScroller;
        class AbsListView extends AdapterView {
            constructor(bindElement, rootElement) {
                super(bindElement, rootElement);
                this.mChoiceMode = AbsListView.CHOICE_MODE_NONE;
                this.mCheckedItemCount = 0;
                this.mDeferNotifyDataSetChanged = false;
                this.mDrawSelectorOnTop = false;
                this.mSelectorPosition = AbsListView.INVALID_POSITION;
                this.mSelectorRect = new Rect();
                this.mRecycler = new AbsListView.RecycleBin(this);
                this.mSelectionLeftPadding = 0;
                this.mSelectionTopPadding = 0;
                this.mSelectionRightPadding = 0;
                this.mSelectionBottomPadding = 0;
                this.mListPadding = new Rect();
                this.mWidthMeasureSpec = 0;
                this.mMotionPosition = 0;
                this.mMotionViewOriginalTop = 0;
                this.mMotionViewNewTop = 0;
                this.mMotionX = 0;
                this.mMotionY = 0;
                this.mTouchMode = AbsListView.TOUCH_MODE_REST;
                this.mLastY = 0;
                this.mMotionCorrection = 0;
                this.mSelectedTop = 0;
                this.mSmoothScrollbarEnabled = true;
                this.mResurrectToPosition = AbsListView.INVALID_POSITION;
                this.mOverscrollMax = 0;
                this.mLastTouchMode = AbsListView.TOUCH_MODE_UNKNOWN;
                this.mScrollProfilingStarted = false;
                this.mFlingProfilingStarted = false;
                this.mTranscriptMode = 0;
                this.mCacheColorHint = 0;
                this.mLastScrollState = AbsListView.OnScrollListener.SCROLL_STATE_IDLE;
                this.mDensityScale = 0;
                this.mMinimumVelocity = 0;
                this.mMaximumVelocity = 0;
                this.mVelocityScale = 1.0;
                this.mIsScrap = new Array(1);
                this.mActivePointerId = AbsListView.INVALID_POINTER;
                this.mOverscrollDistance = 0;
                this._mOverflingDistance = 0;
                this.mFirstPositionDistanceGuess = 0;
                this.mLastPositionDistanceGuess = 0;
                this.mDirection = 0;
                this.mGlowPaddingLeft = 0;
                this.mGlowPaddingRight = 0;
                this.mLastHandledItemCount = 0;
                this.initAbsListView();
                this.setVerticalScrollBarEnabled(true);
                this.initializeScrollbars();
                this._attrBinder.addAttr('listSelector', (value) => {
                    let d = this._attrBinder.parseDrawable(value);
                    if (d)
                        this.setSelector(d);
                });
                this._attrBinder.addAttr('drawSelectorOnTop', (value) => {
                    this.mDrawSelectorOnTop = this._attrBinder.parseBoolean(value, false);
                });
                this._attrBinder.addAttr('stackFromBottom', (value) => {
                    this.setStackFromBottom(this._attrBinder.parseBoolean(value, false));
                });
                this._attrBinder.addAttr('scrollingCache', (value) => {
                    this.setScrollingCacheEnabled(this._attrBinder.parseBoolean(value, true));
                });
                this._attrBinder.addAttr('transcriptMode', (value) => {
                    let transcriptMode = this._attrBinder.parseNumber(value, AbsListView.TRANSCRIPT_MODE_DISABLED);
                    this.setTranscriptMode(transcriptMode);
                });
                this._attrBinder.addAttr('cacheColorHint', (value) => {
                    let color = this._attrBinder.parseNumber(value, 0);
                    this.setCacheColorHint(color);
                });
                this._attrBinder.addAttr('fastScrollEnabled', (value) => {
                    let enableFastScroll = this._attrBinder.parseBoolean(value, false);
                    this.setFastScrollEnabled(enableFastScroll);
                });
                this._attrBinder.addAttr('fastScrollAlwaysVisible', (value) => {
                    let fastScrollAlwaysVisible = this._attrBinder.parseBoolean(value, false);
                    this.setFastScrollAlwaysVisible(fastScrollAlwaysVisible);
                });
                this._attrBinder.addAttr('smoothScrollbar', (value) => {
                    let smoothScrollbar = this._attrBinder.parseBoolean(value, true);
                    this.setSmoothScrollbarEnabled(smoothScrollbar);
                });
                this._attrBinder.addAttr('choiceMode', (value) => {
                    this.setChoiceMode(this._attrBinder.parseNumber(value, AbsListView.CHOICE_MODE_NONE));
                });
            }
            get mOverflingDistance() {
                if (this.mScrollY <= 0) {
                    if (this.mScrollY < -this._mOverflingDistance)
                        return -this.mScrollY;
                    return this._mOverflingDistance;
                }
                let overDistance = this.mScrollY;
                if (overDistance > this._mOverflingDistance)
                    return overDistance;
                return this._mOverflingDistance;
            }
            set mOverflingDistance(value) {
                this._mOverflingDistance = value;
            }
            initAbsListView() {
                this.setClickable(true);
                this.setFocusableInTouchMode(true);
                this.setWillNotDraw(false);
                this.setAlwaysDrawnWithCacheEnabled(false);
                this.setScrollingCacheEnabled(true);
                const configuration = ViewConfiguration.get();
                this.mTouchSlop = configuration.getScaledTouchSlop();
                this.mMinimumVelocity = configuration.getScaledMinimumFlingVelocity();
                this.mMaximumVelocity = configuration.getScaledMaximumFlingVelocity();
                this.mOverscrollDistance = configuration.getScaledOverscrollDistance();
                this.mOverflingDistance = configuration.getScaledOverflingDistance();
                this.mDensityScale = android.content.res.Resources.getDisplayMetrics().density;
                this.mLayoutMode = AbsListView.LAYOUT_NORMAL;
            }
            setOverScrollMode(mode) {
                if (mode != AbsListView.OVER_SCROLL_NEVER) {
                }
                else {
                }
                super.setOverScrollMode(mode);
            }
            setAdapter(adapter) {
                if (adapter != null) {
                    this.mAdapterHasStableIds = this.mAdapter.hasStableIds();
                    if (this.mChoiceMode != AbsListView.CHOICE_MODE_NONE && this.mAdapterHasStableIds && this.mCheckedIdStates == null) {
                        this.mCheckedIdStates = new LongSparseArray();
                    }
                }
                if (this.mCheckStates != null) {
                    this.mCheckStates.clear();
                }
                if (this.mCheckedIdStates != null) {
                    this.mCheckedIdStates.clear();
                }
            }
            getCheckedItemCount() {
                return this.mCheckedItemCount;
            }
            isItemChecked(position) {
                if (this.mChoiceMode != AbsListView.CHOICE_MODE_NONE && this.mCheckStates != null) {
                    return this.mCheckStates.get(position);
                }
                return false;
            }
            getCheckedItemPosition() {
                if (this.mChoiceMode == AbsListView.CHOICE_MODE_SINGLE && this.mCheckStates != null && this.mCheckStates.size() == 1) {
                    return this.mCheckStates.keyAt(0);
                }
                return AbsListView.INVALID_POSITION;
            }
            getCheckedItemPositions() {
                if (this.mChoiceMode != AbsListView.CHOICE_MODE_NONE) {
                    return this.mCheckStates;
                }
                return null;
            }
            getCheckedItemIds() {
                if (this.mChoiceMode == AbsListView.CHOICE_MODE_NONE || this.mCheckedIdStates == null || this.mAdapter == null) {
                    return [0];
                }
                const idStates = this.mCheckedIdStates;
                const count = idStates.size();
                const ids = [count];
                for (let i = 0; i < count; i++) {
                    ids[i] = idStates.keyAt(i);
                }
                return ids;
            }
            clearChoices() {
                if (this.mCheckStates != null) {
                    this.mCheckStates.clear();
                }
                if (this.mCheckedIdStates != null) {
                    this.mCheckedIdStates.clear();
                }
                this.mCheckedItemCount = 0;
            }
            setItemChecked(position, value) {
                if (this.mChoiceMode == AbsListView.CHOICE_MODE_NONE) {
                    return;
                }
                if (this.mChoiceMode == AbsListView.CHOICE_MODE_MULTIPLE || this.mChoiceMode == AbsListView.CHOICE_MODE_MULTIPLE_MODAL) {
                    let oldValue = this.mCheckStates.get(position);
                    this.mCheckStates.put(position, value);
                    if (this.mCheckedIdStates != null && this.mAdapter.hasStableIds()) {
                        if (value) {
                            this.mCheckedIdStates.put(this.mAdapter.getItemId(position), position);
                        }
                        else {
                            this.mCheckedIdStates.delete(this.mAdapter.getItemId(position));
                        }
                    }
                    if (oldValue != value) {
                        if (value) {
                            this.mCheckedItemCount++;
                        }
                        else {
                            this.mCheckedItemCount--;
                        }
                    }
                }
                else {
                    let updateIds = this.mCheckedIdStates != null && this.mAdapter.hasStableIds();
                    if (value || this.isItemChecked(position)) {
                        this.mCheckStates.clear();
                        if (updateIds) {
                            this.mCheckedIdStates.clear();
                        }
                    }
                    if (value) {
                        this.mCheckStates.put(position, true);
                        if (updateIds) {
                            this.mCheckedIdStates.put(this.mAdapter.getItemId(position), position);
                        }
                        this.mCheckedItemCount = 1;
                    }
                    else if (this.mCheckStates.size() == 0 || !this.mCheckStates.valueAt(0)) {
                        this.mCheckedItemCount = 0;
                    }
                }
                if (!this.mInLayout && !this.mBlockLayoutRequests) {
                    this.mDataChanged = true;
                    this.rememberSyncState();
                    this.requestLayout();
                }
            }
            performItemClick(view, position, id) {
                let handled = false;
                let dispatchItemClick = true;
                if (this.mChoiceMode != AbsListView.CHOICE_MODE_NONE) {
                    handled = true;
                    let checkedStateChanged = false;
                    if (this.mChoiceMode == AbsListView.CHOICE_MODE_MULTIPLE || (this.mChoiceMode == AbsListView.CHOICE_MODE_MULTIPLE_MODAL && this.mChoiceActionMode != null)) {
                        let checked = !this.mCheckStates.get(position, false);
                        this.mCheckStates.put(position, checked);
                        if (this.mCheckedIdStates != null && this.mAdapter.hasStableIds()) {
                            if (checked) {
                                this.mCheckedIdStates.put(this.mAdapter.getItemId(position), position);
                            }
                            else {
                                this.mCheckedIdStates.delete(this.mAdapter.getItemId(position));
                            }
                        }
                        if (checked) {
                            this.mCheckedItemCount++;
                        }
                        else {
                            this.mCheckedItemCount--;
                        }
                        checkedStateChanged = true;
                    }
                    else if (this.mChoiceMode == AbsListView.CHOICE_MODE_SINGLE) {
                        let checked = !this.mCheckStates.get(position, false);
                        if (checked) {
                            this.mCheckStates.clear();
                            this.mCheckStates.put(position, true);
                            if (this.mCheckedIdStates != null && this.mAdapter.hasStableIds()) {
                                this.mCheckedIdStates.clear();
                                this.mCheckedIdStates.put(this.mAdapter.getItemId(position), position);
                            }
                            this.mCheckedItemCount = 1;
                        }
                        else if (this.mCheckStates.size() == 0 || !this.mCheckStates.valueAt(0)) {
                            this.mCheckedItemCount = 0;
                        }
                        checkedStateChanged = true;
                    }
                    if (checkedStateChanged) {
                        this.updateOnScreenCheckedViews();
                    }
                }
                if (dispatchItemClick) {
                    handled = super.performItemClick(view, position, id) || handled;
                }
                return handled;
            }
            updateOnScreenCheckedViews() {
                const firstPos = this.mFirstPosition;
                const count = this.getChildCount();
                const useActivated = true;
                for (let i = 0; i < count; i++) {
                    const child = this.getChildAt(i);
                    const position = firstPos + i;
                    if (child['setChecked']) {
                        child.setChecked(this.mCheckStates.get(position));
                    }
                    else if (useActivated) {
                        child.setActivated(this.mCheckStates.get(position));
                    }
                }
            }
            getChoiceMode() {
                return this.mChoiceMode;
            }
            setChoiceMode(choiceMode) {
                this.mChoiceMode = choiceMode;
                if (this.mChoiceActionMode != null) {
                    this.mChoiceActionMode.finish();
                    this.mChoiceActionMode = null;
                }
                if (this.mChoiceMode != AbsListView.CHOICE_MODE_NONE) {
                    if (this.mCheckStates == null) {
                        this.mCheckStates = new SparseBooleanArray(0);
                    }
                    if (this.mCheckedIdStates == null && this.mAdapter != null && this.mAdapter.hasStableIds()) {
                        this.mCheckedIdStates = new LongSparseArray(0);
                    }
                    if (this.mChoiceMode == AbsListView.CHOICE_MODE_MULTIPLE_MODAL) {
                        this.clearChoices();
                        this.setLongClickable(true);
                    }
                }
            }
            contentFits() {
                const childCount = this.getChildCount();
                if (childCount == 0)
                    return true;
                if (childCount != this.mItemCount)
                    return false;
                return this.getChildAt(0).getTop() >= this.mListPadding.top && this.getChildAt(childCount - 1).getBottom() <= this.getHeight() - this.mListPadding.bottom;
            }
            setFastScrollEnabled(enabled) {
                if (this.mFastScrollEnabled != enabled) {
                    this.mFastScrollEnabled = enabled;
                    this.setFastScrollerEnabledUiThread(enabled);
                }
            }
            setFastScrollerEnabledUiThread(enabled) {
            }
            setFastScrollAlwaysVisible(alwaysShow) {
                if (this.mFastScrollAlwaysVisible != alwaysShow) {
                    if (alwaysShow && !this.mFastScrollEnabled) {
                        this.setFastScrollEnabled(true);
                    }
                    this.mFastScrollAlwaysVisible = alwaysShow;
                    this.setFastScrollerAlwaysVisibleUiThread(alwaysShow);
                }
            }
            setFastScrollerAlwaysVisibleUiThread(alwaysShow) {
            }
            isOwnerThread() {
                return true;
            }
            isFastScrollAlwaysVisible() {
                return false;
            }
            getVerticalScrollbarWidth() {
                return super.getVerticalScrollbarWidth();
            }
            isFastScrollEnabled() {
                return false;
            }
            setVerticalScrollbarPosition(position) {
                super.setVerticalScrollbarPosition(position);
            }
            setScrollBarStyle(style) {
                super.setScrollBarStyle(style);
            }
            isVerticalScrollBarHidden() {
                return this.isFastScrollEnabled();
            }
            setSmoothScrollbarEnabled(enabled) {
                this.mSmoothScrollbarEnabled = enabled;
            }
            isSmoothScrollbarEnabled() {
                return this.mSmoothScrollbarEnabled;
            }
            setOnScrollListener(l) {
                this.mOnScrollListener = l;
                this.invokeOnItemScrollListener();
            }
            invokeOnItemScrollListener() {
                if (this.mOnScrollListener != null) {
                    this.mOnScrollListener.onScroll(this, this.mFirstPosition, this.getChildCount(), this.mItemCount);
                }
                this.onScrollChanged(0, 0, 0, 0);
            }
            isScrollingCacheEnabled() {
                return this.mScrollingCacheEnabled;
            }
            setScrollingCacheEnabled(enabled) {
                if (this.mScrollingCacheEnabled && !enabled) {
                    this.clearScrollingCache();
                }
                this.mScrollingCacheEnabled = enabled;
            }
            setTextFilterEnabled(textFilterEnabled) {
                this.mTextFilterEnabled = textFilterEnabled;
            }
            isTextFilterEnabled() {
                return this.mTextFilterEnabled;
            }
            getFocusedRect(r) {
                let view = this.getSelectedView();
                if (view != null && view.getParent() == this) {
                    view.getFocusedRect(r);
                    this.offsetDescendantRectToMyCoords(view, r);
                }
                else {
                    super.getFocusedRect(r);
                }
            }
            useDefaultSelector() {
                this.setSelector(android.R.drawable.list_selector_background);
            }
            isStackFromBottom() {
                return this.mStackFromBottom;
            }
            setStackFromBottom(stackFromBottom) {
                if (this.mStackFromBottom != stackFromBottom) {
                    this.mStackFromBottom = stackFromBottom;
                    this.requestLayoutIfNecessary();
                }
            }
            requestLayoutIfNecessary() {
                if (this.getChildCount() > 0) {
                    this.resetList();
                    this.requestLayout();
                    this.invalidate();
                }
            }
            onFocusChanged(gainFocus, direction, previouslyFocusedRect) {
                super.onFocusChanged(gainFocus, direction, previouslyFocusedRect);
                if (gainFocus && this.mSelectedPosition < 0 && !this.isInTouchMode()) {
                    if (!this.isAttachedToWindow() && this.mAdapter != null) {
                        this.mDataChanged = true;
                        this.mOldItemCount = this.mItemCount;
                        this.mItemCount = this.mAdapter.getCount();
                    }
                    this.resurrectSelection();
                }
            }
            requestLayout() {
                if (!this.mBlockLayoutRequests && !this.mInLayout) {
                    super.requestLayout();
                }
            }
            resetList() {
                this.removeAllViewsInLayout();
                this.mFirstPosition = 0;
                this.mDataChanged = false;
                this.mPositionScrollAfterLayout = null;
                this.mNeedSync = false;
                this.mPendingSync = null;
                this.mOldSelectedPosition = AbsListView.INVALID_POSITION;
                this.mOldSelectedRowId = AbsListView.INVALID_ROW_ID;
                this.setSelectedPositionInt(AbsListView.INVALID_POSITION);
                this.setNextSelectedPositionInt(AbsListView.INVALID_POSITION);
                this.mSelectedTop = 0;
                this.mSelectorPosition = AbsListView.INVALID_POSITION;
                this.mSelectorRect.setEmpty();
                this.invalidate();
            }
            computeVerticalScrollExtent() {
                const count = this.getChildCount();
                if (count > 0) {
                    if (this.mSmoothScrollbarEnabled) {
                        let extent = count * 100;
                        let view = this.getChildAt(0);
                        const top = view.getTop();
                        let height = view.getHeight();
                        if (height > 0) {
                            extent += (top * 100) / height;
                        }
                        view = this.getChildAt(count - 1);
                        const bottom = view.getBottom();
                        height = view.getHeight();
                        if (height > 0) {
                            extent -= ((bottom - this.getHeight()) * 100) / height;
                        }
                        return extent;
                    }
                    else {
                        return 1;
                    }
                }
                return 0;
            }
            computeVerticalScrollOffset() {
                const firstPosition = this.mFirstPosition;
                const childCount = this.getChildCount();
                if (firstPosition >= 0 && childCount > 0) {
                    if (this.mSmoothScrollbarEnabled) {
                        const view = this.getChildAt(0);
                        const top = view.getTop();
                        let height = view.getHeight();
                        if (height > 0) {
                            return Math.max(firstPosition * 100 - (top * 100) / height + Math.floor((this.mScrollY / this.getHeight() * this.mItemCount * 100)), 0);
                        }
                    }
                    else {
                        let index;
                        const count = this.mItemCount;
                        if (firstPosition == 0) {
                            index = 0;
                        }
                        else if (firstPosition + childCount == count) {
                            index = count;
                        }
                        else {
                            index = firstPosition + childCount / 2;
                        }
                        return Math.floor((firstPosition + childCount * (index / count)));
                    }
                }
                return 0;
            }
            computeVerticalScrollRange() {
                let result;
                if (this.mSmoothScrollbarEnabled) {
                    result = Math.max(this.mItemCount * 100, 0);
                    if (this.mScrollY != 0) {
                        result += Math.abs(Math.floor((this.mScrollY / this.getHeight() * this.mItemCount * 100)));
                    }
                }
                else {
                    result = this.mItemCount;
                }
                return result;
            }
            getTopFadingEdgeStrength() {
                const count = this.getChildCount();
                const fadeEdge = super.getTopFadingEdgeStrength();
                if (count == 0) {
                    return fadeEdge;
                }
                else {
                    if (this.mFirstPosition > 0) {
                        return 1.0;
                    }
                    const top = this.getChildAt(0).getTop();
                    const fadeLength = this.getVerticalFadingEdgeLength();
                    return top < this.mPaddingTop ? -(top - this.mPaddingTop) / fadeLength : fadeEdge;
                }
            }
            getBottomFadingEdgeStrength() {
                const count = this.getChildCount();
                const fadeEdge = super.getBottomFadingEdgeStrength();
                if (count == 0) {
                    return fadeEdge;
                }
                else {
                    if (this.mFirstPosition + count - 1 < this.mItemCount - 1) {
                        return 1.0;
                    }
                    const bottom = this.getChildAt(count - 1).getBottom();
                    const height = this.getHeight();
                    const fadeLength = this.getVerticalFadingEdgeLength();
                    return bottom > height - this.mPaddingBottom ? (bottom - height + this.mPaddingBottom) / fadeLength : fadeEdge;
                }
            }
            onMeasure(widthMeasureSpec, heightMeasureSpec) {
                if (this.mSelector == null) {
                    this.useDefaultSelector();
                }
                const listPadding = this.mListPadding;
                listPadding.left = this.mSelectionLeftPadding + this.mPaddingLeft;
                listPadding.top = this.mSelectionTopPadding + this.mPaddingTop;
                listPadding.right = this.mSelectionRightPadding + this.mPaddingRight;
                listPadding.bottom = this.mSelectionBottomPadding + this.mPaddingBottom;
                if (this.mTranscriptMode == AbsListView.TRANSCRIPT_MODE_NORMAL) {
                    const childCount = this.getChildCount();
                    const listBottom = this.getHeight() - this.getPaddingBottom();
                    const lastChild = this.getChildAt(childCount - 1);
                    const lastBottom = lastChild != null ? lastChild.getBottom() : listBottom;
                    this.mForceTranscriptScroll = this.mFirstPosition + childCount >= this.mLastHandledItemCount && lastBottom <= listBottom;
                }
            }
            onLayout(changed, l, t, r, b) {
                super.onLayout(changed, l, t, r, b);
                this.mInLayout = true;
                if (changed) {
                    let childCount = this.getChildCount();
                    for (let i = 0; i < childCount; i++) {
                        this.getChildAt(i).forceLayout();
                    }
                    this.mRecycler.markChildrenDirty();
                }
                this.layoutChildren();
                this.mInLayout = false;
                this.mOverscrollMax = (b - t) / AbsListView.OVERSCROLL_LIMIT_DIVISOR;
            }
            setFrame(left, top, right, bottom) {
                const changed = super.setFrame(left, top, right, bottom);
                if (changed) {
                    const visible = this.getWindowVisibility() == View.VISIBLE;
                }
                return changed;
            }
            layoutChildren() {
            }
            updateScrollIndicators() {
                if (this.mScrollUp != null) {
                    let canScrollUp;
                    canScrollUp = this.mFirstPosition > 0;
                    if (!canScrollUp) {
                        if (this.getChildCount() > 0) {
                            let child = this.getChildAt(0);
                            canScrollUp = child.getTop() < this.mListPadding.top;
                        }
                    }
                    this.mScrollUp.setVisibility(canScrollUp ? View.VISIBLE : View.INVISIBLE);
                }
                if (this.mScrollDown != null) {
                    let canScrollDown;
                    let count = this.getChildCount();
                    canScrollDown = (this.mFirstPosition + count) < this.mItemCount;
                    if (!canScrollDown && count > 0) {
                        let child = this.getChildAt(count - 1);
                        canScrollDown = child.getBottom() > this.mBottom - this.mListPadding.bottom;
                    }
                    this.mScrollDown.setVisibility(canScrollDown ? View.VISIBLE : View.INVISIBLE);
                }
            }
            getSelectedView() {
                if (this.mItemCount > 0 && this.mSelectedPosition >= 0) {
                    return this.getChildAt(this.mSelectedPosition - this.mFirstPosition);
                }
                else {
                    return null;
                }
            }
            getListPaddingTop() {
                return this.mListPadding.top;
            }
            getListPaddingBottom() {
                return this.mListPadding.bottom;
            }
            getListPaddingLeft() {
                return this.mListPadding.left;
            }
            getListPaddingRight() {
                return this.mListPadding.right;
            }
            obtainView(position, isScrap) {
                isScrap[0] = false;
                let scrapView;
                scrapView = this.mRecycler.getTransientStateView(position);
                if (scrapView == null) {
                    scrapView = this.mRecycler.getScrapView(position);
                }
                let child;
                if (scrapView != null) {
                    child = this.mAdapter.getView(position, scrapView, this);
                    if (child != scrapView) {
                        this.mRecycler.addScrapView(scrapView, position);
                        if (this.mCacheColorHint != 0) {
                            child.setDrawingCacheBackgroundColor(this.mCacheColorHint);
                        }
                    }
                    else {
                        isScrap[0] = true;
                        child.dispatchFinishTemporaryDetach();
                    }
                }
                else {
                    child = this.mAdapter.getView(position, null, this);
                    if (this.mCacheColorHint != 0) {
                        child.setDrawingCacheBackgroundColor(this.mCacheColorHint);
                    }
                }
                if (this.mAdapterHasStableIds) {
                    const vlp = child.getLayoutParams();
                    let lp;
                    if (vlp == null) {
                        lp = this.generateDefaultLayoutParams();
                    }
                    else if (!this.checkLayoutParams(vlp)) {
                        lp = this.generateLayoutParams(vlp);
                    }
                    else {
                        lp = vlp;
                    }
                    lp.itemId = this.mAdapter.getItemId(position);
                    child.setLayoutParams(lp);
                }
                return child;
            }
            positionSelector(...args) {
                if (args.length === 4) {
                    let [l, t, r, b] = args;
                    this.mSelectorRect.set(l - this.mSelectionLeftPadding, t - this.mSelectionTopPadding, r + this.mSelectionRightPadding, b + this.mSelectionBottomPadding);
                }
                else {
                    let position = args[0];
                    let sel = args[1];
                    if (position != AbsListView.INVALID_POSITION) {
                        this.mSelectorPosition = position;
                    }
                    const selectorRect = this.mSelectorRect;
                    selectorRect.set(sel.getLeft(), sel.getTop(), sel.getRight(), sel.getBottom());
                    if (sel['adjustListItemSelectionBounds']) {
                        sel.adjustListItemSelectionBounds(selectorRect);
                    }
                    this.positionSelector(selectorRect.left, selectorRect.top, selectorRect.right, selectorRect.bottom);
                    const isChildViewEnabled = this.mIsChildViewEnabled;
                    if (sel.isEnabled() != isChildViewEnabled) {
                        this.mIsChildViewEnabled = !isChildViewEnabled;
                        if (this.getSelectedItemPosition() != AbsListView.INVALID_POSITION) {
                            this.refreshDrawableState();
                        }
                    }
                }
            }
            dispatchDraw(canvas) {
                let saveCount = 0;
                const clipToPadding = (this.mGroupFlags & AbsListView.CLIP_TO_PADDING_MASK) == AbsListView.CLIP_TO_PADDING_MASK;
                if (clipToPadding) {
                    saveCount = canvas.save();
                    const scrollX = this.mScrollX;
                    const scrollY = this.mScrollY;
                    canvas.clipRect(scrollX + this.mPaddingLeft, scrollY + this.mPaddingTop, scrollX + this.mRight - this.mLeft - this.mPaddingRight, scrollY + this.mBottom - this.mTop - this.mPaddingBottom);
                    this.mGroupFlags &= ~AbsListView.CLIP_TO_PADDING_MASK;
                }
                const drawSelectorOnTop = this.mDrawSelectorOnTop;
                if (!drawSelectorOnTop) {
                    this.drawSelector(canvas);
                }
                super.dispatchDraw(canvas);
                if (drawSelectorOnTop) {
                    this.drawSelector(canvas);
                }
                if (clipToPadding) {
                    canvas.restoreToCount(saveCount);
                    this.mGroupFlags |= AbsListView.CLIP_TO_PADDING_MASK;
                }
            }
            isPaddingOffsetRequired() {
                return (this.mGroupFlags & AbsListView.CLIP_TO_PADDING_MASK) != AbsListView.CLIP_TO_PADDING_MASK;
            }
            getLeftPaddingOffset() {
                return (this.mGroupFlags & AbsListView.CLIP_TO_PADDING_MASK) == AbsListView.CLIP_TO_PADDING_MASK ? 0 : -this.mPaddingLeft;
            }
            getTopPaddingOffset() {
                return (this.mGroupFlags & AbsListView.CLIP_TO_PADDING_MASK) == AbsListView.CLIP_TO_PADDING_MASK ? 0 : -this.mPaddingTop;
            }
            getRightPaddingOffset() {
                return (this.mGroupFlags & AbsListView.CLIP_TO_PADDING_MASK) == AbsListView.CLIP_TO_PADDING_MASK ? 0 : this.mPaddingRight;
            }
            getBottomPaddingOffset() {
                return (this.mGroupFlags & AbsListView.CLIP_TO_PADDING_MASK) == AbsListView.CLIP_TO_PADDING_MASK ? 0 : this.mPaddingBottom;
            }
            onSizeChanged(w, h, oldw, oldh) {
                if (this.getChildCount() > 0) {
                    this.mDataChanged = true;
                    this.rememberSyncState();
                }
            }
            touchModeDrawsInPressedState() {
                switch (this.mTouchMode) {
                    case AbsListView.TOUCH_MODE_TAP:
                    case AbsListView.TOUCH_MODE_DONE_WAITING:
                        return true;
                    default:
                        return false;
                }
            }
            shouldShowSelector() {
                return (!this.isInTouchMode()) || (this.touchModeDrawsInPressedState() && this.isPressed());
            }
            drawSelector(canvas) {
                if (!this.mSelectorRect.isEmpty()) {
                    const selector = this.mSelector;
                    selector.setBounds(this.mSelectorRect);
                    selector.draw(canvas);
                }
            }
            setDrawSelectorOnTop(onTop) {
                this.mDrawSelectorOnTop = onTop;
            }
            setSelector(sel) {
                if (this.mSelector != null) {
                    this.mSelector.setCallback(null);
                    this.unscheduleDrawable(this.mSelector);
                }
                this.mSelector = sel;
                let padding = new Rect();
                sel.getPadding(padding);
                this.mSelectionLeftPadding = padding.left;
                this.mSelectionTopPadding = padding.top;
                this.mSelectionRightPadding = padding.right;
                this.mSelectionBottomPadding = padding.bottom;
                sel.setCallback(this);
                this.updateSelectorState();
            }
            getSelector() {
                return this.mSelector;
            }
            keyPressed() {
                if (!this.isEnabled() || !this.isClickable()) {
                    return;
                }
                let selector = this.mSelector;
                let selectorRect = this.mSelectorRect;
                if (selector != null && (this.isFocused() || this.touchModeDrawsInPressedState()) && !selectorRect.isEmpty()) {
                    const v = this.getChildAt(this.mSelectedPosition - this.mFirstPosition);
                    if (v != null) {
                        if (v.hasFocusable())
                            return;
                        v.setPressed(true);
                    }
                    this.setPressed(true);
                    const longClickable = this.isLongClickable();
                    let d = selector.getCurrent();
                    if (longClickable && !this.mDataChanged) {
                        if (this.mPendingCheckForKeyLongPress == null) {
                            this.mPendingCheckForKeyLongPress = new AbsListView.CheckForKeyLongPress(this);
                        }
                        this.mPendingCheckForKeyLongPress.rememberWindowAttachCount();
                        this.postDelayed(this.mPendingCheckForKeyLongPress, ViewConfiguration.getLongPressTimeout());
                    }
                }
            }
            setScrollIndicators(up, down) {
                this.mScrollUp = up;
                this.mScrollDown = down;
            }
            updateSelectorState() {
                if (this.mSelector != null) {
                    if (this.shouldShowSelector()) {
                        this.mSelector.setState(this.getDrawableState());
                    }
                    else {
                        this.mSelector.setState(StateSet.NOTHING);
                    }
                }
            }
            drawableStateChanged() {
                super.drawableStateChanged();
                this.updateSelectorState();
            }
            onCreateDrawableState(extraSpace) {
                if (this.mIsChildViewEnabled) {
                    return super.onCreateDrawableState(extraSpace);
                }
                const enabledState = AbsListView.ENABLED_STATE_SET[0];
                let state = super.onCreateDrawableState(extraSpace + 1);
                let enabledPos = -1;
                for (let i = state.length - 1; i >= 0; i--) {
                    if (state[i] == enabledState) {
                        enabledPos = i;
                        break;
                    }
                }
                if (enabledPos >= 0) {
                    System.arraycopy(state, enabledPos + 1, state, enabledPos, state.length - enabledPos - 1);
                }
                return state;
            }
            verifyDrawable(dr) {
                return this.mSelector == dr || super.verifyDrawable(dr);
            }
            jumpDrawablesToCurrentState() {
                super.jumpDrawablesToCurrentState();
                if (this.mSelector != null)
                    this.mSelector.jumpToCurrentState();
            }
            onAttachedToWindow() {
                super.onAttachedToWindow();
                const treeObserver = this.getViewTreeObserver();
                treeObserver.addOnTouchModeChangeListener(this);
                if (this.mAdapter != null && this.mDataSetObserver == null) {
                    this.mDataSetObserver = new AbsListView.AdapterDataSetObserver(this);
                    this.mAdapter.registerDataSetObserver(this.mDataSetObserver);
                    this.mDataChanged = true;
                    this.mOldItemCount = this.mItemCount;
                    this.mItemCount = this.mAdapter.getCount();
                }
            }
            onDetachedFromWindow() {
                super.onDetachedFromWindow();
                this.dismissPopup();
                this.mRecycler.clear();
                const treeObserver = this.getViewTreeObserver();
                treeObserver.removeOnTouchModeChangeListener(this);
                if (this.mAdapter != null && this.mDataSetObserver != null) {
                    this.mAdapter.unregisterDataSetObserver(this.mDataSetObserver);
                    this.mDataSetObserver = null;
                }
                if (this.mFlingRunnable != null) {
                    this.removeCallbacks(this.mFlingRunnable);
                }
                if (this.mPositionScroller != null) {
                    this.mPositionScroller.stop();
                }
                if (this.mClearScrollingCache != null) {
                    this.removeCallbacks(this.mClearScrollingCache);
                }
                if (this.mPerformClick_ != null) {
                    this.removeCallbacks(this.mPerformClick_);
                }
                if (this.mTouchModeReset != null) {
                    this.removeCallbacks(this.mTouchModeReset);
                    this.mTouchModeReset.run();
                }
            }
            onWindowFocusChanged(hasWindowFocus) {
                super.onWindowFocusChanged(hasWindowFocus);
                const touchMode = this.isInTouchMode() ? AbsListView.TOUCH_MODE_ON : AbsListView.TOUCH_MODE_OFF;
                if (!hasWindowFocus) {
                    this.setChildrenDrawingCacheEnabled(false);
                    if (this.mFlingRunnable != null) {
                        this.removeCallbacks(this.mFlingRunnable);
                        this.mFlingRunnable.endFling();
                        if (this.mPositionScroller != null) {
                            this.mPositionScroller.stop();
                        }
                        if (this.mScrollY != 0) {
                            this.mScrollY = 0;
                            this.invalidateParentCaches();
                            this.finishGlows();
                            this.invalidate();
                        }
                    }
                    this.dismissPopup();
                    if (touchMode == AbsListView.TOUCH_MODE_OFF) {
                        this.mResurrectToPosition = this.mSelectedPosition;
                    }
                }
                else {
                    if (this.mFiltered && !this.mPopupHidden) {
                        this.showPopup();
                    }
                    if (touchMode != this.mLastTouchMode && this.mLastTouchMode != AbsListView.TOUCH_MODE_UNKNOWN) {
                        if (touchMode == AbsListView.TOUCH_MODE_OFF) {
                            this.resurrectSelection();
                        }
                        else {
                            this.hideSelector();
                            this.mLayoutMode = AbsListView.LAYOUT_NORMAL;
                            this.layoutChildren();
                        }
                    }
                }
                this.mLastTouchMode = touchMode;
            }
            onCancelPendingInputEvents() {
                super.onCancelPendingInputEvents();
                if (this.mPerformClick_ != null) {
                    this.removeCallbacks(this.mPerformClick_);
                }
                if (this.mPendingCheckForTap_ != null) {
                    this.removeCallbacks(this.mPendingCheckForTap_);
                }
                if (this.mPendingCheckForLongPress_List != null) {
                    this.removeCallbacks(this.mPendingCheckForLongPress_List);
                }
                if (this.mPendingCheckForKeyLongPress != null) {
                    this.removeCallbacks(this.mPendingCheckForKeyLongPress);
                }
            }
            performLongPress(child, longPressPosition, longPressId) {
                let handled = false;
                if (this.mOnItemLongClickListener != null) {
                    handled = this.mOnItemLongClickListener.onItemLongClick(this, child, longPressPosition, longPressId);
                }
                if (handled) {
                    this.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
                }
                return handled;
            }
            onKeyDown(keyCode, event) {
                return false;
            }
            onKeyUp(keyCode, event) {
                if (KeyEvent.isConfirmKey(keyCode)) {
                    if (!this.isEnabled()) {
                        return true;
                    }
                    if (this.isClickable() && this.isPressed() && this.mSelectedPosition >= 0
                        && this.mAdapter != null && this.mSelectedPosition < this.mAdapter.getCount()) {
                        const view = this.getChildAt(this.mSelectedPosition - this.mFirstPosition);
                        if (view != null) {
                            this.performItemClick(view, this.mSelectedPosition, this.mSelectedRowId);
                            view.setPressed(false);
                        }
                        this.setPressed(false);
                        return true;
                    }
                }
                return super.onKeyUp(keyCode, event);
            }
            dispatchSetPressed(pressed) {
            }
            pointToPosition(x, y) {
                let frame = this.mTouchFrame;
                if (frame == null) {
                    this.mTouchFrame = new Rect();
                    frame = this.mTouchFrame;
                }
                const count = this.getChildCount();
                for (let i = count - 1; i >= 0; i--) {
                    const child = this.getChildAt(i);
                    if (child.getVisibility() == View.VISIBLE) {
                        child.getHitRect(frame);
                        if (frame.contains(x, y)) {
                            return this.mFirstPosition + i;
                        }
                    }
                }
                return AbsListView.INVALID_POSITION;
            }
            pointToRowId(x, y) {
                let position = this.pointToPosition(x, y);
                if (position >= 0) {
                    return this.mAdapter.getItemId(position);
                }
                return AbsListView.INVALID_ROW_ID;
            }
            checkOverScrollStartScrollIfNeeded() {
                return this.mScrollY != 0;
            }
            startScrollIfNeeded(y) {
                const deltaY = y - this.mMotionY;
                const distance = Math.abs(deltaY);
                const overscroll = this.checkOverScrollStartScrollIfNeeded();
                if (overscroll || distance > this.mTouchSlop) {
                    this.createScrollingCache();
                    if (this.mScrollY != 0) {
                        this.mTouchMode = AbsListView.TOUCH_MODE_OVERSCROLL;
                        this.mMotionCorrection = 0;
                    }
                    else {
                        this.mTouchMode = AbsListView.TOUCH_MODE_SCROLL;
                        this.mMotionCorrection = deltaY > 0 ? this.mTouchSlop : -this.mTouchSlop;
                    }
                    this.removeCallbacks(this.mPendingCheckForLongPress_List);
                    this.setPressed(false);
                    const motionView = this.getChildAt(this.mMotionPosition - this.mFirstPosition);
                    if (motionView != null) {
                        motionView.setPressed(false);
                    }
                    this.reportScrollStateChange(AbsListView.OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
                    const parent = this.getParent();
                    if (parent != null) {
                        parent.requestDisallowInterceptTouchEvent(true);
                    }
                    this.scrollIfNeeded(y);
                    return true;
                }
                return false;
            }
            scrollIfNeeded(y) {
                const rawDeltaY = y - this.mMotionY;
                const deltaY = rawDeltaY - this.mMotionCorrection;
                let incrementalDeltaY = this.mLastY != Integer.MIN_VALUE ? y - this.mLastY : deltaY;
                if (this.mTouchMode == AbsListView.TOUCH_MODE_SCROLL) {
                    if (AbsListView.PROFILE_SCROLLING) {
                        if (!this.mScrollProfilingStarted) {
                            this.mScrollProfilingStarted = true;
                        }
                    }
                    if (y != this.mLastY) {
                        if ((this.mGroupFlags & AbsListView.FLAG_DISALLOW_INTERCEPT) == 0 && Math.abs(rawDeltaY) > this.mTouchSlop) {
                            const parent = this.getParent();
                            if (parent != null) {
                                parent.requestDisallowInterceptTouchEvent(true);
                            }
                        }
                        let motionIndex;
                        if (this.mMotionPosition >= 0) {
                            motionIndex = this.mMotionPosition - this.mFirstPosition;
                        }
                        else {
                            motionIndex = this.getChildCount() / 2;
                        }
                        let motionViewPrevTop = 0;
                        let motionView = this.getChildAt(motionIndex);
                        if (motionView != null) {
                            motionViewPrevTop = motionView.getTop();
                        }
                        let atEdge = false;
                        if (incrementalDeltaY != 0) {
                            atEdge = this.trackMotionScroll(deltaY, incrementalDeltaY);
                        }
                        motionView = this.getChildAt(motionIndex);
                        if (motionView != null) {
                            const motionViewRealTop = motionView.getTop();
                            if (atEdge) {
                                let overscroll = -incrementalDeltaY - (motionViewRealTop - motionViewPrevTop);
                                this.overScrollBy(0, overscroll, 0, this.mScrollY, 0, 0, 0, this.mOverscrollDistance, true);
                                if (Math.abs(this.mOverscrollDistance) == Math.abs(this.mScrollY)) {
                                    if (this.mVelocityTracker != null) {
                                        this.mVelocityTracker.clear();
                                    }
                                }
                                const overscrollMode = this.getOverScrollMode();
                                if (overscrollMode == AbsListView.OVER_SCROLL_ALWAYS || (overscrollMode == AbsListView.OVER_SCROLL_IF_CONTENT_SCROLLS && !this.contentFits())) {
                                    this.mDirection = 0;
                                    this.mTouchMode = AbsListView.TOUCH_MODE_OVERSCROLL;
                                    if (rawDeltaY > 0) {
                                    }
                                    else if (rawDeltaY < 0) {
                                    }
                                }
                            }
                            this.mMotionY = y;
                        }
                        this.mLastY = y;
                    }
                }
                else if (this.mTouchMode == AbsListView.TOUCH_MODE_OVERSCROLL) {
                    if (y != this.mLastY) {
                        const oldScroll = this.mScrollY;
                        const newScroll = oldScroll - incrementalDeltaY;
                        let newDirection = y > this.mLastY ? 1 : -1;
                        if (this.mDirection == 0) {
                            this.mDirection = newDirection;
                        }
                        let overScrollDistance = -incrementalDeltaY;
                        if ((newScroll < 0 && oldScroll >= 0) || (newScroll > 0 && oldScroll <= 0)) {
                            overScrollDistance = -oldScroll;
                            incrementalDeltaY += overScrollDistance;
                        }
                        else {
                            incrementalDeltaY = 0;
                        }
                        if (overScrollDistance != 0) {
                            this.overScrollBy(0, overScrollDistance, 0, this.mScrollY, 0, 0, 0, this.mOverscrollDistance, true);
                        }
                        if (incrementalDeltaY != 0) {
                            if (this.mScrollY != 0) {
                                this.mScrollY = 0;
                                this.invalidateParentIfNeeded();
                            }
                            this.trackMotionScroll(incrementalDeltaY, incrementalDeltaY);
                            this.mTouchMode = AbsListView.TOUCH_MODE_SCROLL;
                            const motionPosition = this.findClosestMotionRow(y);
                            this.mMotionCorrection = 0;
                            let motionView = this.getChildAt(motionPosition - this.mFirstPosition);
                            this.mMotionViewOriginalTop = motionView != null ? motionView.getTop() : 0;
                            this.mMotionY = y;
                            this.mMotionPosition = motionPosition;
                        }
                        this.mLastY = y;
                        this.mDirection = newDirection;
                    }
                }
            }
            onTouchModeChanged(isInTouchMode) {
                if (isInTouchMode) {
                    this.hideSelector();
                    if (this.getHeight() > 0 && this.getChildCount() > 0) {
                        this.layoutChildren();
                    }
                    this.updateSelectorState();
                }
                else {
                    let touchMode = this.mTouchMode;
                    if (touchMode == AbsListView.TOUCH_MODE_OVERSCROLL || touchMode == AbsListView.TOUCH_MODE_OVERFLING) {
                        if (this.mFlingRunnable != null) {
                            this.mFlingRunnable.endFling();
                        }
                        if (this.mPositionScroller != null) {
                            this.mPositionScroller.stop();
                        }
                        if (this.mScrollY != 0) {
                            this.mScrollY = 0;
                            this.invalidateParentCaches();
                            this.finishGlows();
                            this.invalidate();
                        }
                    }
                }
            }
            onTouchEvent(ev) {
                if (!this.isEnabled()) {
                    return this.isClickable() || this.isLongClickable();
                }
                if (this.mPositionScroller != null) {
                    this.mPositionScroller.stop();
                }
                if (!this.isAttachedToWindow()) {
                    return false;
                }
                this.initVelocityTrackerIfNotExists();
                this.mVelocityTracker.addMovement(ev);
                const actionMasked = ev.getActionMasked();
                switch (actionMasked) {
                    case MotionEvent.ACTION_DOWN:
                        {
                            this.onTouchDown(ev);
                            break;
                        }
                    case MotionEvent.ACTION_MOVE:
                        {
                            this.onTouchMove(ev);
                            break;
                        }
                    case MotionEvent.ACTION_UP:
                        {
                            this.onTouchUp(ev);
                            break;
                        }
                    case MotionEvent.ACTION_CANCEL:
                        {
                            this.onTouchCancel();
                            break;
                        }
                    case MotionEvent.ACTION_POINTER_UP:
                        {
                            this.onSecondaryPointerUp(ev);
                            const x = this.mMotionX;
                            const y = this.mMotionY;
                            const motionPosition = this.pointToPosition(x, y);
                            if (motionPosition >= 0) {
                                const child = this.getChildAt(motionPosition - this.mFirstPosition);
                                this.mMotionViewOriginalTop = child.getTop();
                                this.mMotionPosition = motionPosition;
                            }
                            this.mLastY = y;
                            break;
                        }
                    case MotionEvent.ACTION_POINTER_DOWN:
                        {
                            const index = ev.getActionIndex();
                            const id = ev.getPointerId(index);
                            const x = Math.floor(ev.getX(index));
                            const y = Math.floor(ev.getY(index));
                            this.mMotionCorrection = 0;
                            this.mActivePointerId = id;
                            this.mMotionX = x;
                            this.mMotionY = y;
                            const motionPosition = this.pointToPosition(x, y);
                            if (motionPosition >= 0) {
                                const child = this.getChildAt(motionPosition - this.mFirstPosition);
                                this.mMotionViewOriginalTop = child.getTop();
                                this.mMotionPosition = motionPosition;
                            }
                            this.mLastY = y;
                            break;
                        }
                }
                return true;
            }
            onTouchDown(ev) {
                this.mActivePointerId = ev.getPointerId(0);
                if (this.mTouchMode == AbsListView.TOUCH_MODE_OVERFLING) {
                    this.mFlingRunnable.endFling();
                    if (this.mPositionScroller != null) {
                        this.mPositionScroller.stop();
                    }
                    this.mTouchMode = AbsListView.TOUCH_MODE_OVERSCROLL;
                    this.mMotionX = Math.floor(ev.getX());
                    this.mMotionY = Math.floor(ev.getY());
                    this.mLastY = this.mMotionY;
                    this.mMotionCorrection = 0;
                    this.mDirection = 0;
                }
                else {
                    const x = Math.floor(ev.getX());
                    const y = Math.floor(ev.getY());
                    let motionPosition = this.pointToPosition(x, y);
                    if (!this.mDataChanged) {
                        if (this.mTouchMode == AbsListView.TOUCH_MODE_FLING) {
                            this.createScrollingCache();
                            this.mTouchMode = AbsListView.TOUCH_MODE_SCROLL;
                            this.mMotionCorrection = 0;
                            motionPosition = this.findMotionRow(y);
                            this.mFlingRunnable.flywheelTouch();
                        }
                        else if ((motionPosition >= 0) && this.getAdapter().isEnabled(motionPosition)) {
                            this.mTouchMode = AbsListView.TOUCH_MODE_DOWN;
                            if (this.mPendingCheckForTap_ == null) {
                                this.mPendingCheckForTap_ = new AbsListView.CheckForTap(this);
                            }
                            this.postDelayed(this.mPendingCheckForTap_, ViewConfiguration.getTapTimeout());
                        }
                        else if (motionPosition < 0) {
                            this.mTouchMode = AbsListView.TOUCH_MODE_DOWN;
                        }
                    }
                    if (motionPosition >= 0) {
                        const v = this.getChildAt(motionPosition - this.mFirstPosition);
                        this.mMotionViewOriginalTop = v.getTop();
                    }
                    this.mMotionX = x;
                    this.mMotionY = y;
                    this.mMotionPosition = motionPosition;
                    this.mLastY = Integer.MIN_VALUE;
                }
                if (this.mTouchMode == AbsListView.TOUCH_MODE_DOWN && this.mMotionPosition != AbsListView.INVALID_POSITION
                    && this.performButtonActionOnTouchDown(ev)) {
                    this.removeCallbacks(this.mPendingCheckForTap_);
                }
            }
            onTouchMove(ev) {
                let pointerIndex = ev.findPointerIndex(this.mActivePointerId);
                if (pointerIndex == -1) {
                    pointerIndex = 0;
                    this.mActivePointerId = ev.getPointerId(pointerIndex);
                }
                if (this.mDataChanged) {
                    this.layoutChildren();
                }
                const y = Math.floor(ev.getY(pointerIndex));
                switch (this.mTouchMode) {
                    case AbsListView.TOUCH_MODE_DOWN:
                    case AbsListView.TOUCH_MODE_TAP:
                    case AbsListView.TOUCH_MODE_DONE_WAITING:
                        if (this.startScrollIfNeeded(y)) {
                            break;
                        }
                        const x = ev.getX(pointerIndex);
                        if (!this.pointInView(x, y, this.mTouchSlop)) {
                            this.setPressed(false);
                            const motionView = this.getChildAt(this.mMotionPosition - this.mFirstPosition);
                            if (motionView != null) {
                                motionView.setPressed(false);
                            }
                            this.removeCallbacks(this.mTouchMode == AbsListView.TOUCH_MODE_DOWN ? this.mPendingCheckForTap_ : this.mPendingCheckForLongPress_List);
                            this.mTouchMode = AbsListView.TOUCH_MODE_DONE_WAITING;
                            this.updateSelectorState();
                        }
                        break;
                    case AbsListView.TOUCH_MODE_SCROLL:
                    case AbsListView.TOUCH_MODE_OVERSCROLL:
                        this.scrollIfNeeded(y);
                        break;
                }
            }
            onTouchUp(ev) {
                switch (this.mTouchMode) {
                    case AbsListView.TOUCH_MODE_DOWN:
                    case AbsListView.TOUCH_MODE_TAP:
                    case AbsListView.TOUCH_MODE_DONE_WAITING:
                        const motionPosition = this.mMotionPosition;
                        const child = this.getChildAt(motionPosition - this.mFirstPosition);
                        if (child != null) {
                            if (this.mTouchMode != AbsListView.TOUCH_MODE_DOWN) {
                                child.setPressed(false);
                            }
                            const x = ev.getX();
                            const inList = x > this.mListPadding.left && x < this.getWidth() - this.mListPadding.right;
                            if (inList && !child.hasFocusable()) {
                                if (this.mPerformClick_ == null) {
                                    this.mPerformClick_ = new AbsListView.PerformClick(this);
                                }
                                const performClick = this.mPerformClick_;
                                performClick.mClickMotionPosition = motionPosition;
                                performClick.rememberWindowAttachCount();
                                this.mResurrectToPosition = motionPosition;
                                if (this.mTouchMode == AbsListView.TOUCH_MODE_DOWN || this.mTouchMode == AbsListView.TOUCH_MODE_TAP) {
                                    this.removeCallbacks(this.mTouchMode == AbsListView.TOUCH_MODE_DOWN ? this.mPendingCheckForTap_ : this.mPendingCheckForLongPress_List);
                                    this.mLayoutMode = AbsListView.LAYOUT_NORMAL;
                                    if (!this.mDataChanged && this.mAdapter.isEnabled(motionPosition)) {
                                        this.mTouchMode = AbsListView.TOUCH_MODE_TAP;
                                        this.setSelectedPositionInt(this.mMotionPosition);
                                        this.layoutChildren();
                                        child.setPressed(true);
                                        this.positionSelector(this.mMotionPosition, child);
                                        this.setPressed(true);
                                        if (this.mSelector != null) {
                                            let d = this.mSelector.getCurrent();
                                        }
                                        if (this.mTouchModeReset != null) {
                                            this.removeCallbacks(this.mTouchModeReset);
                                        }
                                        this.mTouchModeReset = (() => {
                                            const _this = this;
                                            class _Inner {
                                                run() {
                                                    _this.mTouchModeReset = null;
                                                    _this.mTouchMode = AbsListView.TOUCH_MODE_REST;
                                                    child.setPressed(false);
                                                    _this.setPressed(false);
                                                    if (!_this.mDataChanged && _this.isAttachedToWindow()) {
                                                        performClick.run();
                                                    }
                                                }
                                            }
                                            return new _Inner();
                                        })();
                                        this.postDelayed(this.mTouchModeReset, ViewConfiguration.getPressedStateDuration());
                                    }
                                    else {
                                        this.mTouchMode = AbsListView.TOUCH_MODE_REST;
                                        this.updateSelectorState();
                                    }
                                    return;
                                }
                                else if (!this.mDataChanged && this.mAdapter.isEnabled(motionPosition)) {
                                    performClick.run();
                                }
                            }
                        }
                        this.mTouchMode = AbsListView.TOUCH_MODE_REST;
                        this.updateSelectorState();
                        break;
                    case AbsListView.TOUCH_MODE_SCROLL:
                        const childCount = this.getChildCount();
                        if (childCount > 0) {
                            const firstChildTop = this.getChildAt(0).getTop();
                            const lastChildBottom = this.getChildAt(childCount - 1).getBottom();
                            const contentTop = this.mListPadding.top;
                            const contentBottom = this.getHeight() - this.mListPadding.bottom;
                            if (this.mFirstPosition == 0 && firstChildTop >= contentTop && this.mFirstPosition + childCount < this.mItemCount
                                && lastChildBottom <= this.getHeight() - contentBottom) {
                                this.mTouchMode = AbsListView.TOUCH_MODE_REST;
                                this.reportScrollStateChange(AbsListView.OnScrollListener.SCROLL_STATE_IDLE);
                            }
                            else {
                                const velocityTracker = this.mVelocityTracker;
                                velocityTracker.computeCurrentVelocity(1000, this.mMaximumVelocity);
                                const initialVelocity = Math.floor((velocityTracker.getYVelocity(this.mActivePointerId) * this.mVelocityScale));
                                if (Math.abs(initialVelocity) > this.mMinimumVelocity
                                    && !((this.mFirstPosition == 0 && firstChildTop == contentTop - this.mOverscrollDistance)
                                        || (this.mFirstPosition + childCount == this.mItemCount
                                            && lastChildBottom == contentBottom + this.mOverscrollDistance))) {
                                    if (this.mFlingRunnable == null) {
                                        this.mFlingRunnable = new AbsListView.FlingRunnable(this);
                                    }
                                    this.reportScrollStateChange(AbsListView.OnScrollListener.SCROLL_STATE_FLING);
                                    this.mFlingRunnable.start(-initialVelocity);
                                }
                                else {
                                    this.mTouchMode = AbsListView.TOUCH_MODE_REST;
                                    this.reportScrollStateChange(AbsListView.OnScrollListener.SCROLL_STATE_IDLE);
                                    if (this.mFlingRunnable != null) {
                                        this.mFlingRunnable.endFling();
                                    }
                                    if (this.mPositionScroller != null) {
                                        this.mPositionScroller.stop();
                                    }
                                }
                            }
                        }
                        else {
                            this.mTouchMode = AbsListView.TOUCH_MODE_REST;
                            this.reportScrollStateChange(AbsListView.OnScrollListener.SCROLL_STATE_IDLE);
                        }
                        break;
                    case AbsListView.TOUCH_MODE_OVERSCROLL:
                        if (this.mFlingRunnable == null) {
                            this.mFlingRunnable = new AbsListView.FlingRunnable(this);
                        }
                        const velocityTracker = this.mVelocityTracker;
                        velocityTracker.computeCurrentVelocity(1000, this.mMaximumVelocity);
                        const initialVelocity = Math.floor(velocityTracker.getYVelocity(this.mActivePointerId));
                        this.reportScrollStateChange(AbsListView.OnScrollListener.SCROLL_STATE_FLING);
                        if (Math.abs(initialVelocity) > this.mMinimumVelocity) {
                            this.mFlingRunnable.startOverfling(-initialVelocity);
                        }
                        else {
                            this.mFlingRunnable.startSpringback();
                        }
                        break;
                }
                this.setPressed(false);
                this.invalidate();
                this.removeCallbacks(this.mPendingCheckForLongPress_List);
                this.recycleVelocityTracker();
                this.mActivePointerId = AbsListView.INVALID_POINTER;
                if (AbsListView.PROFILE_SCROLLING) {
                    if (this.mScrollProfilingStarted) {
                        this.mScrollProfilingStarted = false;
                    }
                }
            }
            onTouchCancel() {
                switch (this.mTouchMode) {
                    case AbsListView.TOUCH_MODE_OVERSCROLL:
                        if (this.mFlingRunnable == null) {
                            this.mFlingRunnable = new AbsListView.FlingRunnable(this);
                        }
                        this.mFlingRunnable.startSpringback();
                        break;
                    case AbsListView.TOUCH_MODE_OVERFLING:
                        break;
                    default:
                        this.mTouchMode = AbsListView.TOUCH_MODE_REST;
                        this.setPressed(false);
                        const motionView = this.getChildAt(this.mMotionPosition - this.mFirstPosition);
                        if (motionView != null) {
                            motionView.setPressed(false);
                        }
                        this.clearScrollingCache();
                        this.removeCallbacks(this.mPendingCheckForLongPress_List);
                        this.recycleVelocityTracker();
                }
                this.mActivePointerId = AbsListView.INVALID_POINTER;
            }
            onOverScrolled(scrollX, scrollY, clampedX, clampedY) {
                if (this.mScrollY != scrollY) {
                    this.onScrollChanged(this.mScrollX, scrollY, this.mScrollX, this.mScrollY);
                    this.mScrollY = scrollY;
                    this.invalidateParentIfNeeded();
                    this.awakenScrollBars();
                }
            }
            onGenericMotionEvent(event) {
                if (event.isPointerEvent()) {
                    switch (event.getAction()) {
                        case MotionEvent.ACTION_SCROLL:
                            {
                                if (this.mTouchMode == AbsListView.TOUCH_MODE_REST) {
                                    const vscroll = event.getAxisValue(MotionEvent.AXIS_VSCROLL);
                                    if (vscroll != 0) {
                                        const delta = Math.floor((vscroll * this.getVerticalScrollFactor()));
                                        if (!this.trackMotionScroll(delta, delta)) {
                                            return true;
                                        }
                                    }
                                }
                            }
                    }
                }
                return super.onGenericMotionEvent(event);
            }
            draw(canvas) {
                super.draw(canvas);
            }
            setOverScrollEffectPadding(leftPadding, rightPadding) {
                this.mGlowPaddingLeft = leftPadding;
                this.mGlowPaddingRight = rightPadding;
            }
            initOrResetVelocityTracker() {
                if (this.mVelocityTracker == null) {
                    this.mVelocityTracker = VelocityTracker.obtain();
                }
                else {
                    this.mVelocityTracker.clear();
                }
            }
            initVelocityTrackerIfNotExists() {
                if (this.mVelocityTracker == null) {
                    this.mVelocityTracker = VelocityTracker.obtain();
                }
            }
            recycleVelocityTracker() {
                if (this.mVelocityTracker != null) {
                    this.mVelocityTracker.recycle();
                    this.mVelocityTracker = null;
                }
            }
            requestDisallowInterceptTouchEvent(disallowIntercept) {
                if (disallowIntercept) {
                    this.recycleVelocityTracker();
                }
                super.requestDisallowInterceptTouchEvent(disallowIntercept);
            }
            onInterceptTouchEvent(ev) {
                let action = ev.getAction();
                let v;
                if (this.mPositionScroller != null) {
                    this.mPositionScroller.stop();
                }
                if (!this.isAttachedToWindow()) {
                    return false;
                }
                switch (action & MotionEvent.ACTION_MASK) {
                    case MotionEvent.ACTION_DOWN:
                        {
                            let touchMode = this.mTouchMode;
                            if (touchMode == AbsListView.TOUCH_MODE_OVERFLING || touchMode == AbsListView.TOUCH_MODE_OVERSCROLL) {
                                this.mMotionCorrection = 0;
                                return true;
                            }
                            const x = Math.floor(ev.getX());
                            const y = Math.floor(ev.getY());
                            this.mActivePointerId = ev.getPointerId(0);
                            let motionPosition = this.findMotionRow(y);
                            if (touchMode != AbsListView.TOUCH_MODE_FLING && motionPosition >= 0) {
                                v = this.getChildAt(motionPosition - this.mFirstPosition);
                                this.mMotionViewOriginalTop = v.getTop();
                                this.mMotionX = x;
                                this.mMotionY = y;
                                this.mMotionPosition = motionPosition;
                                this.mTouchMode = AbsListView.TOUCH_MODE_DOWN;
                                this.clearScrollingCache();
                            }
                            this.mLastY = Integer.MIN_VALUE;
                            this.initOrResetVelocityTracker();
                            this.mVelocityTracker.addMovement(ev);
                            if (touchMode == AbsListView.TOUCH_MODE_FLING) {
                                return true;
                            }
                            break;
                        }
                    case MotionEvent.ACTION_MOVE:
                        {
                            switch (this.mTouchMode) {
                                case AbsListView.TOUCH_MODE_DOWN:
                                    let pointerIndex = ev.findPointerIndex(this.mActivePointerId);
                                    if (pointerIndex == -1) {
                                        pointerIndex = 0;
                                        this.mActivePointerId = ev.getPointerId(pointerIndex);
                                    }
                                    const y = Math.floor(ev.getY(pointerIndex));
                                    this.initVelocityTrackerIfNotExists();
                                    this.mVelocityTracker.addMovement(ev);
                                    if (this.startScrollIfNeeded(y)) {
                                        return true;
                                    }
                                    break;
                            }
                            break;
                        }
                    case MotionEvent.ACTION_CANCEL:
                    case MotionEvent.ACTION_UP:
                        {
                            this.mTouchMode = AbsListView.TOUCH_MODE_REST;
                            this.mActivePointerId = AbsListView.INVALID_POINTER;
                            this.recycleVelocityTracker();
                            this.reportScrollStateChange(AbsListView.OnScrollListener.SCROLL_STATE_IDLE);
                            break;
                        }
                    case MotionEvent.ACTION_POINTER_UP:
                        {
                            this.onSecondaryPointerUp(ev);
                            break;
                        }
                }
                return false;
            }
            onSecondaryPointerUp(ev) {
                const pointerIndex = (ev.getAction() & MotionEvent.ACTION_POINTER_INDEX_MASK) >> MotionEvent.ACTION_POINTER_INDEX_SHIFT;
                const pointerId = ev.getPointerId(pointerIndex);
                if (pointerId == this.mActivePointerId) {
                    const newPointerIndex = pointerIndex == 0 ? 1 : 0;
                    this.mMotionX = Math.floor(ev.getX(newPointerIndex));
                    this.mMotionY = Math.floor(ev.getY(newPointerIndex));
                    this.mMotionCorrection = 0;
                    this.mActivePointerId = ev.getPointerId(newPointerIndex);
                }
            }
            addTouchables(views) {
                const count = this.getChildCount();
                const firstPosition = this.mFirstPosition;
                const adapter = this.mAdapter;
                if (adapter == null) {
                    return;
                }
                for (let i = 0; i < count; i++) {
                    const child = this.getChildAt(i);
                    if (adapter.isEnabled(firstPosition + i)) {
                        views.add(child);
                    }
                    child.addTouchables(views);
                }
            }
            reportScrollStateChange(newState) {
                if (newState != this.mLastScrollState) {
                    if (this.mOnScrollListener != null) {
                        this.mLastScrollState = newState;
                        this.mOnScrollListener.onScrollStateChanged(this, newState);
                    }
                }
            }
            setFriction(friction) {
                if (this.mFlingRunnable == null) {
                    this.mFlingRunnable = new AbsListView.FlingRunnable(this);
                }
                this.mFlingRunnable.mScroller.setFriction(friction);
            }
            setVelocityScale(scale) {
                this.mVelocityScale = scale;
            }
            smoothScrollToPositionFromTop(position, offset, duration) {
                if (this.mPositionScroller == null) {
                    this.mPositionScroller = new AbsListView.PositionScroller(this);
                }
                this.mPositionScroller.startWithOffset(position, offset, duration);
            }
            smoothScrollToPosition(position, boundPosition) {
                if (this.mPositionScroller == null) {
                    this.mPositionScroller = new AbsListView.PositionScroller(this);
                }
                this.mPositionScroller.start(position, boundPosition);
            }
            smoothScrollBy(distance, duration, linear = false) {
                if (this.mFlingRunnable == null) {
                    this.mFlingRunnable = new AbsListView.FlingRunnable(this);
                }
                const firstPos = this.mFirstPosition;
                const childCount = this.getChildCount();
                const lastPos = firstPos + childCount;
                const topLimit = this.getPaddingTop();
                const bottomLimit = this.getHeight() - this.getPaddingBottom();
                if (distance == 0 || this.mItemCount == 0 || childCount == 0
                    || (firstPos == 0 && this.getChildAt(0).getTop() == topLimit && distance < 0)
                    || (lastPos == this.mItemCount && this.getChildAt(childCount - 1).getBottom() == bottomLimit && distance > 0)) {
                    this.mFlingRunnable.endFling();
                    if (this.mPositionScroller != null) {
                        this.mPositionScroller.stop();
                    }
                }
                else {
                    this.reportScrollStateChange(AbsListView.OnScrollListener.SCROLL_STATE_FLING);
                    this.mFlingRunnable.startScroll(distance, duration, linear);
                }
            }
            smoothScrollByOffset(position) {
                let index = -1;
                if (position < 0) {
                    index = this.getFirstVisiblePosition();
                }
                else if (position > 0) {
                    index = this.getLastVisiblePosition();
                }
                if (index > -1) {
                    let child = this.getChildAt(index - this.getFirstVisiblePosition());
                    if (child != null) {
                        let visibleRect = new Rect();
                        if (child.getGlobalVisibleRect(visibleRect)) {
                            let childRectArea = child.getWidth() * child.getHeight();
                            let visibleRectArea = visibleRect.width() * visibleRect.height();
                            let visibleArea = (visibleRectArea / childRectArea);
                            const visibleThreshold = 0.75;
                            if ((position < 0) && (visibleArea < visibleThreshold)) {
                                ++index;
                            }
                            else if ((position > 0) && (visibleArea < visibleThreshold)) {
                                --index;
                            }
                        }
                        this.smoothScrollToPosition(Math.max(0, Math.min(this.getCount(), index + position)));
                    }
                }
            }
            createScrollingCache() {
                if (this.mScrollingCacheEnabled && !this.mCachingStarted && !this.isHardwareAccelerated()) {
                    this.setChildrenDrawnWithCacheEnabled(true);
                    this.setChildrenDrawingCacheEnabled(true);
                    this.mCachingStarted = this.mCachingActive = true;
                }
            }
            clearScrollingCache() {
                if (!this.isHardwareAccelerated()) {
                    if (this.mClearScrollingCache == null) {
                        this.mClearScrollingCache = (() => {
                            const _this = this;
                            class _Inner {
                                run() {
                                    if (_this.mCachingStarted) {
                                        _this.mCachingStarted = _this.mCachingActive = false;
                                        _this.setChildrenDrawnWithCacheEnabled(false);
                                        if ((_this.mPersistentDrawingCache & AbsListView.PERSISTENT_SCROLLING_CACHE) == 0) {
                                            _this.setChildrenDrawingCacheEnabled(false);
                                        }
                                        if (!_this.isAlwaysDrawnWithCacheEnabled()) {
                                            _this.invalidate();
                                        }
                                    }
                                }
                            }
                            return new _Inner();
                        })();
                    }
                    this.post(this.mClearScrollingCache);
                }
            }
            scrollListBy(y) {
                this.trackMotionScroll(-y, -y);
            }
            canScrollList(direction) {
                const childCount = this.getChildCount();
                if (childCount == 0) {
                    return false;
                }
                const firstPosition = this.mFirstPosition;
                const listPadding = this.mListPadding;
                if (direction > 0) {
                    const lastBottom = this.getChildAt(childCount - 1).getBottom();
                    const lastPosition = firstPosition + childCount;
                    return lastPosition < this.mItemCount || lastBottom > this.getHeight() - listPadding.bottom;
                }
                else {
                    const firstTop = this.getChildAt(0).getTop();
                    return firstPosition > 0 || firstTop < listPadding.top;
                }
            }
            trackMotionScroll(deltaY, incrementalDeltaY) {
                const childCount = this.getChildCount();
                if (childCount == 0) {
                    return true;
                }
                const firstTop = this.getChildAt(0).getTop();
                const lastBottom = this.getChildAt(childCount - 1).getBottom();
                const listPadding = this.mListPadding;
                let effectivePaddingTop = 0;
                let effectivePaddingBottom = 0;
                if ((this.mGroupFlags & AbsListView.CLIP_TO_PADDING_MASK) == AbsListView.CLIP_TO_PADDING_MASK) {
                    effectivePaddingTop = listPadding.top;
                    effectivePaddingBottom = listPadding.bottom;
                }
                const spaceAbove = effectivePaddingTop - firstTop;
                const end = this.getHeight() - effectivePaddingBottom;
                const spaceBelow = lastBottom - end;
                const height = this.getHeight() - this.mPaddingBottom - this.mPaddingTop;
                if (deltaY < 0) {
                    deltaY = Math.max(-(height - 1), deltaY);
                }
                else {
                    deltaY = Math.min(height - 1, deltaY);
                }
                if (incrementalDeltaY < 0) {
                    incrementalDeltaY = Math.max(-(height - 1), incrementalDeltaY);
                }
                else {
                    incrementalDeltaY = Math.min(height - 1, incrementalDeltaY);
                }
                const firstPosition = this.mFirstPosition;
                if (firstPosition == 0) {
                    this.mFirstPositionDistanceGuess = firstTop - listPadding.top;
                }
                else {
                    this.mFirstPositionDistanceGuess += incrementalDeltaY;
                }
                if (firstPosition + childCount == this.mItemCount) {
                    this.mLastPositionDistanceGuess = lastBottom + listPadding.bottom;
                }
                else {
                    this.mLastPositionDistanceGuess += incrementalDeltaY;
                }
                const cannotScrollDown = (firstPosition == 0 && firstTop >= listPadding.top && incrementalDeltaY >= 0);
                const cannotScrollUp = (firstPosition + childCount == this.mItemCount && lastBottom <= this.getHeight() - listPadding.bottom && incrementalDeltaY <= 0);
                if (cannotScrollDown || cannotScrollUp) {
                    return incrementalDeltaY != 0;
                }
                const down = incrementalDeltaY < 0;
                const inTouchMode = this.isInTouchMode();
                if (inTouchMode) {
                    this.hideSelector();
                }
                const headerViewsCount = this.getHeaderViewsCount();
                const footerViewsStart = this.mItemCount - this.getFooterViewsCount();
                let start = 0;
                let count = 0;
                if (down) {
                    let top = -incrementalDeltaY;
                    if ((this.mGroupFlags & AbsListView.CLIP_TO_PADDING_MASK) == AbsListView.CLIP_TO_PADDING_MASK) {
                        top += listPadding.top;
                    }
                    for (let i = 0; i < childCount; i++) {
                        const child = this.getChildAt(i);
                        if (child.getBottom() >= top) {
                            break;
                        }
                        else {
                            count++;
                            let position = firstPosition + i;
                            if (position >= headerViewsCount && position < footerViewsStart) {
                                this.mRecycler.addScrapView(child, position);
                            }
                        }
                    }
                }
                else {
                    let bottom = this.getHeight() - incrementalDeltaY;
                    if ((this.mGroupFlags & AbsListView.CLIP_TO_PADDING_MASK) == AbsListView.CLIP_TO_PADDING_MASK) {
                        bottom -= listPadding.bottom;
                    }
                    for (let i = childCount - 1; i >= 0; i--) {
                        const child = this.getChildAt(i);
                        if (child.getTop() <= bottom) {
                            break;
                        }
                        else {
                            start = i;
                            count++;
                            let position = firstPosition + i;
                            if (position >= headerViewsCount && position < footerViewsStart) {
                                this.mRecycler.addScrapView(child, position);
                            }
                        }
                    }
                }
                this.mMotionViewNewTop = this.mMotionViewOriginalTop + deltaY;
                this.mBlockLayoutRequests = true;
                if (count > 0) {
                    this.detachViewsFromParent(start, count);
                    this.mRecycler.removeSkippedScrap();
                }
                if (!this.awakenScrollBars()) {
                    this.invalidate();
                }
                this.offsetChildrenTopAndBottom(incrementalDeltaY);
                if (down) {
                    this.mFirstPosition += count;
                }
                const absIncrementalDeltaY = Math.abs(incrementalDeltaY);
                if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
                    this.fillGap(down);
                }
                if (!inTouchMode && this.mSelectedPosition != AbsListView.INVALID_POSITION) {
                    const childIndex = this.mSelectedPosition - this.mFirstPosition;
                    if (childIndex >= 0 && childIndex < this.getChildCount()) {
                        this.positionSelector(this.mSelectedPosition, this.getChildAt(childIndex));
                    }
                }
                else if (this.mSelectorPosition != AbsListView.INVALID_POSITION) {
                    const childIndex = this.mSelectorPosition - this.mFirstPosition;
                    if (childIndex >= 0 && childIndex < this.getChildCount()) {
                        this.positionSelector(AbsListView.INVALID_POSITION, this.getChildAt(childIndex));
                    }
                }
                else {
                    this.mSelectorRect.setEmpty();
                }
                this.mBlockLayoutRequests = false;
                this.invokeOnItemScrollListener();
                return false;
            }
            getHeaderViewsCount() {
                return 0;
            }
            getFooterViewsCount() {
                return 0;
            }
            hideSelector() {
                if (this.mSelectedPosition != AbsListView.INVALID_POSITION) {
                    if (this.mLayoutMode != AbsListView.LAYOUT_SPECIFIC) {
                        this.mResurrectToPosition = this.mSelectedPosition;
                    }
                    if (this.mNextSelectedPosition >= 0 && this.mNextSelectedPosition != this.mSelectedPosition) {
                        this.mResurrectToPosition = this.mNextSelectedPosition;
                    }
                    this.setSelectedPositionInt(AbsListView.INVALID_POSITION);
                    this.setNextSelectedPositionInt(AbsListView.INVALID_POSITION);
                    this.mSelectedTop = 0;
                }
            }
            reconcileSelectedPosition() {
                let position = this.mSelectedPosition;
                if (position < 0) {
                    position = this.mResurrectToPosition;
                }
                position = Math.max(0, position);
                position = Math.min(position, this.mItemCount - 1);
                return position;
            }
            findClosestMotionRow(y) {
                const childCount = this.getChildCount();
                if (childCount == 0) {
                    return AbsListView.INVALID_POSITION;
                }
                const motionRow = this.findMotionRow(y);
                return motionRow != AbsListView.INVALID_POSITION ? motionRow : this.mFirstPosition + childCount - 1;
            }
            invalidateViews() {
                this.mDataChanged = true;
                this.rememberSyncState();
                this.requestLayout();
                this.invalidate();
            }
            resurrectSelectionIfNeeded() {
                if (this.mSelectedPosition < 0 && this.resurrectSelection()) {
                    this.updateSelectorState();
                    return true;
                }
                return false;
            }
            resurrectSelection() {
                const childCount = this.getChildCount();
                if (childCount <= 0) {
                    return false;
                }
                let selectedTop = 0;
                let selectedPos;
                let childrenTop = this.mListPadding.top;
                let childrenBottom = this.mBottom - this.mTop - this.mListPadding.bottom;
                const firstPosition = this.mFirstPosition;
                const toPosition = this.mResurrectToPosition;
                let down = true;
                if (toPosition >= firstPosition && toPosition < firstPosition + childCount) {
                    selectedPos = toPosition;
                    const selected = this.getChildAt(selectedPos - this.mFirstPosition);
                    selectedTop = selected.getTop();
                    let selectedBottom = selected.getBottom();
                    if (selectedTop < childrenTop) {
                        selectedTop = childrenTop + this.getVerticalFadingEdgeLength();
                    }
                    else if (selectedBottom > childrenBottom) {
                        selectedTop = childrenBottom - selected.getMeasuredHeight() - this.getVerticalFadingEdgeLength();
                    }
                }
                else {
                    if (toPosition < firstPosition) {
                        selectedPos = firstPosition;
                        for (let i = 0; i < childCount; i++) {
                            const v = this.getChildAt(i);
                            const top = v.getTop();
                            if (i == 0) {
                                selectedTop = top;
                                if (firstPosition > 0 || top < childrenTop) {
                                    childrenTop += this.getVerticalFadingEdgeLength();
                                }
                            }
                            if (top >= childrenTop) {
                                selectedPos = firstPosition + i;
                                selectedTop = top;
                                break;
                            }
                        }
                    }
                    else {
                        const itemCount = this.mItemCount;
                        down = false;
                        selectedPos = firstPosition + childCount - 1;
                        for (let i = childCount - 1; i >= 0; i--) {
                            const v = this.getChildAt(i);
                            const top = v.getTop();
                            const bottom = v.getBottom();
                            if (i == childCount - 1) {
                                selectedTop = top;
                                if (firstPosition + childCount < itemCount || bottom > childrenBottom) {
                                    childrenBottom -= this.getVerticalFadingEdgeLength();
                                }
                            }
                            if (bottom <= childrenBottom) {
                                selectedPos = firstPosition + i;
                                selectedTop = top;
                                break;
                            }
                        }
                    }
                }
                this.mResurrectToPosition = AbsListView.INVALID_POSITION;
                this.removeCallbacks(this.mFlingRunnable);
                if (this.mPositionScroller != null) {
                    this.mPositionScroller.stop();
                }
                this.mTouchMode = AbsListView.TOUCH_MODE_REST;
                this.clearScrollingCache();
                this.mSpecificTop = selectedTop;
                selectedPos = this.lookForSelectablePosition(selectedPos, down);
                if (selectedPos >= firstPosition && selectedPos <= this.getLastVisiblePosition()) {
                    this.mLayoutMode = AbsListView.LAYOUT_SPECIFIC;
                    this.updateSelectorState();
                    this.setSelectionInt(selectedPos);
                    this.invokeOnItemScrollListener();
                }
                else {
                    selectedPos = AbsListView.INVALID_POSITION;
                }
                this.reportScrollStateChange(AbsListView.OnScrollListener.SCROLL_STATE_IDLE);
                return selectedPos >= 0;
            }
            confirmCheckedPositionsById() {
                this.mCheckStates.clear();
                let checkedCountChanged = false;
                for (let checkedIndex = 0; checkedIndex < this.mCheckedIdStates.size(); checkedIndex++) {
                    const id = this.mCheckedIdStates.keyAt(checkedIndex);
                    const lastPos = this.mCheckedIdStates.valueAt(checkedIndex);
                    const lastPosId = this.mAdapter.getItemId(lastPos);
                    if (id != lastPosId) {
                        const start = Math.max(0, lastPos - AbsListView.CHECK_POSITION_SEARCH_DISTANCE);
                        const end = Math.min(lastPos + AbsListView.CHECK_POSITION_SEARCH_DISTANCE, this.mItemCount);
                        let found = false;
                        for (let searchPos = start; searchPos < end; searchPos++) {
                            const searchId = this.mAdapter.getItemId(searchPos);
                            if (id == searchId) {
                                found = true;
                                this.mCheckStates.put(searchPos, true);
                                this.mCheckedIdStates.setValueAt(checkedIndex, searchPos);
                                break;
                            }
                        }
                        if (!found) {
                            this.mCheckedIdStates.delete(id);
                            checkedIndex--;
                            this.mCheckedItemCount--;
                            checkedCountChanged = true;
                        }
                    }
                    else {
                        this.mCheckStates.put(lastPos, true);
                    }
                }
                if (checkedCountChanged && this.mChoiceActionMode != null) {
                    this.mChoiceActionMode.invalidate();
                }
            }
            handleDataChanged() {
                let count = this.mItemCount;
                let lastHandledItemCount = this.mLastHandledItemCount;
                this.mLastHandledItemCount = this.mItemCount;
                if (this.mChoiceMode != AbsListView.CHOICE_MODE_NONE && this.mAdapter != null && this.mAdapter.hasStableIds()) {
                    this.confirmCheckedPositionsById();
                }
                this.mRecycler.clearTransientStateViews();
                if (count > 0) {
                    let newPos;
                    let selectablePos;
                    if (this.mNeedSync) {
                        this.mNeedSync = false;
                        this.mPendingSync = null;
                        if (this.mTranscriptMode == AbsListView.TRANSCRIPT_MODE_ALWAYS_SCROLL) {
                            this.mLayoutMode = AbsListView.LAYOUT_FORCE_BOTTOM;
                            return;
                        }
                        else if (this.mTranscriptMode == AbsListView.TRANSCRIPT_MODE_NORMAL) {
                            if (this.mForceTranscriptScroll) {
                                this.mForceTranscriptScroll = false;
                                this.mLayoutMode = AbsListView.LAYOUT_FORCE_BOTTOM;
                                return;
                            }
                            const childCount = this.getChildCount();
                            const listBottom = this.getHeight() - this.getPaddingBottom();
                            const lastChild = this.getChildAt(childCount - 1);
                            const lastBottom = lastChild != null ? lastChild.getBottom() : listBottom;
                            if (this.mFirstPosition + childCount >= lastHandledItemCount && lastBottom <= listBottom) {
                                this.mLayoutMode = AbsListView.LAYOUT_FORCE_BOTTOM;
                                return;
                            }
                            this.awakenScrollBars();
                        }
                        switch (this.mSyncMode) {
                            case AbsListView.SYNC_SELECTED_POSITION:
                                if (this.isInTouchMode()) {
                                    this.mLayoutMode = AbsListView.LAYOUT_SYNC;
                                    this.mSyncPosition = Math.min(Math.max(0, this.mSyncPosition), count - 1);
                                    return;
                                }
                                else {
                                    newPos = this.findSyncPosition();
                                    if (newPos >= 0) {
                                        selectablePos = this.lookForSelectablePosition(newPos, true);
                                        if (selectablePos == newPos) {
                                            this.mSyncPosition = newPos;
                                            if (this.mSyncHeight == this.getHeight()) {
                                                this.mLayoutMode = AbsListView.LAYOUT_SYNC;
                                            }
                                            else {
                                                this.mLayoutMode = AbsListView.LAYOUT_SET_SELECTION;
                                            }
                                            this.setNextSelectedPositionInt(newPos);
                                            return;
                                        }
                                    }
                                }
                                break;
                            case AbsListView.SYNC_FIRST_POSITION:
                                this.mLayoutMode = AbsListView.LAYOUT_SYNC;
                                this.mSyncPosition = Math.min(Math.max(0, this.mSyncPosition), count - 1);
                                return;
                        }
                    }
                    if (!this.isInTouchMode()) {
                        newPos = this.getSelectedItemPosition();
                        if (newPos >= count) {
                            newPos = count - 1;
                        }
                        if (newPos < 0) {
                            newPos = 0;
                        }
                        selectablePos = this.lookForSelectablePosition(newPos, true);
                        if (selectablePos >= 0) {
                            this.setNextSelectedPositionInt(selectablePos);
                            return;
                        }
                        else {
                            selectablePos = this.lookForSelectablePosition(newPos, false);
                            if (selectablePos >= 0) {
                                this.setNextSelectedPositionInt(selectablePos);
                                return;
                            }
                        }
                    }
                    else {
                        if (this.mResurrectToPosition >= 0) {
                            return;
                        }
                    }
                }
                this.mLayoutMode = this.mStackFromBottom ? AbsListView.LAYOUT_FORCE_BOTTOM : AbsListView.LAYOUT_FORCE_TOP;
                this.mSelectedPosition = AbsListView.INVALID_POSITION;
                this.mSelectedRowId = AbsListView.INVALID_ROW_ID;
                this.mNextSelectedPosition = AbsListView.INVALID_POSITION;
                this.mNextSelectedRowId = AbsListView.INVALID_ROW_ID;
                this.mNeedSync = false;
                this.mPendingSync = null;
                this.mSelectorPosition = AbsListView.INVALID_POSITION;
                this.checkSelectionChanged();
            }
            onDisplayHint(hint) {
                super.onDisplayHint(hint);
                this.mPopupHidden = hint == AbsListView.INVISIBLE;
            }
            dismissPopup() {
            }
            showPopup() {
            }
            positionPopup() {
            }
            static getDistance(source, dest, direction) {
                let sX, sY;
                let dX, dY;
                switch (direction) {
                    case View.FOCUS_RIGHT:
                        sX = source.right;
                        sY = source.top + source.height() / 2;
                        dX = dest.left;
                        dY = dest.top + dest.height() / 2;
                        break;
                    case View.FOCUS_DOWN:
                        sX = source.left + source.width() / 2;
                        sY = source.bottom;
                        dX = dest.left + dest.width() / 2;
                        dY = dest.top;
                        break;
                    case View.FOCUS_LEFT:
                        sX = source.left;
                        sY = source.top + source.height() / 2;
                        dX = dest.right;
                        dY = dest.top + dest.height() / 2;
                        break;
                    case View.FOCUS_UP:
                        sX = source.left + source.width() / 2;
                        sY = source.top;
                        dX = dest.left + dest.width() / 2;
                        dY = dest.bottom;
                        break;
                    case View.FOCUS_FORWARD:
                    case View.FOCUS_BACKWARD:
                        sX = source.right + source.width() / 2;
                        sY = source.top + source.height() / 2;
                        dX = dest.left + dest.width() / 2;
                        dY = dest.top + dest.height() / 2;
                        break;
                    default:
                        throw Error(`new IllegalArgumentException("direction must be one of " + "{FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT, " + "FOCUS_FORWARD, FOCUS_BACKWARD}.")`);
                }
                let deltaX = dX - sX;
                let deltaY = dY - sY;
                return deltaY * deltaY + deltaX * deltaX;
            }
            isInFilterMode() {
                return this.mFiltered;
            }
            hasTextFilter() {
                return this.mFiltered;
            }
            onGlobalLayout() {
                if (this.isShown()) {
                }
                else {
                }
            }
            generateDefaultLayoutParams() {
                return new AbsListView.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT, 0);
            }
            generateLayoutParams(p) {
                return new AbsListView.LayoutParams(p);
            }
            checkLayoutParams(p) {
                return p instanceof AbsListView.LayoutParams;
            }
            setTranscriptMode(mode) {
                this.mTranscriptMode = mode;
            }
            getTranscriptMode() {
                return this.mTranscriptMode;
            }
            getSolidColor() {
                return this.mCacheColorHint;
            }
            setCacheColorHint(color) {
                if (color != this.mCacheColorHint) {
                    this.mCacheColorHint = color;
                    let count = this.getChildCount();
                    for (let i = 0; i < count; i++) {
                        this.getChildAt(i).setDrawingCacheBackgroundColor(color);
                    }
                    this.mRecycler.setCacheColorHint(color);
                }
            }
            getCacheColorHint() {
                return this.mCacheColorHint;
            }
            reclaimViews(views) {
                let childCount = this.getChildCount();
                let listener = this.mRecycler.mRecyclerListener;
                for (let i = 0; i < childCount; i++) {
                    let child = this.getChildAt(i);
                    let lp = child.getLayoutParams();
                    if (lp != null && this.mRecycler.shouldRecycleViewType(lp.viewType)) {
                        views.add(child);
                        if (listener != null) {
                            listener.onMovedToScrapHeap(child);
                        }
                    }
                }
                this.mRecycler.reclaimScrapViews(views);
                this.removeAllViewsInLayout();
            }
            finishGlows() {
            }
            setVisibleRangeHint(start, end) {
            }
            setRecyclerListener(listener) {
                this.mRecycler.mRecyclerListener = listener;
            }
            static retrieveFromScrap(scrapViews, position) {
                let size = scrapViews.size();
                if (size > 0) {
                    for (let i = 0; i < size; i++) {
                        let view = scrapViews.get(i);
                        if (view.getLayoutParams().scrappedFromPosition == position) {
                            scrapViews.remove(i);
                            return view;
                        }
                    }
                    return scrapViews.remove(size - 1);
                }
                else {
                    return null;
                }
            }
        }
        AbsListView.TAG_AbsListView = "AbsListView";
        AbsListView.TRANSCRIPT_MODE_DISABLED = 0;
        AbsListView.TRANSCRIPT_MODE_NORMAL = 1;
        AbsListView.TRANSCRIPT_MODE_ALWAYS_SCROLL = 2;
        AbsListView.TOUCH_MODE_REST = -1;
        AbsListView.TOUCH_MODE_DOWN = 0;
        AbsListView.TOUCH_MODE_TAP = 1;
        AbsListView.TOUCH_MODE_DONE_WAITING = 2;
        AbsListView.TOUCH_MODE_SCROLL = 3;
        AbsListView.TOUCH_MODE_FLING = 4;
        AbsListView.TOUCH_MODE_OVERSCROLL = 5;
        AbsListView.TOUCH_MODE_OVERFLING = 6;
        AbsListView.LAYOUT_NORMAL = 0;
        AbsListView.LAYOUT_FORCE_TOP = 1;
        AbsListView.LAYOUT_SET_SELECTION = 2;
        AbsListView.LAYOUT_FORCE_BOTTOM = 3;
        AbsListView.LAYOUT_SPECIFIC = 4;
        AbsListView.LAYOUT_SYNC = 5;
        AbsListView.LAYOUT_MOVE_SELECTION = 6;
        AbsListView.CHOICE_MODE_NONE = 0;
        AbsListView.CHOICE_MODE_SINGLE = 1;
        AbsListView.CHOICE_MODE_MULTIPLE = 2;
        AbsListView.CHOICE_MODE_MULTIPLE_MODAL = 3;
        AbsListView.OVERSCROLL_LIMIT_DIVISOR = 3;
        AbsListView.CHECK_POSITION_SEARCH_DISTANCE = 20;
        AbsListView.TOUCH_MODE_UNKNOWN = -1;
        AbsListView.TOUCH_MODE_ON = 0;
        AbsListView.TOUCH_MODE_OFF = 1;
        AbsListView.PROFILE_SCROLLING = false;
        AbsListView.PROFILE_FLINGING = false;
        AbsListView.INVALID_POINTER = -1;
        AbsListView.sLinearInterpolator = new LinearInterpolator();
        widget.AbsListView = AbsListView;
        (function (AbsListView) {
            var OnScrollListener;
            (function (OnScrollListener) {
                OnScrollListener.SCROLL_STATE_IDLE = 0;
                OnScrollListener.SCROLL_STATE_TOUCH_SCROLL = 1;
                OnScrollListener.SCROLL_STATE_FLING = 2;
            })(OnScrollListener = AbsListView.OnScrollListener || (AbsListView.OnScrollListener = {}));
            class WindowRunnnable {
                constructor(arg) {
                    this._AbsListView_this = arg;
                }
                rememberWindowAttachCount() {
                    this.mOriginalAttachCount = this._AbsListView_this.getWindowAttachCount();
                }
                sameWindow() {
                    return this._AbsListView_this.getWindowAttachCount() == this.mOriginalAttachCount;
                }
            }
            AbsListView.WindowRunnnable = WindowRunnnable;
            class PerformClick extends AbsListView.WindowRunnnable {
                constructor(arg) {
                    super(arg);
                    this.mClickMotionPosition = 0;
                    this._AbsListView_this = arg;
                }
                run() {
                    if (this._AbsListView_this.mDataChanged)
                        return;
                    const adapter = this._AbsListView_this.mAdapter;
                    const motionPosition = this.mClickMotionPosition;
                    if (adapter != null && this._AbsListView_this.mItemCount > 0 && motionPosition != AbsListView.INVALID_POSITION
                        && motionPosition < adapter.getCount() && this.sameWindow()) {
                        const view = this._AbsListView_this.getChildAt(motionPosition - this._AbsListView_this.mFirstPosition);
                        if (view != null) {
                            this._AbsListView_this.performItemClick(view, motionPosition, adapter.getItemId(motionPosition));
                        }
                    }
                }
            }
            AbsListView.PerformClick = PerformClick;
            class CheckForLongPress extends AbsListView.WindowRunnnable {
                constructor(arg) {
                    super(arg);
                    this._AbsListView_this = arg;
                }
                run() {
                    const motionPosition = this._AbsListView_this.mMotionPosition;
                    const child = this._AbsListView_this.getChildAt(motionPosition - this._AbsListView_this.mFirstPosition);
                    if (child != null) {
                        const longPressPosition = this._AbsListView_this.mMotionPosition;
                        const longPressId = this._AbsListView_this.mAdapter.getItemId(this._AbsListView_this.mMotionPosition);
                        let handled = false;
                        if (this.sameWindow() && !this._AbsListView_this.mDataChanged) {
                            handled = this._AbsListView_this.performLongPress(child, longPressPosition, longPressId);
                        }
                        if (handled) {
                            this._AbsListView_this.mTouchMode = AbsListView.TOUCH_MODE_REST;
                            this._AbsListView_this.setPressed(false);
                            child.setPressed(false);
                        }
                        else {
                            this._AbsListView_this.mTouchMode = AbsListView.TOUCH_MODE_DONE_WAITING;
                        }
                    }
                }
            }
            AbsListView.CheckForLongPress = CheckForLongPress;
            class CheckForKeyLongPress extends AbsListView.WindowRunnnable {
                constructor(arg) {
                    super(arg);
                    this._AbsListView_this = arg;
                }
                run() {
                    if (this._AbsListView_this.isPressed() && this._AbsListView_this.mSelectedPosition >= 0) {
                        let index = this._AbsListView_this.mSelectedPosition - this._AbsListView_this.mFirstPosition;
                        let v = this._AbsListView_this.getChildAt(index);
                        if (!this._AbsListView_this.mDataChanged) {
                            let handled = false;
                            if (this.sameWindow()) {
                                handled = this._AbsListView_this.performLongPress(v, this._AbsListView_this.mSelectedPosition, this._AbsListView_this.mSelectedRowId);
                            }
                            if (handled) {
                                this._AbsListView_this.setPressed(false);
                                v.setPressed(false);
                            }
                        }
                        else {
                            this._AbsListView_this.setPressed(false);
                            if (v != null)
                                v.setPressed(false);
                        }
                    }
                }
            }
            AbsListView.CheckForKeyLongPress = CheckForKeyLongPress;
            class CheckForTap {
                constructor(arg) {
                    this._AbsListView_this = arg;
                }
                run() {
                    if (this._AbsListView_this.mTouchMode == AbsListView.TOUCH_MODE_DOWN) {
                        this._AbsListView_this.mTouchMode = AbsListView.TOUCH_MODE_TAP;
                        const child = this._AbsListView_this.getChildAt(this._AbsListView_this.mMotionPosition - this._AbsListView_this.mFirstPosition);
                        if (child != null && !child.hasFocusable()) {
                            this._AbsListView_this.mLayoutMode = AbsListView.LAYOUT_NORMAL;
                            if (!this._AbsListView_this.mDataChanged) {
                                child.setPressed(true);
                                this._AbsListView_this.setPressed(true);
                                this._AbsListView_this.layoutChildren();
                                this._AbsListView_this.positionSelector(this._AbsListView_this.mMotionPosition, child);
                                this._AbsListView_this.refreshDrawableState();
                                const longPressTimeout = ViewConfiguration.getLongPressTimeout();
                                const longClickable = this._AbsListView_this.isLongClickable();
                                if (this._AbsListView_this.mSelector != null) {
                                    let d = this._AbsListView_this.mSelector.getCurrent();
                                }
                                if (longClickable) {
                                    if (this._AbsListView_this.mPendingCheckForLongPress_List == null) {
                                        this._AbsListView_this.mPendingCheckForLongPress_List = new AbsListView.CheckForLongPress(this._AbsListView_this);
                                    }
                                    this._AbsListView_this.mPendingCheckForLongPress_List.rememberWindowAttachCount();
                                    this._AbsListView_this.postDelayed(this._AbsListView_this.mPendingCheckForLongPress_List, longPressTimeout);
                                }
                                else {
                                    this._AbsListView_this.mTouchMode = AbsListView.TOUCH_MODE_DONE_WAITING;
                                }
                            }
                            else {
                                this._AbsListView_this.mTouchMode = AbsListView.TOUCH_MODE_DONE_WAITING;
                            }
                        }
                    }
                }
            }
            AbsListView.CheckForTap = CheckForTap;
            class FlingRunnable {
                constructor(arg) {
                    this.mLastFlingY = 0;
                    this.mCheckFlywheel = (() => {
                        const _this = this;
                        class _Inner {
                            run() {
                                const activeId = _this._AbsListView_this.mActivePointerId;
                                const vt = _this._AbsListView_this.mVelocityTracker;
                                const scroller = _this.mScroller;
                                if (vt == null || activeId == AbsListView.INVALID_POINTER) {
                                    return;
                                }
                                vt.computeCurrentVelocity(1000, _this._AbsListView_this.mMaximumVelocity);
                                const yvel = -vt.getYVelocity(activeId);
                                if (Math.abs(yvel) >= _this._AbsListView_this.mMinimumVelocity && scroller.isScrollingInDirection(0, yvel)) {
                                    _this._AbsListView_this.postDelayed(_this, FlingRunnable.FLYWHEEL_TIMEOUT);
                                }
                                else {
                                    _this.endFling();
                                    _this._AbsListView_this.mTouchMode = AbsListView.TOUCH_MODE_SCROLL;
                                    _this._AbsListView_this.reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
                                }
                            }
                        }
                        return new _Inner();
                    })();
                    this._AbsListView_this = arg;
                    this.mScroller = new OverScroller();
                }
                start(initialVelocity) {
                    let initialY = initialVelocity < 0 ? Integer.MAX_VALUE : 0;
                    this.mLastFlingY = initialY;
                    this.mScroller.setInterpolator(null);
                    this.mScroller.fling(0, initialY, 0, initialVelocity, 0, Integer.MAX_VALUE, 0, Integer.MAX_VALUE);
                    this._AbsListView_this.mTouchMode = AbsListView.TOUCH_MODE_FLING;
                    this._AbsListView_this.postOnAnimation(this);
                    if (AbsListView.PROFILE_FLINGING) {
                        if (!this._AbsListView_this.mFlingProfilingStarted) {
                            this._AbsListView_this.mFlingProfilingStarted = true;
                        }
                    }
                }
                startSpringback() {
                    if (this.mScroller.springBack(0, this._AbsListView_this.mScrollY, 0, 0, 0, 0)) {
                        this._AbsListView_this.mTouchMode = AbsListView.TOUCH_MODE_OVERFLING;
                        this._AbsListView_this.invalidate();
                        this._AbsListView_this.postOnAnimation(this);
                    }
                    else {
                        this._AbsListView_this.mTouchMode = AbsListView.TOUCH_MODE_REST;
                        this._AbsListView_this.reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                    }
                }
                startOverfling(initialVelocity) {
                    this.mScroller.setInterpolator(null);
                    let minY = Integer.MIN_VALUE, maxY = Integer.MAX_VALUE;
                    if (this._AbsListView_this.mScrollY < 0)
                        minY = 0;
                    else if (this._AbsListView_this.mScrollY > 0)
                        maxY = 0;
                    this.mScroller.fling(0, this._AbsListView_this.mScrollY, 0, initialVelocity, 0, 0, minY, maxY, 0, this._AbsListView_this.getHeight());
                    this._AbsListView_this.mTouchMode = AbsListView.TOUCH_MODE_OVERFLING;
                    this._AbsListView_this.invalidate();
                    this._AbsListView_this.postOnAnimation(this);
                }
                edgeReached(delta) {
                    this.mScroller.notifyVerticalEdgeReached(this._AbsListView_this.mScrollY, 0, this._AbsListView_this.mOverflingDistance);
                    const overscrollMode = this._AbsListView_this.getOverScrollMode();
                    if (overscrollMode == AbsListView.OVER_SCROLL_ALWAYS || (overscrollMode == AbsListView.OVER_SCROLL_IF_CONTENT_SCROLLS && !this._AbsListView_this.contentFits())) {
                        this._AbsListView_this.mTouchMode = AbsListView.TOUCH_MODE_OVERFLING;
                    }
                    else {
                        this._AbsListView_this.mTouchMode = AbsListView.TOUCH_MODE_REST;
                        if (this._AbsListView_this.mPositionScroller != null) {
                            this._AbsListView_this.mPositionScroller.stop();
                        }
                    }
                    this._AbsListView_this.invalidate();
                    this._AbsListView_this.postOnAnimation(this);
                }
                startScroll(distance, duration, linear) {
                    let initialY = distance < 0 ? Integer.MAX_VALUE : 0;
                    this.mLastFlingY = initialY;
                    this.mScroller.setInterpolator(linear ? AbsListView.sLinearInterpolator : null);
                    this.mScroller.startScroll(0, initialY, 0, distance, duration);
                    this._AbsListView_this.mTouchMode = AbsListView.TOUCH_MODE_FLING;
                    this._AbsListView_this.postOnAnimation(this);
                }
                endFling() {
                    this._AbsListView_this.mTouchMode = AbsListView.TOUCH_MODE_REST;
                    this._AbsListView_this.removeCallbacks(this);
                    this._AbsListView_this.removeCallbacks(this.mCheckFlywheel);
                    this._AbsListView_this.reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                    this._AbsListView_this.clearScrollingCache();
                    this.mScroller.abortAnimation();
                }
                flywheelTouch() {
                    this._AbsListView_this.postDelayed(this.mCheckFlywheel, FlingRunnable.FLYWHEEL_TIMEOUT);
                }
                run() {
                    switch (this._AbsListView_this.mTouchMode) {
                        default:
                            this.endFling();
                            return;
                        case AbsListView.TOUCH_MODE_SCROLL:
                            if (this.mScroller.isFinished()) {
                                return;
                            }
                        case AbsListView.TOUCH_MODE_FLING:
                            {
                                if (this._AbsListView_this.mDataChanged) {
                                    this._AbsListView_this.layoutChildren();
                                }
                                if (this._AbsListView_this.mItemCount == 0 || this._AbsListView_this.getChildCount() == 0) {
                                    this.endFling();
                                    return;
                                }
                                const scroller = this.mScroller;
                                let more = scroller.computeScrollOffset();
                                const y = scroller.getCurrY();
                                let delta = this.mLastFlingY - y;
                                if (delta > 0) {
                                    this._AbsListView_this.mMotionPosition = this._AbsListView_this.mFirstPosition;
                                    const firstView = this._AbsListView_this.getChildAt(0);
                                    this._AbsListView_this.mMotionViewOriginalTop = firstView.getTop();
                                    delta = Math.min(this._AbsListView_this.getHeight() - this._AbsListView_this.mPaddingBottom - this._AbsListView_this.mPaddingTop - 1, delta);
                                }
                                else {
                                    let offsetToLast = this._AbsListView_this.getChildCount() - 1;
                                    this._AbsListView_this.mMotionPosition = this._AbsListView_this.mFirstPosition + offsetToLast;
                                    const lastView = this._AbsListView_this.getChildAt(offsetToLast);
                                    this._AbsListView_this.mMotionViewOriginalTop = lastView.getTop();
                                    delta = Math.max(-(this._AbsListView_this.getHeight() - this._AbsListView_this.mPaddingBottom - this._AbsListView_this.mPaddingTop - 1), delta);
                                }
                                let motionView = this._AbsListView_this.getChildAt(this._AbsListView_this.mMotionPosition - this._AbsListView_this.mFirstPosition);
                                let oldTop = 0;
                                if (motionView != null) {
                                    oldTop = motionView.getTop();
                                }
                                const atEdge = this._AbsListView_this.trackMotionScroll(delta, delta);
                                const atEnd = atEdge && (delta != 0);
                                if (atEnd) {
                                    if (motionView != null) {
                                        let overshoot = -(delta - (motionView.getTop() - oldTop));
                                        this._AbsListView_this.overScrollBy(0, overshoot, 0, this._AbsListView_this.mScrollY, 0, 0, 0, this._AbsListView_this.mOverflingDistance, false);
                                    }
                                    if (more) {
                                        this.edgeReached(delta);
                                    }
                                    break;
                                }
                                if (more && !atEnd) {
                                    if (atEdge)
                                        this._AbsListView_this.invalidate();
                                    this.mLastFlingY = y;
                                    this._AbsListView_this.postOnAnimation(this);
                                }
                                else {
                                    this.endFling();
                                    if (AbsListView.PROFILE_FLINGING) {
                                        if (this._AbsListView_this.mFlingProfilingStarted) {
                                            this._AbsListView_this.mFlingProfilingStarted = false;
                                        }
                                    }
                                }
                                break;
                            }
                        case AbsListView.TOUCH_MODE_OVERFLING:
                            {
                                const scroller = this.mScroller;
                                if (scroller.computeScrollOffset()) {
                                    const scrollY = this._AbsListView_this.mScrollY;
                                    const currY = scroller.getCurrY();
                                    let deltaY = currY - scrollY;
                                    const crossDown = scrollY <= 0 && currY > 0;
                                    const crossUp = scrollY >= 0 && currY < 0;
                                    if (crossDown || crossUp) {
                                        let velocity = Math.floor(scroller.getCurrVelocity());
                                        if (crossUp)
                                            velocity = -velocity;
                                        scroller.abortAnimation();
                                        this.start(velocity);
                                        deltaY = -scrollY;
                                    }
                                    if (this._AbsListView_this.overScrollBy(0, deltaY, 0, scrollY, 0, 0, 0, this._AbsListView_this.mOverflingDistance, false)) {
                                        this.startSpringback();
                                    }
                                    else {
                                        this._AbsListView_this.invalidate();
                                        this._AbsListView_this.postOnAnimation(this);
                                    }
                                }
                                else {
                                    this.endFling();
                                }
                                break;
                            }
                    }
                }
            }
            FlingRunnable.FLYWHEEL_TIMEOUT = 40;
            AbsListView.FlingRunnable = FlingRunnable;
            class PositionScroller {
                constructor(arg) {
                    this.mMode = 0;
                    this.mTargetPos = 0;
                    this.mBoundPos = 0;
                    this.mLastSeenPos = 0;
                    this.mScrollDuration = 0;
                    this.mExtraScroll = 0;
                    this.mOffsetFromTop = 0;
                    this._AbsListView_this = arg;
                    this.mExtraScroll = ViewConfiguration.get().getScaledFadingEdgeLength();
                }
                start(...args) {
                    if (args.length === 1)
                        this._start_1(args[0]);
                    else if (args.length === 2)
                        this._start_2(args[0], args[1]);
                }
                _start_1(position) {
                    this.stop();
                    if (this._AbsListView_this.mDataChanged) {
                        this._AbsListView_this.mPositionScrollAfterLayout = (() => {
                            const _this = this;
                            class _Inner {
                                run() {
                                    _this.start(position);
                                }
                            }
                            return new _Inner();
                        })();
                        return;
                    }
                    const childCount = this._AbsListView_this.getChildCount();
                    if (childCount == 0) {
                        return;
                    }
                    const firstPos = this._AbsListView_this.mFirstPosition;
                    const lastPos = firstPos + childCount - 1;
                    let viewTravelCount;
                    let clampedPosition = Math.max(0, Math.min(this._AbsListView_this.getCount() - 1, position));
                    if (clampedPosition < firstPos) {
                        viewTravelCount = firstPos - clampedPosition + 1;
                        this.mMode = PositionScroller.MOVE_UP_POS;
                    }
                    else if (clampedPosition > lastPos) {
                        viewTravelCount = clampedPosition - lastPos + 1;
                        this.mMode = PositionScroller.MOVE_DOWN_POS;
                    }
                    else {
                        this.scrollToVisible(clampedPosition, AbsListView.INVALID_POSITION, PositionScroller.SCROLL_DURATION);
                        return;
                    }
                    if (viewTravelCount > 0) {
                        this.mScrollDuration = PositionScroller.SCROLL_DURATION / viewTravelCount;
                    }
                    else {
                        this.mScrollDuration = PositionScroller.SCROLL_DURATION;
                    }
                    this.mTargetPos = clampedPosition;
                    this.mBoundPos = AbsListView.INVALID_POSITION;
                    this.mLastSeenPos = AbsListView.INVALID_POSITION;
                    this._AbsListView_this.postOnAnimation(this);
                }
                _start_2(position, boundPosition) {
                    this.stop();
                    if (boundPosition == AbsListView.INVALID_POSITION) {
                        this.start(position);
                        return;
                    }
                    if (this._AbsListView_this.mDataChanged) {
                        this._AbsListView_this.mPositionScrollAfterLayout = (() => {
                            const _this = this;
                            class _Inner {
                                run() {
                                    _this.start(position, boundPosition);
                                }
                            }
                            return new _Inner();
                        })();
                        return;
                    }
                    const childCount = this._AbsListView_this.getChildCount();
                    if (childCount == 0) {
                        return;
                    }
                    const firstPos = this._AbsListView_this.mFirstPosition;
                    const lastPos = firstPos + childCount - 1;
                    let viewTravelCount;
                    let clampedPosition = Math.max(0, Math.min(this._AbsListView_this.getCount() - 1, position));
                    if (clampedPosition < firstPos) {
                        const boundPosFromLast = lastPos - boundPosition;
                        if (boundPosFromLast < 1) {
                            return;
                        }
                        const posTravel = firstPos - clampedPosition + 1;
                        const boundTravel = boundPosFromLast - 1;
                        if (boundTravel < posTravel) {
                            viewTravelCount = boundTravel;
                            this.mMode = PositionScroller.MOVE_UP_BOUND;
                        }
                        else {
                            viewTravelCount = posTravel;
                            this.mMode = PositionScroller.MOVE_UP_POS;
                        }
                    }
                    else if (clampedPosition > lastPos) {
                        const boundPosFromFirst = boundPosition - firstPos;
                        if (boundPosFromFirst < 1) {
                            return;
                        }
                        const posTravel = clampedPosition - lastPos + 1;
                        const boundTravel = boundPosFromFirst - 1;
                        if (boundTravel < posTravel) {
                            viewTravelCount = boundTravel;
                            this.mMode = PositionScroller.MOVE_DOWN_BOUND;
                        }
                        else {
                            viewTravelCount = posTravel;
                            this.mMode = PositionScroller.MOVE_DOWN_POS;
                        }
                    }
                    else {
                        this.scrollToVisible(clampedPosition, boundPosition, PositionScroller.SCROLL_DURATION);
                        return;
                    }
                    if (viewTravelCount > 0) {
                        this.mScrollDuration = PositionScroller.SCROLL_DURATION / viewTravelCount;
                    }
                    else {
                        this.mScrollDuration = PositionScroller.SCROLL_DURATION;
                    }
                    this.mTargetPos = clampedPosition;
                    this.mBoundPos = boundPosition;
                    this.mLastSeenPos = AbsListView.INVALID_POSITION;
                    this._AbsListView_this.postOnAnimation(this);
                }
                startWithOffset(position, offset, duration = PositionScroller.SCROLL_DURATION) {
                    this.stop();
                    if (this._AbsListView_this.mDataChanged) {
                        const postOffset = offset;
                        this._AbsListView_this.mPositionScrollAfterLayout = (() => {
                            const _this = this;
                            class _Inner {
                                run() {
                                    _this.startWithOffset(position, postOffset, duration);
                                }
                            }
                            return new _Inner();
                        })();
                        return;
                    }
                    const childCount = this._AbsListView_this.getChildCount();
                    if (childCount == 0) {
                        return;
                    }
                    offset += this._AbsListView_this.getPaddingTop();
                    this.mTargetPos = Math.max(0, Math.min(this._AbsListView_this.getCount() - 1, position));
                    this.mOffsetFromTop = offset;
                    this.mBoundPos = AbsListView.INVALID_POSITION;
                    this.mLastSeenPos = AbsListView.INVALID_POSITION;
                    this.mMode = PositionScroller.MOVE_OFFSET;
                    const firstPos = this._AbsListView_this.mFirstPosition;
                    const lastPos = firstPos + childCount - 1;
                    let viewTravelCount;
                    if (this.mTargetPos < firstPos) {
                        viewTravelCount = firstPos - this.mTargetPos;
                    }
                    else if (this.mTargetPos > lastPos) {
                        viewTravelCount = this.mTargetPos - lastPos;
                    }
                    else {
                        const targetTop = this._AbsListView_this.getChildAt(this.mTargetPos - firstPos).getTop();
                        this._AbsListView_this.smoothScrollBy(targetTop - offset, duration, true);
                        return;
                    }
                    const screenTravelCount = viewTravelCount / childCount;
                    this.mScrollDuration = screenTravelCount < 1 ? duration : Math.floor((duration / screenTravelCount));
                    this.mLastSeenPos = AbsListView.INVALID_POSITION;
                    this._AbsListView_this.postOnAnimation(this);
                }
                scrollToVisible(targetPos, boundPos, duration) {
                    const firstPos = this._AbsListView_this.mFirstPosition;
                    const childCount = this._AbsListView_this.getChildCount();
                    const lastPos = firstPos + childCount - 1;
                    const paddedTop = this._AbsListView_this.mListPadding.top;
                    const paddedBottom = this._AbsListView_this.getHeight() - this._AbsListView_this.mListPadding.bottom;
                    if (targetPos < firstPos || targetPos > lastPos) {
                        Log.w(AbsListView.TAG_AbsListView, "scrollToVisible called with targetPos " + targetPos + " not visible [" + firstPos + ", " + lastPos + "]");
                    }
                    if (boundPos < firstPos || boundPos > lastPos) {
                        boundPos = AbsListView.INVALID_POSITION;
                    }
                    const targetChild = this._AbsListView_this.getChildAt(targetPos - firstPos);
                    const targetTop = targetChild.getTop();
                    const targetBottom = targetChild.getBottom();
                    let scrollBy = 0;
                    if (targetBottom > paddedBottom) {
                        scrollBy = targetBottom - paddedBottom;
                    }
                    if (targetTop < paddedTop) {
                        scrollBy = targetTop - paddedTop;
                    }
                    if (scrollBy == 0) {
                        return;
                    }
                    if (boundPos >= 0) {
                        const boundChild = this._AbsListView_this.getChildAt(boundPos - firstPos);
                        const boundTop = boundChild.getTop();
                        const boundBottom = boundChild.getBottom();
                        const absScroll = Math.abs(scrollBy);
                        if (scrollBy < 0 && boundBottom + absScroll > paddedBottom) {
                            scrollBy = Math.max(0, boundBottom - paddedBottom);
                        }
                        else if (scrollBy > 0 && boundTop - absScroll < paddedTop) {
                            scrollBy = Math.min(0, boundTop - paddedTop);
                        }
                    }
                    this._AbsListView_this.smoothScrollBy(scrollBy, duration);
                }
                stop() {
                    this._AbsListView_this.removeCallbacks(this);
                }
                run() {
                    const listHeight = this._AbsListView_this.getHeight();
                    const firstPos = this._AbsListView_this.mFirstPosition;
                    switch (this.mMode) {
                        case PositionScroller.MOVE_DOWN_POS:
                            {
                                const lastViewIndex = this._AbsListView_this.getChildCount() - 1;
                                const lastPos = firstPos + lastViewIndex;
                                if (lastViewIndex < 0) {
                                    return;
                                }
                                if (lastPos == this.mLastSeenPos) {
                                    this._AbsListView_this.postOnAnimation(this);
                                    return;
                                }
                                const lastView = this._AbsListView_this.getChildAt(lastViewIndex);
                                const lastViewHeight = lastView.getHeight();
                                const lastViewTop = lastView.getTop();
                                const lastViewPixelsShowing = listHeight - lastViewTop;
                                const extraScroll = lastPos < this._AbsListView_this.mItemCount - 1 ? Math.max(this._AbsListView_this.mListPadding.bottom, this.mExtraScroll) : this._AbsListView_this.mListPadding.bottom;
                                const scrollBy = lastViewHeight - lastViewPixelsShowing + extraScroll;
                                this._AbsListView_this.smoothScrollBy(scrollBy, this.mScrollDuration, true);
                                this.mLastSeenPos = lastPos;
                                if (lastPos < this.mTargetPos) {
                                    this._AbsListView_this.postOnAnimation(this);
                                }
                                break;
                            }
                        case PositionScroller.MOVE_DOWN_BOUND:
                            {
                                const nextViewIndex = 1;
                                const childCount = this._AbsListView_this.getChildCount();
                                if (firstPos == this.mBoundPos || childCount <= nextViewIndex || firstPos + childCount >= this._AbsListView_this.mItemCount) {
                                    return;
                                }
                                const nextPos = firstPos + nextViewIndex;
                                if (nextPos == this.mLastSeenPos) {
                                    this._AbsListView_this.postOnAnimation(this);
                                    return;
                                }
                                const nextView = this._AbsListView_this.getChildAt(nextViewIndex);
                                const nextViewHeight = nextView.getHeight();
                                const nextViewTop = nextView.getTop();
                                const extraScroll = Math.max(this._AbsListView_this.mListPadding.bottom, this.mExtraScroll);
                                if (nextPos < this.mBoundPos) {
                                    this._AbsListView_this.smoothScrollBy(Math.max(0, nextViewHeight + nextViewTop - extraScroll), this.mScrollDuration, true);
                                    this.mLastSeenPos = nextPos;
                                    this._AbsListView_this.postOnAnimation(this);
                                }
                                else {
                                    if (nextViewTop > extraScroll) {
                                        this._AbsListView_this.smoothScrollBy(nextViewTop - extraScroll, this.mScrollDuration, true);
                                    }
                                }
                                break;
                            }
                        case PositionScroller.MOVE_UP_POS:
                            {
                                if (firstPos == this.mLastSeenPos) {
                                    this._AbsListView_this.postOnAnimation(this);
                                    return;
                                }
                                const firstView = this._AbsListView_this.getChildAt(0);
                                if (firstView == null) {
                                    return;
                                }
                                const firstViewTop = firstView.getTop();
                                const extraScroll = firstPos > 0 ? Math.max(this.mExtraScroll, this._AbsListView_this.mListPadding.top) : this._AbsListView_this.mListPadding.top;
                                this._AbsListView_this.smoothScrollBy(firstViewTop - extraScroll, this.mScrollDuration, true);
                                this.mLastSeenPos = firstPos;
                                if (firstPos > this.mTargetPos) {
                                    this._AbsListView_this.postOnAnimation(this);
                                }
                                break;
                            }
                        case PositionScroller.MOVE_UP_BOUND:
                            {
                                const lastViewIndex = this._AbsListView_this.getChildCount() - 2;
                                if (lastViewIndex < 0) {
                                    return;
                                }
                                const lastPos = firstPos + lastViewIndex;
                                if (lastPos == this.mLastSeenPos) {
                                    this._AbsListView_this.postOnAnimation(this);
                                    return;
                                }
                                const lastView = this._AbsListView_this.getChildAt(lastViewIndex);
                                const lastViewHeight = lastView.getHeight();
                                const lastViewTop = lastView.getTop();
                                const lastViewPixelsShowing = listHeight - lastViewTop;
                                const extraScroll = Math.max(this._AbsListView_this.mListPadding.top, this.mExtraScroll);
                                this.mLastSeenPos = lastPos;
                                if (lastPos > this.mBoundPos) {
                                    this._AbsListView_this.smoothScrollBy(-(lastViewPixelsShowing - extraScroll), this.mScrollDuration, true);
                                    this._AbsListView_this.postOnAnimation(this);
                                }
                                else {
                                    const bottom = listHeight - extraScroll;
                                    const lastViewBottom = lastViewTop + lastViewHeight;
                                    if (bottom > lastViewBottom) {
                                        this._AbsListView_this.smoothScrollBy(-(bottom - lastViewBottom), this.mScrollDuration, true);
                                    }
                                }
                                break;
                            }
                        case PositionScroller.MOVE_OFFSET:
                            {
                                if (this.mLastSeenPos == firstPos) {
                                    this._AbsListView_this.postOnAnimation(this);
                                    return;
                                }
                                this.mLastSeenPos = firstPos;
                                const childCount = this._AbsListView_this.getChildCount();
                                const position = this.mTargetPos;
                                const lastPos = firstPos + childCount - 1;
                                let viewTravelCount = 0;
                                if (position < firstPos) {
                                    viewTravelCount = firstPos - position + 1;
                                }
                                else if (position > lastPos) {
                                    viewTravelCount = position - lastPos;
                                }
                                const screenTravelCount = viewTravelCount / childCount;
                                const modifier = Math.min(Math.abs(screenTravelCount), 1.);
                                if (position < firstPos) {
                                    const distance = Math.floor((-this._AbsListView_this.getHeight() * modifier));
                                    const duration = Math.floor((this.mScrollDuration * modifier));
                                    this._AbsListView_this.smoothScrollBy(distance, duration, true);
                                    this._AbsListView_this.postOnAnimation(this);
                                }
                                else if (position > lastPos) {
                                    const distance = Math.floor((this._AbsListView_this.getHeight() * modifier));
                                    const duration = Math.floor((this.mScrollDuration * modifier));
                                    this._AbsListView_this.smoothScrollBy(distance, duration, true);
                                    this._AbsListView_this.postOnAnimation(this);
                                }
                                else {
                                    const targetTop = this._AbsListView_this.getChildAt(position - firstPos).getTop();
                                    const distance = targetTop - this.mOffsetFromTop;
                                    const duration = Math.floor((this.mScrollDuration * (Math.abs(distance) / this._AbsListView_this.getHeight())));
                                    this._AbsListView_this.smoothScrollBy(distance, duration, true);
                                }
                                break;
                            }
                        default:
                            break;
                    }
                }
            }
            PositionScroller.SCROLL_DURATION = 200;
            PositionScroller.MOVE_DOWN_POS = 1;
            PositionScroller.MOVE_UP_POS = 2;
            PositionScroller.MOVE_DOWN_BOUND = 3;
            PositionScroller.MOVE_UP_BOUND = 4;
            PositionScroller.MOVE_OFFSET = 5;
            AbsListView.PositionScroller = PositionScroller;
            class AdapterDataSetObserver extends AdapterView.AdapterDataSetObserver {
                constructor(arg) {
                    super(arg);
                    this._AbsListView_this = arg;
                }
                onChanged() {
                    super.onChanged();
                }
                onInvalidated() {
                    super.onInvalidated();
                }
            }
            AbsListView.AdapterDataSetObserver = AdapterDataSetObserver;
            class LayoutParams extends ViewGroup.LayoutParams {
                constructor(...args) {
                    super();
                    this.viewType = 0;
                    this.scrappedFromPosition = 0;
                    this.itemId = -1;
                    if (args.length === 1) {
                        super(args[0]);
                    }
                    else if (args.length === 2) {
                        super(args[0], args[1]);
                    }
                    else if (args.length === 3) {
                        super(args[0], args[1]);
                        this.viewType = args[2];
                    }
                }
            }
            AbsListView.LayoutParams = LayoutParams;
            class RecycleBin {
                constructor(arg) {
                    this.mFirstActivePosition = 0;
                    this.mActiveViews = [];
                    this.mViewTypeCount = 0;
                    this._AbsListView_this = arg;
                }
                setViewTypeCount(viewTypeCount) {
                    if (viewTypeCount < 1) {
                        throw Error(`new IllegalArgumentException("Can't have a viewTypeCount < 1")`);
                    }
                    let scrapViews = new Array(viewTypeCount);
                    for (let i = 0; i < viewTypeCount; i++) {
                        scrapViews[i] = new ArrayList();
                    }
                    this.mViewTypeCount = viewTypeCount;
                    this.mCurrentScrap = scrapViews[0];
                    this.mScrapViews = scrapViews;
                }
                markChildrenDirty() {
                    if (this.mViewTypeCount == 1) {
                        const scrap = this.mCurrentScrap;
                        const scrapCount = scrap.size();
                        for (let i = 0; i < scrapCount; i++) {
                            scrap.get(i).forceLayout();
                        }
                    }
                    else {
                        const typeCount = this.mViewTypeCount;
                        for (let i = 0; i < typeCount; i++) {
                            const scrap = this.mScrapViews[i];
                            const scrapCount = scrap.size();
                            for (let j = 0; j < scrapCount; j++) {
                                scrap.get(j).forceLayout();
                            }
                        }
                    }
                    if (this.mTransientStateViews != null) {
                        const count = this.mTransientStateViews.size();
                        for (let i = 0; i < count; i++) {
                            this.mTransientStateViews.valueAt(i).forceLayout();
                        }
                    }
                    if (this.mTransientStateViewsById != null) {
                        const count = this.mTransientStateViewsById.size();
                        for (let i = 0; i < count; i++) {
                            this.mTransientStateViewsById.valueAt(i).forceLayout();
                        }
                    }
                }
                shouldRecycleViewType(viewType) {
                    return viewType >= 0;
                }
                clear() {
                    if (this.mViewTypeCount == 1) {
                        const scrap = this.mCurrentScrap;
                        const scrapCount = scrap.size();
                        for (let i = 0; i < scrapCount; i++) {
                            this._AbsListView_this.removeDetachedView(scrap.remove(scrapCount - 1 - i), false);
                        }
                    }
                    else {
                        const typeCount = this.mViewTypeCount;
                        for (let i = 0; i < typeCount; i++) {
                            const scrap = this.mScrapViews[i];
                            const scrapCount = scrap.size();
                            for (let j = 0; j < scrapCount; j++) {
                                this._AbsListView_this.removeDetachedView(scrap.remove(scrapCount - 1 - j), false);
                            }
                        }
                    }
                    if (this.mTransientStateViews != null) {
                        this.mTransientStateViews.clear();
                    }
                    if (this.mTransientStateViewsById != null) {
                        this.mTransientStateViewsById.clear();
                    }
                }
                fillActiveViews(childCount, firstActivePosition) {
                    if (this.mActiveViews.length < childCount) {
                        this.mActiveViews = new Array(childCount);
                    }
                    this.mFirstActivePosition = firstActivePosition;
                    const activeViews = this.mActiveViews;
                    for (let i = 0; i < childCount; i++) {
                        let child = this._AbsListView_this.getChildAt(i);
                        let lp = child.getLayoutParams();
                        if (lp != null && lp.viewType != AbsListView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER) {
                            activeViews[i] = child;
                        }
                    }
                }
                getActiveView(position) {
                    let index = position - this.mFirstActivePosition;
                    const activeViews = this.mActiveViews;
                    if (index >= 0 && index < activeViews.length) {
                        const match = activeViews[index];
                        activeViews[index] = null;
                        return match;
                    }
                    return null;
                }
                getTransientStateView(position) {
                    if (this._AbsListView_this.mAdapter != null && this._AbsListView_this.mAdapterHasStableIds && this.mTransientStateViewsById != null) {
                        let id = this._AbsListView_this.mAdapter.getItemId(position);
                        let result = this.mTransientStateViewsById.get(id);
                        this.mTransientStateViewsById.remove(id);
                        return result;
                    }
                    if (this.mTransientStateViews != null) {
                        const index = this.mTransientStateViews.indexOfKey(position);
                        if (index >= 0) {
                            let result = this.mTransientStateViews.valueAt(index);
                            this.mTransientStateViews.removeAt(index);
                            return result;
                        }
                    }
                    return null;
                }
                clearTransientStateViews() {
                    if (this.mTransientStateViews != null) {
                        this.mTransientStateViews.clear();
                    }
                    if (this.mTransientStateViewsById != null) {
                        this.mTransientStateViewsById.clear();
                    }
                }
                getScrapView(position) {
                    if (this.mViewTypeCount == 1) {
                        return AbsListView.retrieveFromScrap(this.mCurrentScrap, position);
                    }
                    else {
                        let whichScrap = this._AbsListView_this.mAdapter.getItemViewType(position);
                        if (whichScrap >= 0 && whichScrap < this.mScrapViews.length) {
                            return AbsListView.retrieveFromScrap(this.mScrapViews[whichScrap], position);
                        }
                    }
                    return null;
                }
                addScrapView(scrap, position) {
                    const lp = scrap.getLayoutParams();
                    if (lp == null) {
                        return;
                    }
                    lp.scrappedFromPosition = position;
                    const viewType = lp.viewType;
                    if (!this.shouldRecycleViewType(viewType)) {
                        return;
                    }
                    scrap.dispatchStartTemporaryDetach();
                    const scrapHasTransientState = scrap.hasTransientState();
                    if (scrapHasTransientState) {
                        if (this._AbsListView_this.mAdapter != null && this._AbsListView_this.mAdapterHasStableIds) {
                            if (this.mTransientStateViewsById == null) {
                                this.mTransientStateViewsById = new LongSparseArray();
                            }
                            this.mTransientStateViewsById.put(lp.itemId, scrap);
                        }
                        else if (!this._AbsListView_this.mDataChanged) {
                            if (this.mTransientStateViews == null) {
                                this.mTransientStateViews = new SparseArray();
                            }
                            this.mTransientStateViews.put(position, scrap);
                        }
                        else {
                            if (this.mSkippedScrap == null) {
                                this.mSkippedScrap = new ArrayList();
                            }
                            this.mSkippedScrap.add(scrap);
                        }
                    }
                    else {
                        if (this.mViewTypeCount == 1) {
                            this.mCurrentScrap.add(scrap);
                        }
                        else {
                            this.mScrapViews[viewType].add(scrap);
                        }
                        if (this.mRecyclerListener != null) {
                            this.mRecyclerListener.onMovedToScrapHeap(scrap);
                        }
                    }
                }
                removeSkippedScrap() {
                    if (this.mSkippedScrap == null) {
                        return;
                    }
                    const count = this.mSkippedScrap.size();
                    for (let i = 0; i < count; i++) {
                        this._AbsListView_this.removeDetachedView(this.mSkippedScrap.get(i), false);
                    }
                    this.mSkippedScrap.clear();
                }
                scrapActiveViews() {
                    const activeViews = this.mActiveViews;
                    const hasListener = this.mRecyclerListener != null;
                    const multipleScraps = this.mViewTypeCount > 1;
                    let scrapViews = this.mCurrentScrap;
                    const count = activeViews.length;
                    for (let i = count - 1; i >= 0; i--) {
                        const victim = activeViews[i];
                        if (victim != null) {
                            const lp = victim.getLayoutParams();
                            let whichScrap = lp.viewType;
                            activeViews[i] = null;
                            const scrapHasTransientState = victim.hasTransientState();
                            if (!this.shouldRecycleViewType(whichScrap) || scrapHasTransientState) {
                                if (whichScrap != AbsListView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER && scrapHasTransientState) {
                                    this._AbsListView_this.removeDetachedView(victim, false);
                                }
                                if (scrapHasTransientState) {
                                    if (this._AbsListView_this.mAdapter != null && this._AbsListView_this.mAdapterHasStableIds) {
                                        if (this.mTransientStateViewsById == null) {
                                            this.mTransientStateViewsById = new LongSparseArray();
                                        }
                                        let id = this._AbsListView_this.mAdapter.getItemId(this.mFirstActivePosition + i);
                                        this.mTransientStateViewsById.put(id, victim);
                                    }
                                    else {
                                        if (this.mTransientStateViews == null) {
                                            this.mTransientStateViews = new SparseArray();
                                        }
                                        this.mTransientStateViews.put(this.mFirstActivePosition + i, victim);
                                    }
                                }
                                continue;
                            }
                            if (multipleScraps) {
                                scrapViews = this.mScrapViews[whichScrap];
                            }
                            victim.dispatchStartTemporaryDetach();
                            lp.scrappedFromPosition = this.mFirstActivePosition + i;
                            scrapViews.add(victim);
                            if (hasListener) {
                                this.mRecyclerListener.onMovedToScrapHeap(victim);
                            }
                        }
                    }
                    this.pruneScrapViews();
                }
                pruneScrapViews() {
                    const maxViews = this.mActiveViews.length;
                    const viewTypeCount = this.mViewTypeCount;
                    const scrapViews = this.mScrapViews;
                    for (let i = 0; i < viewTypeCount; ++i) {
                        const scrapPile = scrapViews[i];
                        let size = scrapPile.size();
                        const extras = size - maxViews;
                        size--;
                        for (let j = 0; j < extras; j++) {
                            this._AbsListView_this.removeDetachedView(scrapPile.remove(size--), false);
                        }
                    }
                    if (this.mTransientStateViews != null) {
                        for (let i = 0; i < this.mTransientStateViews.size(); i++) {
                            const v = this.mTransientStateViews.valueAt(i);
                            if (!v.hasTransientState()) {
                                this.mTransientStateViews.removeAt(i);
                                i--;
                            }
                        }
                    }
                    if (this.mTransientStateViewsById != null) {
                        for (let i = 0; i < this.mTransientStateViewsById.size(); i++) {
                            const v = this.mTransientStateViewsById.valueAt(i);
                            if (!v.hasTransientState()) {
                                this.mTransientStateViewsById.removeAt(i);
                                i--;
                            }
                        }
                    }
                }
                reclaimScrapViews(views) {
                    if (this.mViewTypeCount == 1) {
                        views.addAll(this.mCurrentScrap);
                    }
                    else {
                        const viewTypeCount = this.mViewTypeCount;
                        const scrapViews = this.mScrapViews;
                        for (let i = 0; i < viewTypeCount; ++i) {
                            const scrapPile = scrapViews[i];
                            views.addAll(scrapPile);
                        }
                    }
                }
                setCacheColorHint(color) {
                    if (this.mViewTypeCount == 1) {
                        const scrap = this.mCurrentScrap;
                        const scrapCount = scrap.size();
                        for (let i = 0; i < scrapCount; i++) {
                            scrap.get(i).setDrawingCacheBackgroundColor(color);
                        }
                    }
                    else {
                        const typeCount = this.mViewTypeCount;
                        for (let i = 0; i < typeCount; i++) {
                            const scrap = this.mScrapViews[i];
                            const scrapCount = scrap.size();
                            for (let j = 0; j < scrapCount; j++) {
                                scrap.get(j).setDrawingCacheBackgroundColor(color);
                            }
                        }
                    }
                    const activeViews = this.mActiveViews;
                    const count = activeViews.length;
                    for (let i = 0; i < count; ++i) {
                        const victim = activeViews[i];
                        if (victim != null) {
                            victim.setDrawingCacheBackgroundColor(color);
                        }
                    }
                }
            }
            AbsListView.RecycleBin = RecycleBin;
        })(AbsListView = widget.AbsListView || (widget.AbsListView = {}));
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/widget/Adapter.ts"/>
///<reference path="../../android/widget/ListAdapter.ts"/>
///<reference path="../../android/widget/ListView.ts"/>
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/database/DataSetObserver.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../java/util/ArrayList.ts"/>
///<reference path="../../android/widget/Adapter.ts"/>
///<reference path="../../android/widget/AdapterView.ts"/>
///<reference path="../../android/widget/ListAdapter.ts"/>
///<reference path="../../android/widget/ListView.ts"/>
///<reference path="../../android/widget/WrapperListAdapter.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var ArrayList = java.util.ArrayList;
        var AdapterView = android.widget.AdapterView;
        class HeaderViewListAdapter {
            constructor(headerViewInfos, footerViewInfos, adapter) {
                this.mAdapter = adapter;
                this.mIsFilterable = false;
                if (headerViewInfos == null) {
                    this.mHeaderViewInfos = HeaderViewListAdapter.EMPTY_INFO_LIST;
                }
                else {
                    this.mHeaderViewInfos = headerViewInfos;
                }
                if (footerViewInfos == null) {
                    this.mFooterViewInfos = HeaderViewListAdapter.EMPTY_INFO_LIST;
                }
                else {
                    this.mFooterViewInfos = footerViewInfos;
                }
                this.mAreAllFixedViewsSelectable = this.areAllListInfosSelectable(this.mHeaderViewInfos) && this.areAllListInfosSelectable(this.mFooterViewInfos);
            }
            getHeadersCount() {
                return this.mHeaderViewInfos.size();
            }
            getFootersCount() {
                return this.mFooterViewInfos.size();
            }
            isEmpty() {
                return this.mAdapter == null || this.mAdapter.isEmpty();
            }
            areAllListInfosSelectable(infos) {
                if (infos != null) {
                    for (let info of infos.array) {
                        if (!info.isSelectable) {
                            return false;
                        }
                    }
                }
                return true;
            }
            removeHeader(v) {
                for (let i = 0; i < this.mHeaderViewInfos.size(); i++) {
                    let info = this.mHeaderViewInfos.get(i);
                    if (info.view == v) {
                        this.mHeaderViewInfos.remove(i);
                        this.mAreAllFixedViewsSelectable = this.areAllListInfosSelectable(this.mHeaderViewInfos) && this.areAllListInfosSelectable(this.mFooterViewInfos);
                        return true;
                    }
                }
                return false;
            }
            removeFooter(v) {
                for (let i = 0; i < this.mFooterViewInfos.size(); i++) {
                    let info = this.mFooterViewInfos.get(i);
                    if (info.view == v) {
                        this.mFooterViewInfos.remove(i);
                        this.mAreAllFixedViewsSelectable = this.areAllListInfosSelectable(this.mHeaderViewInfos) && this.areAllListInfosSelectable(this.mFooterViewInfos);
                        return true;
                    }
                }
                return false;
            }
            getCount() {
                if (this.mAdapter != null) {
                    return this.getFootersCount() + this.getHeadersCount() + this.mAdapter.getCount();
                }
                else {
                    return this.getFootersCount() + this.getHeadersCount();
                }
            }
            areAllItemsEnabled() {
                if (this.mAdapter != null) {
                    return this.mAreAllFixedViewsSelectable && this.mAdapter.areAllItemsEnabled();
                }
                else {
                    return true;
                }
            }
            isEnabled(position) {
                let numHeaders = this.getHeadersCount();
                if (position < numHeaders) {
                    return this.mHeaderViewInfos.get(position).isSelectable;
                }
                const adjPosition = position - numHeaders;
                let adapterCount = 0;
                if (this.mAdapter != null) {
                    adapterCount = this.mAdapter.getCount();
                    if (adjPosition < adapterCount) {
                        return this.mAdapter.isEnabled(adjPosition);
                    }
                }
                return this.mFooterViewInfos.get(adjPosition - adapterCount).isSelectable;
            }
            getItem(position) {
                let numHeaders = this.getHeadersCount();
                if (position < numHeaders) {
                    return this.mHeaderViewInfos.get(position).data;
                }
                const adjPosition = position - numHeaders;
                let adapterCount = 0;
                if (this.mAdapter != null) {
                    adapterCount = this.mAdapter.getCount();
                    if (adjPosition < adapterCount) {
                        return this.mAdapter.getItem(adjPosition);
                    }
                }
                return this.mFooterViewInfos.get(adjPosition - adapterCount).data;
            }
            getItemId(position) {
                let numHeaders = this.getHeadersCount();
                if (this.mAdapter != null && position >= numHeaders) {
                    let adjPosition = position - numHeaders;
                    let adapterCount = this.mAdapter.getCount();
                    if (adjPosition < adapterCount) {
                        return this.mAdapter.getItemId(adjPosition);
                    }
                }
                return -1;
            }
            hasStableIds() {
                if (this.mAdapter != null) {
                    return this.mAdapter.hasStableIds();
                }
                return false;
            }
            getView(position, convertView, parent) {
                let numHeaders = this.getHeadersCount();
                if (position < numHeaders) {
                    return this.mHeaderViewInfos.get(position).view;
                }
                const adjPosition = position - numHeaders;
                let adapterCount = 0;
                if (this.mAdapter != null) {
                    adapterCount = this.mAdapter.getCount();
                    if (adjPosition < adapterCount) {
                        return this.mAdapter.getView(adjPosition, convertView, parent);
                    }
                }
                return this.mFooterViewInfos.get(adjPosition - adapterCount).view;
            }
            getItemViewType(position) {
                let numHeaders = this.getHeadersCount();
                if (this.mAdapter != null && position >= numHeaders) {
                    let adjPosition = position - numHeaders;
                    let adapterCount = this.mAdapter.getCount();
                    if (adjPosition < adapterCount) {
                        return this.mAdapter.getItemViewType(adjPosition);
                    }
                }
                return AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER;
            }
            getViewTypeCount() {
                if (this.mAdapter != null) {
                    return this.mAdapter.getViewTypeCount();
                }
                return 1;
            }
            registerDataSetObserver(observer) {
                if (this.mAdapter != null) {
                    this.mAdapter.registerDataSetObserver(observer);
                }
            }
            unregisterDataSetObserver(observer) {
                if (this.mAdapter != null) {
                    this.mAdapter.unregisterDataSetObserver(observer);
                }
            }
            getFilter() {
                return null;
            }
            getWrappedAdapter() {
                return this.mAdapter;
            }
        }
        HeaderViewListAdapter.EMPTY_INFO_LIST = new ArrayList();
        widget.HeaderViewListAdapter = HeaderViewListAdapter;
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/5.
 */
///<reference path="../../java/util/ArrayList.ts"/>
var android;
(function (android) {
    var database;
    (function (database) {
        var ArrayList = java.util.ArrayList;
        class Observable {
            constructor() {
                this.mObservers = new ArrayList();
            }
            registerObserver(observer) {
                if (observer == null) {
                    throw new Error("The observer is null.");
                }
                if (this.mObservers.contains(observer)) {
                    throw new Error("Observer " + observer + " is already registered.");
                }
                this.mObservers.add(observer);
            }
            unregisterObserver(observer) {
                if (observer == null) {
                    throw new Error("The observer is null.");
                }
                let index = this.mObservers.indexOf(observer);
                if (index == -1) {
                    throw new Error("Observer " + observer + " was not registered.");
                }
                this.mObservers.remove(index);
            }
            unregisterAll() {
                this.mObservers.clear();
            }
        }
        database.Observable = Observable;
    })(database = android.database || (android.database = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/5.
 */
///<reference path="Observable.ts"/>
///<reference path="DataSetObserver.ts"/>
///<reference path="../../java/util/ArrayList.ts"/>
var android;
(function (android) {
    var database;
    (function (database) {
        var Observable = android.database.Observable;
        class DataSetObservable extends Observable {
            notifyChanged() {
                for (let i = this.mObservers.size() - 1; i >= 0; i--) {
                    this.mObservers.get(i).onChanged();
                }
            }
            notifyInvalidated() {
                for (let i = this.mObservers.size() - 1; i >= 0; i--) {
                    this.mObservers.get(i).onInvalidated();
                }
            }
        }
        database.DataSetObservable = DataSetObservable;
    })(database = android.database || (android.database = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../android/widget/Adapter.ts"/>
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/database/DataSetObservable.ts"/>
///<reference path="../../android/database/DataSetObserver.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../android/widget/Adapter.ts"/>
///<reference path="../../android/widget/ListAdapter.ts"/>
///<reference path="../../android/widget/ListView.ts"/>
///<reference path="../../android/widget/SpinnerAdapter.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var DataSetObservable = android.database.DataSetObservable;
        class BaseAdapter {
            constructor() {
                this.mDataSetObservable = new DataSetObservable();
            }
            hasStableIds() {
                return false;
            }
            registerDataSetObserver(observer) {
                this.mDataSetObservable.registerObserver(observer);
            }
            unregisterDataSetObserver(observer) {
                this.mDataSetObservable.unregisterObserver(observer);
            }
            notifyDataSetChanged() {
                this.mDataSetObservable.notifyChanged();
            }
            notifyDataSetInvalidated() {
                this.mDataSetObservable.notifyInvalidated();
            }
            areAllItemsEnabled() {
                return true;
            }
            isEnabled(position) {
                return true;
            }
            getDropDownView(position, convertView, parent) {
                return this.getView(position, convertView, parent);
            }
            getItemViewType(position) {
                return 0;
            }
            getViewTypeCount() {
                return 1;
            }
            isEmpty() {
                return this.getCount() == 0;
            }
        }
        widget.BaseAdapter = BaseAdapter;
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/graphics/Canvas.ts"/>
///<reference path="../../android/graphics/Paint.ts"/>
///<reference path="../../android/graphics/PixelFormat.ts"/>
///<reference path="../../android/graphics/Rect.ts"/>
///<reference path="../../android/graphics/drawable/Drawable.ts"/>
///<reference path="../../android/util/MathUtils.ts"/>
///<reference path="../../android/util/SparseBooleanArray.ts"/>
///<reference path="../../android/view/FocusFinder.ts"/>
///<reference path="../../android/view/KeyEvent.ts"/>
///<reference path="../../android/view/SoundEffectConstants.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../android/view/ViewParent.ts"/>
///<reference path="../../android/view/ViewRootImpl.ts"/>
///<reference path="../../android/os/Trace.ts"/>
///<reference path="../../java/util/ArrayList.ts"/>
///<reference path="../../java/lang/Integer.ts"/>
///<reference path="../../java/lang/System.ts"/>
///<reference path="../../java/lang/Runnable.ts"/>
///<reference path="../../android/widget/AbsListView.ts"/>
///<reference path="../../android/widget/Adapter.ts"/>
///<reference path="../../android/widget/AdapterView.ts"/>
///<reference path="../../android/widget/Checkable.ts"/>
///<reference path="../../android/widget/HeaderViewListAdapter.ts"/>
///<reference path="../../android/widget/ListAdapter.ts"/>
///<reference path="../../android/widget/WrapperListAdapter.ts"/>
///<reference path="../../android/widget/BaseAdapter.ts"/>
///<reference path="../../android/R/attr.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var Paint = android.graphics.Paint;
        var PixelFormat = android.graphics.PixelFormat;
        var Rect = android.graphics.Rect;
        var MathUtils = android.util.MathUtils;
        var FocusFinder = android.view.FocusFinder;
        var KeyEvent = android.view.KeyEvent;
        var SoundEffectConstants = android.view.SoundEffectConstants;
        var View = android.view.View;
        var ViewGroup = android.view.ViewGroup;
        var Trace = android.os.Trace;
        var ArrayList = java.util.ArrayList;
        var Integer = java.lang.Integer;
        var System = java.lang.System;
        var AbsListView = android.widget.AbsListView;
        var AdapterView = android.widget.AdapterView;
        var HeaderViewListAdapter = android.widget.HeaderViewListAdapter;
        class ListView extends AbsListView {
            constructor(bindElement, rootElement) {
                super(bindElement, rootElement);
                this.mHeaderViewInfos = new ArrayList();
                this.mFooterViewInfos = new ArrayList();
                this.mDividerHeight = 0;
                this.mIsCacheColorOpaque = false;
                this.mDividerIsOpaque = false;
                this.mHeaderDividersEnabled = true;
                this.mFooterDividersEnabled = true;
                this.mAreAllItemsSelectable = true;
                this.mItemsCanFocus = false;
                this.mTempRect = new Rect();
                this.mArrowScrollFocusResult = new ListView.ArrowScrollFocusResult();
                this._attrBinder.addAttr('divider', (value) => {
                    let divider = this._attrBinder.parseDrawable(value);
                    if (divider)
                        this.setDivider(divider);
                });
                this._attrBinder.addAttr('overScrollHeader', (value) => {
                    let header = this._attrBinder.parseDrawable(value);
                    if (header)
                        this.setOverscrollHeader(header);
                });
                this._attrBinder.addAttr('overScrollFooter', (value) => {
                    let footer = this._attrBinder.parseDrawable(value);
                    if (footer)
                        this.setOverscrollFooter(footer);
                });
                this._attrBinder.addAttr('dividerHeight', (value) => {
                    let dividerHeight = this._attrBinder.parseNumber(value, -1);
                    if (dividerHeight >= 0) {
                        this.setDividerHeight(dividerHeight);
                    }
                });
                this._attrBinder.addAttr('headerDividersEnabled', (value) => {
                    this.setHeaderDividersEnabled(this._attrBinder.parseBoolean(value, true));
                });
                this._attrBinder.addAttr('footerDividersEnabled', (value) => {
                    this.setFooterDividersEnabled(this._attrBinder.parseBoolean(value, true));
                });
                this.applyDefaultAttributes(android.R.attr.listViewStyle);
            }
            getMaxScrollAmount() {
                return Math.floor((ListView.MAX_SCROLL_FACTOR * (this.mBottom - this.mTop)));
            }
            adjustViewsUpOrDown() {
                const childCount = this.getChildCount();
                let delta;
                if (childCount > 0) {
                    let child;
                    if (!this.mStackFromBottom) {
                        child = this.getChildAt(0);
                        delta = child.getTop() - this.mListPadding.top;
                        if (this.mFirstPosition != 0) {
                            delta -= this.mDividerHeight;
                        }
                        if (delta < 0) {
                            delta = 0;
                        }
                    }
                    else {
                        child = this.getChildAt(childCount - 1);
                        delta = child.getBottom() - (this.getHeight() - this.mListPadding.bottom);
                        if (this.mFirstPosition + childCount < this.mItemCount) {
                            delta += this.mDividerHeight;
                        }
                        if (delta > 0) {
                            delta = 0;
                        }
                    }
                    if (delta != 0) {
                        this.offsetChildrenTopAndBottom(-delta);
                    }
                }
            }
            addHeaderView(v, data = null, isSelectable = true) {
                const info = new ListView.FixedViewInfo(this);
                info.view = v;
                info.data = data;
                info.isSelectable = isSelectable;
                this.mHeaderViewInfos.add(info);
                if (this.mAdapter != null) {
                    if (!(this.mAdapter instanceof HeaderViewListAdapter)) {
                        this.mAdapter = new HeaderViewListAdapter(this.mHeaderViewInfos, this.mFooterViewInfos, this.mAdapter);
                    }
                    if (this.mDataSetObserver != null) {
                        this.mDataSetObserver.onChanged();
                    }
                }
            }
            getHeaderViewsCount() {
                return this.mHeaderViewInfos.size();
            }
            removeHeaderView(v) {
                if (this.mHeaderViewInfos.size() > 0) {
                    let result = false;
                    if (this.mAdapter != null && this.mAdapter.removeHeader(v)) {
                        if (this.mDataSetObserver != null) {
                            this.mDataSetObserver.onChanged();
                        }
                        result = true;
                    }
                    this.removeFixedViewInfo(v, this.mHeaderViewInfos);
                    return result;
                }
                return false;
            }
            removeFixedViewInfo(v, where) {
                let len = where.size();
                for (let i = 0; i < len; ++i) {
                    let info = where.get(i);
                    if (info.view == v) {
                        where.remove(i);
                        break;
                    }
                }
            }
            addFooterView(v, data = null, isSelectable = true) {
                const info = new ListView.FixedViewInfo(this);
                info.view = v;
                info.data = data;
                info.isSelectable = isSelectable;
                this.mFooterViewInfos.add(info);
                if (this.mAdapter != null) {
                    if (!(this.mAdapter instanceof HeaderViewListAdapter)) {
                        this.mAdapter = new HeaderViewListAdapter(this.mHeaderViewInfos, this.mFooterViewInfos, this.mAdapter);
                    }
                    if (this.mDataSetObserver != null) {
                        this.mDataSetObserver.onChanged();
                    }
                }
            }
            getFooterViewsCount() {
                return this.mFooterViewInfos.size();
            }
            removeFooterView(v) {
                if (this.mFooterViewInfos.size() > 0) {
                    let result = false;
                    if (this.mAdapter != null && this.mAdapter.removeFooter(v)) {
                        if (this.mDataSetObserver != null) {
                            this.mDataSetObserver.onChanged();
                        }
                        result = true;
                    }
                    this.removeFixedViewInfo(v, this.mFooterViewInfos);
                    return result;
                }
                return false;
            }
            getAdapter() {
                return this.mAdapter;
            }
            setAdapter(adapter) {
                if (this.mAdapter != null && this.mDataSetObserver != null) {
                    this.mAdapter.unregisterDataSetObserver(this.mDataSetObserver);
                }
                this.resetList();
                this.mRecycler.clear();
                if (this.mHeaderViewInfos.size() > 0 || this.mFooterViewInfos.size() > 0) {
                    this.mAdapter = new HeaderViewListAdapter(this.mHeaderViewInfos, this.mFooterViewInfos, adapter);
                }
                else {
                    this.mAdapter = adapter;
                }
                this.mOldSelectedPosition = ListView.INVALID_POSITION;
                this.mOldSelectedRowId = ListView.INVALID_ROW_ID;
                super.setAdapter(adapter);
                if (this.mAdapter != null) {
                    this.mAreAllItemsSelectable = this.mAdapter.areAllItemsEnabled();
                    this.mOldItemCount = this.mItemCount;
                    this.mItemCount = this.mAdapter.getCount();
                    this.checkFocus();
                    this.mDataSetObserver = new AbsListView.AdapterDataSetObserver(this);
                    this.mAdapter.registerDataSetObserver(this.mDataSetObserver);
                    this.mRecycler.setViewTypeCount(this.mAdapter.getViewTypeCount());
                    let position;
                    if (this.mStackFromBottom) {
                        position = this.lookForSelectablePosition(this.mItemCount - 1, false);
                    }
                    else {
                        position = this.lookForSelectablePosition(0, true);
                    }
                    this.setSelectedPositionInt(position);
                    this.setNextSelectedPositionInt(position);
                    if (this.mItemCount == 0) {
                        this.checkSelectionChanged();
                    }
                }
                else {
                    this.mAreAllItemsSelectable = true;
                    this.checkFocus();
                    this.checkSelectionChanged();
                }
                this.requestLayout();
            }
            resetList() {
                this.clearRecycledState(this.mHeaderViewInfos);
                this.clearRecycledState(this.mFooterViewInfos);
                super.resetList();
                this.mLayoutMode = ListView.LAYOUT_NORMAL;
            }
            clearRecycledState(infos) {
                if (infos != null) {
                    const count = infos.size();
                    for (let i = 0; i < count; i++) {
                        const child = infos.get(i).view;
                        const p = child.getLayoutParams();
                        if (p != null) {
                            p.recycledHeaderFooter = false;
                        }
                    }
                }
            }
            showingTopFadingEdge() {
                const listTop = this.mScrollY + this.mListPadding.top;
                return (this.mFirstPosition > 0) || (this.getChildAt(0).getTop() > listTop);
            }
            showingBottomFadingEdge() {
                const childCount = this.getChildCount();
                const bottomOfBottomChild = this.getChildAt(childCount - 1).getBottom();
                const lastVisiblePosition = this.mFirstPosition + childCount - 1;
                const listBottom = this.mScrollY + this.getHeight() - this.mListPadding.bottom;
                return (lastVisiblePosition < this.mItemCount - 1) || (bottomOfBottomChild < listBottom);
            }
            requestChildRectangleOnScreen(child, rect, immediate) {
                let rectTopWithinChild = rect.top;
                rect.offset(child.getLeft(), child.getTop());
                rect.offset(-child.getScrollX(), -child.getScrollY());
                const height = this.getHeight();
                let listUnfadedTop = this.getScrollY();
                let listUnfadedBottom = listUnfadedTop + height;
                const fadingEdge = this.getVerticalFadingEdgeLength();
                if (this.showingTopFadingEdge()) {
                    if ((this.mSelectedPosition > 0) || (rectTopWithinChild > fadingEdge)) {
                        listUnfadedTop += fadingEdge;
                    }
                }
                let childCount = this.getChildCount();
                let bottomOfBottomChild = this.getChildAt(childCount - 1).getBottom();
                if (this.showingBottomFadingEdge()) {
                    if ((this.mSelectedPosition < this.mItemCount - 1) || (rect.bottom < (bottomOfBottomChild - fadingEdge))) {
                        listUnfadedBottom -= fadingEdge;
                    }
                }
                let scrollYDelta = 0;
                if (rect.bottom > listUnfadedBottom && rect.top > listUnfadedTop) {
                    if (rect.height() > height) {
                        scrollYDelta += (rect.top - listUnfadedTop);
                    }
                    else {
                        scrollYDelta += (rect.bottom - listUnfadedBottom);
                    }
                    let distanceToBottom = bottomOfBottomChild - listUnfadedBottom;
                    scrollYDelta = Math.min(scrollYDelta, distanceToBottom);
                }
                else if (rect.top < listUnfadedTop && rect.bottom < listUnfadedBottom) {
                    if (rect.height() > height) {
                        scrollYDelta -= (listUnfadedBottom - rect.bottom);
                    }
                    else {
                        scrollYDelta -= (listUnfadedTop - rect.top);
                    }
                    let top = this.getChildAt(0).getTop();
                    let deltaToTop = top - listUnfadedTop;
                    scrollYDelta = Math.max(scrollYDelta, deltaToTop);
                }
                const scroll = scrollYDelta != 0;
                if (scroll) {
                    this.scrollListItemsBy(-scrollYDelta);
                    this.positionSelector(ListView.INVALID_POSITION, child);
                    this.mSelectedTop = child.getTop();
                    this.invalidate();
                }
                return scroll;
            }
            fillGap(down) {
                const count = this.getChildCount();
                if (down) {
                    let paddingTop = 0;
                    if ((this.mGroupFlags & ListView.CLIP_TO_PADDING_MASK) == ListView.CLIP_TO_PADDING_MASK) {
                        paddingTop = this.getListPaddingTop();
                    }
                    const startOffset = count > 0 ? this.getChildAt(count - 1).getBottom() + this.mDividerHeight : paddingTop;
                    this.fillDown(this.mFirstPosition + count, startOffset);
                    this.correctTooHigh(this.getChildCount());
                }
                else {
                    let paddingBottom = 0;
                    if ((this.mGroupFlags & ListView.CLIP_TO_PADDING_MASK) == ListView.CLIP_TO_PADDING_MASK) {
                        paddingBottom = this.getListPaddingBottom();
                    }
                    const startOffset = count > 0 ? this.getChildAt(0).getTop() - this.mDividerHeight : this.getHeight() - paddingBottom;
                    this.fillUp(this.mFirstPosition - 1, startOffset);
                    this.correctTooLow(this.getChildCount());
                }
            }
            fillDown(pos, nextTop) {
                let selectedView = null;
                let end = (this.mBottom - this.mTop);
                if ((this.mGroupFlags & ListView.CLIP_TO_PADDING_MASK) == ListView.CLIP_TO_PADDING_MASK) {
                    end -= this.mListPadding.bottom;
                }
                while (nextTop < end && pos < this.mItemCount) {
                    let selected = pos == this.mSelectedPosition;
                    let child = this.makeAndAddView(pos, nextTop, true, this.mListPadding.left, selected);
                    nextTop = child.getBottom() + this.mDividerHeight;
                    if (selected) {
                        selectedView = child;
                    }
                    pos++;
                }
                this.setVisibleRangeHint(this.mFirstPosition, this.mFirstPosition + this.getChildCount() - 1);
                return selectedView;
            }
            fillUp(pos, nextBottom) {
                let selectedView = null;
                let end = 0;
                if ((this.mGroupFlags & ListView.CLIP_TO_PADDING_MASK) == ListView.CLIP_TO_PADDING_MASK) {
                    end = this.mListPadding.top;
                }
                while (nextBottom > end && pos >= 0) {
                    let selected = pos == this.mSelectedPosition;
                    let child = this.makeAndAddView(pos, nextBottom, false, this.mListPadding.left, selected);
                    nextBottom = child.getTop() - this.mDividerHeight;
                    if (selected) {
                        selectedView = child;
                    }
                    pos--;
                }
                this.mFirstPosition = pos + 1;
                this.setVisibleRangeHint(this.mFirstPosition, this.mFirstPosition + this.getChildCount() - 1);
                return selectedView;
            }
            fillFromTop(nextTop) {
                this.mFirstPosition = Math.min(this.mFirstPosition, this.mSelectedPosition);
                this.mFirstPosition = Math.min(this.mFirstPosition, this.mItemCount - 1);
                if (this.mFirstPosition < 0) {
                    this.mFirstPosition = 0;
                }
                return this.fillDown(this.mFirstPosition, nextTop);
            }
            fillFromMiddle(childrenTop, childrenBottom) {
                let height = childrenBottom - childrenTop;
                let position = this.reconcileSelectedPosition();
                let sel = this.makeAndAddView(position, childrenTop, true, this.mListPadding.left, true);
                this.mFirstPosition = position;
                let selHeight = sel.getMeasuredHeight();
                if (selHeight <= height) {
                    sel.offsetTopAndBottom((height - selHeight) / 2);
                }
                this.fillAboveAndBelow(sel, position);
                if (!this.mStackFromBottom) {
                    this.correctTooHigh(this.getChildCount());
                }
                else {
                    this.correctTooLow(this.getChildCount());
                }
                return sel;
            }
            fillAboveAndBelow(sel, position) {
                const dividerHeight = this.mDividerHeight;
                if (!this.mStackFromBottom) {
                    this.fillUp(position - 1, sel.getTop() - dividerHeight);
                    this.adjustViewsUpOrDown();
                    this.fillDown(position + 1, sel.getBottom() + dividerHeight);
                }
                else {
                    this.fillDown(position + 1, sel.getBottom() + dividerHeight);
                    this.adjustViewsUpOrDown();
                    this.fillUp(position - 1, sel.getTop() - dividerHeight);
                }
            }
            fillFromSelection(selectedTop, childrenTop, childrenBottom) {
                let fadingEdgeLength = this.getVerticalFadingEdgeLength();
                const selectedPosition = this.mSelectedPosition;
                let sel;
                const topSelectionPixel = this.getTopSelectionPixel(childrenTop, fadingEdgeLength, selectedPosition);
                const bottomSelectionPixel = this.getBottomSelectionPixel(childrenBottom, fadingEdgeLength, selectedPosition);
                sel = this.makeAndAddView(selectedPosition, selectedTop, true, this.mListPadding.left, true);
                if (sel.getBottom() > bottomSelectionPixel) {
                    const spaceAbove = sel.getTop() - topSelectionPixel;
                    const spaceBelow = sel.getBottom() - bottomSelectionPixel;
                    const offset = Math.min(spaceAbove, spaceBelow);
                    sel.offsetTopAndBottom(-offset);
                }
                else if (sel.getTop() < topSelectionPixel) {
                    const spaceAbove = topSelectionPixel - sel.getTop();
                    const spaceBelow = bottomSelectionPixel - sel.getBottom();
                    const offset = Math.min(spaceAbove, spaceBelow);
                    sel.offsetTopAndBottom(offset);
                }
                this.fillAboveAndBelow(sel, selectedPosition);
                if (!this.mStackFromBottom) {
                    this.correctTooHigh(this.getChildCount());
                }
                else {
                    this.correctTooLow(this.getChildCount());
                }
                return sel;
            }
            getBottomSelectionPixel(childrenBottom, fadingEdgeLength, selectedPosition) {
                let bottomSelectionPixel = childrenBottom;
                if (selectedPosition != this.mItemCount - 1) {
                    bottomSelectionPixel -= fadingEdgeLength;
                }
                return bottomSelectionPixel;
            }
            getTopSelectionPixel(childrenTop, fadingEdgeLength, selectedPosition) {
                let topSelectionPixel = childrenTop;
                if (selectedPosition > 0) {
                    topSelectionPixel += fadingEdgeLength;
                }
                return topSelectionPixel;
            }
            smoothScrollToPosition(position) {
                super.smoothScrollToPosition(position);
            }
            smoothScrollByOffset(offset) {
                super.smoothScrollByOffset(offset);
            }
            moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom) {
                let fadingEdgeLength = this.getVerticalFadingEdgeLength();
                const selectedPosition = this.mSelectedPosition;
                let sel;
                const topSelectionPixel = this.getTopSelectionPixel(childrenTop, fadingEdgeLength, selectedPosition);
                const bottomSelectionPixel = this.getBottomSelectionPixel(childrenTop, fadingEdgeLength, selectedPosition);
                if (delta > 0) {
                    oldSel = this.makeAndAddView(selectedPosition - 1, oldSel.getTop(), true, this.mListPadding.left, false);
                    const dividerHeight = this.mDividerHeight;
                    sel = this.makeAndAddView(selectedPosition, oldSel.getBottom() + dividerHeight, true, this.mListPadding.left, true);
                    if (sel.getBottom() > bottomSelectionPixel) {
                        let spaceAbove = sel.getTop() - topSelectionPixel;
                        let spaceBelow = sel.getBottom() - bottomSelectionPixel;
                        let halfVerticalSpace = (childrenBottom - childrenTop) / 2;
                        let offset = Math.min(spaceAbove, spaceBelow);
                        offset = Math.min(offset, halfVerticalSpace);
                        oldSel.offsetTopAndBottom(-offset);
                        sel.offsetTopAndBottom(-offset);
                    }
                    if (!this.mStackFromBottom) {
                        this.fillUp(this.mSelectedPosition - 2, sel.getTop() - dividerHeight);
                        this.adjustViewsUpOrDown();
                        this.fillDown(this.mSelectedPosition + 1, sel.getBottom() + dividerHeight);
                    }
                    else {
                        this.fillDown(this.mSelectedPosition + 1, sel.getBottom() + dividerHeight);
                        this.adjustViewsUpOrDown();
                        this.fillUp(this.mSelectedPosition - 2, sel.getTop() - dividerHeight);
                    }
                }
                else if (delta < 0) {
                    if (newSel != null) {
                        sel = this.makeAndAddView(selectedPosition, newSel.getTop(), true, this.mListPadding.left, true);
                    }
                    else {
                        sel = this.makeAndAddView(selectedPosition, oldSel.getTop(), false, this.mListPadding.left, true);
                    }
                    if (sel.getTop() < topSelectionPixel) {
                        let spaceAbove = topSelectionPixel - sel.getTop();
                        let spaceBelow = bottomSelectionPixel - sel.getBottom();
                        let halfVerticalSpace = (childrenBottom - childrenTop) / 2;
                        let offset = Math.min(spaceAbove, spaceBelow);
                        offset = Math.min(offset, halfVerticalSpace);
                        sel.offsetTopAndBottom(offset);
                    }
                    this.fillAboveAndBelow(sel, selectedPosition);
                }
                else {
                    let oldTop = oldSel.getTop();
                    sel = this.makeAndAddView(selectedPosition, oldTop, true, this.mListPadding.left, true);
                    if (oldTop < childrenTop) {
                        let newBottom = sel.getBottom();
                        if (newBottom < childrenTop + 20) {
                            sel.offsetTopAndBottom(childrenTop - sel.getTop());
                        }
                    }
                    this.fillAboveAndBelow(sel, selectedPosition);
                }
                return sel;
            }
            onSizeChanged(w, h, oldw, oldh) {
                if (this.getChildCount() > 0) {
                    let focusedChild = this.getFocusedChild();
                    if (focusedChild != null) {
                        const childPosition = this.mFirstPosition + this.indexOfChild(focusedChild);
                        const childBottom = focusedChild.getBottom();
                        const offset = Math.max(0, childBottom - (h - this.mPaddingTop));
                        const top = focusedChild.getTop() - offset;
                        if (this.mFocusSelector == null) {
                            this.mFocusSelector = new ListView.FocusSelector(this);
                        }
                        this.post(this.mFocusSelector.setup(childPosition, top));
                    }
                }
                super.onSizeChanged(w, h, oldw, oldh);
            }
            onMeasure(widthMeasureSpec, heightMeasureSpec) {
                super.onMeasure(widthMeasureSpec, heightMeasureSpec);
                let widthMode = ListView.MeasureSpec.getMode(widthMeasureSpec);
                let heightMode = ListView.MeasureSpec.getMode(heightMeasureSpec);
                let widthSize = ListView.MeasureSpec.getSize(widthMeasureSpec);
                let heightSize = ListView.MeasureSpec.getSize(heightMeasureSpec);
                let childWidth = 0;
                let childHeight = 0;
                let childState = 0;
                this.mItemCount = this.mAdapter == null ? 0 : this.mAdapter.getCount();
                if (this.mItemCount > 0 && (widthMode == ListView.MeasureSpec.UNSPECIFIED || heightMode == ListView.MeasureSpec.UNSPECIFIED)) {
                    const child = this.obtainView(0, this.mIsScrap);
                    this.measureScrapChild(child, 0, widthMeasureSpec);
                    childWidth = child.getMeasuredWidth();
                    childHeight = child.getMeasuredHeight();
                    childState = ListView.combineMeasuredStates(childState, child.getMeasuredState());
                    if (this.recycleOnMeasure() && this.mRecycler.shouldRecycleViewType(child.getLayoutParams().viewType)) {
                        this.mRecycler.addScrapView(child, -1);
                    }
                }
                if (widthMode == ListView.MeasureSpec.UNSPECIFIED) {
                    widthSize = this.mListPadding.left + this.mListPadding.right + childWidth + this.getVerticalScrollbarWidth();
                }
                else {
                    widthSize |= (childState & ListView.MEASURED_STATE_MASK);
                }
                if (heightMode == ListView.MeasureSpec.UNSPECIFIED) {
                    heightSize = this.mListPadding.top + this.mListPadding.bottom + childHeight + this.getVerticalFadingEdgeLength() * 2;
                }
                if (heightMode == ListView.MeasureSpec.AT_MOST) {
                    heightSize = this.measureHeightOfChildren(widthMeasureSpec, 0, ListView.NO_POSITION, heightSize, -1);
                }
                this.setMeasuredDimension(widthSize, heightSize);
                this.mWidthMeasureSpec = widthMeasureSpec;
            }
            measureScrapChild(child, position, widthMeasureSpec) {
                let p = child.getLayoutParams();
                if (p == null) {
                    p = this.generateDefaultLayoutParams();
                    child.setLayoutParams(p);
                }
                p.viewType = this.mAdapter.getItemViewType(position);
                p.forceAdd = true;
                let childWidthSpec = ViewGroup.getChildMeasureSpec(widthMeasureSpec, this.mListPadding.left + this.mListPadding.right, p.width);
                let lpHeight = p.height;
                let childHeightSpec;
                if (lpHeight > 0) {
                    childHeightSpec = ListView.MeasureSpec.makeMeasureSpec(lpHeight, ListView.MeasureSpec.EXACTLY);
                }
                else {
                    childHeightSpec = ListView.MeasureSpec.makeMeasureSpec(0, ListView.MeasureSpec.UNSPECIFIED);
                }
                child.measure(childWidthSpec, childHeightSpec);
            }
            recycleOnMeasure() {
                return true;
            }
            measureHeightOfChildren(widthMeasureSpec, startPosition, endPosition, maxHeight, disallowPartialChildPosition) {
                const adapter = this.mAdapter;
                if (adapter == null) {
                    return this.mListPadding.top + this.mListPadding.bottom;
                }
                let returnedHeight = this.mListPadding.top + this.mListPadding.bottom;
                const dividerHeight = ((this.mDividerHeight > 0) && this.mDivider != null) ? this.mDividerHeight : 0;
                let prevHeightWithoutPartialChild = 0;
                let i;
                let child;
                endPosition = (endPosition == ListView.NO_POSITION) ? adapter.getCount() - 1 : endPosition;
                const recycleBin = this.mRecycler;
                const recyle = this.recycleOnMeasure();
                const isScrap = this.mIsScrap;
                for (i = startPosition; i <= endPosition; ++i) {
                    child = this.obtainView(i, isScrap);
                    this.measureScrapChild(child, i, widthMeasureSpec);
                    if (i > 0) {
                        returnedHeight += dividerHeight;
                    }
                    if (recyle && recycleBin.shouldRecycleViewType(child.getLayoutParams().viewType)) {
                        recycleBin.addScrapView(child, -1);
                    }
                    returnedHeight += child.getMeasuredHeight();
                    if (returnedHeight >= maxHeight) {
                        return (disallowPartialChildPosition >= 0) &&
                            (i > disallowPartialChildPosition) &&
                            (prevHeightWithoutPartialChild > 0) &&
                            (returnedHeight != maxHeight) ? prevHeightWithoutPartialChild : maxHeight;
                    }
                    if ((disallowPartialChildPosition >= 0) && (i >= disallowPartialChildPosition)) {
                        prevHeightWithoutPartialChild = returnedHeight;
                    }
                }
                return returnedHeight;
            }
            findMotionRow(y) {
                let childCount = this.getChildCount();
                if (childCount > 0) {
                    if (!this.mStackFromBottom) {
                        for (let i = 0; i < childCount; i++) {
                            let v = this.getChildAt(i);
                            if (y <= v.getBottom()) {
                                return this.mFirstPosition + i;
                            }
                        }
                    }
                    else {
                        for (let i = childCount - 1; i >= 0; i--) {
                            let v = this.getChildAt(i);
                            if (y >= v.getTop()) {
                                return this.mFirstPosition + i;
                            }
                        }
                    }
                }
                return ListView.INVALID_POSITION;
            }
            fillSpecific(position, top) {
                let tempIsSelected = position == this.mSelectedPosition;
                let temp = this.makeAndAddView(position, top, true, this.mListPadding.left, tempIsSelected);
                this.mFirstPosition = position;
                let above;
                let below;
                const dividerHeight = this.mDividerHeight;
                if (!this.mStackFromBottom) {
                    above = this.fillUp(position - 1, temp.getTop() - dividerHeight);
                    this.adjustViewsUpOrDown();
                    below = this.fillDown(position + 1, temp.getBottom() + dividerHeight);
                    let childCount = this.getChildCount();
                    if (childCount > 0) {
                        this.correctTooHigh(childCount);
                    }
                }
                else {
                    below = this.fillDown(position + 1, temp.getBottom() + dividerHeight);
                    this.adjustViewsUpOrDown();
                    above = this.fillUp(position - 1, temp.getTop() - dividerHeight);
                    let childCount = this.getChildCount();
                    if (childCount > 0) {
                        this.correctTooLow(childCount);
                    }
                }
                if (tempIsSelected) {
                    return temp;
                }
                else if (above != null) {
                    return above;
                }
                else {
                    return below;
                }
            }
            correctTooHigh(childCount) {
                let lastPosition = this.mFirstPosition + childCount - 1;
                if (lastPosition == this.mItemCount - 1 && childCount > 0) {
                    const lastChild = this.getChildAt(childCount - 1);
                    const lastBottom = lastChild.getBottom();
                    const end = (this.mBottom - this.mTop) - this.mListPadding.bottom;
                    let bottomOffset = end - lastBottom;
                    let firstChild = this.getChildAt(0);
                    const firstTop = firstChild.getTop();
                    if (bottomOffset > 0 && (this.mFirstPosition > 0 || firstTop < this.mListPadding.top)) {
                        if (this.mFirstPosition == 0) {
                            bottomOffset = Math.min(bottomOffset, this.mListPadding.top - firstTop);
                        }
                        this.offsetChildrenTopAndBottom(bottomOffset);
                        if (this.mFirstPosition > 0) {
                            this.fillUp(this.mFirstPosition - 1, firstChild.getTop() - this.mDividerHeight);
                            this.adjustViewsUpOrDown();
                        }
                    }
                }
            }
            correctTooLow(childCount) {
                if (this.mFirstPosition == 0 && childCount > 0) {
                    const firstChild = this.getChildAt(0);
                    const firstTop = firstChild.getTop();
                    const start = this.mListPadding.top;
                    const end = (this.mBottom - this.mTop) - this.mListPadding.bottom;
                    let topOffset = firstTop - start;
                    let lastChild = this.getChildAt(childCount - 1);
                    const lastBottom = lastChild.getBottom();
                    let lastPosition = this.mFirstPosition + childCount - 1;
                    if (topOffset > 0) {
                        if (lastPosition < this.mItemCount - 1 || lastBottom > end) {
                            if (lastPosition == this.mItemCount - 1) {
                                topOffset = Math.min(topOffset, lastBottom - end);
                            }
                            this.offsetChildrenTopAndBottom(-topOffset);
                            if (lastPosition < this.mItemCount - 1) {
                                this.fillDown(lastPosition + 1, lastChild.getBottom() + this.mDividerHeight);
                                this.adjustViewsUpOrDown();
                            }
                        }
                        else if (lastPosition == this.mItemCount - 1) {
                            this.adjustViewsUpOrDown();
                        }
                    }
                }
            }
            layoutChildren() {
                const blockLayoutRequests = this.mBlockLayoutRequests;
                if (blockLayoutRequests) {
                    return;
                }
                this.mBlockLayoutRequests = true;
                try {
                    super.layoutChildren();
                    this.invalidate();
                    if (this.mAdapter == null) {
                        this.resetList();
                        this.invokeOnItemScrollListener();
                        return;
                    }
                    const childrenTop = this.mListPadding.top;
                    const childrenBottom = this.mBottom - this.mTop - this.mListPadding.bottom;
                    const childCount = this.getChildCount();
                    let index = 0;
                    let delta = 0;
                    let sel;
                    let oldSel = null;
                    let oldFirst = null;
                    let newSel = null;
                    switch (this.mLayoutMode) {
                        case ListView.LAYOUT_SET_SELECTION:
                            index = this.mNextSelectedPosition - this.mFirstPosition;
                            if (index >= 0 && index < childCount) {
                                newSel = this.getChildAt(index);
                            }
                            break;
                        case ListView.LAYOUT_FORCE_TOP:
                        case ListView.LAYOUT_FORCE_BOTTOM:
                        case ListView.LAYOUT_SPECIFIC:
                        case ListView.LAYOUT_SYNC:
                            break;
                        case ListView.LAYOUT_MOVE_SELECTION:
                        default:
                            index = this.mSelectedPosition - this.mFirstPosition;
                            if (index >= 0 && index < childCount) {
                                oldSel = this.getChildAt(index);
                            }
                            oldFirst = this.getChildAt(0);
                            if (this.mNextSelectedPosition >= 0) {
                                delta = this.mNextSelectedPosition - this.mSelectedPosition;
                            }
                            newSel = this.getChildAt(index + delta);
                    }
                    let dataChanged = this.mDataChanged;
                    if (dataChanged) {
                        this.handleDataChanged();
                    }
                    if (this.mItemCount == 0) {
                        this.resetList();
                        this.invokeOnItemScrollListener();
                        return;
                    }
                    else if (this.mItemCount != this.mAdapter.getCount()) {
                        throw Error(`IllegalStateException("The content of the adapter has changed but
                ListView did not receive a notification. Make sure the content of
                your adapter is not modified from a background thread, but only from
                the UI thread. Make sure your adapter calls notifyDataSetChanged()
                when its content changes. [in ListView(${this.getId()},${this.constructor.name})
                with Adapter(${this.mAdapter.constructor.name})]")`);
                    }
                    this.setSelectedPositionInt(this.mNextSelectedPosition);
                    const accessFocusedChild = null;
                    const focusedChild = this.getFocusedChild();
                    if (focusedChild != null) {
                        focusedChild.setHasTransientState(true);
                    }
                    const firstPosition = this.mFirstPosition;
                    const recycleBin = this.mRecycler;
                    if (dataChanged) {
                        for (let i = 0; i < childCount; i++) {
                            recycleBin.addScrapView(this.getChildAt(i), firstPosition + i);
                        }
                    }
                    else {
                        recycleBin.fillActiveViews(childCount, firstPosition);
                    }
                    this.detachAllViewsFromParent();
                    recycleBin.removeSkippedScrap();
                    switch (this.mLayoutMode) {
                        case ListView.LAYOUT_SET_SELECTION:
                            if (newSel != null) {
                                sel = this.fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);
                            }
                            else {
                                sel = this.fillFromMiddle(childrenTop, childrenBottom);
                            }
                            break;
                        case ListView.LAYOUT_SYNC:
                            sel = this.fillSpecific(this.mSyncPosition, this.mSpecificTop);
                            break;
                        case ListView.LAYOUT_FORCE_BOTTOM:
                            sel = this.fillUp(this.mItemCount - 1, childrenBottom);
                            this.adjustViewsUpOrDown();
                            break;
                        case ListView.LAYOUT_FORCE_TOP:
                            this.mFirstPosition = 0;
                            sel = this.fillFromTop(childrenTop);
                            this.adjustViewsUpOrDown();
                            break;
                        case ListView.LAYOUT_SPECIFIC:
                            sel = this.fillSpecific(this.reconcileSelectedPosition(), this.mSpecificTop);
                            break;
                        case ListView.LAYOUT_MOVE_SELECTION:
                            sel = this.moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom);
                            break;
                        default:
                            if (childCount == 0) {
                                if (!this.mStackFromBottom) {
                                    const position = this.lookForSelectablePosition(0, true);
                                    this.setSelectedPositionInt(position);
                                    sel = this.fillFromTop(childrenTop);
                                }
                                else {
                                    const position = this.lookForSelectablePosition(this.mItemCount - 1, false);
                                    this.setSelectedPositionInt(position);
                                    sel = this.fillUp(this.mItemCount - 1, childrenBottom);
                                }
                            }
                            else {
                                if (this.mSelectedPosition >= 0 && this.mSelectedPosition < this.mItemCount) {
                                    sel = this.fillSpecific(this.mSelectedPosition, oldSel == null ? childrenTop : oldSel.getTop());
                                }
                                else if (this.mFirstPosition < this.mItemCount) {
                                    sel = this.fillSpecific(this.mFirstPosition, oldFirst == null ? childrenTop : oldFirst.getTop());
                                }
                                else {
                                    sel = this.fillSpecific(0, childrenTop);
                                }
                            }
                            break;
                    }
                    recycleBin.scrapActiveViews();
                    if (sel != null) {
                        const shouldPlaceFocus = this.mItemsCanFocus && this.hasFocus();
                        const maintainedFocus = focusedChild != null && focusedChild.hasFocus();
                        if (shouldPlaceFocus && !maintainedFocus && !sel.hasFocus()) {
                            if (sel.requestFocus()) {
                                sel.setSelected(false);
                                this.mSelectorRect.setEmpty();
                            }
                            else {
                                const focused = this.getFocusedChild();
                                if (focused != null) {
                                    focused.clearFocus();
                                }
                                this.positionSelector(ListView.INVALID_POSITION, sel);
                            }
                        }
                        else {
                            this.positionSelector(ListView.INVALID_POSITION, sel);
                        }
                        this.mSelectedTop = sel.getTop();
                    }
                    else {
                        if (this.mTouchMode == ListView.TOUCH_MODE_TAP || this.mTouchMode == ListView.TOUCH_MODE_DONE_WAITING) {
                            const child = this.getChildAt(this.mMotionPosition - this.mFirstPosition);
                            if (child != null) {
                                this.positionSelector(this.mMotionPosition, child);
                            }
                        }
                        else {
                            this.mSelectedTop = 0;
                            this.mSelectorRect.setEmpty();
                        }
                    }
                    if (accessFocusedChild != null) {
                        accessFocusedChild.setHasTransientState(false);
                    }
                    if (focusedChild != null) {
                        focusedChild.setHasTransientState(false);
                    }
                    this.mLayoutMode = ListView.LAYOUT_NORMAL;
                    this.mDataChanged = false;
                    if (this.mPositionScrollAfterLayout != null) {
                        this.post(this.mPositionScrollAfterLayout);
                        this.mPositionScrollAfterLayout = null;
                    }
                    this.mNeedSync = false;
                    this.setNextSelectedPositionInt(this.mSelectedPosition);
                    this.updateScrollIndicators();
                    if (this.mItemCount > 0) {
                        this.checkSelectionChanged();
                    }
                    this.invokeOnItemScrollListener();
                }
                finally {
                    if (!blockLayoutRequests) {
                        this.mBlockLayoutRequests = false;
                    }
                }
            }
            makeAndAddView(position, y, flow, childrenLeft, selected) {
                let child;
                if (!this.mDataChanged) {
                    child = this.mRecycler.getActiveView(position);
                    if (child != null) {
                        this.setupChild(child, position, y, flow, childrenLeft, selected, true);
                        return child;
                    }
                }
                child = this.obtainView(position, this.mIsScrap);
                this.setupChild(child, position, y, flow, childrenLeft, selected, this.mIsScrap[0]);
                return child;
            }
            setupChild(child, position, y, flowDown, childrenLeft, selected, recycled) {
                Trace.traceBegin(Trace.TRACE_TAG_VIEW, "setupListItem");
                const isSelected = selected && this.shouldShowSelector();
                const updateChildSelected = isSelected != child.isSelected();
                const mode = this.mTouchMode;
                const isPressed = mode > ListView.TOUCH_MODE_DOWN && mode < ListView.TOUCH_MODE_SCROLL && this.mMotionPosition == position;
                const updateChildPressed = isPressed != child.isPressed();
                const needToMeasure = !recycled || updateChildSelected || child.isLayoutRequested();
                let p = child.getLayoutParams();
                if (p == null) {
                    p = this.generateDefaultLayoutParams();
                }
                p.viewType = this.mAdapter.getItemViewType(position);
                if ((recycled && !p.forceAdd) || (p.recycledHeaderFooter && p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER)) {
                    this.attachViewToParent(child, flowDown ? -1 : 0, p);
                }
                else {
                    p.forceAdd = false;
                    if (p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER) {
                        p.recycledHeaderFooter = true;
                    }
                    this.addViewInLayout(child, flowDown ? -1 : 0, p, true);
                }
                if (updateChildSelected) {
                    child.setSelected(isSelected);
                }
                if (updateChildPressed) {
                    child.setPressed(isPressed);
                }
                if (this.mChoiceMode != ListView.CHOICE_MODE_NONE && this.mCheckStates != null) {
                    if (child['setChecked']) {
                        child.setChecked(this.mCheckStates.get(position));
                    }
                    else {
                        child.setActivated(this.mCheckStates.get(position));
                    }
                }
                if (needToMeasure) {
                    let childWidthSpec = ViewGroup.getChildMeasureSpec(this.mWidthMeasureSpec, this.mListPadding.left + this.mListPadding.right, p.width);
                    let lpHeight = p.height;
                    let childHeightSpec;
                    if (lpHeight > 0) {
                        childHeightSpec = ListView.MeasureSpec.makeMeasureSpec(lpHeight, ListView.MeasureSpec.EXACTLY);
                    }
                    else {
                        childHeightSpec = ListView.MeasureSpec.makeMeasureSpec(0, ListView.MeasureSpec.UNSPECIFIED);
                    }
                    child.measure(childWidthSpec, childHeightSpec);
                }
                else {
                    this.cleanupLayoutState(child);
                }
                const w = child.getMeasuredWidth();
                const h = child.getMeasuredHeight();
                const childTop = flowDown ? y : y - h;
                if (needToMeasure) {
                    const childRight = childrenLeft + w;
                    const childBottom = childTop + h;
                    child.layout(childrenLeft, childTop, childRight, childBottom);
                }
                else {
                    child.offsetLeftAndRight(childrenLeft - child.getLeft());
                    child.offsetTopAndBottom(childTop - child.getTop());
                }
                if (this.mCachingStarted && !child.isDrawingCacheEnabled()) {
                    child.setDrawingCacheEnabled(true);
                }
                if (recycled && (child.getLayoutParams().scrappedFromPosition) != position) {
                    child.jumpDrawablesToCurrentState();
                }
                Trace.traceEnd(Trace.TRACE_TAG_VIEW);
            }
            canAnimate() {
                return super.canAnimate() && this.mItemCount > 0;
            }
            setSelection(position) {
                this.setSelectionFromTop(position, 0);
            }
            setSelectionFromTop(position, y) {
                if (this.mAdapter == null) {
                    return;
                }
                if (!this.isInTouchMode()) {
                    position = this.lookForSelectablePosition(position, true);
                    if (position >= 0) {
                        this.setNextSelectedPositionInt(position);
                    }
                }
                else {
                    this.mResurrectToPosition = position;
                }
                if (position >= 0) {
                    this.mLayoutMode = ListView.LAYOUT_SPECIFIC;
                    this.mSpecificTop = this.mListPadding.top + y;
                    if (this.mNeedSync) {
                        this.mSyncPosition = position;
                        this.mSyncRowId = this.mAdapter.getItemId(position);
                    }
                    if (this.mPositionScroller != null) {
                        this.mPositionScroller.stop();
                    }
                    this.requestLayout();
                }
            }
            setSelectionInt(position) {
                this.setNextSelectedPositionInt(position);
                let awakeScrollbars = false;
                const selectedPosition = this.mSelectedPosition;
                if (selectedPosition >= 0) {
                    if (position == selectedPosition - 1) {
                        awakeScrollbars = true;
                    }
                    else if (position == selectedPosition + 1) {
                        awakeScrollbars = true;
                    }
                }
                if (this.mPositionScroller != null) {
                    this.mPositionScroller.stop();
                }
                this.layoutChildren();
                if (awakeScrollbars) {
                    this.awakenScrollBars();
                }
            }
            lookForSelectablePosition(position, lookDown) {
                const adapter = this.mAdapter;
                if (adapter == null || this.isInTouchMode()) {
                    return ListView.INVALID_POSITION;
                }
                const count = adapter.getCount();
                if (!this.mAreAllItemsSelectable) {
                    if (lookDown) {
                        position = Math.max(0, position);
                        while (position < count && !adapter.isEnabled(position)) {
                            position++;
                        }
                    }
                    else {
                        position = Math.min(position, count - 1);
                        while (position >= 0 && !adapter.isEnabled(position)) {
                            position--;
                        }
                    }
                }
                if (position < 0 || position >= count) {
                    return ListView.INVALID_POSITION;
                }
                return position;
            }
            lookForSelectablePositionAfter(current, position, lookDown) {
                const adapter = this.mAdapter;
                if (adapter == null || this.isInTouchMode()) {
                    return ListView.INVALID_POSITION;
                }
                const after = this.lookForSelectablePosition(position, lookDown);
                if (after != ListView.INVALID_POSITION) {
                    return after;
                }
                const count = adapter.getCount();
                current = MathUtils.constrain(current, -1, count - 1);
                if (lookDown) {
                    position = Math.min(position - 1, count - 1);
                    while ((position > current) && !adapter.isEnabled(position)) {
                        position--;
                    }
                    if (position <= current) {
                        return ListView.INVALID_POSITION;
                    }
                }
                else {
                    position = Math.max(0, position + 1);
                    while ((position < current) && !adapter.isEnabled(position)) {
                        position++;
                    }
                    if (position >= current) {
                        return ListView.INVALID_POSITION;
                    }
                }
                return position;
            }
            setSelectionAfterHeaderView() {
                const count = this.mHeaderViewInfos.size();
                if (count > 0) {
                    this.mNextSelectedPosition = 0;
                    return;
                }
                if (this.mAdapter != null) {
                    this.setSelection(count);
                }
                else {
                    this.mNextSelectedPosition = count;
                    this.mLayoutMode = ListView.LAYOUT_SET_SELECTION;
                }
            }
            dispatchKeyEvent(event) {
                let handled = super.dispatchKeyEvent(event);
                if (!handled) {
                    let focused = this.getFocusedChild();
                    if (focused != null && event.getAction() == KeyEvent.ACTION_DOWN) {
                        handled = this.onKeyDown(event.getKeyCode(), event);
                    }
                }
                return handled;
            }
            onKeyDown(keyCode, event) {
                return this.commonKey(keyCode, 1, event);
            }
            onKeyMultiple(keyCode, repeatCount, event) {
                return this.commonKey(keyCode, repeatCount, event);
            }
            onKeyUp(keyCode, event) {
                return this.commonKey(keyCode, 1, event);
            }
            commonKey(keyCode, count, event) {
                if (this.mAdapter == null || !this.isAttachedToWindow()) {
                    return false;
                }
                if (this.mDataChanged) {
                    this.layoutChildren();
                }
                let handled = false;
                let action = event.getAction();
                if (action != KeyEvent.ACTION_UP) {
                    switch (keyCode) {
                        case KeyEvent.KEYCODE_DPAD_UP:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded();
                                if (!handled) {
                                    while (count-- > 0) {
                                        if (this.arrowScroll(ListView.FOCUS_UP)) {
                                            handled = true;
                                        }
                                        else {
                                            break;
                                        }
                                    }
                                }
                            }
                            else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
                                handled = this.resurrectSelectionIfNeeded() || this.fullScroll(ListView.FOCUS_UP);
                            }
                            break;
                        case KeyEvent.KEYCODE_DPAD_DOWN:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded();
                                if (!handled) {
                                    while (count-- > 0) {
                                        if (this.arrowScroll(ListView.FOCUS_DOWN)) {
                                            handled = true;
                                        }
                                        else {
                                            break;
                                        }
                                    }
                                }
                            }
                            else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
                                handled = this.resurrectSelectionIfNeeded() || this.fullScroll(ListView.FOCUS_DOWN);
                            }
                            break;
                        case KeyEvent.KEYCODE_DPAD_LEFT:
                            if (event.hasNoModifiers()) {
                                handled = this.handleHorizontalFocusWithinListItem(View.FOCUS_LEFT);
                            }
                            break;
                        case KeyEvent.KEYCODE_DPAD_RIGHT:
                            if (event.hasNoModifiers()) {
                                handled = this.handleHorizontalFocusWithinListItem(View.FOCUS_RIGHT);
                            }
                            break;
                        case KeyEvent.KEYCODE_DPAD_CENTER:
                        case KeyEvent.KEYCODE_ENTER:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded();
                                if (!handled && event.getRepeatCount() == 0 && this.getChildCount() > 0) {
                                    this.keyPressed();
                                    handled = true;
                                }
                            }
                            break;
                        case KeyEvent.KEYCODE_SPACE:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded() || this.pageScroll(ListView.FOCUS_DOWN);
                            }
                            else if (event.hasModifiers(KeyEvent.META_SHIFT_ON)) {
                                handled = this.resurrectSelectionIfNeeded() || this.pageScroll(ListView.FOCUS_UP);
                            }
                            handled = true;
                            break;
                        case KeyEvent.KEYCODE_PAGE_UP:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded() || this.pageScroll(ListView.FOCUS_UP);
                            }
                            else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
                                handled = this.resurrectSelectionIfNeeded() || this.fullScroll(ListView.FOCUS_UP);
                            }
                            break;
                        case KeyEvent.KEYCODE_PAGE_DOWN:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded() || this.pageScroll(ListView.FOCUS_DOWN);
                            }
                            else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
                                handled = this.resurrectSelectionIfNeeded() || this.fullScroll(ListView.FOCUS_DOWN);
                            }
                            break;
                        case KeyEvent.KEYCODE_MOVE_HOME:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded() || this.fullScroll(ListView.FOCUS_UP);
                            }
                            break;
                        case KeyEvent.KEYCODE_MOVE_END:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded() || this.fullScroll(ListView.FOCUS_DOWN);
                            }
                            break;
                        case KeyEvent.KEYCODE_TAB:
                            if (false) {
                                if (event.hasNoModifiers()) {
                                    handled = this.resurrectSelectionIfNeeded() || this.arrowScroll(ListView.FOCUS_DOWN);
                                }
                                else if (event.hasModifiers(KeyEvent.META_SHIFT_ON)) {
                                    handled = this.resurrectSelectionIfNeeded() || this.arrowScroll(ListView.FOCUS_UP);
                                }
                            }
                            break;
                    }
                }
                if (handled) {
                    return true;
                }
                switch (action) {
                    case KeyEvent.ACTION_DOWN:
                        return super.onKeyDown(keyCode, event);
                    case KeyEvent.ACTION_UP:
                        return super.onKeyUp(keyCode, event);
                    default:
                        return false;
                }
            }
            pageScroll(direction) {
                let nextPage;
                let down;
                if (direction == ListView.FOCUS_UP) {
                    nextPage = Math.max(0, this.mSelectedPosition - this.getChildCount() - 1);
                    down = false;
                }
                else if (direction == ListView.FOCUS_DOWN) {
                    nextPage = Math.min(this.mItemCount - 1, this.mSelectedPosition + this.getChildCount() - 1);
                    down = true;
                }
                else {
                    return false;
                }
                if (nextPage >= 0) {
                    const position = this.lookForSelectablePositionAfter(this.mSelectedPosition, nextPage, down);
                    if (position >= 0) {
                        this.mLayoutMode = ListView.LAYOUT_SPECIFIC;
                        this.mSpecificTop = this.mPaddingTop + this.getVerticalFadingEdgeLength();
                        if (down && (position > (this.mItemCount - this.getChildCount()))) {
                            this.mLayoutMode = ListView.LAYOUT_FORCE_BOTTOM;
                        }
                        if (!down && (position < this.getChildCount())) {
                            this.mLayoutMode = ListView.LAYOUT_FORCE_TOP;
                        }
                        this.setSelectionInt(position);
                        this.invokeOnItemScrollListener();
                        if (!this.awakenScrollBars()) {
                            this.invalidate();
                        }
                        return true;
                    }
                }
                return false;
            }
            fullScroll(direction) {
                let moved = false;
                if (direction == ListView.FOCUS_UP) {
                    if (this.mSelectedPosition != 0) {
                        const position = this.lookForSelectablePositionAfter(this.mSelectedPosition, 0, true);
                        if (position >= 0) {
                            this.mLayoutMode = ListView.LAYOUT_FORCE_TOP;
                            this.setSelectionInt(position);
                            this.invokeOnItemScrollListener();
                        }
                        moved = true;
                    }
                }
                else if (direction == ListView.FOCUS_DOWN) {
                    const lastItem = (this.mItemCount - 1);
                    if (this.mSelectedPosition < lastItem) {
                        const position = this.lookForSelectablePositionAfter(this.mSelectedPosition, lastItem, false);
                        if (position >= 0) {
                            this.mLayoutMode = ListView.LAYOUT_FORCE_BOTTOM;
                            this.setSelectionInt(position);
                            this.invokeOnItemScrollListener();
                        }
                        moved = true;
                    }
                }
                if (moved && !this.awakenScrollBars()) {
                    this.awakenScrollBars();
                    this.invalidate();
                }
                return moved;
            }
            handleHorizontalFocusWithinListItem(direction) {
                if (direction != View.FOCUS_LEFT && direction != View.FOCUS_RIGHT) {
                    throw Error(`new IllegalArgumentException("direction must be one of" + " {View.FOCUS_LEFT, View.FOCUS_RIGHT}")`);
                }
                const numChildren = this.getChildCount();
                if (this.mItemsCanFocus && numChildren > 0 && this.mSelectedPosition != ListView.INVALID_POSITION) {
                    const selectedView = this.getSelectedView();
                    if (selectedView != null && selectedView.hasFocus() && selectedView instanceof ViewGroup) {
                        const currentFocus = selectedView.findFocus();
                        const nextFocus = FocusFinder.getInstance().findNextFocus(selectedView, currentFocus, direction);
                        if (nextFocus != null) {
                            currentFocus.getFocusedRect(this.mTempRect);
                            this.offsetDescendantRectToMyCoords(currentFocus, this.mTempRect);
                            this.offsetRectIntoDescendantCoords(nextFocus, this.mTempRect);
                            if (nextFocus.requestFocus(direction, this.mTempRect)) {
                                return true;
                            }
                        }
                        const globalNextFocus = FocusFinder.getInstance().findNextFocus(this.getRootView(), currentFocus, direction);
                        if (globalNextFocus != null) {
                            return this.isViewAncestorOf(globalNextFocus, this);
                        }
                    }
                }
                return false;
            }
            arrowScroll(direction) {
                try {
                    this.mInLayout = true;
                    const handled = this.arrowScrollImpl(direction);
                    if (handled) {
                        this.playSoundEffect(SoundEffectConstants.getContantForFocusDirection(direction));
                    }
                    return handled;
                }
                finally {
                    this.mInLayout = false;
                }
            }
            nextSelectedPositionForDirection(selectedView, selectedPos, direction) {
                let nextSelected;
                if (direction == View.FOCUS_DOWN) {
                    const listBottom = this.getHeight() - this.mListPadding.bottom;
                    if (selectedView != null && selectedView.getBottom() <= listBottom) {
                        nextSelected = selectedPos != ListView.INVALID_POSITION && selectedPos >= this.mFirstPosition ? selectedPos + 1 : this.mFirstPosition;
                    }
                    else {
                        return ListView.INVALID_POSITION;
                    }
                }
                else {
                    const listTop = this.mListPadding.top;
                    if (selectedView != null && selectedView.getTop() >= listTop) {
                        const lastPos = this.mFirstPosition + this.getChildCount() - 1;
                        nextSelected = selectedPos != ListView.INVALID_POSITION && selectedPos <= lastPos ? selectedPos - 1 : lastPos;
                    }
                    else {
                        return ListView.INVALID_POSITION;
                    }
                }
                if (nextSelected < 0 || nextSelected >= this.mAdapter.getCount()) {
                    return ListView.INVALID_POSITION;
                }
                return this.lookForSelectablePosition(nextSelected, direction == View.FOCUS_DOWN);
            }
            arrowScrollImpl(direction) {
                if (this.getChildCount() <= 0) {
                    return false;
                }
                let selectedView = this.getSelectedView();
                let selectedPos = this.mSelectedPosition;
                let nextSelectedPosition = this.nextSelectedPositionForDirection(selectedView, selectedPos, direction);
                let amountToScroll = this.amountToScroll(direction, nextSelectedPosition);
                const focusResult = this.mItemsCanFocus ? this.arrowScrollFocused(direction) : null;
                if (focusResult != null) {
                    nextSelectedPosition = focusResult.getSelectedPosition();
                    amountToScroll = focusResult.getAmountToScroll();
                }
                let needToRedraw = focusResult != null;
                if (nextSelectedPosition != ListView.INVALID_POSITION) {
                    this.handleNewSelectionChange(selectedView, direction, nextSelectedPosition, focusResult != null);
                    this.setSelectedPositionInt(nextSelectedPosition);
                    this.setNextSelectedPositionInt(nextSelectedPosition);
                    selectedView = this.getSelectedView();
                    selectedPos = nextSelectedPosition;
                    if (this.mItemsCanFocus && focusResult == null) {
                        const focused = this.getFocusedChild();
                        if (focused != null) {
                            focused.clearFocus();
                        }
                    }
                    needToRedraw = true;
                    this.checkSelectionChanged();
                }
                if (amountToScroll > 0) {
                    this.scrollListItemsBy((direction == View.FOCUS_UP) ? amountToScroll : -amountToScroll);
                    needToRedraw = true;
                }
                if (this.mItemsCanFocus && (focusResult == null) && selectedView != null && selectedView.hasFocus()) {
                    const focused = selectedView.findFocus();
                    if (!this.isViewAncestorOf(focused, this) || this.distanceToView(focused) > 0) {
                        focused.clearFocus();
                    }
                }
                if (nextSelectedPosition == ListView.INVALID_POSITION && selectedView != null && !this.isViewAncestorOf(selectedView, this)) {
                    selectedView = null;
                    this.hideSelector();
                    this.mResurrectToPosition = ListView.INVALID_POSITION;
                }
                if (needToRedraw) {
                    if (selectedView != null) {
                        this.positionSelector(selectedPos, selectedView);
                        this.mSelectedTop = selectedView.getTop();
                    }
                    if (!this.awakenScrollBars()) {
                        this.invalidate();
                    }
                    this.invokeOnItemScrollListener();
                    return true;
                }
                return false;
            }
            handleNewSelectionChange(selectedView, direction, newSelectedPosition, newFocusAssigned) {
                if (newSelectedPosition == ListView.INVALID_POSITION) {
                    throw Error(`new IllegalArgumentException("newSelectedPosition needs to be valid")`);
                }
                let topView;
                let bottomView;
                let topViewIndex, bottomViewIndex;
                let topSelected = false;
                const selectedIndex = this.mSelectedPosition - this.mFirstPosition;
                const nextSelectedIndex = newSelectedPosition - this.mFirstPosition;
                if (direction == View.FOCUS_UP) {
                    topViewIndex = nextSelectedIndex;
                    bottomViewIndex = selectedIndex;
                    topView = this.getChildAt(topViewIndex);
                    bottomView = selectedView;
                    topSelected = true;
                }
                else {
                    topViewIndex = selectedIndex;
                    bottomViewIndex = nextSelectedIndex;
                    topView = selectedView;
                    bottomView = this.getChildAt(bottomViewIndex);
                }
                const numChildren = this.getChildCount();
                if (topView != null) {
                    topView.setSelected(!newFocusAssigned && topSelected);
                    this.measureAndAdjustDown(topView, topViewIndex, numChildren);
                }
                if (bottomView != null) {
                    bottomView.setSelected(!newFocusAssigned && !topSelected);
                    this.measureAndAdjustDown(bottomView, bottomViewIndex, numChildren);
                }
            }
            measureAndAdjustDown(child, childIndex, numChildren) {
                let oldHeight = child.getHeight();
                this.measureItem(child);
                if (child.getMeasuredHeight() != oldHeight) {
                    this.relayoutMeasuredItem(child);
                    const heightDelta = child.getMeasuredHeight() - oldHeight;
                    for (let i = childIndex + 1; i < numChildren; i++) {
                        this.getChildAt(i).offsetTopAndBottom(heightDelta);
                    }
                }
            }
            measureItem(child) {
                let p = child.getLayoutParams();
                if (p == null) {
                    p = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT);
                }
                let childWidthSpec = ViewGroup.getChildMeasureSpec(this.mWidthMeasureSpec, this.mListPadding.left + this.mListPadding.right, p.width);
                let lpHeight = p.height;
                let childHeightSpec;
                if (lpHeight > 0) {
                    childHeightSpec = ListView.MeasureSpec.makeMeasureSpec(lpHeight, ListView.MeasureSpec.EXACTLY);
                }
                else {
                    childHeightSpec = ListView.MeasureSpec.makeMeasureSpec(0, ListView.MeasureSpec.UNSPECIFIED);
                }
                child.measure(childWidthSpec, childHeightSpec);
            }
            relayoutMeasuredItem(child) {
                const w = child.getMeasuredWidth();
                const h = child.getMeasuredHeight();
                const childLeft = this.mListPadding.left;
                const childRight = childLeft + w;
                const childTop = child.getTop();
                const childBottom = childTop + h;
                child.layout(childLeft, childTop, childRight, childBottom);
            }
            getArrowScrollPreviewLength() {
                return Math.max(ListView.MIN_SCROLL_PREVIEW_PIXELS, this.getVerticalFadingEdgeLength());
            }
            amountToScroll(direction, nextSelectedPosition) {
                const listBottom = this.getHeight() - this.mListPadding.bottom;
                const listTop = this.mListPadding.top;
                let numChildren = this.getChildCount();
                if (direction == View.FOCUS_DOWN) {
                    let indexToMakeVisible = numChildren - 1;
                    if (nextSelectedPosition != ListView.INVALID_POSITION) {
                        indexToMakeVisible = nextSelectedPosition - this.mFirstPosition;
                    }
                    while (numChildren <= indexToMakeVisible) {
                        this.addViewBelow(this.getChildAt(numChildren - 1), this.mFirstPosition + numChildren - 1);
                        numChildren++;
                    }
                    const positionToMakeVisible = this.mFirstPosition + indexToMakeVisible;
                    const viewToMakeVisible = this.getChildAt(indexToMakeVisible);
                    let goalBottom = listBottom;
                    if (positionToMakeVisible < this.mItemCount - 1) {
                        goalBottom -= this.getArrowScrollPreviewLength();
                    }
                    if (viewToMakeVisible.getBottom() <= goalBottom) {
                        return 0;
                    }
                    if (nextSelectedPosition != ListView.INVALID_POSITION && (goalBottom - viewToMakeVisible.getTop()) >= this.getMaxScrollAmount()) {
                        return 0;
                    }
                    let amountToScroll = (viewToMakeVisible.getBottom() - goalBottom);
                    if ((this.mFirstPosition + numChildren) == this.mItemCount) {
                        const max = this.getChildAt(numChildren - 1).getBottom() - listBottom;
                        amountToScroll = Math.min(amountToScroll, max);
                    }
                    return Math.min(amountToScroll, this.getMaxScrollAmount());
                }
                else {
                    let indexToMakeVisible = 0;
                    if (nextSelectedPosition != ListView.INVALID_POSITION) {
                        indexToMakeVisible = nextSelectedPosition - this.mFirstPosition;
                    }
                    while (indexToMakeVisible < 0) {
                        this.addViewAbove(this.getChildAt(0), this.mFirstPosition);
                        this.mFirstPosition--;
                        indexToMakeVisible = nextSelectedPosition - this.mFirstPosition;
                    }
                    const positionToMakeVisible = this.mFirstPosition + indexToMakeVisible;
                    const viewToMakeVisible = this.getChildAt(indexToMakeVisible);
                    let goalTop = listTop;
                    if (positionToMakeVisible > 0) {
                        goalTop += this.getArrowScrollPreviewLength();
                    }
                    if (viewToMakeVisible.getTop() >= goalTop) {
                        return 0;
                    }
                    if (nextSelectedPosition != ListView.INVALID_POSITION && (viewToMakeVisible.getBottom() - goalTop) >= this.getMaxScrollAmount()) {
                        return 0;
                    }
                    let amountToScroll = (goalTop - viewToMakeVisible.getTop());
                    if (this.mFirstPosition == 0) {
                        const max = listTop - this.getChildAt(0).getTop();
                        amountToScroll = Math.min(amountToScroll, max);
                    }
                    return Math.min(amountToScroll, this.getMaxScrollAmount());
                }
            }
            lookForSelectablePositionOnScreen(direction) {
                const firstPosition = this.mFirstPosition;
                if (direction == View.FOCUS_DOWN) {
                    let startPos = (this.mSelectedPosition != ListView.INVALID_POSITION) ? this.mSelectedPosition + 1 : firstPosition;
                    if (startPos >= this.mAdapter.getCount()) {
                        return ListView.INVALID_POSITION;
                    }
                    if (startPos < firstPosition) {
                        startPos = firstPosition;
                    }
                    const lastVisiblePos = this.getLastVisiblePosition();
                    const adapter = this.getAdapter();
                    for (let pos = startPos; pos <= lastVisiblePos; pos++) {
                        if (adapter.isEnabled(pos) && this.getChildAt(pos - firstPosition).getVisibility() == View.VISIBLE) {
                            return pos;
                        }
                    }
                }
                else {
                    let last = firstPosition + this.getChildCount() - 1;
                    let startPos = (this.mSelectedPosition != ListView.INVALID_POSITION) ? this.mSelectedPosition - 1 : firstPosition + this.getChildCount() - 1;
                    if (startPos < 0 || startPos >= this.mAdapter.getCount()) {
                        return ListView.INVALID_POSITION;
                    }
                    if (startPos > last) {
                        startPos = last;
                    }
                    const adapter = this.getAdapter();
                    for (let pos = startPos; pos >= firstPosition; pos--) {
                        if (adapter.isEnabled(pos) && this.getChildAt(pos - firstPosition).getVisibility() == View.VISIBLE) {
                            return pos;
                        }
                    }
                }
                return ListView.INVALID_POSITION;
            }
            arrowScrollFocused(direction) {
                const selectedView = this.getSelectedView();
                let newFocus;
                if (selectedView != null && selectedView.hasFocus()) {
                    let oldFocus = selectedView.findFocus();
                    newFocus = FocusFinder.getInstance().findNextFocus(this, oldFocus, direction);
                }
                else {
                    if (direction == View.FOCUS_DOWN) {
                        const topFadingEdgeShowing = (this.mFirstPosition > 0);
                        const listTop = this.mListPadding.top + (topFadingEdgeShowing ? this.getArrowScrollPreviewLength() : 0);
                        const ySearchPoint = (selectedView != null && selectedView.getTop() > listTop) ? selectedView.getTop() : listTop;
                        this.mTempRect.set(0, ySearchPoint, 0, ySearchPoint);
                    }
                    else {
                        const bottomFadingEdgeShowing = (this.mFirstPosition + this.getChildCount() - 1) < this.mItemCount;
                        const listBottom = this.getHeight() - this.mListPadding.bottom - (bottomFadingEdgeShowing ? this.getArrowScrollPreviewLength() : 0);
                        const ySearchPoint = (selectedView != null && selectedView.getBottom() < listBottom) ? selectedView.getBottom() : listBottom;
                        this.mTempRect.set(0, ySearchPoint, 0, ySearchPoint);
                    }
                    newFocus = FocusFinder.getInstance().findNextFocusFromRect(this, this.mTempRect, direction);
                }
                if (newFocus != null) {
                    const positionOfNewFocus = this.positionOfNewFocus(newFocus);
                    if (this.mSelectedPosition != ListView.INVALID_POSITION && positionOfNewFocus != this.mSelectedPosition) {
                        const selectablePosition = this.lookForSelectablePositionOnScreen(direction);
                        if (selectablePosition != ListView.INVALID_POSITION && ((direction == View.FOCUS_DOWN && selectablePosition < positionOfNewFocus) || (direction == View.FOCUS_UP && selectablePosition > positionOfNewFocus))) {
                            return null;
                        }
                    }
                    let focusScroll = this.amountToScrollToNewFocus(direction, newFocus, positionOfNewFocus);
                    const maxScrollAmount = this.getMaxScrollAmount();
                    if (focusScroll < maxScrollAmount) {
                        newFocus.requestFocus(direction);
                        this.mArrowScrollFocusResult.populate(positionOfNewFocus, focusScroll);
                        return this.mArrowScrollFocusResult;
                    }
                    else if (this.distanceToView(newFocus) < maxScrollAmount) {
                        newFocus.requestFocus(direction);
                        this.mArrowScrollFocusResult.populate(positionOfNewFocus, maxScrollAmount);
                        return this.mArrowScrollFocusResult;
                    }
                }
                return null;
            }
            positionOfNewFocus(newFocus) {
                const numChildren = this.getChildCount();
                for (let i = 0; i < numChildren; i++) {
                    const child = this.getChildAt(i);
                    if (this.isViewAncestorOf(newFocus, child)) {
                        return this.mFirstPosition + i;
                    }
                }
                throw Error(`new IllegalArgumentException("newFocus is not a child of any of the" + " children of the list!")`);
            }
            isViewAncestorOf(child, parent) {
                if (child == parent) {
                    return true;
                }
                const theParent = child.getParent();
                return (theParent instanceof ViewGroup) && this.isViewAncestorOf(theParent, parent);
            }
            amountToScrollToNewFocus(direction, newFocus, positionOfNewFocus) {
                let amountToScroll = 0;
                newFocus.getDrawingRect(this.mTempRect);
                this.offsetDescendantRectToMyCoords(newFocus, this.mTempRect);
                if (direction == View.FOCUS_UP) {
                    if (this.mTempRect.top < this.mListPadding.top) {
                        amountToScroll = this.mListPadding.top - this.mTempRect.top;
                        if (positionOfNewFocus > 0) {
                            amountToScroll += this.getArrowScrollPreviewLength();
                        }
                    }
                }
                else {
                    const listBottom = this.getHeight() - this.mListPadding.bottom;
                    if (this.mTempRect.bottom > listBottom) {
                        amountToScroll = this.mTempRect.bottom - listBottom;
                        if (positionOfNewFocus < this.mItemCount - 1) {
                            amountToScroll += this.getArrowScrollPreviewLength();
                        }
                    }
                }
                return amountToScroll;
            }
            distanceToView(descendant) {
                let distance = 0;
                descendant.getDrawingRect(this.mTempRect);
                this.offsetDescendantRectToMyCoords(descendant, this.mTempRect);
                const listBottom = this.mBottom - this.mTop - this.mListPadding.bottom;
                if (this.mTempRect.bottom < this.mListPadding.top) {
                    distance = this.mListPadding.top - this.mTempRect.bottom;
                }
                else if (this.mTempRect.top > listBottom) {
                    distance = this.mTempRect.top - listBottom;
                }
                return distance;
            }
            scrollListItemsBy(amount) {
                this.offsetChildrenTopAndBottom(amount);
                const listBottom = this.getHeight() - this.mListPadding.bottom;
                const listTop = this.mListPadding.top;
                const recycleBin = this.mRecycler;
                if (amount < 0) {
                    let numChildren = this.getChildCount();
                    let last = this.getChildAt(numChildren - 1);
                    while (last.getBottom() < listBottom) {
                        const lastVisiblePosition = this.mFirstPosition + numChildren - 1;
                        if (lastVisiblePosition < this.mItemCount - 1) {
                            last = this.addViewBelow(last, lastVisiblePosition);
                            numChildren++;
                        }
                        else {
                            break;
                        }
                    }
                    if (last.getBottom() < listBottom) {
                        this.offsetChildrenTopAndBottom(listBottom - last.getBottom());
                    }
                    let first = this.getChildAt(0);
                    while (first.getBottom() < listTop) {
                        let layoutParams = first.getLayoutParams();
                        if (recycleBin.shouldRecycleViewType(layoutParams.viewType)) {
                            recycleBin.addScrapView(first, this.mFirstPosition);
                        }
                        this.detachViewFromParent(first);
                        first = this.getChildAt(0);
                        this.mFirstPosition++;
                    }
                }
                else {
                    let first = this.getChildAt(0);
                    while ((first.getTop() > listTop) && (this.mFirstPosition > 0)) {
                        first = this.addViewAbove(first, this.mFirstPosition);
                        this.mFirstPosition--;
                    }
                    if (first.getTop() > listTop) {
                        this.offsetChildrenTopAndBottom(listTop - first.getTop());
                    }
                    let lastIndex = this.getChildCount() - 1;
                    let last = this.getChildAt(lastIndex);
                    while (last.getTop() > listBottom) {
                        let layoutParams = last.getLayoutParams();
                        if (recycleBin.shouldRecycleViewType(layoutParams.viewType)) {
                            recycleBin.addScrapView(last, this.mFirstPosition + lastIndex);
                        }
                        this.detachViewFromParent(last);
                        last = this.getChildAt(--lastIndex);
                    }
                }
            }
            addViewAbove(theView, position) {
                let abovePosition = position - 1;
                let view = this.obtainView(abovePosition, this.mIsScrap);
                let edgeOfNewChild = theView.getTop() - this.mDividerHeight;
                this.setupChild(view, abovePosition, edgeOfNewChild, false, this.mListPadding.left, false, this.mIsScrap[0]);
                return view;
            }
            addViewBelow(theView, position) {
                let belowPosition = position + 1;
                let view = this.obtainView(belowPosition, this.mIsScrap);
                let edgeOfNewChild = theView.getBottom() + this.mDividerHeight;
                this.setupChild(view, belowPosition, edgeOfNewChild, true, this.mListPadding.left, false, this.mIsScrap[0]);
                return view;
            }
            setItemsCanFocus(itemsCanFocus) {
                this.mItemsCanFocus = itemsCanFocus;
                if (!itemsCanFocus) {
                    this.setDescendantFocusability(ViewGroup.FOCUS_BLOCK_DESCENDANTS);
                }
            }
            getItemsCanFocus() {
                return this.mItemsCanFocus;
            }
            isOpaque() {
                let retValue = (this.mCachingActive && this.mIsCacheColorOpaque && this.mDividerIsOpaque && this.hasOpaqueScrollbars()) || super.isOpaque();
                if (retValue) {
                    const listTop = this.mListPadding != null ? this.mListPadding.top : this.mPaddingTop;
                    let first = this.getChildAt(0);
                    if (first == null || first.getTop() > listTop) {
                        return false;
                    }
                    const listBottom = this.getHeight() - (this.mListPadding != null ? this.mListPadding.bottom : this.mPaddingBottom);
                    let last = this.getChildAt(this.getChildCount() - 1);
                    if (last == null || last.getBottom() < listBottom) {
                        return false;
                    }
                }
                return retValue;
            }
            setCacheColorHint(color) {
                const opaque = (color >>> 24) == 0xFF;
                this.mIsCacheColorOpaque = opaque;
                if (opaque) {
                    if (this.mDividerPaint == null) {
                        this.mDividerPaint = new Paint();
                    }
                    this.mDividerPaint.setColor(color);
                }
                super.setCacheColorHint(color);
            }
            drawOverscrollHeader(canvas, drawable, bounds) {
                const height = drawable.getMinimumHeight();
                canvas.save();
                canvas.clipRect(bounds);
                const span = bounds.bottom - bounds.top;
                if (span < height) {
                    bounds.top = bounds.bottom - height;
                }
                drawable.setBounds(bounds);
                drawable.draw(canvas);
                canvas.restore();
            }
            drawOverscrollFooter(canvas, drawable, bounds) {
                const height = drawable.getMinimumHeight();
                canvas.save();
                canvas.clipRect(bounds);
                const span = bounds.bottom - bounds.top;
                if (span < height) {
                    bounds.bottom = bounds.top + height;
                }
                drawable.setBounds(bounds);
                drawable.draw(canvas);
                canvas.restore();
            }
            dispatchDraw(canvas) {
                if (this.mCachingStarted) {
                    this.mCachingActive = true;
                }
                const dividerHeight = this.mDividerHeight;
                const overscrollHeader = this.mOverScrollHeader;
                const overscrollFooter = this.mOverScrollFooter;
                const drawOverscrollHeader = overscrollHeader != null;
                const drawOverscrollFooter = overscrollFooter != null;
                const drawDividers = dividerHeight > 0 && this.mDivider != null;
                if (drawDividers || drawOverscrollHeader || drawOverscrollFooter) {
                    const bounds = this.mTempRect;
                    bounds.left = this.mPaddingLeft;
                    bounds.right = this.mRight - this.mLeft - this.mPaddingRight;
                    const count = this.getChildCount();
                    const headerCount = this.mHeaderViewInfos.size();
                    const itemCount = this.mItemCount;
                    const footerLimit = (itemCount - this.mFooterViewInfos.size());
                    const headerDividers = this.mHeaderDividersEnabled;
                    const footerDividers = this.mFooterDividersEnabled;
                    const first = this.mFirstPosition;
                    const areAllItemsSelectable = this.mAreAllItemsSelectable;
                    const adapter = this.mAdapter;
                    const fillForMissingDividers = this.isOpaque() && !super.isOpaque();
                    if (fillForMissingDividers && this.mDividerPaint == null && this.mIsCacheColorOpaque) {
                        this.mDividerPaint = new Paint();
                        this.mDividerPaint.setColor(this.getCacheColorHint());
                    }
                    const paint = this.mDividerPaint;
                    let effectivePaddingTop = 0;
                    let effectivePaddingBottom = 0;
                    if ((this.mGroupFlags & ListView.CLIP_TO_PADDING_MASK) == ListView.CLIP_TO_PADDING_MASK) {
                        effectivePaddingTop = this.mListPadding.top;
                        effectivePaddingBottom = this.mListPadding.bottom;
                    }
                    const listBottom = this.mBottom - this.mTop - effectivePaddingBottom + this.mScrollY;
                    if (!this.mStackFromBottom) {
                        let bottom = 0;
                        const scrollY = this.mScrollY;
                        if (count > 0 && scrollY < 0) {
                            if (drawOverscrollHeader) {
                                bounds.bottom = 0;
                                bounds.top = scrollY;
                                this.drawOverscrollHeader(canvas, overscrollHeader, bounds);
                            }
                            else if (drawDividers) {
                                bounds.bottom = 0;
                                bounds.top = -dividerHeight;
                                this.drawDivider(canvas, bounds, -1);
                            }
                        }
                        for (let i = 0; i < count; i++) {
                            const itemIndex = (first + i);
                            const isHeader = (itemIndex < headerCount);
                            const isFooter = (itemIndex >= footerLimit);
                            if ((headerDividers || !isHeader) && (footerDividers || !isFooter)) {
                                const child = this.getChildAt(i);
                                bottom = child.getBottom();
                                const isLastItem = (i == (count - 1));
                                if (drawDividers && (bottom < listBottom) && !(drawOverscrollFooter && isLastItem)) {
                                    const nextIndex = (itemIndex + 1);
                                    if (areAllItemsSelectable || ((adapter.isEnabled(itemIndex) || (headerDividers && isHeader) || (footerDividers && isFooter)) && (isLastItem || adapter.isEnabled(nextIndex) || (headerDividers && (nextIndex < headerCount)) || (footerDividers && (nextIndex >= footerLimit))))) {
                                        bounds.top = bottom;
                                        bounds.bottom = bottom + dividerHeight;
                                        this.drawDivider(canvas, bounds, i);
                                    }
                                    else if (fillForMissingDividers) {
                                        bounds.top = bottom;
                                        bounds.bottom = bottom + dividerHeight;
                                        canvas.drawRect(bounds, paint);
                                    }
                                }
                            }
                        }
                        const overFooterBottom = this.mBottom + this.mScrollY;
                        if (drawOverscrollFooter && first + count == itemCount && overFooterBottom > bottom) {
                            bounds.top = bottom;
                            bounds.bottom = overFooterBottom;
                            this.drawOverscrollFooter(canvas, overscrollFooter, bounds);
                        }
                    }
                    else {
                        let top;
                        const scrollY = this.mScrollY;
                        if (count > 0 && drawOverscrollHeader) {
                            bounds.top = scrollY;
                            bounds.bottom = this.getChildAt(0).getTop();
                            this.drawOverscrollHeader(canvas, overscrollHeader, bounds);
                        }
                        const start = drawOverscrollHeader ? 1 : 0;
                        for (let i = start; i < count; i++) {
                            const itemIndex = (first + i);
                            const isHeader = (itemIndex < headerCount);
                            const isFooter = (itemIndex >= footerLimit);
                            if ((headerDividers || !isHeader) && (footerDividers || !isFooter)) {
                                const child = this.getChildAt(i);
                                top = child.getTop();
                                if (drawDividers && (top > effectivePaddingTop)) {
                                    const isFirstItem = (i == start);
                                    const previousIndex = (itemIndex - 1);
                                    if (areAllItemsSelectable || ((adapter.isEnabled(itemIndex) || (headerDividers && isHeader) || (footerDividers && isFooter)) && (isFirstItem || adapter.isEnabled(previousIndex) || (headerDividers && (previousIndex < headerCount)) || (footerDividers && (previousIndex >= footerLimit))))) {
                                        bounds.top = top - dividerHeight;
                                        bounds.bottom = top;
                                        this.drawDivider(canvas, bounds, i - 1);
                                    }
                                    else if (fillForMissingDividers) {
                                        bounds.top = top - dividerHeight;
                                        bounds.bottom = top;
                                        canvas.drawRect(bounds, paint);
                                    }
                                }
                            }
                        }
                        if (count > 0 && scrollY > 0) {
                            if (drawOverscrollFooter) {
                                const absListBottom = this.mBottom;
                                bounds.top = absListBottom;
                                bounds.bottom = absListBottom + scrollY;
                                this.drawOverscrollFooter(canvas, overscrollFooter, bounds);
                            }
                            else if (drawDividers) {
                                bounds.top = listBottom;
                                bounds.bottom = listBottom + dividerHeight;
                                this.drawDivider(canvas, bounds, -1);
                            }
                        }
                    }
                }
                super.dispatchDraw(canvas);
            }
            drawChild(canvas, child, drawingTime) {
                let more = super.drawChild(canvas, child, drawingTime);
                if (this.mCachingActive && child.mCachingFailed) {
                    this.mCachingActive = false;
                }
                return more;
            }
            drawDivider(canvas, bounds, childIndex) {
                const divider = this.mDivider;
                divider.setBounds(bounds);
                divider.draw(canvas);
            }
            getDivider() {
                return this.mDivider;
            }
            setDivider(divider) {
                if (divider != null) {
                    this.mDividerHeight = divider.getIntrinsicHeight();
                }
                else {
                    this.mDividerHeight = 0;
                }
                this.mDivider = divider;
                this.mDividerIsOpaque = divider == null || divider.getOpacity() == PixelFormat.OPAQUE;
                this.requestLayout();
                this.invalidate();
            }
            getDividerHeight() {
                return this.mDividerHeight;
            }
            setDividerHeight(height) {
                this.mDividerHeight = height;
                this.requestLayout();
                this.invalidate();
            }
            setHeaderDividersEnabled(headerDividersEnabled) {
                this.mHeaderDividersEnabled = headerDividersEnabled;
                this.invalidate();
            }
            areHeaderDividersEnabled() {
                return this.mHeaderDividersEnabled;
            }
            setFooterDividersEnabled(footerDividersEnabled) {
                this.mFooterDividersEnabled = footerDividersEnabled;
                this.invalidate();
            }
            areFooterDividersEnabled() {
                return this.mFooterDividersEnabled;
            }
            setOverscrollHeader(header) {
                this.mOverScrollHeader = header;
                if (this.mScrollY < 0) {
                    this.invalidate();
                }
            }
            getOverscrollHeader() {
                return this.mOverScrollHeader;
            }
            setOverscrollFooter(footer) {
                this.mOverScrollFooter = footer;
                this.invalidate();
            }
            getOverscrollFooter() {
                return this.mOverScrollFooter;
            }
            onFocusChanged(gainFocus, direction, previouslyFocusedRect) {
                super.onFocusChanged(gainFocus, direction, previouslyFocusedRect);
                const adapter = this.mAdapter;
                let closetChildIndex = -1;
                let closestChildTop = 0;
                if (adapter != null && gainFocus && previouslyFocusedRect != null) {
                    previouslyFocusedRect.offset(this.mScrollX, this.mScrollY);
                    if (adapter.getCount() < this.getChildCount() + this.mFirstPosition) {
                        this.mLayoutMode = ListView.LAYOUT_NORMAL;
                        this.layoutChildren();
                    }
                    let otherRect = this.mTempRect;
                    let minDistance = Integer.MAX_VALUE;
                    const childCount = this.getChildCount();
                    const firstPosition = this.mFirstPosition;
                    for (let i = 0; i < childCount; i++) {
                        if (!adapter.isEnabled(firstPosition + i)) {
                            continue;
                        }
                        let other = this.getChildAt(i);
                        other.getDrawingRect(otherRect);
                        this.offsetDescendantRectToMyCoords(other, otherRect);
                        let distance = ListView.getDistance(previouslyFocusedRect, otherRect, direction);
                        if (distance < minDistance) {
                            minDistance = distance;
                            closetChildIndex = i;
                            closestChildTop = other.getTop();
                        }
                    }
                }
                if (closetChildIndex >= 0) {
                    this.setSelectionFromTop(closetChildIndex + this.mFirstPosition, closestChildTop);
                }
                else {
                    this.requestLayout();
                }
            }
            onFinishInflate() {
                super.onFinishInflate();
                let count = this.getChildCount();
                if (count > 0) {
                    for (let i = 0; i < count; ++i) {
                        this.addHeaderView(this.getChildAt(i));
                    }
                    this.removeAllViews();
                }
            }
            findViewTraversal(id) {
                let v;
                v = super.findViewTraversal(id);
                if (v == null) {
                    v = this.findViewInHeadersOrFooters(this.mHeaderViewInfos, id);
                    if (v != null) {
                        return v;
                    }
                    v = this.findViewInHeadersOrFooters(this.mFooterViewInfos, id);
                    if (v != null) {
                        return v;
                    }
                }
                return v;
            }
            findViewInHeadersOrFooters(where, id) {
                if (where != null) {
                    let len = where.size();
                    let v;
                    for (let i = 0; i < len; i++) {
                        v = where.get(i).view;
                        if (!v.isRootNamespace()) {
                            v = v.findViewById(id);
                            if (v != null) {
                                return v;
                            }
                        }
                    }
                }
                return null;
            }
            findViewByPredicateTraversal(predicate, childToSkip) {
                let v;
                v = super.findViewByPredicateTraversal(predicate, childToSkip);
                if (v == null) {
                    v = this.findViewByPredicateInHeadersOrFooters(this.mHeaderViewInfos, predicate, childToSkip);
                    if (v != null) {
                        return v;
                    }
                    v = this.findViewByPredicateInHeadersOrFooters(this.mFooterViewInfos, predicate, childToSkip);
                    if (v != null) {
                        return v;
                    }
                }
                return v;
            }
            findViewByPredicateInHeadersOrFooters(where, predicate, childToSkip) {
                if (where != null) {
                    let len = where.size();
                    let v;
                    for (let i = 0; i < len; i++) {
                        v = where.get(i).view;
                        if (v != childToSkip && !v.isRootNamespace()) {
                            v = v.findViewByPredicate(predicate);
                            if (v != null) {
                                return v;
                            }
                        }
                    }
                }
                return null;
            }
            getCheckItemIds() {
                if (this.mAdapter != null && this.mAdapter.hasStableIds()) {
                    return this.getCheckedItemIds();
                }
                if (this.mChoiceMode != ListView.CHOICE_MODE_NONE && this.mCheckStates != null && this.mAdapter != null) {
                    const states = this.mCheckStates;
                    const count = states.size();
                    const ids = new Array(count);
                    const adapter = this.mAdapter;
                    let checkedCount = 0;
                    for (let i = 0; i < count; i++) {
                        if (states.valueAt(i)) {
                            ids[checkedCount++] = adapter.getItemId(states.keyAt(i));
                        }
                    }
                    if (checkedCount == count) {
                        return ids;
                    }
                    else {
                        const result = new Array(checkedCount);
                        System.arraycopy(ids, 0, result, 0, checkedCount);
                        return result;
                    }
                }
                return new Array(0);
            }
        }
        ListView.NO_POSITION = -1;
        ListView.MAX_SCROLL_FACTOR = 0.33;
        ListView.MIN_SCROLL_PREVIEW_PIXELS = 2;
        widget.ListView = ListView;
        (function (ListView) {
            class FixedViewInfo {
                constructor(arg) {
                    this._ListView_this = arg;
                }
            }
            ListView.FixedViewInfo = FixedViewInfo;
            class FocusSelector {
                constructor(arg) {
                    this.mPosition = 0;
                    this.mPositionTop = 0;
                    this._ListView_this = arg;
                }
                setup(position, top) {
                    this.mPosition = position;
                    this.mPositionTop = top;
                    return this;
                }
                run() {
                    this._ListView_this.setSelectionFromTop(this.mPosition, this.mPositionTop);
                }
            }
            ListView.FocusSelector = FocusSelector;
            class ArrowScrollFocusResult {
                constructor() {
                    this.mSelectedPosition = 0;
                    this.mAmountToScroll = 0;
                }
                populate(selectedPosition, amountToScroll) {
                    this.mSelectedPosition = selectedPosition;
                    this.mAmountToScroll = amountToScroll;
                }
                getSelectedPosition() {
                    return this.mSelectedPosition;
                }
                getAmountToScroll() {
                    return this.mAmountToScroll;
                }
            }
            ListView.ArrowScrollFocusResult = ArrowScrollFocusResult;
        })(ListView = widget.ListView || (widget.ListView = {}));
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/graphics/Rect.ts"/>
///<reference path="../../android/os/Trace.ts"/>
///<reference path="../../android/view/Gravity.ts"/>
///<reference path="../../android/view/KeyEvent.ts"/>
///<reference path="../../android/view/SoundEffectConstants.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../java/lang/Integer.ts"/>
///<reference path="../../android/widget/AbsListView.ts"/>
///<reference path="../../android/widget/Adapter.ts"/>
///<reference path="../../android/widget/Checkable.ts"/>
///<reference path="../../android/widget/ListAdapter.ts"/>
///<reference path="../../android/widget/ListView.ts"/>
///<reference path="../../android/R/attr.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var Rect = android.graphics.Rect;
        var Trace = android.os.Trace;
        var Gravity = android.view.Gravity;
        var KeyEvent = android.view.KeyEvent;
        var SoundEffectConstants = android.view.SoundEffectConstants;
        var View = android.view.View;
        var ViewGroup = android.view.ViewGroup;
        var Integer = java.lang.Integer;
        var AbsListView = android.widget.AbsListView;
        class GridView extends AbsListView {
            constructor(bindElement, rootElement) {
                super(bindElement, rootElement);
                this.mNumColumns = GridView.AUTO_FIT;
                this.mHorizontalSpacing = 0;
                this.mRequestedHorizontalSpacing = 0;
                this.mVerticalSpacing = 0;
                this.mStretchMode = GridView.STRETCH_COLUMN_WIDTH;
                this.mColumnWidth = 0;
                this.mRequestedColumnWidth = 0;
                this.mRequestedNumColumns = 0;
                this.mReferenceView = null;
                this.mReferenceViewInSelectedRow = null;
                this.mGravity = Gravity.LEFT;
                this.mTempRect = new Rect();
                this._attrBinder.addAttr('horizontalSpacing', (value) => {
                    this.setHorizontalSpacing(this._attrBinder.parseNumber(value, 0));
                });
                this._attrBinder.addAttr('verticalSpacing', (value) => {
                    this.setVerticalSpacing(this._attrBinder.parseNumber(value, 0));
                });
                this._attrBinder.addAttr('stretchMode', (value) => {
                    let strechMode = this._attrBinder.parseNumber(value, -1);
                    if (strechMode >= 0) {
                        this.setStretchMode(strechMode);
                    }
                });
                this._attrBinder.addAttr('columnWidth', (value) => {
                    let columnWidth = this._attrBinder.parseNumber(value, -1);
                    if (columnWidth > 0) {
                        this.setColumnWidth(columnWidth);
                    }
                });
                this._attrBinder.addAttr('numColumns', (value) => {
                    this.setNumColumns(this._attrBinder.parseNumber(value, 1));
                });
                this._attrBinder.addAttr('gravity', (value) => {
                    this.setNumColumns(this._attrBinder.parseNumber(value, 1));
                });
                this.applyDefaultAttributes(android.R.attr.gridViewStyle);
            }
            getAdapter() {
                return this.mAdapter;
            }
            setAdapter(adapter) {
                if (this.mAdapter != null && this.mDataSetObserver != null) {
                    this.mAdapter.unregisterDataSetObserver(this.mDataSetObserver);
                }
                this.resetList();
                this.mRecycler.clear();
                this.mAdapter = adapter;
                this.mOldSelectedPosition = GridView.INVALID_POSITION;
                this.mOldSelectedRowId = GridView.INVALID_ROW_ID;
                super.setAdapter(adapter);
                if (this.mAdapter != null) {
                    this.mOldItemCount = this.mItemCount;
                    this.mItemCount = this.mAdapter.getCount();
                    this.mDataChanged = true;
                    this.checkFocus();
                    this.mDataSetObserver = new AbsListView.AdapterDataSetObserver(this);
                    this.mAdapter.registerDataSetObserver(this.mDataSetObserver);
                    this.mRecycler.setViewTypeCount(this.mAdapter.getViewTypeCount());
                    let position;
                    if (this.mStackFromBottom) {
                        position = this.lookForSelectablePosition(this.mItemCount - 1, false);
                    }
                    else {
                        position = this.lookForSelectablePosition(0, true);
                    }
                    this.setSelectedPositionInt(position);
                    this.setNextSelectedPositionInt(position);
                    this.checkSelectionChanged();
                }
                else {
                    this.checkFocus();
                    this.checkSelectionChanged();
                }
                this.requestLayout();
            }
            lookForSelectablePosition(position, lookDown) {
                const adapter = this.mAdapter;
                if (adapter == null || this.isInTouchMode()) {
                    return GridView.INVALID_POSITION;
                }
                if (position < 0 || position >= this.mItemCount) {
                    return GridView.INVALID_POSITION;
                }
                return position;
            }
            fillGap(down) {
                const numColumns = this.mNumColumns;
                const verticalSpacing = this.mVerticalSpacing;
                const count = this.getChildCount();
                if (down) {
                    let paddingTop = 0;
                    if ((this.mGroupFlags & GridView.CLIP_TO_PADDING_MASK) == GridView.CLIP_TO_PADDING_MASK) {
                        paddingTop = this.getListPaddingTop();
                    }
                    const startOffset = count > 0 ? this.getChildAt(count - 1).getBottom() + verticalSpacing : paddingTop;
                    let position = this.mFirstPosition + count;
                    if (this.mStackFromBottom) {
                        position += numColumns - 1;
                    }
                    this.fillDown(position, startOffset);
                    this.correctTooHigh(numColumns, verticalSpacing, this.getChildCount());
                }
                else {
                    let paddingBottom = 0;
                    if ((this.mGroupFlags & GridView.CLIP_TO_PADDING_MASK) == GridView.CLIP_TO_PADDING_MASK) {
                        paddingBottom = this.getListPaddingBottom();
                    }
                    const startOffset = count > 0 ? this.getChildAt(0).getTop() - verticalSpacing : this.getHeight() - paddingBottom;
                    let position = this.mFirstPosition;
                    if (!this.mStackFromBottom) {
                        position -= numColumns;
                    }
                    else {
                        position--;
                    }
                    this.fillUp(position, startOffset);
                    this.correctTooLow(numColumns, verticalSpacing, this.getChildCount());
                }
            }
            fillDown(pos, nextTop) {
                let selectedView = null;
                let end = (this.mBottom - this.mTop);
                if ((this.mGroupFlags & GridView.CLIP_TO_PADDING_MASK) == GridView.CLIP_TO_PADDING_MASK) {
                    end -= this.mListPadding.bottom;
                }
                while (nextTop < end && pos < this.mItemCount) {
                    let temp = this.makeRow(pos, nextTop, true);
                    if (temp != null) {
                        selectedView = temp;
                    }
                    nextTop = this.mReferenceView.getBottom() + this.mVerticalSpacing;
                    pos += this.mNumColumns;
                }
                this.setVisibleRangeHint(this.mFirstPosition, this.mFirstPosition + this.getChildCount() - 1);
                return selectedView;
            }
            makeRow(startPos, y, flow) {
                const columnWidth = this.mColumnWidth;
                const horizontalSpacing = this.mHorizontalSpacing;
                const isLayoutRtl = this.isLayoutRtl();
                let last;
                let nextLeft;
                if (isLayoutRtl) {
                    nextLeft = this.getWidth() - this.mListPadding.right - columnWidth - ((this.mStretchMode == GridView.STRETCH_SPACING_UNIFORM) ? horizontalSpacing : 0);
                }
                else {
                    nextLeft = this.mListPadding.left + ((this.mStretchMode == GridView.STRETCH_SPACING_UNIFORM) ? horizontalSpacing : 0);
                }
                if (!this.mStackFromBottom) {
                    last = Math.min(startPos + this.mNumColumns, this.mItemCount);
                }
                else {
                    last = startPos + 1;
                    startPos = Math.max(0, startPos - this.mNumColumns + 1);
                    if (last - startPos < this.mNumColumns) {
                        const deltaLeft = (this.mNumColumns - (last - startPos)) * (columnWidth + horizontalSpacing);
                        nextLeft += (isLayoutRtl ? -1 : +1) * deltaLeft;
                    }
                }
                let selectedView = null;
                const hasFocus = this.shouldShowSelector();
                const inClick = this.touchModeDrawsInPressedState();
                const selectedPosition = this.mSelectedPosition;
                let child = null;
                for (let pos = startPos; pos < last; pos++) {
                    let selected = pos == selectedPosition;
                    const where = flow ? -1 : pos - startPos;
                    child = this.makeAndAddView(pos, y, flow, nextLeft, selected, where);
                    nextLeft += (isLayoutRtl ? -1 : +1) * columnWidth;
                    if (pos < last - 1) {
                        nextLeft += horizontalSpacing;
                    }
                    if (selected && (hasFocus || inClick)) {
                        selectedView = child;
                    }
                }
                this.mReferenceView = child;
                if (selectedView != null) {
                    this.mReferenceViewInSelectedRow = this.mReferenceView;
                }
                return selectedView;
            }
            fillUp(pos, nextBottom) {
                let selectedView = null;
                let end = 0;
                if ((this.mGroupFlags & GridView.CLIP_TO_PADDING_MASK) == GridView.CLIP_TO_PADDING_MASK) {
                    end = this.mListPadding.top;
                }
                while (nextBottom > end && pos >= 0) {
                    let temp = this.makeRow(pos, nextBottom, false);
                    if (temp != null) {
                        selectedView = temp;
                    }
                    nextBottom = this.mReferenceView.getTop() - this.mVerticalSpacing;
                    this.mFirstPosition = pos;
                    pos -= this.mNumColumns;
                }
                if (this.mStackFromBottom) {
                    this.mFirstPosition = Math.max(0, pos + 1);
                }
                this.setVisibleRangeHint(this.mFirstPosition, this.mFirstPosition + this.getChildCount() - 1);
                return selectedView;
            }
            fillFromTop(nextTop) {
                this.mFirstPosition = Math.min(this.mFirstPosition, this.mSelectedPosition);
                this.mFirstPosition = Math.min(this.mFirstPosition, this.mItemCount - 1);
                if (this.mFirstPosition < 0) {
                    this.mFirstPosition = 0;
                }
                this.mFirstPosition -= this.mFirstPosition % this.mNumColumns;
                return this.fillDown(this.mFirstPosition, nextTop);
            }
            fillFromBottom(lastPosition, nextBottom) {
                lastPosition = Math.max(lastPosition, this.mSelectedPosition);
                lastPosition = Math.min(lastPosition, this.mItemCount - 1);
                const invertedPosition = this.mItemCount - 1 - lastPosition;
                lastPosition = this.mItemCount - 1 - (invertedPosition - (invertedPosition % this.mNumColumns));
                return this.fillUp(lastPosition, nextBottom);
            }
            fillSelection(childrenTop, childrenBottom) {
                const selectedPosition = this.reconcileSelectedPosition();
                const numColumns = this.mNumColumns;
                const verticalSpacing = this.mVerticalSpacing;
                let rowStart;
                let rowEnd = -1;
                if (!this.mStackFromBottom) {
                    rowStart = selectedPosition - (selectedPosition % numColumns);
                }
                else {
                    const invertedSelection = this.mItemCount - 1 - selectedPosition;
                    rowEnd = this.mItemCount - 1 - (invertedSelection - (invertedSelection % numColumns));
                    rowStart = Math.max(0, rowEnd - numColumns + 1);
                }
                const fadingEdgeLength = this.getVerticalFadingEdgeLength();
                const topSelectionPixel = this.getTopSelectionPixel(childrenTop, fadingEdgeLength, rowStart);
                const sel = this.makeRow(this.mStackFromBottom ? rowEnd : rowStart, topSelectionPixel, true);
                this.mFirstPosition = rowStart;
                const referenceView = this.mReferenceView;
                if (!this.mStackFromBottom) {
                    this.fillDown(rowStart + numColumns, referenceView.getBottom() + verticalSpacing);
                    this.pinToBottom(childrenBottom);
                    this.fillUp(rowStart - numColumns, referenceView.getTop() - verticalSpacing);
                    this.adjustViewsUpOrDown();
                }
                else {
                    const bottomSelectionPixel = this.getBottomSelectionPixel(childrenBottom, fadingEdgeLength, numColumns, rowStart);
                    const offset = bottomSelectionPixel - referenceView.getBottom();
                    this.offsetChildrenTopAndBottom(offset);
                    this.fillUp(rowStart - 1, referenceView.getTop() - verticalSpacing);
                    this.pinToTop(childrenTop);
                    this.fillDown(rowEnd + numColumns, referenceView.getBottom() + verticalSpacing);
                    this.adjustViewsUpOrDown();
                }
                return sel;
            }
            pinToTop(childrenTop) {
                if (this.mFirstPosition == 0) {
                    const top = this.getChildAt(0).getTop();
                    const offset = childrenTop - top;
                    if (offset < 0) {
                        this.offsetChildrenTopAndBottom(offset);
                    }
                }
            }
            pinToBottom(childrenBottom) {
                const count = this.getChildCount();
                if (this.mFirstPosition + count == this.mItemCount) {
                    const bottom = this.getChildAt(count - 1).getBottom();
                    const offset = childrenBottom - bottom;
                    if (offset > 0) {
                        this.offsetChildrenTopAndBottom(offset);
                    }
                }
            }
            findMotionRow(y) {
                const childCount = this.getChildCount();
                if (childCount > 0) {
                    const numColumns = this.mNumColumns;
                    if (!this.mStackFromBottom) {
                        for (let i = 0; i < childCount; i += numColumns) {
                            if (y <= this.getChildAt(i).getBottom()) {
                                return this.mFirstPosition + i;
                            }
                        }
                    }
                    else {
                        for (let i = childCount - 1; i >= 0; i -= numColumns) {
                            if (y >= this.getChildAt(i).getTop()) {
                                return this.mFirstPosition + i;
                            }
                        }
                    }
                }
                return GridView.INVALID_POSITION;
            }
            fillSpecific(position, top) {
                const numColumns = this.mNumColumns;
                let motionRowStart;
                let motionRowEnd = -1;
                if (!this.mStackFromBottom) {
                    motionRowStart = position - (position % numColumns);
                }
                else {
                    const invertedSelection = this.mItemCount - 1 - position;
                    motionRowEnd = this.mItemCount - 1 - (invertedSelection - (invertedSelection % numColumns));
                    motionRowStart = Math.max(0, motionRowEnd - numColumns + 1);
                }
                const temp = this.makeRow(this.mStackFromBottom ? motionRowEnd : motionRowStart, top, true);
                this.mFirstPosition = motionRowStart;
                const referenceView = this.mReferenceView;
                if (referenceView == null) {
                    return null;
                }
                const verticalSpacing = this.mVerticalSpacing;
                let above;
                let below;
                if (!this.mStackFromBottom) {
                    above = this.fillUp(motionRowStart - numColumns, referenceView.getTop() - verticalSpacing);
                    this.adjustViewsUpOrDown();
                    below = this.fillDown(motionRowStart + numColumns, referenceView.getBottom() + verticalSpacing);
                    const childCount = this.getChildCount();
                    if (childCount > 0) {
                        this.correctTooHigh(numColumns, verticalSpacing, childCount);
                    }
                }
                else {
                    below = this.fillDown(motionRowEnd + numColumns, referenceView.getBottom() + verticalSpacing);
                    this.adjustViewsUpOrDown();
                    above = this.fillUp(motionRowStart - 1, referenceView.getTop() - verticalSpacing);
                    const childCount = this.getChildCount();
                    if (childCount > 0) {
                        this.correctTooLow(numColumns, verticalSpacing, childCount);
                    }
                }
                if (temp != null) {
                    return temp;
                }
                else if (above != null) {
                    return above;
                }
                else {
                    return below;
                }
            }
            correctTooHigh(numColumns, verticalSpacing, childCount) {
                const lastPosition = this.mFirstPosition + childCount - 1;
                if (lastPosition == this.mItemCount - 1 && childCount > 0) {
                    const lastChild = this.getChildAt(childCount - 1);
                    const lastBottom = lastChild.getBottom();
                    const end = (this.mBottom - this.mTop) - this.mListPadding.bottom;
                    let bottomOffset = end - lastBottom;
                    const firstChild = this.getChildAt(0);
                    const firstTop = firstChild.getTop();
                    if (bottomOffset > 0 && (this.mFirstPosition > 0 || firstTop < this.mListPadding.top)) {
                        if (this.mFirstPosition == 0) {
                            bottomOffset = Math.min(bottomOffset, this.mListPadding.top - firstTop);
                        }
                        this.offsetChildrenTopAndBottom(bottomOffset);
                        if (this.mFirstPosition > 0) {
                            this.fillUp(this.mFirstPosition - (this.mStackFromBottom ? 1 : numColumns), firstChild.getTop() - verticalSpacing);
                            this.adjustViewsUpOrDown();
                        }
                    }
                }
            }
            correctTooLow(numColumns, verticalSpacing, childCount) {
                if (this.mFirstPosition == 0 && childCount > 0) {
                    const firstChild = this.getChildAt(0);
                    const firstTop = firstChild.getTop();
                    const start = this.mListPadding.top;
                    const end = (this.mBottom - this.mTop) - this.mListPadding.bottom;
                    let topOffset = firstTop - start;
                    const lastChild = this.getChildAt(childCount - 1);
                    const lastBottom = lastChild.getBottom();
                    const lastPosition = this.mFirstPosition + childCount - 1;
                    if (topOffset > 0 && (lastPosition < this.mItemCount - 1 || lastBottom > end)) {
                        if (lastPosition == this.mItemCount - 1) {
                            topOffset = Math.min(topOffset, lastBottom - end);
                        }
                        this.offsetChildrenTopAndBottom(-topOffset);
                        if (lastPosition < this.mItemCount - 1) {
                            this.fillDown(lastPosition + (!this.mStackFromBottom ? 1 : numColumns), lastChild.getBottom() + verticalSpacing);
                            this.adjustViewsUpOrDown();
                        }
                    }
                }
            }
            fillFromSelection(selectedTop, childrenTop, childrenBottom) {
                const fadingEdgeLength = this.getVerticalFadingEdgeLength();
                const selectedPosition = this.mSelectedPosition;
                const numColumns = this.mNumColumns;
                const verticalSpacing = this.mVerticalSpacing;
                let rowStart;
                let rowEnd = -1;
                if (!this.mStackFromBottom) {
                    rowStart = selectedPosition - (selectedPosition % numColumns);
                }
                else {
                    let invertedSelection = this.mItemCount - 1 - selectedPosition;
                    rowEnd = this.mItemCount - 1 - (invertedSelection - (invertedSelection % numColumns));
                    rowStart = Math.max(0, rowEnd - numColumns + 1);
                }
                let sel;
                let referenceView;
                let topSelectionPixel = this.getTopSelectionPixel(childrenTop, fadingEdgeLength, rowStart);
                let bottomSelectionPixel = this.getBottomSelectionPixel(childrenBottom, fadingEdgeLength, numColumns, rowStart);
                sel = this.makeRow(this.mStackFromBottom ? rowEnd : rowStart, selectedTop, true);
                this.mFirstPosition = rowStart;
                referenceView = this.mReferenceView;
                this.adjustForTopFadingEdge(referenceView, topSelectionPixel, bottomSelectionPixel);
                this.adjustForBottomFadingEdge(referenceView, topSelectionPixel, bottomSelectionPixel);
                if (!this.mStackFromBottom) {
                    this.fillUp(rowStart - numColumns, referenceView.getTop() - verticalSpacing);
                    this.adjustViewsUpOrDown();
                    this.fillDown(rowStart + numColumns, referenceView.getBottom() + verticalSpacing);
                }
                else {
                    this.fillDown(rowEnd + numColumns, referenceView.getBottom() + verticalSpacing);
                    this.adjustViewsUpOrDown();
                    this.fillUp(rowStart - 1, referenceView.getTop() - verticalSpacing);
                }
                return sel;
            }
            getBottomSelectionPixel(childrenBottom, fadingEdgeLength, numColumns, rowStart) {
                let bottomSelectionPixel = childrenBottom;
                if (rowStart + numColumns - 1 < this.mItemCount - 1) {
                    bottomSelectionPixel -= fadingEdgeLength;
                }
                return bottomSelectionPixel;
            }
            getTopSelectionPixel(childrenTop, fadingEdgeLength, rowStart) {
                let topSelectionPixel = childrenTop;
                if (rowStart > 0) {
                    topSelectionPixel += fadingEdgeLength;
                }
                return topSelectionPixel;
            }
            adjustForBottomFadingEdge(childInSelectedRow, topSelectionPixel, bottomSelectionPixel) {
                if (childInSelectedRow.getBottom() > bottomSelectionPixel) {
                    let spaceAbove = childInSelectedRow.getTop() - topSelectionPixel;
                    let spaceBelow = childInSelectedRow.getBottom() - bottomSelectionPixel;
                    let offset = Math.min(spaceAbove, spaceBelow);
                    this.offsetChildrenTopAndBottom(-offset);
                }
            }
            adjustForTopFadingEdge(childInSelectedRow, topSelectionPixel, bottomSelectionPixel) {
                if (childInSelectedRow.getTop() < topSelectionPixel) {
                    let spaceAbove = topSelectionPixel - childInSelectedRow.getTop();
                    let spaceBelow = bottomSelectionPixel - childInSelectedRow.getBottom();
                    let offset = Math.min(spaceAbove, spaceBelow);
                    this.offsetChildrenTopAndBottom(offset);
                }
            }
            smoothScrollToPosition(position) {
                super.smoothScrollToPosition(position);
            }
            smoothScrollByOffset(offset) {
                super.smoothScrollByOffset(offset);
            }
            moveSelection(delta, childrenTop, childrenBottom) {
                const fadingEdgeLength = this.getVerticalFadingEdgeLength();
                const selectedPosition = this.mSelectedPosition;
                const numColumns = this.mNumColumns;
                const verticalSpacing = this.mVerticalSpacing;
                let oldRowStart;
                let rowStart;
                let rowEnd = -1;
                if (!this.mStackFromBottom) {
                    oldRowStart = (selectedPosition - delta) - ((selectedPosition - delta) % numColumns);
                    rowStart = selectedPosition - (selectedPosition % numColumns);
                }
                else {
                    let invertedSelection = this.mItemCount - 1 - selectedPosition;
                    rowEnd = this.mItemCount - 1 - (invertedSelection - (invertedSelection % numColumns));
                    rowStart = Math.max(0, rowEnd - numColumns + 1);
                    invertedSelection = this.mItemCount - 1 - (selectedPosition - delta);
                    oldRowStart = this.mItemCount - 1 - (invertedSelection - (invertedSelection % numColumns));
                    oldRowStart = Math.max(0, oldRowStart - numColumns + 1);
                }
                const rowDelta = rowStart - oldRowStart;
                const topSelectionPixel = this.getTopSelectionPixel(childrenTop, fadingEdgeLength, rowStart);
                const bottomSelectionPixel = this.getBottomSelectionPixel(childrenBottom, fadingEdgeLength, numColumns, rowStart);
                this.mFirstPosition = rowStart;
                let sel;
                let referenceView;
                if (rowDelta > 0) {
                    const oldBottom = this.mReferenceViewInSelectedRow == null ? 0 : this.mReferenceViewInSelectedRow.getBottom();
                    sel = this.makeRow(this.mStackFromBottom ? rowEnd : rowStart, oldBottom + verticalSpacing, true);
                    referenceView = this.mReferenceView;
                    this.adjustForBottomFadingEdge(referenceView, topSelectionPixel, bottomSelectionPixel);
                }
                else if (rowDelta < 0) {
                    const oldTop = this.mReferenceViewInSelectedRow == null ? 0 : this.mReferenceViewInSelectedRow.getTop();
                    sel = this.makeRow(this.mStackFromBottom ? rowEnd : rowStart, oldTop - verticalSpacing, false);
                    referenceView = this.mReferenceView;
                    this.adjustForTopFadingEdge(referenceView, topSelectionPixel, bottomSelectionPixel);
                }
                else {
                    const oldTop = this.mReferenceViewInSelectedRow == null ? 0 : this.mReferenceViewInSelectedRow.getTop();
                    sel = this.makeRow(this.mStackFromBottom ? rowEnd : rowStart, oldTop, true);
                    referenceView = this.mReferenceView;
                }
                if (!this.mStackFromBottom) {
                    this.fillUp(rowStart - numColumns, referenceView.getTop() - verticalSpacing);
                    this.adjustViewsUpOrDown();
                    this.fillDown(rowStart + numColumns, referenceView.getBottom() + verticalSpacing);
                }
                else {
                    this.fillDown(rowEnd + numColumns, referenceView.getBottom() + verticalSpacing);
                    this.adjustViewsUpOrDown();
                    this.fillUp(rowStart - 1, referenceView.getTop() - verticalSpacing);
                }
                return sel;
            }
            determineColumns(availableSpace) {
                const requestedHorizontalSpacing = this.mRequestedHorizontalSpacing;
                const stretchMode = this.mStretchMode;
                const requestedColumnWidth = this.mRequestedColumnWidth;
                let didNotInitiallyFit = false;
                if (this.mRequestedNumColumns == GridView.AUTO_FIT) {
                    if (requestedColumnWidth > 0) {
                        this.mNumColumns = (availableSpace + requestedHorizontalSpacing) / (requestedColumnWidth + requestedHorizontalSpacing);
                    }
                    else {
                        this.mNumColumns = 2;
                    }
                }
                else {
                    this.mNumColumns = this.mRequestedNumColumns;
                }
                if (this.mNumColumns <= 0) {
                    this.mNumColumns = 1;
                }
                switch (stretchMode) {
                    case GridView.NO_STRETCH:
                        this.mColumnWidth = requestedColumnWidth;
                        this.mHorizontalSpacing = requestedHorizontalSpacing;
                        break;
                    default:
                        let spaceLeftOver = availableSpace - (this.mNumColumns * requestedColumnWidth) - ((this.mNumColumns - 1) * requestedHorizontalSpacing);
                        if (spaceLeftOver < 0) {
                            didNotInitiallyFit = true;
                        }
                        switch (stretchMode) {
                            case GridView.STRETCH_COLUMN_WIDTH:
                                this.mColumnWidth = requestedColumnWidth + spaceLeftOver / this.mNumColumns;
                                this.mHorizontalSpacing = requestedHorizontalSpacing;
                                break;
                            case GridView.STRETCH_SPACING:
                                this.mColumnWidth = requestedColumnWidth;
                                if (this.mNumColumns > 1) {
                                    this.mHorizontalSpacing = requestedHorizontalSpacing + spaceLeftOver / (this.mNumColumns - 1);
                                }
                                else {
                                    this.mHorizontalSpacing = requestedHorizontalSpacing + spaceLeftOver;
                                }
                                break;
                            case GridView.STRETCH_SPACING_UNIFORM:
                                this.mColumnWidth = requestedColumnWidth;
                                if (this.mNumColumns > 1) {
                                    this.mHorizontalSpacing = requestedHorizontalSpacing + spaceLeftOver / (this.mNumColumns + 1);
                                }
                                else {
                                    this.mHorizontalSpacing = requestedHorizontalSpacing + spaceLeftOver;
                                }
                                break;
                        }
                        break;
                }
                return didNotInitiallyFit;
            }
            onMeasure(widthMeasureSpec, heightMeasureSpec) {
                super.onMeasure(widthMeasureSpec, heightMeasureSpec);
                let widthMode = GridView.MeasureSpec.getMode(widthMeasureSpec);
                let heightMode = GridView.MeasureSpec.getMode(heightMeasureSpec);
                let widthSize = GridView.MeasureSpec.getSize(widthMeasureSpec);
                let heightSize = GridView.MeasureSpec.getSize(heightMeasureSpec);
                if (widthMode == GridView.MeasureSpec.UNSPECIFIED) {
                    if (this.mColumnWidth > 0) {
                        widthSize = this.mColumnWidth + this.mListPadding.left + this.mListPadding.right;
                    }
                    else {
                        widthSize = this.mListPadding.left + this.mListPadding.right;
                    }
                    widthSize += this.getVerticalScrollbarWidth();
                }
                let childWidth = widthSize - this.mListPadding.left - this.mListPadding.right;
                let didNotInitiallyFit = this.determineColumns(childWidth);
                let childHeight = 0;
                let childState = 0;
                this.mItemCount = this.mAdapter == null ? 0 : this.mAdapter.getCount();
                const count = this.mItemCount;
                if (count > 0) {
                    const child = this.obtainView(0, this.mIsScrap);
                    let p = child.getLayoutParams();
                    if (p == null) {
                        p = this.generateDefaultLayoutParams();
                        child.setLayoutParams(p);
                    }
                    p.viewType = this.mAdapter.getItemViewType(0);
                    p.forceAdd = true;
                    let childHeightSpec = GridView.getChildMeasureSpec(GridView.MeasureSpec.makeMeasureSpec(0, GridView.MeasureSpec.UNSPECIFIED), 0, p.height);
                    let childWidthSpec = GridView.getChildMeasureSpec(GridView.MeasureSpec.makeMeasureSpec(this.mColumnWidth, GridView.MeasureSpec.EXACTLY), 0, p.width);
                    child.measure(childWidthSpec, childHeightSpec);
                    childHeight = child.getMeasuredHeight();
                    childState = GridView.combineMeasuredStates(childState, child.getMeasuredState());
                    if (this.mRecycler.shouldRecycleViewType(p.viewType)) {
                        this.mRecycler.addScrapView(child, -1);
                    }
                }
                if (heightMode == GridView.MeasureSpec.UNSPECIFIED) {
                    heightSize = this.mListPadding.top + this.mListPadding.bottom + childHeight + this.getVerticalFadingEdgeLength() * 2;
                }
                if (heightMode == GridView.MeasureSpec.AT_MOST) {
                    let ourSize = this.mListPadding.top + this.mListPadding.bottom;
                    const numColumns = this.mNumColumns;
                    for (let i = 0; i < count; i += numColumns) {
                        ourSize += childHeight;
                        if (i + numColumns < count) {
                            ourSize += this.mVerticalSpacing;
                        }
                        if (ourSize >= heightSize) {
                            ourSize = heightSize;
                            break;
                        }
                    }
                    heightSize = ourSize;
                }
                if (widthMode == GridView.MeasureSpec.AT_MOST && this.mRequestedNumColumns != GridView.AUTO_FIT) {
                    let ourSize = (this.mRequestedNumColumns * this.mColumnWidth) + ((this.mRequestedNumColumns - 1) * this.mHorizontalSpacing) + this.mListPadding.left + this.mListPadding.right;
                    if (ourSize > widthSize || didNotInitiallyFit) {
                        widthSize |= GridView.MEASURED_STATE_TOO_SMALL;
                    }
                }
                this.setMeasuredDimension(widthSize, heightSize);
                this.mWidthMeasureSpec = widthMeasureSpec;
            }
            layoutChildren() {
                const blockLayoutRequests = this.mBlockLayoutRequests;
                if (!blockLayoutRequests) {
                    this.mBlockLayoutRequests = true;
                }
                try {
                    super.layoutChildren();
                    this.invalidate();
                    if (this.mAdapter == null) {
                        this.resetList();
                        this.invokeOnItemScrollListener();
                        return;
                    }
                    const childrenTop = this.mListPadding.top;
                    const childrenBottom = this.mBottom - this.mTop - this.mListPadding.bottom;
                    let childCount = this.getChildCount();
                    let index;
                    let delta = 0;
                    let sel;
                    let oldSel = null;
                    let oldFirst = null;
                    let newSel = null;
                    switch (this.mLayoutMode) {
                        case GridView.LAYOUT_SET_SELECTION:
                            index = this.mNextSelectedPosition - this.mFirstPosition;
                            if (index >= 0 && index < childCount) {
                                newSel = this.getChildAt(index);
                            }
                            break;
                        case GridView.LAYOUT_FORCE_TOP:
                        case GridView.LAYOUT_FORCE_BOTTOM:
                        case GridView.LAYOUT_SPECIFIC:
                        case GridView.LAYOUT_SYNC:
                            break;
                        case GridView.LAYOUT_MOVE_SELECTION:
                            if (this.mNextSelectedPosition >= 0) {
                                delta = this.mNextSelectedPosition - this.mSelectedPosition;
                            }
                            break;
                        default:
                            index = this.mSelectedPosition - this.mFirstPosition;
                            if (index >= 0 && index < childCount) {
                                oldSel = this.getChildAt(index);
                            }
                            oldFirst = this.getChildAt(0);
                    }
                    let dataChanged = this.mDataChanged;
                    if (dataChanged) {
                        this.handleDataChanged();
                    }
                    if (this.mItemCount == 0) {
                        this.resetList();
                        this.invokeOnItemScrollListener();
                        return;
                    }
                    this.setSelectedPositionInt(this.mNextSelectedPosition);
                    const firstPosition = this.mFirstPosition;
                    const recycleBin = this.mRecycler;
                    if (dataChanged) {
                        for (let i = 0; i < childCount; i++) {
                            recycleBin.addScrapView(this.getChildAt(i), firstPosition + i);
                        }
                    }
                    else {
                        recycleBin.fillActiveViews(childCount, firstPosition);
                    }
                    this.detachAllViewsFromParent();
                    recycleBin.removeSkippedScrap();
                    switch (this.mLayoutMode) {
                        case GridView.LAYOUT_SET_SELECTION:
                            if (newSel != null) {
                                sel = this.fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);
                            }
                            else {
                                sel = this.fillSelection(childrenTop, childrenBottom);
                            }
                            break;
                        case GridView.LAYOUT_FORCE_TOP:
                            this.mFirstPosition = 0;
                            sel = this.fillFromTop(childrenTop);
                            this.adjustViewsUpOrDown();
                            break;
                        case GridView.LAYOUT_FORCE_BOTTOM:
                            sel = this.fillUp(this.mItemCount - 1, childrenBottom);
                            this.adjustViewsUpOrDown();
                            break;
                        case GridView.LAYOUT_SPECIFIC:
                            sel = this.fillSpecific(this.mSelectedPosition, this.mSpecificTop);
                            break;
                        case GridView.LAYOUT_SYNC:
                            sel = this.fillSpecific(this.mSyncPosition, this.mSpecificTop);
                            break;
                        case GridView.LAYOUT_MOVE_SELECTION:
                            sel = this.moveSelection(delta, childrenTop, childrenBottom);
                            break;
                        default:
                            if (childCount == 0) {
                                if (!this.mStackFromBottom) {
                                    this.setSelectedPositionInt(this.mAdapter == null || this.isInTouchMode() ? GridView.INVALID_POSITION : 0);
                                    sel = this.fillFromTop(childrenTop);
                                }
                                else {
                                    const last = this.mItemCount - 1;
                                    this.setSelectedPositionInt(this.mAdapter == null || this.isInTouchMode() ? GridView.INVALID_POSITION : last);
                                    sel = this.fillFromBottom(last, childrenBottom);
                                }
                            }
                            else {
                                if (this.mSelectedPosition >= 0 && this.mSelectedPosition < this.mItemCount) {
                                    sel = this.fillSpecific(this.mSelectedPosition, oldSel == null ? childrenTop : oldSel.getTop());
                                }
                                else if (this.mFirstPosition < this.mItemCount) {
                                    sel = this.fillSpecific(this.mFirstPosition, oldFirst == null ? childrenTop : oldFirst.getTop());
                                }
                                else {
                                    sel = this.fillSpecific(0, childrenTop);
                                }
                            }
                            break;
                    }
                    recycleBin.scrapActiveViews();
                    if (sel != null) {
                        this.positionSelector(GridView.INVALID_POSITION, sel);
                        this.mSelectedTop = sel.getTop();
                    }
                    else if (this.mTouchMode > GridView.TOUCH_MODE_DOWN && this.mTouchMode < GridView.TOUCH_MODE_SCROLL) {
                        let child = this.getChildAt(this.mMotionPosition - this.mFirstPosition);
                        if (child != null)
                            this.positionSelector(this.mMotionPosition, child);
                    }
                    else {
                        this.mSelectedTop = 0;
                        this.mSelectorRect.setEmpty();
                    }
                    this.mLayoutMode = GridView.LAYOUT_NORMAL;
                    this.mDataChanged = false;
                    if (this.mPositionScrollAfterLayout != null) {
                        this.post(this.mPositionScrollAfterLayout);
                        this.mPositionScrollAfterLayout = null;
                    }
                    this.mNeedSync = false;
                    this.setNextSelectedPositionInt(this.mSelectedPosition);
                    this.updateScrollIndicators();
                    if (this.mItemCount > 0) {
                        this.checkSelectionChanged();
                    }
                    this.invokeOnItemScrollListener();
                }
                finally {
                    if (!blockLayoutRequests) {
                        this.mBlockLayoutRequests = false;
                    }
                }
            }
            makeAndAddView(position, y, flow, childrenLeft, selected, where) {
                let child;
                if (!this.mDataChanged) {
                    child = this.mRecycler.getActiveView(position);
                    if (child != null) {
                        this.setupChild(child, position, y, flow, childrenLeft, selected, true, where);
                        return child;
                    }
                }
                child = this.obtainView(position, this.mIsScrap);
                this.setupChild(child, position, y, flow, childrenLeft, selected, this.mIsScrap[0], where);
                return child;
            }
            setupChild(child, position, y, flow, childrenLeft, selected, recycled, where) {
                Trace.traceBegin(Trace.TRACE_TAG_VIEW, "setupGridItem");
                let isSelected = selected && this.shouldShowSelector();
                const updateChildSelected = isSelected != child.isSelected();
                const mode = this.mTouchMode;
                const isPressed = mode > GridView.TOUCH_MODE_DOWN && mode < GridView.TOUCH_MODE_SCROLL && this.mMotionPosition == position;
                const updateChildPressed = isPressed != child.isPressed();
                let needToMeasure = !recycled || updateChildSelected || child.isLayoutRequested();
                let p = child.getLayoutParams();
                if (p == null) {
                    p = this.generateDefaultLayoutParams();
                }
                p.viewType = this.mAdapter.getItemViewType(position);
                if (recycled && !p.forceAdd) {
                    this.attachViewToParent(child, where, p);
                }
                else {
                    p.forceAdd = false;
                    this.addViewInLayout(child, where, p, true);
                }
                if (updateChildSelected) {
                    child.setSelected(isSelected);
                    if (isSelected) {
                        this.requestFocus();
                    }
                }
                if (updateChildPressed) {
                    child.setPressed(isPressed);
                }
                if (this.mChoiceMode != GridView.CHOICE_MODE_NONE && this.mCheckStates != null) {
                    if (child['setChecked']) {
                        child.setChecked(this.mCheckStates.get(position));
                    }
                    else {
                        child.setActivated(this.mCheckStates.get(position));
                    }
                }
                if (needToMeasure) {
                    let childHeightSpec = ViewGroup.getChildMeasureSpec(GridView.MeasureSpec.makeMeasureSpec(0, GridView.MeasureSpec.UNSPECIFIED), 0, p.height);
                    let childWidthSpec = ViewGroup.getChildMeasureSpec(GridView.MeasureSpec.makeMeasureSpec(this.mColumnWidth, GridView.MeasureSpec.EXACTLY), 0, p.width);
                    child.measure(childWidthSpec, childHeightSpec);
                }
                else {
                    this.cleanupLayoutState(child);
                }
                const w = child.getMeasuredWidth();
                const h = child.getMeasuredHeight();
                let childLeft;
                const childTop = flow ? y : y - h;
                const absoluteGravity = this.mGravity;
                switch (absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
                    case Gravity.LEFT:
                        childLeft = childrenLeft;
                        break;
                    case Gravity.CENTER_HORIZONTAL:
                        childLeft = childrenLeft + ((this.mColumnWidth - w) / 2);
                        break;
                    case Gravity.RIGHT:
                        childLeft = childrenLeft + this.mColumnWidth - w;
                        break;
                    default:
                        childLeft = childrenLeft;
                        break;
                }
                if (needToMeasure) {
                    const childRight = childLeft + w;
                    const childBottom = childTop + h;
                    child.layout(childLeft, childTop, childRight, childBottom);
                }
                else {
                    child.offsetLeftAndRight(childLeft - child.getLeft());
                    child.offsetTopAndBottom(childTop - child.getTop());
                }
                if (this.mCachingStarted) {
                    child.setDrawingCacheEnabled(true);
                }
                if (recycled && (child.getLayoutParams().scrappedFromPosition) != position) {
                    child.jumpDrawablesToCurrentState();
                }
                Trace.traceEnd(Trace.TRACE_TAG_VIEW);
            }
            setSelection(position) {
                if (!this.isInTouchMode()) {
                    this.setNextSelectedPositionInt(position);
                }
                else {
                    this.mResurrectToPosition = position;
                }
                this.mLayoutMode = GridView.LAYOUT_SET_SELECTION;
                if (this.mPositionScroller != null) {
                    this.mPositionScroller.stop();
                }
                this.requestLayout();
            }
            setSelectionInt(position) {
                let previousSelectedPosition = this.mNextSelectedPosition;
                if (this.mPositionScroller != null) {
                    this.mPositionScroller.stop();
                }
                this.setNextSelectedPositionInt(position);
                this.layoutChildren();
                const next = this.mStackFromBottom ? this.mItemCount - 1 - this.mNextSelectedPosition : this.mNextSelectedPosition;
                const previous = this.mStackFromBottom ? this.mItemCount - 1 - previousSelectedPosition : previousSelectedPosition;
                const nextRow = next / this.mNumColumns;
                const previousRow = previous / this.mNumColumns;
                if (nextRow != previousRow) {
                    this.awakenScrollBars();
                }
            }
            onKeyDown(keyCode, event) {
                return this.commonKey(keyCode, 1, event);
            }
            onKeyMultiple(keyCode, repeatCount, event) {
                return this.commonKey(keyCode, repeatCount, event);
            }
            onKeyUp(keyCode, event) {
                return this.commonKey(keyCode, 1, event);
            }
            commonKey(keyCode, count, event) {
                if (this.mAdapter == null) {
                    return false;
                }
                if (this.mDataChanged) {
                    this.layoutChildren();
                }
                let handled = false;
                let action = event.getAction();
                if (action != KeyEvent.ACTION_UP) {
                    switch (keyCode) {
                        case KeyEvent.KEYCODE_DPAD_LEFT:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded() || this.arrowScroll(GridView.FOCUS_LEFT);
                            }
                            break;
                        case KeyEvent.KEYCODE_DPAD_RIGHT:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded() || this.arrowScroll(GridView.FOCUS_RIGHT);
                            }
                            break;
                        case KeyEvent.KEYCODE_DPAD_UP:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded() || this.arrowScroll(GridView.FOCUS_UP);
                            }
                            else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
                                handled = this.resurrectSelectionIfNeeded() || this.fullScroll(GridView.FOCUS_UP);
                            }
                            break;
                        case KeyEvent.KEYCODE_DPAD_DOWN:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded() || this.arrowScroll(GridView.FOCUS_DOWN);
                            }
                            else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
                                handled = this.resurrectSelectionIfNeeded() || this.fullScroll(GridView.FOCUS_DOWN);
                            }
                            break;
                        case KeyEvent.KEYCODE_DPAD_CENTER:
                        case KeyEvent.KEYCODE_ENTER:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded();
                                if (!handled && event.getRepeatCount() == 0 && this.getChildCount() > 0) {
                                    this.keyPressed();
                                    handled = true;
                                }
                            }
                            break;
                        case KeyEvent.KEYCODE_SPACE:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded() || this.pageScroll(GridView.FOCUS_DOWN);
                            }
                            else if (event.hasModifiers(KeyEvent.META_SHIFT_ON)) {
                                handled = this.resurrectSelectionIfNeeded() || this.pageScroll(GridView.FOCUS_UP);
                            }
                            break;
                        case KeyEvent.KEYCODE_PAGE_UP:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded() || this.pageScroll(GridView.FOCUS_UP);
                            }
                            else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
                                handled = this.resurrectSelectionIfNeeded() || this.fullScroll(GridView.FOCUS_UP);
                            }
                            break;
                        case KeyEvent.KEYCODE_PAGE_DOWN:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded() || this.pageScroll(GridView.FOCUS_DOWN);
                            }
                            else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
                                handled = this.resurrectSelectionIfNeeded() || this.fullScroll(GridView.FOCUS_DOWN);
                            }
                            break;
                        case KeyEvent.KEYCODE_MOVE_HOME:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded() || this.fullScroll(GridView.FOCUS_UP);
                            }
                            break;
                        case KeyEvent.KEYCODE_MOVE_END:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded() || this.fullScroll(GridView.FOCUS_DOWN);
                            }
                            break;
                        case KeyEvent.KEYCODE_TAB:
                            if (false) {
                                if (event.hasNoModifiers()) {
                                    handled = this.resurrectSelectionIfNeeded() || this.sequenceScroll(GridView.FOCUS_FORWARD);
                                }
                                else if (event.hasModifiers(KeyEvent.META_SHIFT_ON)) {
                                    handled = this.resurrectSelectionIfNeeded() || this.sequenceScroll(GridView.FOCUS_BACKWARD);
                                }
                            }
                            break;
                    }
                }
                if (handled) {
                    return true;
                }
                switch (action) {
                    case KeyEvent.ACTION_DOWN:
                        return super.onKeyDown(keyCode, event);
                    case KeyEvent.ACTION_UP:
                        return super.onKeyUp(keyCode, event);
                    default:
                        return false;
                }
            }
            pageScroll(direction) {
                let nextPage = -1;
                if (direction == GridView.FOCUS_UP) {
                    nextPage = Math.max(0, this.mSelectedPosition - this.getChildCount());
                }
                else if (direction == GridView.FOCUS_DOWN) {
                    nextPage = Math.min(this.mItemCount - 1, this.mSelectedPosition + this.getChildCount());
                }
                if (nextPage >= 0) {
                    this.setSelectionInt(nextPage);
                    this.invokeOnItemScrollListener();
                    this.awakenScrollBars();
                    return true;
                }
                return false;
            }
            fullScroll(direction) {
                let moved = false;
                if (direction == GridView.FOCUS_UP) {
                    this.mLayoutMode = GridView.LAYOUT_SET_SELECTION;
                    this.setSelectionInt(0);
                    this.invokeOnItemScrollListener();
                    moved = true;
                }
                else if (direction == GridView.FOCUS_DOWN) {
                    this.mLayoutMode = GridView.LAYOUT_SET_SELECTION;
                    this.setSelectionInt(this.mItemCount - 1);
                    this.invokeOnItemScrollListener();
                    moved = true;
                }
                if (moved) {
                    this.awakenScrollBars();
                }
                return moved;
            }
            arrowScroll(direction) {
                const selectedPosition = this.mSelectedPosition;
                const numColumns = this.mNumColumns;
                let startOfRowPos;
                let endOfRowPos;
                let moved = false;
                if (!this.mStackFromBottom) {
                    startOfRowPos = Math.floor(selectedPosition / numColumns) * numColumns;
                    endOfRowPos = Math.min(startOfRowPos + numColumns - 1, this.mItemCount - 1);
                }
                else {
                    const invertedSelection = this.mItemCount - 1 - selectedPosition;
                    endOfRowPos = this.mItemCount - 1 - (invertedSelection / numColumns) * numColumns;
                    startOfRowPos = Math.max(0, endOfRowPos - numColumns + 1);
                }
                switch (direction) {
                    case GridView.FOCUS_UP:
                        if (startOfRowPos > 0) {
                            this.mLayoutMode = GridView.LAYOUT_MOVE_SELECTION;
                            this.setSelectionInt(Math.max(0, selectedPosition - numColumns));
                            moved = true;
                        }
                        break;
                    case GridView.FOCUS_DOWN:
                        if (endOfRowPos < this.mItemCount - 1) {
                            this.mLayoutMode = GridView.LAYOUT_MOVE_SELECTION;
                            this.setSelectionInt(Math.min(selectedPosition + numColumns, this.mItemCount - 1));
                            moved = true;
                        }
                        break;
                    case GridView.FOCUS_LEFT:
                        if (selectedPosition > startOfRowPos) {
                            this.mLayoutMode = GridView.LAYOUT_MOVE_SELECTION;
                            this.setSelectionInt(Math.max(0, selectedPosition - 1));
                            moved = true;
                        }
                        break;
                    case GridView.FOCUS_RIGHT:
                        if (selectedPosition < endOfRowPos) {
                            this.mLayoutMode = GridView.LAYOUT_MOVE_SELECTION;
                            this.setSelectionInt(Math.min(selectedPosition + 1, this.mItemCount - 1));
                            moved = true;
                        }
                        break;
                }
                if (moved) {
                    this.playSoundEffect(SoundEffectConstants.getContantForFocusDirection(direction));
                    this.invokeOnItemScrollListener();
                }
                if (moved) {
                    this.awakenScrollBars();
                }
                return moved;
            }
            sequenceScroll(direction) {
                let selectedPosition = this.mSelectedPosition;
                let numColumns = this.mNumColumns;
                let count = this.mItemCount;
                let startOfRow;
                let endOfRow;
                if (!this.mStackFromBottom) {
                    startOfRow = (selectedPosition / numColumns) * numColumns;
                    endOfRow = Math.min(startOfRow + numColumns - 1, count - 1);
                }
                else {
                    let invertedSelection = count - 1 - selectedPosition;
                    endOfRow = count - 1 - (invertedSelection / numColumns) * numColumns;
                    startOfRow = Math.max(0, endOfRow - numColumns + 1);
                }
                let moved = false;
                let showScroll = false;
                switch (direction) {
                    case GridView.FOCUS_FORWARD:
                        if (selectedPosition < count - 1) {
                            this.mLayoutMode = GridView.LAYOUT_MOVE_SELECTION;
                            this.setSelectionInt(selectedPosition + 1);
                            moved = true;
                            showScroll = selectedPosition == endOfRow;
                        }
                        break;
                    case GridView.FOCUS_BACKWARD:
                        if (selectedPosition > 0) {
                            this.mLayoutMode = GridView.LAYOUT_MOVE_SELECTION;
                            this.setSelectionInt(selectedPosition - 1);
                            moved = true;
                            showScroll = selectedPosition == startOfRow;
                        }
                        break;
                }
                if (moved) {
                    this.playSoundEffect(SoundEffectConstants.getContantForFocusDirection(direction));
                    this.invokeOnItemScrollListener();
                }
                if (showScroll) {
                    this.awakenScrollBars();
                }
                return moved;
            }
            onFocusChanged(gainFocus, direction, previouslyFocusedRect) {
                super.onFocusChanged(gainFocus, direction, previouslyFocusedRect);
                let closestChildIndex = -1;
                if (gainFocus && previouslyFocusedRect != null) {
                    previouslyFocusedRect.offset(this.mScrollX, this.mScrollY);
                    let otherRect = this.mTempRect;
                    let minDistance = Integer.MAX_VALUE;
                    const childCount = this.getChildCount();
                    for (let i = 0; i < childCount; i++) {
                        if (!this.isCandidateSelection(i, direction)) {
                            continue;
                        }
                        const other = this.getChildAt(i);
                        other.getDrawingRect(otherRect);
                        this.offsetDescendantRectToMyCoords(other, otherRect);
                        let distance = GridView.getDistance(previouslyFocusedRect, otherRect, direction);
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestChildIndex = i;
                        }
                    }
                }
                if (closestChildIndex >= 0) {
                    this.setSelection(closestChildIndex + this.mFirstPosition);
                }
                else {
                    this.requestLayout();
                }
            }
            isCandidateSelection(childIndex, direction) {
                const count = this.getChildCount();
                const invertedIndex = count - 1 - childIndex;
                let rowStart;
                let rowEnd;
                if (!this.mStackFromBottom) {
                    rowStart = childIndex - (childIndex % this.mNumColumns);
                    rowEnd = Math.max(rowStart + this.mNumColumns - 1, count);
                }
                else {
                    rowEnd = count - 1 - (invertedIndex - (invertedIndex % this.mNumColumns));
                    rowStart = Math.max(0, rowEnd - this.mNumColumns + 1);
                }
                switch (direction) {
                    case View.FOCUS_RIGHT:
                        return childIndex == rowStart;
                    case View.FOCUS_DOWN:
                        return rowStart == 0;
                    case View.FOCUS_LEFT:
                        return childIndex == rowEnd;
                    case View.FOCUS_UP:
                        return rowEnd == count - 1;
                    case View.FOCUS_FORWARD:
                        return childIndex == rowStart && rowStart == 0;
                    case View.FOCUS_BACKWARD:
                        return childIndex == rowEnd && rowEnd == count - 1;
                    default:
                        throw Error(`new IllegalArgumentException("direction must be one of " + "{FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT, " + "FOCUS_FORWARD, FOCUS_BACKWARD}.")`);
                }
            }
            setGravity(gravity) {
                if (this.mGravity != gravity) {
                    this.mGravity = gravity;
                    this.requestLayoutIfNecessary();
                }
            }
            getGravity() {
                return this.mGravity;
            }
            setHorizontalSpacing(horizontalSpacing) {
                if (horizontalSpacing != this.mRequestedHorizontalSpacing) {
                    this.mRequestedHorizontalSpacing = horizontalSpacing;
                    this.requestLayoutIfNecessary();
                }
            }
            getHorizontalSpacing() {
                return this.mHorizontalSpacing;
            }
            getRequestedHorizontalSpacing() {
                return this.mRequestedHorizontalSpacing;
            }
            setVerticalSpacing(verticalSpacing) {
                if (verticalSpacing != this.mVerticalSpacing) {
                    this.mVerticalSpacing = verticalSpacing;
                    this.requestLayoutIfNecessary();
                }
            }
            getVerticalSpacing() {
                return this.mVerticalSpacing;
            }
            setStretchMode(stretchMode) {
                if (stretchMode != this.mStretchMode) {
                    this.mStretchMode = stretchMode;
                    this.requestLayoutIfNecessary();
                }
            }
            getStretchMode() {
                return this.mStretchMode;
            }
            setColumnWidth(columnWidth) {
                if (columnWidth != this.mRequestedColumnWidth) {
                    this.mRequestedColumnWidth = columnWidth;
                    this.requestLayoutIfNecessary();
                }
            }
            getColumnWidth() {
                return this.mColumnWidth;
            }
            getRequestedColumnWidth() {
                return this.mRequestedColumnWidth;
            }
            setNumColumns(numColumns) {
                if (numColumns != this.mRequestedNumColumns) {
                    this.mRequestedNumColumns = numColumns;
                    this.requestLayoutIfNecessary();
                }
            }
            getNumColumns() {
                return this.mNumColumns;
            }
            adjustViewsUpOrDown() {
                const childCount = this.getChildCount();
                if (childCount > 0) {
                    let delta;
                    let child;
                    if (!this.mStackFromBottom) {
                        child = this.getChildAt(0);
                        delta = child.getTop() - this.mListPadding.top;
                        if (this.mFirstPosition != 0) {
                            delta -= this.mVerticalSpacing;
                        }
                        if (delta < 0) {
                            delta = 0;
                        }
                    }
                    else {
                        child = this.getChildAt(childCount - 1);
                        delta = child.getBottom() - (this.getHeight() - this.mListPadding.bottom);
                        if (this.mFirstPosition + childCount < this.mItemCount) {
                            delta += this.mVerticalSpacing;
                        }
                        if (delta > 0) {
                            delta = 0;
                        }
                    }
                    if (delta != 0) {
                        this.offsetChildrenTopAndBottom(-delta);
                    }
                }
            }
            computeVerticalScrollExtent() {
                const count = this.getChildCount();
                if (count > 0) {
                    const numColumns = this.mNumColumns;
                    const rowCount = (count + numColumns - 1) / numColumns;
                    let extent = rowCount * 100;
                    let view = this.getChildAt(0);
                    const top = view.getTop();
                    let height = view.getHeight();
                    if (height > 0) {
                        extent += (top * 100) / height;
                    }
                    view = this.getChildAt(count - 1);
                    const bottom = view.getBottom();
                    height = view.getHeight();
                    if (height > 0) {
                        extent -= ((bottom - this.getHeight()) * 100) / height;
                    }
                    return extent;
                }
                return 0;
            }
            computeVerticalScrollOffset() {
                if (this.mFirstPosition >= 0 && this.getChildCount() > 0) {
                    const view = this.getChildAt(0);
                    const top = view.getTop();
                    let height = view.getHeight();
                    if (height > 0) {
                        const numColumns = this.mNumColumns;
                        const rowCount = (this.mItemCount + numColumns - 1) / numColumns;
                        const oddItemsOnFirstRow = this.isStackFromBottom() ? ((rowCount * numColumns) - this.mItemCount) : 0;
                        const whichRow = (this.mFirstPosition + oddItemsOnFirstRow) / numColumns;
                        return Math.max(whichRow * 100 - (top * 100) / height + Math.floor((this.mScrollY / this.getHeight() * rowCount * 100)), 0);
                    }
                }
                return 0;
            }
            computeVerticalScrollRange() {
                const numColumns = this.mNumColumns;
                const rowCount = (this.mItemCount + numColumns - 1) / numColumns;
                let result = Math.max(rowCount * 100, 0);
                if (this.mScrollY != 0) {
                    result += Math.abs(Math.floor((this.mScrollY / this.getHeight() * rowCount * 100)));
                }
                return result;
            }
        }
        GridView.NO_STRETCH = 0;
        GridView.STRETCH_SPACING = 1;
        GridView.STRETCH_COLUMN_WIDTH = 2;
        GridView.STRETCH_SPACING_UNIFORM = 3;
        GridView.AUTO_FIT = -1;
        widget.GridView = GridView;
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/graphics/Canvas.ts"/>
///<reference path="../../android/graphics/Rect.ts"/>
///<reference path="../../android/util/Log.ts"/>
///<reference path="../../android/view/FocusFinder.ts"/>
///<reference path="../../android/view/KeyEvent.ts"/>
///<reference path="../../android/view/MotionEvent.ts"/>
///<reference path="../../android/view/VelocityTracker.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewConfiguration.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../android/view/ViewParent.ts"/>
///<reference path="../../android/view/animation/AnimationUtils.ts"/>
///<reference path="../../java/util/List.ts"/>
///<reference path="../../java/lang/Integer.ts"/>
///<reference path="../../java/lang/System.ts"/>
///<reference path="../../android/widget/FrameLayout.ts"/>
///<reference path="../../android/widget/LinearLayout.ts"/>
///<reference path="../../android/widget/ListView.ts"/>
///<reference path="../../android/widget/OverScroller.ts"/>
///<reference path="../../android/widget/ScrollView.ts"/>
///<reference path="../../android/widget/TextView.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var Rect = android.graphics.Rect;
        var Log = android.util.Log;
        var FocusFinder = android.view.FocusFinder;
        var KeyEvent = android.view.KeyEvent;
        var MotionEvent = android.view.MotionEvent;
        var VelocityTracker = android.view.VelocityTracker;
        var View = android.view.View;
        var ViewConfiguration = android.view.ViewConfiguration;
        var ViewGroup = android.view.ViewGroup;
        var AnimationUtils = android.view.animation.AnimationUtils;
        var FrameLayout = android.widget.FrameLayout;
        var OverScroller = android.widget.OverScroller;
        var ScrollView = android.widget.ScrollView;
        class HorizontalScrollView extends FrameLayout {
            constructor(bindElement, rootElement) {
                super(bindElement, rootElement);
                this.mLastScroll = 0;
                this.mTempRect = new Rect();
                this.mLastMotionX = 0;
                this.mIsLayoutDirty = true;
                this.mChildToScrollTo = null;
                this.mIsBeingDragged = false;
                this.mSmoothScrollingEnabled = true;
                this.mMinimumVelocity = 0;
                this.mMaximumVelocity = 0;
                this.mOverscrollDistance = 0;
                this._mOverflingDistance = 0;
                this.mActivePointerId = HorizontalScrollView.INVALID_POINTER;
                this.initScrollView();
                this._attrBinder.addAttr('fillViewport', (value) => {
                    this.setFillViewport(this._attrBinder.parseBoolean(value));
                });
            }
            get mOverflingDistance() {
                if (this.mScrollX < -this._mOverflingDistance)
                    return -this.mScrollX;
                let overDistance = this.mScrollX - this.getScrollRange();
                if (overDistance > this._mOverflingDistance)
                    return overDistance;
                return this._mOverflingDistance;
            }
            set mOverflingDistance(value) {
                this._mOverflingDistance = value;
            }
            getLeftFadingEdgeStrength() {
                if (this.getChildCount() == 0) {
                    return 0.0;
                }
                const length = this.getHorizontalFadingEdgeLength();
                if (this.mScrollX < length) {
                    return this.mScrollX / length;
                }
                return 1.0;
            }
            getRightFadingEdgeStrength() {
                if (this.getChildCount() == 0) {
                    return 0.0;
                }
                const length = this.getHorizontalFadingEdgeLength();
                const rightEdge = this.getWidth() - this.mPaddingRight;
                const span = this.getChildAt(0).getRight() - this.mScrollX - rightEdge;
                if (span < length) {
                    return span / length;
                }
                return 1.0;
            }
            getMaxScrollAmount() {
                return Math.floor((HorizontalScrollView.MAX_SCROLL_FACTOR * (this.mRight - this.mLeft)));
            }
            initScrollView() {
                this.mScroller = new OverScroller();
                this.setFocusable(true);
                this.setDescendantFocusability(HorizontalScrollView.FOCUS_AFTER_DESCENDANTS);
                this.setWillNotDraw(false);
                const configuration = ViewConfiguration.get();
                this.mTouchSlop = configuration.getScaledTouchSlop();
                this.mMinimumVelocity = configuration.getScaledMinimumFlingVelocity();
                this.mMaximumVelocity = configuration.getScaledMaximumFlingVelocity();
                this.mOverscrollDistance = configuration.getScaledOverscrollDistance();
                this._mOverflingDistance = configuration.getScaledOverflingDistance();
                this.initScrollCache();
                this.setHorizontalScrollBarEnabled(true);
            }
            addView(...args) {
                if (this.getChildCount() > 0) {
                    throw new Error("ScrollView can host only one direct child");
                }
                return super.addView(...args);
            }
            canScroll() {
                let child = this.getChildAt(0);
                if (child != null) {
                    let childWidth = child.getWidth();
                    return this.getWidth() < childWidth + this.mPaddingLeft + this.mPaddingRight;
                }
                return false;
            }
            isFillViewport() {
                return this.mFillViewport;
            }
            setFillViewport(fillViewport) {
                if (fillViewport != this.mFillViewport) {
                    this.mFillViewport = fillViewport;
                    this.requestLayout();
                }
            }
            isSmoothScrollingEnabled() {
                return this.mSmoothScrollingEnabled;
            }
            setSmoothScrollingEnabled(smoothScrollingEnabled) {
                this.mSmoothScrollingEnabled = smoothScrollingEnabled;
            }
            onMeasure(widthMeasureSpec, heightMeasureSpec) {
                super.onMeasure(widthMeasureSpec, heightMeasureSpec);
                if (!this.mFillViewport) {
                    return;
                }
                const widthMode = HorizontalScrollView.MeasureSpec.getMode(widthMeasureSpec);
                if (widthMode == HorizontalScrollView.MeasureSpec.UNSPECIFIED) {
                    return;
                }
                if (this.getChildCount() > 0) {
                    const child = this.getChildAt(0);
                    let width = this.getMeasuredWidth();
                    if (child.getMeasuredWidth() < width) {
                        const lp = child.getLayoutParams();
                        let childHeightMeasureSpec = HorizontalScrollView.getChildMeasureSpec(heightMeasureSpec, this.mPaddingTop + this.mPaddingBottom, lp.height);
                        width -= this.mPaddingLeft;
                        width -= this.mPaddingRight;
                        let childWidthMeasureSpec = HorizontalScrollView.MeasureSpec.makeMeasureSpec(width, HorizontalScrollView.MeasureSpec.EXACTLY);
                        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
                    }
                }
            }
            dispatchKeyEvent(event) {
                return super.dispatchKeyEvent(event) || this.executeKeyEvent(event);
            }
            executeKeyEvent(event) {
                this.mTempRect.setEmpty();
                if (!this.canScroll()) {
                    if (this.isFocused()) {
                        let currentFocused = this.findFocus();
                        if (currentFocused == this)
                            currentFocused = null;
                        let nextFocused = FocusFinder.getInstance().findNextFocus(this, currentFocused, View.FOCUS_RIGHT);
                        return nextFocused != null && nextFocused != this && nextFocused.requestFocus(View.FOCUS_RIGHT);
                    }
                    return false;
                }
                let handled = false;
                if (event.getAction() == KeyEvent.ACTION_DOWN) {
                    switch (event.getKeyCode()) {
                        case KeyEvent.KEYCODE_DPAD_LEFT:
                            if (!event.isAltPressed()) {
                                handled = this.arrowScroll(View.FOCUS_LEFT);
                            }
                            else {
                                handled = this.fullScroll(View.FOCUS_LEFT);
                            }
                            break;
                        case KeyEvent.KEYCODE_DPAD_RIGHT:
                            if (!event.isAltPressed()) {
                                handled = this.arrowScroll(View.FOCUS_RIGHT);
                            }
                            else {
                                handled = this.fullScroll(View.FOCUS_RIGHT);
                            }
                            break;
                        case KeyEvent.KEYCODE_SPACE:
                            this.pageScroll(event.isShiftPressed() ? View.FOCUS_LEFT : View.FOCUS_RIGHT);
                            break;
                    }
                }
                return handled;
            }
            inChild(x, y) {
                if (this.getChildCount() > 0) {
                    const scrollX = this.mScrollX;
                    const child = this.getChildAt(0);
                    return !(y < child.getTop() || y >= child.getBottom() || x < child.getLeft() - scrollX || x >= child.getRight() - scrollX);
                }
                return false;
            }
            initOrResetVelocityTracker() {
                if (this.mVelocityTracker == null) {
                    this.mVelocityTracker = VelocityTracker.obtain();
                }
                else {
                    this.mVelocityTracker.clear();
                }
            }
            initVelocityTrackerIfNotExists() {
                if (this.mVelocityTracker == null) {
                    this.mVelocityTracker = VelocityTracker.obtain();
                }
            }
            recycleVelocityTracker() {
                if (this.mVelocityTracker != null) {
                    this.mVelocityTracker.recycle();
                    this.mVelocityTracker = null;
                }
            }
            requestDisallowInterceptTouchEvent(disallowIntercept) {
                if (disallowIntercept) {
                    this.recycleVelocityTracker();
                }
                super.requestDisallowInterceptTouchEvent(disallowIntercept);
            }
            onInterceptTouchEvent(ev) {
                const action = ev.getAction();
                if ((action == MotionEvent.ACTION_MOVE) && (this.mIsBeingDragged)) {
                    return true;
                }
                switch (action & MotionEvent.ACTION_MASK) {
                    case MotionEvent.ACTION_MOVE:
                        {
                            const activePointerId = this.mActivePointerId;
                            if (activePointerId == HorizontalScrollView.INVALID_POINTER) {
                                break;
                            }
                            const pointerIndex = ev.findPointerIndex(activePointerId);
                            if (pointerIndex == -1) {
                                Log.e(HorizontalScrollView.TAG, "Invalid pointerId=" + activePointerId + " in onInterceptTouchEvent");
                                break;
                            }
                            const x = Math.floor(ev.getX(pointerIndex));
                            const xDiff = Math.floor(Math.abs(x - this.mLastMotionX));
                            if (xDiff > this.mTouchSlop) {
                                this.mIsBeingDragged = true;
                                this.mLastMotionX = x;
                                this.initVelocityTrackerIfNotExists();
                                this.mVelocityTracker.addMovement(ev);
                                if (this.mParent != null)
                                    this.mParent.requestDisallowInterceptTouchEvent(true);
                            }
                            break;
                        }
                    case MotionEvent.ACTION_DOWN:
                        {
                            const x = Math.floor(ev.getX());
                            if (!this.inChild(Math.floor(x), Math.floor(ev.getY()))) {
                                this.mIsBeingDragged = false;
                                this.recycleVelocityTracker();
                                break;
                            }
                            this.mLastMotionX = x;
                            this.mActivePointerId = ev.getPointerId(0);
                            this.initOrResetVelocityTracker();
                            this.mVelocityTracker.addMovement(ev);
                            this.mIsBeingDragged = !this.mScroller.isFinished();
                            break;
                        }
                    case MotionEvent.ACTION_CANCEL:
                    case MotionEvent.ACTION_UP:
                        this.mIsBeingDragged = false;
                        this.mActivePointerId = HorizontalScrollView.INVALID_POINTER;
                        if (this.mScroller.springBack(this.mScrollX, this.mScrollY, 0, this.getScrollRange(), 0, 0)) {
                            this.postInvalidateOnAnimation();
                        }
                        break;
                    case MotionEvent.ACTION_POINTER_DOWN:
                        {
                            const index = ev.getActionIndex();
                            this.mLastMotionX = Math.floor(ev.getX(index));
                            this.mActivePointerId = ev.getPointerId(index);
                            break;
                        }
                    case MotionEvent.ACTION_POINTER_UP:
                        this.onSecondaryPointerUp(ev);
                        this.mLastMotionX = Math.floor(ev.getX(ev.findPointerIndex(this.mActivePointerId)));
                        break;
                }
                return this.mIsBeingDragged;
            }
            onTouchEvent(ev) {
                this.initVelocityTrackerIfNotExists();
                this.mVelocityTracker.addMovement(ev);
                const action = ev.getAction();
                switch (action & MotionEvent.ACTION_MASK) {
                    case MotionEvent.ACTION_DOWN:
                        {
                            if (this.getChildCount() == 0) {
                                return false;
                            }
                            if ((this.mIsBeingDragged = !this.mScroller.isFinished())) {
                                const parent = this.getParent();
                                if (parent != null) {
                                    parent.requestDisallowInterceptTouchEvent(true);
                                }
                            }
                            if (!this.mScroller.isFinished()) {
                                this.mScroller.abortAnimation();
                            }
                            this.mLastMotionX = Math.floor(ev.getX());
                            this.mActivePointerId = ev.getPointerId(0);
                            break;
                        }
                    case MotionEvent.ACTION_MOVE:
                        const activePointerIndex = ev.findPointerIndex(this.mActivePointerId);
                        if (activePointerIndex == -1) {
                            Log.e(HorizontalScrollView.TAG, "Invalid pointerId=" + this.mActivePointerId + " in onTouchEvent");
                            break;
                        }
                        const x = Math.floor(ev.getX(activePointerIndex));
                        let deltaX = this.mLastMotionX - x;
                        if (!this.mIsBeingDragged && Math.abs(deltaX) > this.mTouchSlop) {
                            const parent = this.getParent();
                            if (parent != null) {
                                parent.requestDisallowInterceptTouchEvent(true);
                            }
                            this.mIsBeingDragged = true;
                            if (deltaX > 0) {
                                deltaX -= this.mTouchSlop;
                            }
                            else {
                                deltaX += this.mTouchSlop;
                            }
                        }
                        if (this.mIsBeingDragged) {
                            this.mLastMotionX = x;
                            const oldX = this.mScrollX;
                            const oldY = this.mScrollY;
                            const range = this.getScrollRange();
                            const overscrollMode = this.getOverScrollMode();
                            const canOverscroll = overscrollMode == HorizontalScrollView.OVER_SCROLL_ALWAYS || (overscrollMode == HorizontalScrollView.OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
                            if (this.overScrollBy(deltaX, 0, this.mScrollX, 0, range, 0, this.mOverscrollDistance, 0, true)) {
                                this.mVelocityTracker.clear();
                            }
                            if (canOverscroll) {
                            }
                        }
                        break;
                    case MotionEvent.ACTION_UP:
                        if (this.mIsBeingDragged) {
                            const velocityTracker = this.mVelocityTracker;
                            velocityTracker.computeCurrentVelocity(1000, this.mMaximumVelocity);
                            let initialVelocity = Math.floor(velocityTracker.getXVelocity(this.mActivePointerId));
                            if (this.getChildCount() > 0) {
                                let isOverDrag = this.mScrollX < 0 || this.mScrollX > this.getScrollRange();
                                if (!isOverDrag && (Math.abs(initialVelocity) > this.mMinimumVelocity)) {
                                    this.fling(-initialVelocity);
                                }
                                else {
                                    if (this.mScroller.springBack(this.mScrollX, this.mScrollY, 0, this.getScrollRange(), 0, 0)) {
                                        this.postInvalidateOnAnimation();
                                    }
                                }
                            }
                            this.mActivePointerId = HorizontalScrollView.INVALID_POINTER;
                            this.mIsBeingDragged = false;
                            this.recycleVelocityTracker();
                        }
                        break;
                    case MotionEvent.ACTION_CANCEL:
                        if (this.mIsBeingDragged && this.getChildCount() > 0) {
                            if (this.mScroller.springBack(this.mScrollX, this.mScrollY, 0, this.getScrollRange(), 0, 0)) {
                                this.postInvalidateOnAnimation();
                            }
                            this.mActivePointerId = HorizontalScrollView.INVALID_POINTER;
                            this.mIsBeingDragged = false;
                            this.recycleVelocityTracker();
                        }
                        break;
                    case MotionEvent.ACTION_POINTER_UP:
                        this.onSecondaryPointerUp(ev);
                        break;
                }
                return true;
            }
            onSecondaryPointerUp(ev) {
                const pointerIndex = (ev.getAction() & MotionEvent.ACTION_POINTER_INDEX_MASK) >> MotionEvent.ACTION_POINTER_INDEX_SHIFT;
                const pointerId = ev.getPointerId(pointerIndex);
                if (pointerId == this.mActivePointerId) {
                    const newPointerIndex = pointerIndex == 0 ? 1 : 0;
                    this.mLastMotionX = Math.floor(ev.getX(newPointerIndex));
                    this.mActivePointerId = ev.getPointerId(newPointerIndex);
                    if (this.mVelocityTracker != null) {
                        this.mVelocityTracker.clear();
                    }
                }
            }
            onGenericMotionEvent(event) {
                if (event.isPointerEvent()) {
                    switch (event.getAction()) {
                        case MotionEvent.ACTION_SCROLL:
                            {
                                if (!this.mIsBeingDragged) {
                                    let hscroll;
                                    hscroll = event.getAxisValue(MotionEvent.AXIS_HSCROLL);
                                    if (hscroll != 0) {
                                        const delta = Math.floor((hscroll * this.getHorizontalScrollFactor()));
                                        const range = this.getScrollRange();
                                        let oldScrollX = this.mScrollX;
                                        let newScrollX = oldScrollX + delta;
                                        if (newScrollX < 0) {
                                            newScrollX = 0;
                                        }
                                        else if (newScrollX > range) {
                                            newScrollX = range;
                                        }
                                        if (newScrollX != oldScrollX) {
                                            super.scrollTo(newScrollX, this.mScrollY);
                                            return true;
                                        }
                                    }
                                }
                            }
                    }
                }
                return super.onGenericMotionEvent(event);
            }
            shouldDelayChildPressedState() {
                return true;
            }
            onOverScrolled(scrollX, scrollY, clampedX, clampedY) {
                if (!this.mScroller.isFinished()) {
                    const oldX = this.mScrollX;
                    const oldY = this.mScrollY;
                    this.mScrollX = scrollX;
                    this.mScrollY = scrollY;
                    this.invalidateParentIfNeeded();
                    this.onScrollChanged(this.mScrollX, this.mScrollY, oldX, oldY);
                    if (clampedX) {
                        this.mScroller.springBack(this.mScrollX, this.mScrollY, 0, this.getScrollRange(), 0, 0);
                    }
                }
                else {
                    super.scrollTo(scrollX, scrollY);
                }
                this.awakenScrollBars();
            }
            getScrollRange() {
                let scrollRange = 0;
                if (this.getChildCount() > 0) {
                    let child = this.getChildAt(0);
                    scrollRange = Math.max(0, child.getWidth() - (this.getWidth() - this.mPaddingLeft - this.mPaddingRight));
                }
                return scrollRange;
            }
            findFocusableViewInMyBounds(leftFocus, left, preferredFocusable) {
                const fadingEdgeLength = this.getHorizontalFadingEdgeLength() / 2;
                const leftWithoutFadingEdge = left + fadingEdgeLength;
                const rightWithoutFadingEdge = left + this.getWidth() - fadingEdgeLength;
                if ((preferredFocusable != null) && (preferredFocusable.getLeft() < rightWithoutFadingEdge) && (preferredFocusable.getRight() > leftWithoutFadingEdge)) {
                    return preferredFocusable;
                }
                return this.findFocusableViewInBounds(leftFocus, leftWithoutFadingEdge, rightWithoutFadingEdge);
            }
            findFocusableViewInBounds(leftFocus, left, right) {
                let focusables = this.getFocusables(View.FOCUS_FORWARD);
                let focusCandidate = null;
                let foundFullyContainedFocusable = false;
                let count = focusables.size();
                for (let i = 0; i < count; i++) {
                    let view = focusables.get(i);
                    let viewLeft = view.getLeft();
                    let viewRight = view.getRight();
                    if (left < viewRight && viewLeft < right) {
                        const viewIsFullyContained = (left < viewLeft) && (viewRight < right);
                        if (focusCandidate == null) {
                            focusCandidate = view;
                            foundFullyContainedFocusable = viewIsFullyContained;
                        }
                        else {
                            const viewIsCloserToBoundary = (leftFocus && viewLeft < focusCandidate.getLeft()) || (!leftFocus && viewRight > focusCandidate.getRight());
                            if (foundFullyContainedFocusable) {
                                if (viewIsFullyContained && viewIsCloserToBoundary) {
                                    focusCandidate = view;
                                }
                            }
                            else {
                                if (viewIsFullyContained) {
                                    focusCandidate = view;
                                    foundFullyContainedFocusable = true;
                                }
                                else if (viewIsCloserToBoundary) {
                                    focusCandidate = view;
                                }
                            }
                        }
                    }
                }
                return focusCandidate;
            }
            pageScroll(direction) {
                let right = direction == View.FOCUS_RIGHT;
                let width = this.getWidth();
                if (right) {
                    this.mTempRect.left = this.getScrollX() + width;
                    let count = this.getChildCount();
                    if (count > 0) {
                        let view = this.getChildAt(0);
                        if (this.mTempRect.left + width > view.getRight()) {
                            this.mTempRect.left = view.getRight() - width;
                        }
                    }
                }
                else {
                    this.mTempRect.left = this.getScrollX() - width;
                    if (this.mTempRect.left < 0) {
                        this.mTempRect.left = 0;
                    }
                }
                this.mTempRect.right = this.mTempRect.left + width;
                return this.scrollAndFocus(direction, this.mTempRect.left, this.mTempRect.right);
            }
            fullScroll(direction) {
                let right = direction == View.FOCUS_RIGHT;
                let width = this.getWidth();
                this.mTempRect.left = 0;
                this.mTempRect.right = width;
                if (right) {
                    let count = this.getChildCount();
                    if (count > 0) {
                        let view = this.getChildAt(0);
                        this.mTempRect.right = view.getRight();
                        this.mTempRect.left = this.mTempRect.right - width;
                    }
                }
                return this.scrollAndFocus(direction, this.mTempRect.left, this.mTempRect.right);
            }
            scrollAndFocus(direction, left, right) {
                let handled = true;
                let width = this.getWidth();
                let containerLeft = this.getScrollX();
                let containerRight = containerLeft + width;
                let goLeft = direction == View.FOCUS_LEFT;
                let newFocused = this.findFocusableViewInBounds(goLeft, left, right);
                if (newFocused == null) {
                    newFocused = this;
                }
                if (left >= containerLeft && right <= containerRight) {
                    handled = false;
                }
                else {
                    let delta = goLeft ? (left - containerLeft) : (right - containerRight);
                    this.doScrollX(delta);
                }
                if (newFocused != this.findFocus())
                    newFocused.requestFocus(direction);
                return handled;
            }
            arrowScroll(direction) {
                let currentFocused = this.findFocus();
                if (currentFocused == this)
                    currentFocused = null;
                let nextFocused = FocusFinder.getInstance().findNextFocus(this, currentFocused, direction);
                const maxJump = this.getMaxScrollAmount();
                if (nextFocused != null && this.isWithinDeltaOfScreen(nextFocused, maxJump)) {
                    nextFocused.getDrawingRect(this.mTempRect);
                    this.offsetDescendantRectToMyCoords(nextFocused, this.mTempRect);
                    let scrollDelta = this.computeScrollDeltaToGetChildRectOnScreen(this.mTempRect);
                    this.doScrollX(scrollDelta);
                    nextFocused.requestFocus(direction);
                }
                else {
                    let scrollDelta = maxJump;
                    if (direction == View.FOCUS_LEFT && this.getScrollX() < scrollDelta) {
                        scrollDelta = this.getScrollX();
                    }
                    else if (direction == View.FOCUS_RIGHT && this.getChildCount() > 0) {
                        let daRight = this.getChildAt(0).getRight();
                        let screenRight = this.getScrollX() + this.getWidth();
                        if (daRight - screenRight < maxJump) {
                            scrollDelta = daRight - screenRight;
                        }
                    }
                    if (scrollDelta == 0) {
                        return false;
                    }
                    this.doScrollX(direction == View.FOCUS_RIGHT ? scrollDelta : -scrollDelta);
                }
                if (currentFocused != null && currentFocused.isFocused() && this.isOffScreen(currentFocused)) {
                    const descendantFocusability = this.getDescendantFocusability();
                    this.setDescendantFocusability(ViewGroup.FOCUS_BEFORE_DESCENDANTS);
                    this.requestFocus();
                    this.setDescendantFocusability(descendantFocusability);
                }
                return true;
            }
            isOffScreen(descendant) {
                return !this.isWithinDeltaOfScreen(descendant, 0);
            }
            isWithinDeltaOfScreen(descendant, delta) {
                descendant.getDrawingRect(this.mTempRect);
                this.offsetDescendantRectToMyCoords(descendant, this.mTempRect);
                return (this.mTempRect.right + delta) >= this.getScrollX() && (this.mTempRect.left - delta) <= (this.getScrollX() + this.getWidth());
            }
            doScrollX(delta) {
                if (delta != 0) {
                    if (this.mSmoothScrollingEnabled) {
                        this.smoothScrollBy(delta, 0);
                    }
                    else {
                        this.scrollBy(delta, 0);
                    }
                }
            }
            smoothScrollBy(dx, dy) {
                if (this.getChildCount() == 0) {
                    return;
                }
                let duration = AnimationUtils.currentAnimationTimeMillis() - this.mLastScroll;
                if (duration > HorizontalScrollView.ANIMATED_SCROLL_GAP) {
                    const width = this.getWidth() - this.mPaddingRight - this.mPaddingLeft;
                    const right = this.getChildAt(0).getWidth();
                    const maxX = Math.max(0, right - width);
                    const scrollX = this.mScrollX;
                    dx = Math.max(0, Math.min(scrollX + dx, maxX)) - scrollX;
                    this.mScroller.startScroll(scrollX, this.mScrollY, dx, 0);
                    this.postInvalidateOnAnimation();
                }
                else {
                    if (!this.mScroller.isFinished()) {
                        this.mScroller.abortAnimation();
                    }
                    this.scrollBy(dx, dy);
                }
                this.mLastScroll = AnimationUtils.currentAnimationTimeMillis();
            }
            smoothScrollTo(x, y) {
                this.smoothScrollBy(x - this.mScrollX, y - this.mScrollY);
            }
            computeHorizontalScrollRange() {
                const count = this.getChildCount();
                const contentWidth = this.getWidth() - this.mPaddingLeft - this.mPaddingRight;
                if (count == 0) {
                    return contentWidth;
                }
                let scrollRange = this.getChildAt(0).getRight();
                const scrollX = this.mScrollX;
                const overscrollRight = Math.max(0, scrollRange - contentWidth);
                if (scrollX < 0) {
                    scrollRange -= scrollX;
                }
                else if (scrollX > overscrollRight) {
                    scrollRange += scrollX - overscrollRight;
                }
                return scrollRange;
            }
            computeHorizontalScrollOffset() {
                return Math.max(0, super.computeHorizontalScrollOffset());
            }
            measureChild(child, parentWidthMeasureSpec, parentHeightMeasureSpec) {
                let lp = child.getLayoutParams();
                let childWidthMeasureSpec;
                let childHeightMeasureSpec;
                childHeightMeasureSpec = HorizontalScrollView.getChildMeasureSpec(parentHeightMeasureSpec, this.mPaddingTop + this.mPaddingBottom, lp.height);
                childWidthMeasureSpec = HorizontalScrollView.MeasureSpec.makeMeasureSpec(0, HorizontalScrollView.MeasureSpec.UNSPECIFIED);
                child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
            }
            measureChildWithMargins(child, parentWidthMeasureSpec, widthUsed, parentHeightMeasureSpec, heightUsed) {
                const lp = child.getLayoutParams();
                const childHeightMeasureSpec = HorizontalScrollView.getChildMeasureSpec(parentHeightMeasureSpec, this.mPaddingTop + this.mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height);
                const childWidthMeasureSpec = HorizontalScrollView.MeasureSpec.makeMeasureSpec(lp.leftMargin + lp.rightMargin, HorizontalScrollView.MeasureSpec.UNSPECIFIED);
                child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
            }
            computeScroll() {
                if (this.mScroller.computeScrollOffset()) {
                    let oldX = this.mScrollX;
                    let oldY = this.mScrollY;
                    let x = this.mScroller.getCurrX();
                    let y = this.mScroller.getCurrY();
                    if (oldX != x || oldY != y) {
                        const range = this.getScrollRange();
                        const overscrollMode = this.getOverScrollMode();
                        const canOverscroll = overscrollMode == HorizontalScrollView.OVER_SCROLL_ALWAYS || (overscrollMode == HorizontalScrollView.OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
                        this.overScrollBy(x - oldX, y - oldY, oldX, oldY, range, 0, this.mOverflingDistance, 0, false);
                        this.onScrollChanged(this.mScrollX, this.mScrollY, oldX, oldY);
                        if (canOverscroll) {
                        }
                    }
                    if (!this.awakenScrollBars()) {
                        this.postInvalidateOnAnimation();
                    }
                }
            }
            scrollToChild(child) {
                child.getDrawingRect(this.mTempRect);
                this.offsetDescendantRectToMyCoords(child, this.mTempRect);
                let scrollDelta = this.computeScrollDeltaToGetChildRectOnScreen(this.mTempRect);
                if (scrollDelta != 0) {
                    this.scrollBy(scrollDelta, 0);
                }
            }
            scrollToChildRect(rect, immediate) {
                const delta = this.computeScrollDeltaToGetChildRectOnScreen(rect);
                const scroll = delta != 0;
                if (scroll) {
                    if (immediate) {
                        this.scrollBy(delta, 0);
                    }
                    else {
                        this.smoothScrollBy(delta, 0);
                    }
                }
                return scroll;
            }
            computeScrollDeltaToGetChildRectOnScreen(rect) {
                if (this.getChildCount() == 0)
                    return 0;
                let width = this.getWidth();
                let screenLeft = this.getScrollX();
                let screenRight = screenLeft + width;
                let fadingEdge = this.getHorizontalFadingEdgeLength();
                if (rect.left > 0) {
                    screenLeft += fadingEdge;
                }
                if (rect.right < this.getChildAt(0).getWidth()) {
                    screenRight -= fadingEdge;
                }
                let scrollXDelta = 0;
                if (rect.right > screenRight && rect.left > screenLeft) {
                    if (rect.width() > width) {
                        scrollXDelta += (rect.left - screenLeft);
                    }
                    else {
                        scrollXDelta += (rect.right - screenRight);
                    }
                    let right = this.getChildAt(0).getRight();
                    let distanceToRight = right - screenRight;
                    scrollXDelta = Math.min(scrollXDelta, distanceToRight);
                }
                else if (rect.left < screenLeft && rect.right < screenRight) {
                    if (rect.width() > width) {
                        scrollXDelta -= (screenRight - rect.right);
                    }
                    else {
                        scrollXDelta -= (screenLeft - rect.left);
                    }
                    scrollXDelta = Math.max(scrollXDelta, -this.getScrollX());
                }
                return scrollXDelta;
            }
            requestChildFocus(child, focused) {
                if (!this.mIsLayoutDirty) {
                    this.scrollToChild(focused);
                }
                else {
                    this.mChildToScrollTo = focused;
                }
                super.requestChildFocus(child, focused);
            }
            onRequestFocusInDescendants(direction, previouslyFocusedRect) {
                if (direction == View.FOCUS_FORWARD) {
                    direction = View.FOCUS_RIGHT;
                }
                else if (direction == View.FOCUS_BACKWARD) {
                    direction = View.FOCUS_LEFT;
                }
                const nextFocus = previouslyFocusedRect == null ? FocusFinder.getInstance().findNextFocus(this, null, direction) : FocusFinder.getInstance().findNextFocusFromRect(this, previouslyFocusedRect, direction);
                if (nextFocus == null) {
                    return false;
                }
                if (this.isOffScreen(nextFocus)) {
                    return false;
                }
                return nextFocus.requestFocus(direction, previouslyFocusedRect);
            }
            requestChildRectangleOnScreen(child, rectangle, immediate) {
                rectangle.offset(child.getLeft() - child.getScrollX(), child.getTop() - child.getScrollY());
                return this.scrollToChildRect(rectangle, immediate);
            }
            requestLayout() {
                this.mIsLayoutDirty = true;
                super.requestLayout();
            }
            onLayout(changed, l, t, r, b) {
                let childWidth = 0;
                let childMargins = 0;
                if (this.getChildCount() > 0) {
                    childWidth = this.getChildAt(0).getMeasuredWidth();
                    let childParams = this.getChildAt(0).getLayoutParams();
                    childMargins = childParams.leftMargin + childParams.rightMargin;
                }
                const available = r - l - this.getPaddingLeftWithForeground() - this.getPaddingRightWithForeground() - childMargins;
                const forceLeftGravity = (childWidth > available);
                this.layoutChildren(l, t, r, b, forceLeftGravity);
                this.mIsLayoutDirty = false;
                if (this.mChildToScrollTo != null && HorizontalScrollView.isViewDescendantOf(this.mChildToScrollTo, this)) {
                    this.scrollToChild(this.mChildToScrollTo);
                }
                this.mChildToScrollTo = null;
                if (!this.isLaidOut()) {
                    const scrollRange = Math.max(0, childWidth - (r - l - this.mPaddingLeft - this.mPaddingRight));
                    {
                        if (this.isLayoutRtl()) {
                            this.mScrollX = scrollRange - this.mScrollX;
                        }
                    }
                    if (this.mScrollX > scrollRange) {
                        this.mScrollX = scrollRange;
                    }
                    else if (this.mScrollX < 0) {
                        this.mScrollX = 0;
                    }
                }
                this.scrollTo(this.mScrollX, this.mScrollY);
            }
            onSizeChanged(w, h, oldw, oldh) {
                super.onSizeChanged(w, h, oldw, oldh);
                let currentFocused = this.findFocus();
                if (null == currentFocused || this == currentFocused)
                    return;
                const maxJump = this.mRight - this.mLeft;
                if (this.isWithinDeltaOfScreen(currentFocused, maxJump)) {
                    currentFocused.getDrawingRect(this.mTempRect);
                    this.offsetDescendantRectToMyCoords(currentFocused, this.mTempRect);
                    let scrollDelta = this.computeScrollDeltaToGetChildRectOnScreen(this.mTempRect);
                    this.doScrollX(scrollDelta);
                }
            }
            static isViewDescendantOf(child, parent) {
                if (child == parent) {
                    return true;
                }
                const theParent = child.getParent();
                return (theParent instanceof ViewGroup) && HorizontalScrollView.isViewDescendantOf(theParent, parent);
            }
            fling(velocityX) {
                if (this.getChildCount() > 0) {
                    let width = this.getWidth() - this.mPaddingRight - this.mPaddingLeft;
                    let right = this.getChildAt(0).getWidth();
                    this.mScroller.fling(this.mScrollX, this.mScrollY, velocityX, 0, 0, Math.max(0, right - width), 0, 0, width / 2, 0);
                    const movingRight = velocityX > 0;
                    let currentFocused = this.findFocus();
                    let newFocused = this.findFocusableViewInMyBounds(movingRight, this.mScroller.getFinalX(), currentFocused);
                    if (newFocused == null) {
                        newFocused = this;
                    }
                    if (newFocused != currentFocused) {
                        newFocused.requestFocus(movingRight ? View.FOCUS_RIGHT : View.FOCUS_LEFT);
                    }
                    this.postInvalidateOnAnimation();
                }
            }
            scrollTo(x, y) {
                if (this.getChildCount() > 0) {
                    let child = this.getChildAt(0);
                    x = HorizontalScrollView.clamp(x, this.getWidth() - this.mPaddingRight - this.mPaddingLeft, child.getWidth());
                    y = HorizontalScrollView.clamp(y, this.getHeight() - this.mPaddingBottom - this.mPaddingTop, child.getHeight());
                    if (x != this.mScrollX || y != this.mScrollY) {
                        super.scrollTo(x, y);
                    }
                }
            }
            setOverScrollMode(mode) {
                super.setOverScrollMode(mode);
            }
            draw(canvas) {
                super.draw(canvas);
            }
            static clamp(n, my, child) {
                if (my >= child || n < 0) {
                    return 0;
                }
                if ((my + n) > child) {
                    return child - my;
                }
                return n;
            }
        }
        HorizontalScrollView.ANIMATED_SCROLL_GAP = ScrollView.ANIMATED_SCROLL_GAP;
        HorizontalScrollView.MAX_SCROLL_FACTOR = ScrollView.MAX_SCROLL_FACTOR;
        HorizontalScrollView.TAG = "HorizontalScrollView";
        HorizontalScrollView.INVALID_POINTER = -1;
        widget.HorizontalScrollView = HorizontalScrollView;
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/1.
 */
///<reference path="Interpolator.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var animation;
        (function (animation) {
            class DecelerateInterpolator {
                constructor(factor = 1) {
                    this.mFactor = factor;
                }
                getInterpolation(input) {
                    let result;
                    if (this.mFactor == 1.0) {
                        result = (1.0 - (1.0 - input) * (1.0 - input));
                    }
                    else {
                        result = (1.0 - Math.pow((1.0 - input), 2 * this.mFactor));
                    }
                    return result;
                }
            }
            animation.DecelerateInterpolator = DecelerateInterpolator;
        })(animation = view.animation || (view.animation = {}));
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/28.
 */
///<reference path="List.ts"/>
///<reference path="ArrayList.ts"/>
var java;
(function (java) {
    var util;
    (function (util) {
        class Collections {
            static emptyList() {
                return Collections.EMPTY_LIST;
            }
        }
        Collections.EMPTY_LIST = new util.ArrayList();
        util.Collections = Collections;
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
var android;
(function (android) {
    var R;
    (function (R) {
        const div = document.createElement('div');
        function stringToElement(html) {
            div.innerHTML = html;
            return div.firstElementChild;
        }
        class layout {
            static get number_picker() {
                return stringToElement(`
                    <merge>
                        <ImageButton android:id="@+id/increment"
                            android:layout_width="fill_parent"
                            android:layout_height="wrap_content"
                            android:background="transparent"
                            android:state_pressed="#ddd"
                            android:paddingTop="22dip"
                            android:paddingBottom="22dip"
                            android:contentDescription="@string/number_picker_increment_button" ></ImageButton>

                        <View
                            android:id="@+id/numberpicker_input"
                            android:layout_width="fill_parent"
                            android:layout_height="wrap_content"></View>

                        <ImageButton android:id="@+id/decrement"
                            android:layout_width="fill_parent"
                            android:layout_height="wrap_content"
                            android:background="transparent"
                            android:state_pressed="#ddd"
                            android:paddingTop="22dip"
                            android:paddingBottom="22dip"
                            android:contentDescription="@string/number_picker_decrement_button" ></ImageButton>
                    </merge>`)
                    .cloneNode(true);
            }
        }
        R.layout = layout;
    })(R = android.R || (android.R = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/content/res/ColorStateList.ts"/>
///<reference path="../../android/graphics/Canvas.ts"/>
///<reference path="../../android/graphics/Color.ts"/>
///<reference path="../../android/graphics/Paint.ts"/>
///<reference path="../../android/graphics/Rect.ts"/>
///<reference path="../../android/graphics/drawable/Drawable.ts"/>
///<reference path="../../android/text/TextUtils.ts"/>
///<reference path="../../android/util/SparseArray.ts"/>
///<reference path="../../android/util/TypedValue.ts"/>
///<reference path="../../android/view/KeyEvent.ts"/>
///<reference path="../../android/view/MotionEvent.ts"/>
///<reference path="../../android/view/VelocityTracker.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewConfiguration.ts"/>
///<reference path="../../android/view/animation/DecelerateInterpolator.ts"/>
///<reference path="../../java/util/ArrayList.ts"/>
///<reference path="../../java/util/Collections.ts"/>
///<reference path="../../java/util/List.ts"/>
///<reference path="../../java/lang/Integer.ts"/>
///<reference path="../../java/lang/StringBuilder.ts"/>
///<reference path="../../java/lang/Runnable.ts"/>
///<reference path="../../android/widget/Button.ts"/>
///<reference path="../../android/widget/ImageButton.ts"/>
///<reference path="../../android/widget/LinearLayout.ts"/>
///<reference path="../../android/widget/OverScroller.ts"/>
///<reference path="../../android/widget/TextView.ts"/>
///<reference path="../../android/R/layout.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var Color = android.graphics.Color;
        var Paint = android.graphics.Paint;
        var Align = android.graphics.Paint.Align;
        var SparseArray = android.util.SparseArray;
        var KeyEvent = android.view.KeyEvent;
        var MotionEvent = android.view.MotionEvent;
        var VelocityTracker = android.view.VelocityTracker;
        var ViewConfiguration = android.view.ViewConfiguration;
        var DecelerateInterpolator = android.view.animation.DecelerateInterpolator;
        var Integer = java.lang.Integer;
        var LinearLayout = android.widget.LinearLayout;
        var OverScroller = android.widget.OverScroller;
        var R = android.R;
        class NumberPicker extends LinearLayout {
            constructor(bindElement, rootElement) {
                super(bindElement, rootElement);
                this.SELECTOR_WHEEL_ITEM_COUNT = 3;
                this.SELECTOR_MIDDLE_ITEM_INDEX = Math.floor(this.SELECTOR_WHEEL_ITEM_COUNT / 2);
                this.mSelectionDividersDistance = 0;
                this.mMinHeight_ = NumberPicker.SIZE_UNSPECIFIED;
                this.mMaxHeight = NumberPicker.SIZE_UNSPECIFIED;
                this.mMinWidth_ = NumberPicker.SIZE_UNSPECIFIED;
                this.mMaxWidth = NumberPicker.SIZE_UNSPECIFIED;
                this.mTextSize = 0;
                this.mSelectorTextGapHeight = 0;
                this.mMinValue = 0;
                this.mMaxValue = 0;
                this.mValue = 0;
                this.mLongPressUpdateInterval = NumberPicker.DEFAULT_LONG_PRESS_UPDATE_INTERVAL;
                this.mSelectorIndexToStringCache = new SparseArray();
                this.mSelectorElementHeight = 0;
                this.mInitialScrollOffset = Integer.MIN_VALUE;
                this.mCurrentScrollOffset = 0;
                this.mPreviousScrollerY = 0;
                this.mLastDownEventY = 0;
                this.mLastDownEventTime = 0;
                this.mLastDownOrMoveEventY = 0;
                this.mMinimumFlingVelocity = 0;
                this.mMaximumFlingVelocity = 0;
                this.mSolidColor = 0;
                this.mSelectionDividerHeight = 0;
                this.mScrollState = NumberPicker.OnScrollListener.SCROLL_STATE_IDLE;
                this.mTopSelectionDividerTop = 0;
                this.mBottomSelectionDividerBottom = 0;
                this.mLastHoveredChildVirtualViewId = 0;
                this.mLastHandledDownDpadKeyCode = -1;
                this.mHasSelectorWheel = true;
                this._attrBinder.addAttr('solidColor', (value) => {
                    this.mSolidColor = this._attrBinder.parseColor(value) || 0;
                });
                this._attrBinder.addAttr('selectionDivider', (value) => {
                    this.mSelectionDivider = this._attrBinder.parseDrawable(value);
                });
                this._attrBinder.addAttr('selectionDividerHeight', (value) => {
                    const defSelectionDividerHeight = NumberPicker.UNSCALED_DEFAULT_SELECTION_DIVIDER_HEIGHT
                        * this.getResources().getDisplayMetrics().density;
                    this.mSelectionDividerHeight = this._attrBinder.parseNumber(value, defSelectionDividerHeight);
                });
                this._attrBinder.addAttr('selectionDividersDistance', (value) => {
                    const defSelectionDividerDistance = NumberPicker.UNSCALED_DEFAULT_SELECTION_DIVIDERS_DISTANCE
                        * this.getResources().getDisplayMetrics().density;
                    this.mSelectionDividersDistance = this._attrBinder.parseNumber(value, defSelectionDividerDistance);
                });
                this._attrBinder.addAttr('internalMinHeight', (value) => {
                    this.mMinHeight_ = this._attrBinder.parseNumber(value, NumberPicker.SIZE_UNSPECIFIED);
                });
                this._attrBinder.addAttr('internalMaxHeight', (value) => {
                    this.mMaxHeight = this._attrBinder.parseNumber(value, NumberPicker.SIZE_UNSPECIFIED);
                });
                this._attrBinder.addAttr('internalMinWidth', (value) => {
                    this.mMinWidth_ = this._attrBinder.parseNumber(value, NumberPicker.SIZE_UNSPECIFIED);
                });
                this._attrBinder.addAttr('internalMaxWidth', (value) => {
                    this.mMaxWidth = this._attrBinder.parseNumber(value, NumberPicker.SIZE_UNSPECIFIED);
                });
                this._attrBinder.addAttr('internalMaxWidth', (value) => {
                    this.mMaxWidth = this._attrBinder.parseNumber(value, NumberPicker.SIZE_UNSPECIFIED);
                });
                this._attrBinder.addAttr('virtualButtonPressedDrawable', (value) => {
                    this.mVirtualButtonPressedDrawable = this._attrBinder.parseDrawable(value);
                });
                this._attrBinder.addAttr('textSize', (value) => {
                    this.mTextSize = this._attrBinder.parseNumber(value, this.mTextSize);
                    this.mSelectorWheelPaint.setTextSize(this.mTextSize);
                });
                this._attrBinder.addAttr('textColor', (value) => {
                    this.mSelectorWheelPaint.setColor(this._attrBinder.parseColor(value, this.mSelectorWheelPaint.getColor()));
                });
                this._attrBinder.addAttr('minValue', (value) => {
                    this.setMinValue(this._attrBinder.parseNumber(value, this.mMinValue));
                });
                this._attrBinder.addAttr('maxValue', (value) => {
                    this.setMaxValue(this._attrBinder.parseNumber(value, this.mMaxValue));
                });
                this._attrBinder.addAttr('itemCount', (value) => {
                    this.SELECTOR_WHEEL_ITEM_COUNT = this._attrBinder.parseNumber(value, this.SELECTOR_WHEEL_ITEM_COUNT);
                    this.SELECTOR_MIDDLE_ITEM_INDEX = Math.floor(this.SELECTOR_WHEEL_ITEM_COUNT / 2);
                    this.mSelectorIndices = new Array(this.SELECTOR_WHEEL_ITEM_COUNT);
                });
                this.mTextSize = Math.floor(16 * this.getResources().getDisplayMetrics().density);
                let paint = new Paint();
                paint.setAntiAlias(true);
                paint.setTextAlign(Align.CENTER);
                paint.setTextSize(this.mTextSize);
                paint.setColor(Color.DKGRAY);
                this.mSelectorWheelPaint = paint;
                this.mSelectorIndices = new Array(this.SELECTOR_WHEEL_ITEM_COUNT);
                this.applyDefaultAttributes(R.attr.numberPickerStyle);
                if (this.mMinHeight_ != NumberPicker.SIZE_UNSPECIFIED && this.mMaxHeight != NumberPicker.SIZE_UNSPECIFIED && this.mMinHeight_ > this.mMaxHeight) {
                    throw Error(`new IllegalArgumentException("minHeight > maxHeight")`);
                }
                if (this.mMinWidth_ != NumberPicker.SIZE_UNSPECIFIED && this.mMaxWidth != NumberPicker.SIZE_UNSPECIFIED && this.mMinWidth_ > this.mMaxWidth) {
                    throw Error(`new IllegalArgumentException("minWidth > maxWidth")`);
                }
                this.mComputeMaxWidth = (this.mMaxWidth == NumberPicker.SIZE_UNSPECIFIED);
                this.mPressedStateHelper = new NumberPicker.PressedStateHelper(this);
                this.setWillNotDraw(!this.mHasSelectorWheel);
                let configuration = ViewConfiguration.get();
                this.mMinimumFlingVelocity = configuration.getScaledMinimumFlingVelocity();
                this.mMaximumFlingVelocity = configuration.getScaledMaximumFlingVelocity() / NumberPicker.SELECTOR_MAX_FLING_VELOCITY_ADJUSTMENT;
                this.mFlingScroller = new OverScroller(null, true);
                this.mAdjustScroller = new OverScroller(new DecelerateInterpolator(2.5));
                this.updateInputTextView();
            }
            static getTwoDigitFormatter() {
                if (!NumberPicker.sTwoDigitFormatter) {
                    NumberPicker.sTwoDigitFormatter = new NumberPicker.TwoDigitFormatter();
                }
                return NumberPicker.sTwoDigitFormatter;
            }
            onLayout(changed, left, top, right, bottom) {
                if (!this.mHasSelectorWheel) {
                    super.onLayout(changed, left, top, right, bottom);
                    return;
                }
                const msrdWdth = this.getMeasuredWidth();
                const msrdHght = this.getMeasuredHeight();
                if (changed) {
                    this.initializeSelectorWheel();
                    this.initializeFadingEdges();
                    this.mTopSelectionDividerTop = (this.getHeight() - this.mSelectionDividersDistance) / 2 - this.mSelectionDividerHeight;
                    this.mBottomSelectionDividerBottom = this.mTopSelectionDividerTop + 2 * this.mSelectionDividerHeight + this.mSelectionDividersDistance;
                }
            }
            onMeasure(widthMeasureSpec, heightMeasureSpec) {
                if (!this.mHasSelectorWheel) {
                    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
                    return;
                }
                const newWidthMeasureSpec = this.makeMeasureSpec(widthMeasureSpec, this.mMaxWidth);
                const newHeightMeasureSpec = this.makeMeasureSpec(heightMeasureSpec, this.mMaxHeight);
                super.onMeasure(newWidthMeasureSpec, newHeightMeasureSpec);
                const widthSize = this.resolveSizeAndStateRespectingMinSize(this.mMinWidth_, this.getMeasuredWidth(), widthMeasureSpec);
                const heightSize = this.resolveSizeAndStateRespectingMinSize(this.mMinHeight_, this.getMeasuredHeight(), heightMeasureSpec);
                this.setMeasuredDimension(widthSize, heightSize);
            }
            moveToFinalScrollerPosition(scroller) {
                scroller.forceFinished(true);
                let amountToScroll = scroller.getFinalY() - scroller.getCurrY();
                let futureScrollOffset = (this.mCurrentScrollOffset + amountToScroll) % this.mSelectorElementHeight;
                let overshootAdjustment = this.mInitialScrollOffset - futureScrollOffset;
                if (overshootAdjustment != 0) {
                    if (Math.abs(overshootAdjustment) > this.mSelectorElementHeight / 2) {
                        if (overshootAdjustment > 0) {
                            overshootAdjustment -= this.mSelectorElementHeight;
                        }
                        else {
                            overshootAdjustment += this.mSelectorElementHeight;
                        }
                    }
                    amountToScroll += overshootAdjustment;
                    this.scrollBy(0, amountToScroll);
                    return true;
                }
                return false;
            }
            onInterceptTouchEvent(event) {
                if (!this.mHasSelectorWheel || !this.isEnabled()) {
                    return false;
                }
                const action = event.getActionMasked();
                switch (action) {
                    case MotionEvent.ACTION_DOWN:
                        {
                            this.removeAllCallbacks();
                            this.mLastDownOrMoveEventY = this.mLastDownEventY = event.getY();
                            this.mLastDownEventTime = event.getEventTime();
                            this.mIngonreMoveEvents = false;
                            this.mShowSoftInputOnTap = false;
                            if (this.mLastDownEventY < this.mTopSelectionDividerTop) {
                                if (this.mScrollState == NumberPicker.OnScrollListener.SCROLL_STATE_IDLE) {
                                    this.mPressedStateHelper.buttonPressDelayed(NumberPicker.PressedStateHelper.BUTTON_DECREMENT);
                                }
                            }
                            else if (this.mLastDownEventY > this.mBottomSelectionDividerBottom) {
                                if (this.mScrollState == NumberPicker.OnScrollListener.SCROLL_STATE_IDLE) {
                                    this.mPressedStateHelper.buttonPressDelayed(NumberPicker.PressedStateHelper.BUTTON_INCREMENT);
                                }
                            }
                            this.getParent().requestDisallowInterceptTouchEvent(true);
                            if (!this.mFlingScroller.isFinished()) {
                                this.mFlingScroller.forceFinished(true);
                                this.mAdjustScroller.forceFinished(true);
                                this.onScrollStateChange(NumberPicker.OnScrollListener.SCROLL_STATE_IDLE);
                            }
                            else if (!this.mAdjustScroller.isFinished()) {
                                this.mFlingScroller.forceFinished(true);
                                this.mAdjustScroller.forceFinished(true);
                            }
                            else if (this.mLastDownEventY < this.mTopSelectionDividerTop) {
                                this.hideSoftInput();
                                this.postChangeCurrentByOneFromLongPress(false, ViewConfiguration.getLongPressTimeout());
                            }
                            else if (this.mLastDownEventY > this.mBottomSelectionDividerBottom) {
                                this.hideSoftInput();
                                this.postChangeCurrentByOneFromLongPress(true, ViewConfiguration.getLongPressTimeout());
                            }
                            else {
                                this.mShowSoftInputOnTap = true;
                                this.postBeginSoftInputOnLongPressCommand();
                            }
                            return true;
                        }
                }
                return false;
            }
            onTouchEvent(event) {
                if (!this.isEnabled() || !this.mHasSelectorWheel) {
                    return false;
                }
                if (this.mVelocityTracker == null) {
                    this.mVelocityTracker = VelocityTracker.obtain();
                }
                this.mVelocityTracker.addMovement(event);
                let action = event.getActionMasked();
                switch (action) {
                    case MotionEvent.ACTION_MOVE:
                        {
                            if (this.mIngonreMoveEvents) {
                                break;
                            }
                            let currentMoveY = event.getY();
                            if (this.mScrollState != NumberPicker.OnScrollListener.SCROLL_STATE_TOUCH_SCROLL) {
                                let deltaDownY = Math.floor(Math.abs(currentMoveY - this.mLastDownEventY));
                                if (deltaDownY > this.mTouchSlop) {
                                    this.removeAllCallbacks();
                                    this.onScrollStateChange(NumberPicker.OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
                                }
                            }
                            else {
                                let deltaMoveY = Math.floor(((currentMoveY - this.mLastDownOrMoveEventY)));
                                this.scrollBy(0, deltaMoveY);
                                this.invalidate();
                            }
                            this.mLastDownOrMoveEventY = currentMoveY;
                        }
                        break;
                    case MotionEvent.ACTION_UP:
                        {
                            this.removeBeginSoftInputCommand();
                            this.removeChangeCurrentByOneFromLongPress();
                            this.mPressedStateHelper.cancel();
                            let velocityTracker = this.mVelocityTracker;
                            velocityTracker.computeCurrentVelocity(1000, this.mMaximumFlingVelocity);
                            let initialVelocity = Math.floor(velocityTracker.getYVelocity());
                            if (Math.abs(initialVelocity) > this.mMinimumFlingVelocity) {
                                this.fling(initialVelocity);
                                this.onScrollStateChange(NumberPicker.OnScrollListener.SCROLL_STATE_FLING);
                            }
                            else {
                                let eventY = Math.floor(event.getY());
                                let deltaMoveY = Math.floor(Math.abs(eventY - this.mLastDownEventY));
                                let deltaTime = event.getEventTime() - this.mLastDownEventTime;
                                if (deltaMoveY <= this.mTouchSlop && deltaTime < ViewConfiguration.getTapTimeout()) {
                                    if (this.mShowSoftInputOnTap) {
                                        this.mShowSoftInputOnTap = false;
                                        this.showSoftInput();
                                    }
                                    else {
                                        let selectorIndexOffset = (eventY / this.mSelectorElementHeight) - this.SELECTOR_MIDDLE_ITEM_INDEX;
                                        if (selectorIndexOffset > 0) {
                                            this.changeValueByOne(true);
                                            this.mPressedStateHelper.buttonTapped(NumberPicker.PressedStateHelper.BUTTON_INCREMENT);
                                        }
                                        else if (selectorIndexOffset < 0) {
                                            this.changeValueByOne(false);
                                            this.mPressedStateHelper.buttonTapped(NumberPicker.PressedStateHelper.BUTTON_DECREMENT);
                                        }
                                    }
                                }
                                else {
                                    this.ensureScrollWheelAdjusted();
                                }
                                this.onScrollStateChange(NumberPicker.OnScrollListener.SCROLL_STATE_IDLE);
                            }
                            this.mVelocityTracker.recycle();
                            this.mVelocityTracker = null;
                        }
                        break;
                }
                return true;
            }
            dispatchTouchEvent(event) {
                const action = event.getActionMasked();
                switch (action) {
                    case MotionEvent.ACTION_CANCEL:
                    case MotionEvent.ACTION_UP:
                        this.removeAllCallbacks();
                        break;
                }
                return super.dispatchTouchEvent(event);
            }
            dispatchKeyEvent(event) {
                const keyCode = event.getKeyCode();
                switch (keyCode) {
                    case KeyEvent.KEYCODE_DPAD_CENTER:
                    case KeyEvent.KEYCODE_ENTER:
                        this.removeAllCallbacks();
                        break;
                    case KeyEvent.KEYCODE_DPAD_DOWN:
                    case KeyEvent.KEYCODE_DPAD_UP:
                        if (!this.mHasSelectorWheel) {
                            break;
                        }
                        switch (event.getAction()) {
                            case KeyEvent.ACTION_DOWN:
                                if (this.mWrapSelectorWheel || (keyCode == KeyEvent.KEYCODE_DPAD_DOWN) ? this.getValue() < this.getMaxValue() : this.getValue() > this.getMinValue()) {
                                    this.requestFocus();
                                    this.mLastHandledDownDpadKeyCode = keyCode;
                                    this.removeAllCallbacks();
                                    if (this.mFlingScroller.isFinished()) {
                                        this.changeValueByOne(keyCode == KeyEvent.KEYCODE_DPAD_DOWN);
                                    }
                                    return true;
                                }
                                break;
                            case KeyEvent.ACTION_UP:
                                if (this.mLastHandledDownDpadKeyCode == keyCode) {
                                    this.mLastHandledDownDpadKeyCode = -1;
                                    return true;
                                }
                                break;
                        }
                }
                return super.dispatchKeyEvent(event);
            }
            computeScroll() {
                let scroller = this.mFlingScroller;
                if (scroller.isFinished()) {
                    scroller = this.mAdjustScroller;
                    if (scroller.isFinished()) {
                        return;
                    }
                }
                scroller.computeScrollOffset();
                let currentScrollerY = scroller.getCurrY();
                if (this.mPreviousScrollerY == 0) {
                    this.mPreviousScrollerY = scroller.getStartY();
                }
                this.scrollBy(0, currentScrollerY - this.mPreviousScrollerY);
                this.mPreviousScrollerY = currentScrollerY;
                if (scroller.isFinished()) {
                    this.onScrollerFinished(scroller);
                }
                else {
                    this.invalidate();
                }
            }
            setEnabled(enabled) {
                super.setEnabled(enabled);
                if (!this.mHasSelectorWheel) {
                }
                if (!this.mHasSelectorWheel) {
                }
            }
            scrollBy(x, y) {
                let selectorIndices = this.mSelectorIndices;
                if (!this.mWrapSelectorWheel && y > 0 && selectorIndices[this.SELECTOR_MIDDLE_ITEM_INDEX] <= this.mMinValue) {
                    this.mCurrentScrollOffset = this.mInitialScrollOffset;
                    return;
                }
                if (!this.mWrapSelectorWheel && y < 0 && selectorIndices[this.SELECTOR_MIDDLE_ITEM_INDEX] >= this.mMaxValue) {
                    this.mCurrentScrollOffset = this.mInitialScrollOffset;
                    return;
                }
                this.mCurrentScrollOffset += y;
                while (this.mCurrentScrollOffset - this.mInitialScrollOffset > this.mSelectorTextGapHeight) {
                    this.mCurrentScrollOffset -= this.mSelectorElementHeight;
                    this.decrementSelectorIndices(selectorIndices);
                    this.setValueInternal(selectorIndices[this.SELECTOR_MIDDLE_ITEM_INDEX], true);
                    if (!this.mWrapSelectorWheel && selectorIndices[this.SELECTOR_MIDDLE_ITEM_INDEX] <= this.mMinValue) {
                        this.mCurrentScrollOffset = this.mInitialScrollOffset;
                    }
                }
                while (this.mCurrentScrollOffset - this.mInitialScrollOffset < -this.mSelectorTextGapHeight) {
                    this.mCurrentScrollOffset += this.mSelectorElementHeight;
                    this.incrementSelectorIndices(selectorIndices);
                    this.setValueInternal(selectorIndices[this.SELECTOR_MIDDLE_ITEM_INDEX], true);
                    if (!this.mWrapSelectorWheel && selectorIndices[this.SELECTOR_MIDDLE_ITEM_INDEX] >= this.mMaxValue) {
                        this.mCurrentScrollOffset = this.mInitialScrollOffset;
                    }
                }
            }
            computeVerticalScrollOffset() {
                return this.mCurrentScrollOffset;
            }
            computeVerticalScrollRange() {
                return (this.mMaxValue - this.mMinValue + 1) * this.mSelectorElementHeight;
            }
            computeVerticalScrollExtent() {
                return this.getHeight();
            }
            getSolidColor() {
                return this.mSolidColor;
            }
            setOnValueChangedListener(onValueChangedListener) {
                this.mOnValueChangeListener = onValueChangedListener;
            }
            setOnScrollListener(onScrollListener) {
                this.mOnScrollListener = onScrollListener;
            }
            setFormatter(formatter) {
                if (formatter == this.mFormatter) {
                    return;
                }
                this.mFormatter = formatter;
                this.initializeSelectorWheelIndices();
                this.updateInputTextView();
            }
            setValue(value) {
                this.setValueInternal(value, false);
            }
            showSoftInput() {
            }
            hideSoftInput() {
            }
            tryComputeMaxWidth() {
                if (!this.mComputeMaxWidth) {
                    return;
                }
                let maxTextWidth = 0;
                if (this.mDisplayedValues == null) {
                    let maxDigitWidth = 0;
                    for (let i = 0; i <= 9; i++) {
                        const digitWidth = this.mSelectorWheelPaint.measureText(NumberPicker.formatNumberWithLocale(i));
                        if (digitWidth > maxDigitWidth) {
                            maxDigitWidth = digitWidth;
                        }
                    }
                    let numberOfDigits = 0;
                    let current = this.mMaxValue;
                    while (current > 0) {
                        numberOfDigits++;
                        current = current / 10;
                    }
                    maxTextWidth = Math.floor((numberOfDigits * maxDigitWidth));
                }
                else {
                    const valueCount = this.mDisplayedValues.length;
                    for (let i = 0; i < valueCount; i++) {
                        const textWidth = this.mSelectorWheelPaint.measureText(this.mDisplayedValues[i]);
                        if (textWidth > maxTextWidth) {
                            maxTextWidth = Math.floor(textWidth);
                        }
                    }
                }
                if (this.mMaxWidth != maxTextWidth) {
                    if (maxTextWidth > this.mMinWidth_) {
                        this.mMaxWidth = maxTextWidth;
                    }
                    else {
                        this.mMaxWidth = this.mMinWidth_;
                    }
                    this.invalidate();
                }
            }
            getWrapSelectorWheel() {
                return this.mWrapSelectorWheel;
            }
            setWrapSelectorWheel(wrapSelectorWheel) {
                const wrappingAllowed = (this.mMaxValue - this.mMinValue) >= this.mSelectorIndices.length;
                if ((!wrapSelectorWheel || wrappingAllowed) && wrapSelectorWheel != this.mWrapSelectorWheel) {
                    this.mWrapSelectorWheel = wrapSelectorWheel;
                }
            }
            setOnLongPressUpdateInterval(intervalMillis) {
                this.mLongPressUpdateInterval = intervalMillis;
            }
            getValue() {
                return this.mValue;
            }
            getMinValue() {
                return this.mMinValue;
            }
            setMinValue(minValue) {
                if (this.mMinValue == minValue) {
                    return;
                }
                if (minValue < 0) {
                    throw Error(`new IllegalArgumentException("minValue must be >= 0")`);
                }
                this.mMinValue = minValue;
                if (this.mMinValue > this.mValue) {
                    this.mValue = this.mMinValue;
                }
                let wrapSelectorWheel = this.mMaxValue - this.mMinValue > this.mSelectorIndices.length;
                this.setWrapSelectorWheel(wrapSelectorWheel);
                this.initializeSelectorWheelIndices();
                this.updateInputTextView();
                this.tryComputeMaxWidth();
                this.invalidate();
            }
            getMaxValue() {
                return this.mMaxValue;
            }
            setMaxValue(maxValue) {
                if (this.mMaxValue == maxValue) {
                    return;
                }
                if (maxValue < 0) {
                    throw Error(`new IllegalArgumentException("maxValue must be >= 0")`);
                }
                this.mMaxValue = maxValue;
                if (this.mMaxValue < this.mValue) {
                    this.mValue = this.mMaxValue;
                }
                let wrapSelectorWheel = this.mMaxValue - this.mMinValue > this.mSelectorIndices.length;
                this.setWrapSelectorWheel(wrapSelectorWheel);
                this.initializeSelectorWheelIndices();
                this.updateInputTextView();
                this.tryComputeMaxWidth();
                this.invalidate();
            }
            getDisplayedValues() {
                return this.mDisplayedValues;
            }
            setDisplayedValues(displayedValues) {
                if (this.mDisplayedValues == displayedValues) {
                    return;
                }
                this.mDisplayedValues = displayedValues;
                if (this.mDisplayedValues != null) {
                }
                else {
                }
                this.updateInputTextView();
                this.initializeSelectorWheelIndices();
                this.tryComputeMaxWidth();
            }
            getTopFadingEdgeStrength() {
                return NumberPicker.TOP_AND_BOTTOM_FADING_EDGE_STRENGTH;
            }
            getBottomFadingEdgeStrength() {
                return NumberPicker.TOP_AND_BOTTOM_FADING_EDGE_STRENGTH;
            }
            onDetachedFromWindow() {
                super.onDetachedFromWindow();
                this.removeAllCallbacks();
            }
            onDraw(canvas) {
                if (!this.mHasSelectorWheel) {
                    super.onDraw(canvas);
                    return;
                }
                let x = (this.mRight - this.mLeft) / 2;
                let y = this.mCurrentScrollOffset;
                if (this.mVirtualButtonPressedDrawable != null && this.mScrollState == NumberPicker.OnScrollListener.SCROLL_STATE_IDLE) {
                    if (this.mDecrementVirtualButtonPressed) {
                        this.mVirtualButtonPressedDrawable.setState(NumberPicker.PRESSED_STATE_SET);
                        this.mVirtualButtonPressedDrawable.setBounds(0, 0, this.mRight, this.mTopSelectionDividerTop);
                        this.mVirtualButtonPressedDrawable.draw(canvas);
                    }
                    if (this.mIncrementVirtualButtonPressed) {
                        this.mVirtualButtonPressedDrawable.setState(NumberPicker.PRESSED_STATE_SET);
                        this.mVirtualButtonPressedDrawable.setBounds(0, this.mBottomSelectionDividerBottom, this.mRight, this.mBottom);
                        this.mVirtualButtonPressedDrawable.draw(canvas);
                    }
                }
                let selectorIndices = this.mSelectorIndices;
                for (let i = 0; i < selectorIndices.length; i++) {
                    let selectorIndex = selectorIndices[i];
                    let scrollSelectorValue = this.mSelectorIndexToStringCache.get(selectorIndex);
                    canvas.drawText(scrollSelectorValue, x, y, this.mSelectorWheelPaint);
                    y += this.mSelectorElementHeight;
                }
                if (this.mSelectionDivider != null) {
                    let topOfTopDivider = this.mTopSelectionDividerTop;
                    let bottomOfTopDivider = topOfTopDivider + this.mSelectionDividerHeight;
                    this.mSelectionDivider.setBounds(0, topOfTopDivider, this.mRight, bottomOfTopDivider);
                    this.mSelectionDivider.draw(canvas);
                    let bottomOfBottomDivider = this.mBottomSelectionDividerBottom;
                    let topOfBottomDivider = bottomOfBottomDivider - this.mSelectionDividerHeight;
                    this.mSelectionDivider.setBounds(0, topOfBottomDivider, this.mRight, bottomOfBottomDivider);
                    this.mSelectionDivider.draw(canvas);
                }
            }
            makeMeasureSpec(measureSpec, maxSize) {
                if (maxSize == NumberPicker.SIZE_UNSPECIFIED) {
                    return measureSpec;
                }
                const size = NumberPicker.MeasureSpec.getSize(measureSpec);
                const mode = NumberPicker.MeasureSpec.getMode(measureSpec);
                switch (mode) {
                    case NumberPicker.MeasureSpec.EXACTLY:
                        return measureSpec;
                    case NumberPicker.MeasureSpec.AT_MOST:
                        return NumberPicker.MeasureSpec.makeMeasureSpec(Math.min(size, maxSize), NumberPicker.MeasureSpec.EXACTLY);
                    case NumberPicker.MeasureSpec.UNSPECIFIED:
                        return NumberPicker.MeasureSpec.makeMeasureSpec(maxSize, NumberPicker.MeasureSpec.EXACTLY);
                    default:
                        throw Error(`new IllegalArgumentException("Unknown measure mode: " + mode)`);
                }
            }
            resolveSizeAndStateRespectingMinSize(minSize, measuredSize, measureSpec) {
                if (minSize != NumberPicker.SIZE_UNSPECIFIED) {
                    const desiredWidth = Math.max(minSize, measuredSize);
                    return NumberPicker.resolveSizeAndState(desiredWidth, measureSpec, 0);
                }
                else {
                    return measuredSize;
                }
            }
            initializeSelectorWheelIndices() {
                this.mSelectorIndexToStringCache.clear();
                let selectorIndices = this.mSelectorIndices;
                let current = this.getValue();
                for (let i = 0; i < this.mSelectorIndices.length; i++) {
                    let selectorIndex = Math.floor(current + (i - this.SELECTOR_MIDDLE_ITEM_INDEX));
                    if (this.mWrapSelectorWheel) {
                        selectorIndex = this.getWrappedSelectorIndex(selectorIndex);
                    }
                    selectorIndices[i] = selectorIndex;
                    this.ensureCachedScrollSelectorValue(selectorIndices[i]);
                }
            }
            setValueInternal(current, notifyChange) {
                if (this.mValue == current) {
                    return;
                }
                if (this.mWrapSelectorWheel) {
                    current = this.getWrappedSelectorIndex(current);
                }
                else {
                    current = Math.max(current, this.mMinValue);
                    current = Math.min(current, this.mMaxValue);
                }
                let previous = this.mValue;
                this.mValue = current;
                this.updateInputTextView();
                if (notifyChange) {
                    this.notifyChange(previous, current);
                }
                this.initializeSelectorWheelIndices();
                this.invalidate();
            }
            changeValueByOne(increment) {
                if (this.mHasSelectorWheel) {
                    if (!this.moveToFinalScrollerPosition(this.mFlingScroller)) {
                        this.moveToFinalScrollerPosition(this.mAdjustScroller);
                    }
                    this.mPreviousScrollerY = 0;
                    if (increment) {
                        this.mFlingScroller.startScroll(0, 0, 0, -this.mSelectorElementHeight, NumberPicker.SNAP_SCROLL_DURATION);
                    }
                    else {
                        this.mFlingScroller.startScroll(0, 0, 0, this.mSelectorElementHeight, NumberPicker.SNAP_SCROLL_DURATION);
                    }
                    this.invalidate();
                }
                else {
                    if (increment) {
                        this.setValueInternal(this.mValue + 1, true);
                    }
                    else {
                        this.setValueInternal(this.mValue - 1, true);
                    }
                }
            }
            initializeSelectorWheel() {
                this.initializeSelectorWheelIndices();
                let selectorIndices = this.mSelectorIndices;
                let totalTextHeight = selectorIndices.length * this.mTextSize;
                let totalTextGapHeight = (this.mBottom - this.mTop) - totalTextHeight;
                let textGapCount = selectorIndices.length;
                this.mSelectorTextGapHeight = Math.floor((totalTextGapHeight / textGapCount + 0.5));
                this.mSelectorElementHeight = this.mTextSize + this.mSelectorTextGapHeight;
                let editTextTextPosition = this.getHeight() / 2 + this.mTextSize / 2;
                this.mInitialScrollOffset = editTextTextPosition - (this.mSelectorElementHeight * this.SELECTOR_MIDDLE_ITEM_INDEX);
                this.mCurrentScrollOffset = this.mInitialScrollOffset;
                this.updateInputTextView();
            }
            initializeFadingEdges() {
                this.setVerticalFadingEdgeEnabled(true);
                this.setFadingEdgeLength((this.mBottom - this.mTop - this.mTextSize) / 2);
            }
            onScrollerFinished(scroller) {
                if (scroller == this.mFlingScroller) {
                    if (!this.ensureScrollWheelAdjusted()) {
                        this.updateInputTextView();
                    }
                    this.onScrollStateChange(NumberPicker.OnScrollListener.SCROLL_STATE_IDLE);
                }
                else {
                    if (this.mScrollState != NumberPicker.OnScrollListener.SCROLL_STATE_TOUCH_SCROLL) {
                        this.updateInputTextView();
                    }
                }
            }
            onScrollStateChange(scrollState) {
                if (this.mScrollState == scrollState) {
                    return;
                }
                this.mScrollState = scrollState;
                if (this.mOnScrollListener != null) {
                    this.mOnScrollListener.onScrollStateChange(this, scrollState);
                }
            }
            fling(velocityY) {
                this.mPreviousScrollerY = 0;
                if (velocityY > 0) {
                    this.mFlingScroller.fling(0, 0, 0, velocityY, 0, 0, 0, Integer.MAX_VALUE);
                }
                else {
                    this.mFlingScroller.fling(0, Integer.MAX_VALUE, 0, velocityY, 0, 0, 0, Integer.MAX_VALUE);
                }
                this.invalidate();
            }
            getWrappedSelectorIndex(selectorIndex) {
                if (selectorIndex > this.mMaxValue) {
                    return this.mMinValue + (selectorIndex - this.mMaxValue) % (this.mMaxValue - this.mMinValue) - 1;
                }
                else if (selectorIndex < this.mMinValue) {
                    return this.mMaxValue - (this.mMinValue - selectorIndex) % (this.mMaxValue - this.mMinValue) + 1;
                }
                return selectorIndex;
            }
            incrementSelectorIndices(selectorIndices) {
                for (let i = 0; i < selectorIndices.length - 1; i++) {
                    selectorIndices[i] = selectorIndices[i + 1];
                }
                let nextScrollSelectorIndex = selectorIndices[selectorIndices.length - 2] + 1;
                if (this.mWrapSelectorWheel && nextScrollSelectorIndex > this.mMaxValue) {
                    nextScrollSelectorIndex = this.mMinValue;
                }
                selectorIndices[selectorIndices.length - 1] = nextScrollSelectorIndex;
                this.ensureCachedScrollSelectorValue(nextScrollSelectorIndex);
            }
            decrementSelectorIndices(selectorIndices) {
                for (let i = selectorIndices.length - 1; i > 0; i--) {
                    selectorIndices[i] = selectorIndices[i - 1];
                }
                let nextScrollSelectorIndex = selectorIndices[1] - 1;
                if (this.mWrapSelectorWheel && nextScrollSelectorIndex < this.mMinValue) {
                    nextScrollSelectorIndex = this.mMaxValue;
                }
                selectorIndices[0] = nextScrollSelectorIndex;
                this.ensureCachedScrollSelectorValue(nextScrollSelectorIndex);
            }
            ensureCachedScrollSelectorValue(selectorIndex) {
                let cache = this.mSelectorIndexToStringCache;
                let scrollSelectorValue = cache.get(selectorIndex);
                if (scrollSelectorValue != null) {
                    return;
                }
                if (selectorIndex < this.mMinValue || selectorIndex > this.mMaxValue) {
                    scrollSelectorValue = "";
                }
                else {
                    if (this.mDisplayedValues != null) {
                        let displayedValueIndex = selectorIndex - this.mMinValue;
                        scrollSelectorValue = this.mDisplayedValues[displayedValueIndex];
                    }
                    else {
                        scrollSelectorValue = this.formatNumber(selectorIndex);
                    }
                }
                cache.put(selectorIndex, scrollSelectorValue);
            }
            formatNumber(value) {
                return (this.mFormatter != null) ? this.mFormatter.format(value) : NumberPicker.formatNumberWithLocale(value);
            }
            validateInputTextView(v) {
            }
            updateInputTextView() {
                return false;
            }
            notifyChange(previous, current) {
                if (this.mOnValueChangeListener != null) {
                    this.mOnValueChangeListener.onValueChange(this, previous, this.mValue);
                }
            }
            postChangeCurrentByOneFromLongPress(increment, delayMillis) {
                if (this.mChangeCurrentByOneFromLongPressCommand == null) {
                    this.mChangeCurrentByOneFromLongPressCommand = new NumberPicker.ChangeCurrentByOneFromLongPressCommand(this);
                }
                else {
                    this.removeCallbacks(this.mChangeCurrentByOneFromLongPressCommand);
                }
                this.mChangeCurrentByOneFromLongPressCommand.setStep(increment);
                this.postDelayed(this.mChangeCurrentByOneFromLongPressCommand, delayMillis);
            }
            removeChangeCurrentByOneFromLongPress() {
                if (this.mChangeCurrentByOneFromLongPressCommand != null) {
                    this.removeCallbacks(this.mChangeCurrentByOneFromLongPressCommand);
                }
            }
            postBeginSoftInputOnLongPressCommand() {
                if (this.mBeginSoftInputOnLongPressCommand == null) {
                    this.mBeginSoftInputOnLongPressCommand = new NumberPicker.BeginSoftInputOnLongPressCommand(this);
                }
                else {
                    this.removeCallbacks(this.mBeginSoftInputOnLongPressCommand);
                }
                this.postDelayed(this.mBeginSoftInputOnLongPressCommand, ViewConfiguration.getLongPressTimeout());
            }
            removeBeginSoftInputCommand() {
                if (this.mBeginSoftInputOnLongPressCommand != null) {
                    this.removeCallbacks(this.mBeginSoftInputOnLongPressCommand);
                }
            }
            removeAllCallbacks() {
                if (this.mChangeCurrentByOneFromLongPressCommand != null) {
                    this.removeCallbacks(this.mChangeCurrentByOneFromLongPressCommand);
                }
                if (this.mSetSelectionCommand != null) {
                    this.removeCallbacks(this.mSetSelectionCommand);
                }
                if (this.mBeginSoftInputOnLongPressCommand != null) {
                    this.removeCallbacks(this.mBeginSoftInputOnLongPressCommand);
                }
                this.mPressedStateHelper.cancel();
            }
            getSelectedPos(value) {
                if (this.mDisplayedValues == null) {
                    try {
                        return Integer.parseInt(value);
                    }
                    catch (e) {
                    }
                }
                else {
                    for (let i = 0; i < this.mDisplayedValues.length; i++) {
                        value = value.toLowerCase();
                        if (this.mDisplayedValues[i].toLowerCase().startsWith(value)) {
                            return this.mMinValue + i;
                        }
                    }
                    try {
                        return Integer.parseInt(value);
                    }
                    catch (e) {
                    }
                }
                return this.mMinValue;
            }
            postSetSelectionCommand(selectionStart, selectionEnd) {
                if (this.mSetSelectionCommand == null) {
                    this.mSetSelectionCommand = new NumberPicker.SetSelectionCommand(this);
                }
                else {
                    this.removeCallbacks(this.mSetSelectionCommand);
                }
                this.mSetSelectionCommand.mSelectionStart = selectionStart;
                this.mSetSelectionCommand.mSelectionEnd = selectionEnd;
                this.post(this.mSetSelectionCommand);
            }
            ensureScrollWheelAdjusted() {
                let deltaY = this.mInitialScrollOffset - this.mCurrentScrollOffset;
                if (deltaY != 0) {
                    this.mPreviousScrollerY = 0;
                    if (Math.abs(deltaY) > this.mSelectorElementHeight / 2) {
                        deltaY += (deltaY > 0) ? -this.mSelectorElementHeight : this.mSelectorElementHeight;
                    }
                    this.mAdjustScroller.startScroll(0, 0, 0, deltaY, NumberPicker.SELECTOR_ADJUSTMENT_DURATION_MILLIS);
                    this.invalidate();
                    return true;
                }
                return false;
            }
            static formatNumberWithLocale(value) {
                return value + '';
            }
        }
        NumberPicker.DEFAULT_LONG_PRESS_UPDATE_INTERVAL = 300;
        NumberPicker.SELECTOR_MAX_FLING_VELOCITY_ADJUSTMENT = 8;
        NumberPicker.SELECTOR_ADJUSTMENT_DURATION_MILLIS = 800;
        NumberPicker.SNAP_SCROLL_DURATION = 300;
        NumberPicker.TOP_AND_BOTTOM_FADING_EDGE_STRENGTH = 0.9;
        NumberPicker.UNSCALED_DEFAULT_SELECTION_DIVIDER_HEIGHT = 2;
        NumberPicker.UNSCALED_DEFAULT_SELECTION_DIVIDERS_DISTANCE = 48;
        NumberPicker.SIZE_UNSPECIFIED = -1;
        widget.NumberPicker = NumberPicker;
        (function (NumberPicker) {
            class TwoDigitFormatter {
                format(value) {
                    let s = value + '';
                    if (s.length === 1)
                        s = '0' + s;
                    return s;
                }
            }
            NumberPicker.TwoDigitFormatter = TwoDigitFormatter;
            var OnScrollListener;
            (function (OnScrollListener) {
                OnScrollListener.SCROLL_STATE_IDLE = 0;
                OnScrollListener.SCROLL_STATE_TOUCH_SCROLL = 1;
                OnScrollListener.SCROLL_STATE_FLING = 2;
            })(OnScrollListener = NumberPicker.OnScrollListener || (NumberPicker.OnScrollListener = {}));
            class PressedStateHelper {
                constructor(arg) {
                    this.MODE_PRESS = 1;
                    this.MODE_TAPPED = 2;
                    this.mManagedButton = 0;
                    this.mMode = 0;
                    this._NumberPicker_this = arg;
                }
                cancel() {
                    this.mMode = 0;
                    this.mManagedButton = 0;
                    this._NumberPicker_this.removeCallbacks(this);
                    if (this._NumberPicker_this.mIncrementVirtualButtonPressed) {
                        this._NumberPicker_this.mIncrementVirtualButtonPressed = false;
                        this._NumberPicker_this.invalidate(0, this._NumberPicker_this.mBottomSelectionDividerBottom, this._NumberPicker_this.mRight, this._NumberPicker_this.mBottom);
                    }
                    if (this._NumberPicker_this.mDecrementVirtualButtonPressed) {
                        this._NumberPicker_this.mDecrementVirtualButtonPressed = false;
                        this._NumberPicker_this.invalidate(0, 0, this._NumberPicker_this.mRight, this._NumberPicker_this.mTopSelectionDividerTop);
                    }
                }
                buttonPressDelayed(button) {
                    this.cancel();
                    this.mMode = this.MODE_PRESS;
                    this.mManagedButton = button;
                    this._NumberPicker_this.postDelayed(this, ViewConfiguration.getTapTimeout());
                }
                buttonTapped(button) {
                    this.cancel();
                    this.mMode = this.MODE_TAPPED;
                    this.mManagedButton = button;
                    this._NumberPicker_this.post(this);
                }
                run() {
                    switch (this.mMode) {
                        case this.MODE_PRESS:
                            {
                                switch (this.mManagedButton) {
                                    case PressedStateHelper.BUTTON_INCREMENT:
                                        {
                                            this._NumberPicker_this.mIncrementVirtualButtonPressed = true;
                                            this._NumberPicker_this.invalidate(0, this._NumberPicker_this.mBottomSelectionDividerBottom, this._NumberPicker_this.mRight, this._NumberPicker_this.mBottom);
                                        }
                                        break;
                                    case PressedStateHelper.BUTTON_DECREMENT:
                                        {
                                            this._NumberPicker_this.mDecrementVirtualButtonPressed = true;
                                            this._NumberPicker_this.invalidate(0, 0, this._NumberPicker_this.mRight, this._NumberPicker_this.mTopSelectionDividerTop);
                                        }
                                }
                            }
                            break;
                        case this.MODE_TAPPED:
                            {
                                switch (this.mManagedButton) {
                                    case PressedStateHelper.BUTTON_INCREMENT:
                                        {
                                            if (!this._NumberPicker_this.mIncrementVirtualButtonPressed) {
                                                this._NumberPicker_this.postDelayed(this, ViewConfiguration.getPressedStateDuration());
                                            }
                                            this._NumberPicker_this.mIncrementVirtualButtonPressed = !this._NumberPicker_this.mIncrementVirtualButtonPressed;
                                            this._NumberPicker_this.invalidate(0, this._NumberPicker_this.mBottomSelectionDividerBottom, this._NumberPicker_this.mRight, this._NumberPicker_this.mBottom);
                                        }
                                        break;
                                    case PressedStateHelper.BUTTON_DECREMENT:
                                        {
                                            if (!this._NumberPicker_this.mDecrementVirtualButtonPressed) {
                                                this._NumberPicker_this.postDelayed(this, ViewConfiguration.getPressedStateDuration());
                                            }
                                            this._NumberPicker_this.mDecrementVirtualButtonPressed = !this._NumberPicker_this.mDecrementVirtualButtonPressed;
                                            this._NumberPicker_this.invalidate(0, 0, this._NumberPicker_this.mRight, this._NumberPicker_this.mTopSelectionDividerTop);
                                        }
                                }
                            }
                            break;
                    }
                }
            }
            PressedStateHelper.BUTTON_INCREMENT = 1;
            PressedStateHelper.BUTTON_DECREMENT = 2;
            NumberPicker.PressedStateHelper = PressedStateHelper;
            class SetSelectionCommand {
                constructor(arg) {
                    this.mSelectionStart = 0;
                    this.mSelectionEnd = 0;
                    this._NumberPicker_this = arg;
                }
                run() {
                }
            }
            NumberPicker.SetSelectionCommand = SetSelectionCommand;
            class ChangeCurrentByOneFromLongPressCommand {
                constructor(arg) {
                    this._NumberPicker_this = arg;
                }
                setStep(increment) {
                    this.mIncrement = increment;
                }
                run() {
                    this._NumberPicker_this.changeValueByOne(this.mIncrement);
                    this._NumberPicker_this.postDelayed(this, this._NumberPicker_this.mLongPressUpdateInterval);
                }
            }
            NumberPicker.ChangeCurrentByOneFromLongPressCommand = ChangeCurrentByOneFromLongPressCommand;
            class BeginSoftInputOnLongPressCommand {
                constructor(arg) {
                    this._NumberPicker_this = arg;
                }
                run() {
                    this._NumberPicker_this.showSoftInput();
                    this._NumberPicker_this.mIngonreMoveEvents = true;
                }
            }
            NumberPicker.BeginSoftInputOnLongPressCommand = BeginSoftInputOnLongPressCommand;
        })(NumberPicker = widget.NumberPicker || (widget.NumberPicker = {}));
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/5.
 */
///<reference path="../../../database/DataSetObservable.ts"/>
///<reference path="../../../database/Observable.ts"/>
///<reference path="../../../database/DataSetObserver.ts"/>
///<reference path="../../../view/ViewGroup.ts"/>
var android;
(function (android) {
    var support;
    (function (support) {
        var v4;
        (function (v4) {
            var view;
            (function (view_5) {
                var DataSetObservable = android.database.DataSetObservable;
                class PagerAdapter {
                    constructor() {
                        this.mObservable = new DataSetObservable();
                    }
                    startUpdate(container) {
                    }
                    instantiateItem(container, position) {
                        throw new Error("Required method instantiateItem was not overridden");
                    }
                    destroyItem(container, position, object) {
                        throw new Error("Required method destroyItem was not overridden");
                    }
                    setPrimaryItem(container, position, object) {
                    }
                    finishUpdate(container) {
                    }
                    getItemPosition(object) {
                        return PagerAdapter.POSITION_UNCHANGED;
                    }
                    notifyDataSetChanged() {
                        this.mObservable.notifyChanged();
                    }
                    registerDataSetObserver(observer) {
                        this.mObservable.registerObserver(observer);
                    }
                    unregisterDataSetObserver(observer) {
                        this.mObservable.unregisterObserver(observer);
                    }
                    getPageTitle(position) {
                        return null;
                    }
                    getPageWidth(position) {
                        return 1;
                    }
                }
                PagerAdapter.POSITION_UNCHANGED = -1;
                PagerAdapter.POSITION_NONE = -2;
                view_5.PagerAdapter = PagerAdapter;
            })(view = v4.view || (v4.view = {}));
        })(v4 = support.v4 || (support.v4 = {}));
    })(support = android.support || (android.support = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/5.
 */
///<reference path="../../../view/View.ts"/>
///<reference path="../../../view/VelocityTracker.ts"/>
///<reference path="../../../widget/OverScroller.ts"/>
///<reference path="../../../view/ViewGroup.ts"/>
///<reference path="../../../view/MotionEvent.ts"/>
///<reference path="../../../view/animation/Interpolator.ts"/>
///<reference path="../../../../java/util/ArrayList.ts"/>
///<reference path="../../../database/DataSetObservable.ts"/>
///<reference path="../../../database/Observable.ts"/>
///<reference path="../../../database/DataSetObserver.ts"/>
///<reference path="PagerAdapter.ts"/>
var android;
(function (android) {
    var support;
    (function (support) {
        var v4;
        (function (v4) {
            var view;
            (function (view_6) {
                var View = android.view.View;
                var Gravity = android.view.Gravity;
                var MeasureSpec = View.MeasureSpec;
                var OverScroller = android.widget.OverScroller;
                var ViewGroup = android.view.ViewGroup;
                var ArrayList = java.util.ArrayList;
                var Rect = android.graphics.Rect;
                var PagerAdapter = android.support.v4.view.PagerAdapter;
                var DataSetObserver = android.database.DataSetObserver;
                var VelocityTracker = android.view.VelocityTracker;
                var ViewConfiguration = android.view.ViewConfiguration;
                var Resources = android.content.res.Resources;
                var Log = android.util.Log;
                var MotionEvent = android.view.MotionEvent;
                var KeyEvent = android.view.KeyEvent;
                const TAG = "ViewPager";
                const DEBUG = false;
                const SymbolDecor = Symbol();
                class ViewPager extends ViewGroup {
                    constructor(bindElement, rootElement) {
                        super(bindElement, rootElement);
                        this.mExpectedAdapterCount = 0;
                        this.mItems = new ArrayList();
                        this.mTempItem = new ItemInfo();
                        this.mTempRect = new Rect();
                        this.mCurItem = 0;
                        this.mRestoredCurItem = -1;
                        this.mPageMargin = 0;
                        this.mTopPageBounds = 0;
                        this.mBottomPageBounds = 0;
                        this.mFirstOffset = -Number.MAX_VALUE;
                        this.mLastOffset = Number.MAX_VALUE;
                        this.mChildWidthMeasureSpec = 0;
                        this.mChildHeightMeasureSpec = 0;
                        this.mInLayout = false;
                        this.mScrollingCacheEnabled = false;
                        this.mPopulatePending = false;
                        this.mOffscreenPageLimit = ViewPager.DEFAULT_OFFSCREEN_PAGES;
                        this.mIsBeingDragged = false;
                        this.mIsUnableToDrag = false;
                        this.mDefaultGutterSize = 0;
                        this.mGutterSize = 0;
                        this.mLastMotionX = 0;
                        this.mLastMotionY = 0;
                        this.mInitialMotionX = 0;
                        this.mInitialMotionY = 0;
                        this.mActivePointerId = ViewPager.INVALID_POINTER;
                        this.mMinimumVelocity = 0;
                        this.mMaximumVelocity = 0;
                        this.mFlingDistance = 0;
                        this.mCloseEnough = 0;
                        this.mFakeDragging = false;
                        this.mFakeDragBeginTime = 0;
                        this.mFirstLayout = true;
                        this.mNeedCalculatePageOffsets = false;
                        this.mCalledSuper = false;
                        this.mDecorChildCount = 0;
                        this.mDrawingOrder = 0;
                        this.mEndScrollRunnable = (() => {
                            let ViewPager_this = this;
                            class InnerClass {
                                run() {
                                    ViewPager_this.setScrollState(ViewPager.SCROLL_STATE_IDLE);
                                    ViewPager_this.populate();
                                }
                            }
                            return new InnerClass();
                        })();
                        this.mScrollState = ViewPager.SCROLL_STATE_IDLE;
                        this.initViewPager();
                    }
                    initViewPager() {
                        this.setWillNotDraw(false);
                        this.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);
                        this.setFocusable(true);
                        this.mScroller = new OverScroller(ViewPager.sInterpolator);
                        let density = Resources.getDisplayMetrics().density;
                        this.mTouchSlop = ViewConfiguration.get().getScaledPagingTouchSlop();
                        this.mMinimumVelocity = Math.floor(ViewPager.MIN_FLING_VELOCITY * density);
                        this.mMaximumVelocity = ViewConfiguration.get().getScaledMaximumFlingVelocity();
                        this.mFlingDistance = Math.floor(ViewPager.MIN_DISTANCE_FOR_FLING * density);
                        this.mCloseEnough = Math.floor(ViewPager.CLOSE_ENOUGH * density);
                        this.mDefaultGutterSize = Math.floor(ViewPager.DEFAULT_GUTTER_SIZE * density);
                    }
                    onDetachedFromWindow() {
                        this.removeCallbacks(this.mEndScrollRunnable);
                        super.onDetachedFromWindow();
                    }
                    setScrollState(newState) {
                        if (this.mScrollState == newState) {
                            return;
                        }
                        this.mScrollState = newState;
                        if (this.mPageTransformer != null) {
                            this.enableLayers(newState != ViewPager.SCROLL_STATE_IDLE);
                        }
                        this.dispatchOnScrollStateChanged(newState);
                    }
                    setAdapter(adapter) {
                        if (this.mAdapter != null) {
                            this.mAdapter.unregisterDataSetObserver(this.mObserver);
                            this.mAdapter.startUpdate(this);
                            for (let i = 0; i < this.mItems.size(); i++) {
                                const ii = this.mItems.get(i);
                                this.mAdapter.destroyItem(this, ii.position, ii.object);
                            }
                            this.mAdapter.finishUpdate(this);
                            this.mItems.clear();
                            this.removeNonDecorViews();
                            this.mCurItem = 0;
                            this.scrollTo(0, 0);
                        }
                        const oldAdapter = this.mAdapter;
                        this.mAdapter = adapter;
                        this.mExpectedAdapterCount = 0;
                        if (this.mAdapter != null) {
                            if (this.mObserver == null) {
                                this.mObserver = new PagerObserver(this);
                            }
                            this.mAdapter.registerDataSetObserver(this.mObserver);
                            this.mPopulatePending = false;
                            const wasFirstLayout = this.mFirstLayout;
                            this.mFirstLayout = true;
                            this.mExpectedAdapterCount = this.mAdapter.getCount();
                            if (this.mRestoredCurItem >= 0) {
                                this.setCurrentItemInternal(this.mRestoredCurItem, false, true);
                                this.mRestoredCurItem = -1;
                            }
                            else if (!wasFirstLayout) {
                                this.populate();
                            }
                            else {
                                this.requestLayout();
                            }
                        }
                        if (this.mAdapterChangeListener != null && oldAdapter != adapter) {
                            this.mAdapterChangeListener.onAdapterChanged(oldAdapter, adapter);
                        }
                    }
                    removeNonDecorViews() {
                        for (let i = 0; i < this.getChildCount(); i++) {
                            const child = this.getChildAt(i);
                            const lp = child.getLayoutParams();
                            if (!lp.isDecor) {
                                this.removeViewAt(i);
                                i--;
                            }
                        }
                    }
                    getAdapter() {
                        return this.mAdapter;
                    }
                    setOnAdapterChangeListener(listener) {
                        this.mAdapterChangeListener = listener;
                    }
                    getClientWidth() {
                        return this.getMeasuredWidth() - this.getPaddingLeft() - this.getPaddingRight();
                    }
                    setCurrentItem(item, smoothScroll = !this.mFirstLayout) {
                        this.mPopulatePending = false;
                        this.setCurrentItemInternal(item, smoothScroll, false);
                    }
                    getCurrentItem() {
                        return this.mCurItem;
                    }
                    setCurrentItemInternal(item, smoothScroll, always, velocity = 0) {
                        if (this.mAdapter == null || this.mAdapter.getCount() <= 0) {
                            this.setScrollingCacheEnabled(false);
                            return;
                        }
                        if (!always && this.mCurItem == item && this.mItems.size() != 0) {
                            this.setScrollingCacheEnabled(false);
                            return;
                        }
                        if (item < 0) {
                            item = 0;
                        }
                        else if (item >= this.mAdapter.getCount()) {
                            item = this.mAdapter.getCount() - 1;
                        }
                        const pageLimit = this.mOffscreenPageLimit;
                        if (item > (this.mCurItem + pageLimit) || item < (this.mCurItem - pageLimit)) {
                            for (let i = 0; i < this.mItems.size(); i++) {
                                this.mItems.get(i).scrolling = true;
                            }
                        }
                        const dispatchSelected = this.mCurItem != item;
                        if (this.mFirstLayout) {
                            this.mCurItem = item;
                            if (dispatchSelected) {
                                this.dispatchOnPageSelected(item);
                            }
                            this.requestLayout();
                        }
                        else {
                            this.populate(item);
                            this.scrollToItem(item, smoothScroll, velocity, dispatchSelected);
                        }
                    }
                    scrollToItem(item, smoothScroll, velocity, dispatchSelected) {
                        const curInfo = this.infoForPosition(item);
                        let destX = 0;
                        if (curInfo != null) {
                            const width = this.getClientWidth();
                            destX = Math.floor(width * Math.max(this.mFirstOffset, Math.min(curInfo.offset, this.mLastOffset)));
                        }
                        if (smoothScroll) {
                            this.smoothScrollTo(destX, 0, velocity);
                            if (dispatchSelected) {
                                this.dispatchOnPageSelected(item);
                            }
                        }
                        else {
                            if (dispatchSelected) {
                                this.dispatchOnPageSelected(item);
                            }
                            this.completeScroll(false);
                            this.scrollTo(destX, 0);
                            this.pageScrolled(destX);
                        }
                    }
                    setOnPageChangeListener(listener) {
                        this.mOnPageChangeListener = listener;
                    }
                    addOnPageChangeListener(listener) {
                        if (this.mOnPageChangeListeners == null) {
                            this.mOnPageChangeListeners = new ArrayList();
                        }
                        this.mOnPageChangeListeners.add(listener);
                    }
                    removeOnPageChangeListener(listener) {
                        if (this.mOnPageChangeListeners != null) {
                            this.mOnPageChangeListeners.remove(listener);
                        }
                    }
                    clearOnPageChangeListeners() {
                        if (this.mOnPageChangeListeners != null) {
                            this.mOnPageChangeListeners.clear();
                        }
                    }
                    setPageTransformer(reverseDrawingOrder, transformer) {
                        const hasTransformer = transformer != null;
                        const needsPopulate = hasTransformer != (this.mPageTransformer != null);
                        this.mPageTransformer = transformer;
                        this.setChildrenDrawingOrderEnabledCompat(hasTransformer);
                        if (hasTransformer) {
                            this.mDrawingOrder = reverseDrawingOrder ? ViewPager.DRAW_ORDER_REVERSE : ViewPager.DRAW_ORDER_FORWARD;
                        }
                        else {
                            this.mDrawingOrder = ViewPager.DRAW_ORDER_DEFAULT;
                        }
                        if (needsPopulate)
                            this.populate();
                    }
                    setChildrenDrawingOrderEnabledCompat(enable = true) {
                        this.setChildrenDrawingOrderEnabled(enable);
                    }
                    getChildDrawingOrder(childCount, i) {
                        const index = this.mDrawingOrder == ViewPager.DRAW_ORDER_REVERSE ? childCount - 1 - i : i;
                        const result = this.mDrawingOrderedChildren.get(index).getLayoutParams().childIndex;
                        return result;
                    }
                    setInternalPageChangeListener(listener) {
                        let oldListener = this.mInternalPageChangeListener;
                        this.mInternalPageChangeListener = listener;
                        return oldListener;
                    }
                    getOffscreenPageLimit() {
                        return this.mOffscreenPageLimit;
                    }
                    setOffscreenPageLimit(limit) {
                        if (limit < ViewPager.DEFAULT_OFFSCREEN_PAGES) {
                            Log.w(TAG, "Requested offscreen page limit " + limit + " too small; defaulting to " +
                                ViewPager.DEFAULT_OFFSCREEN_PAGES);
                            limit = ViewPager.DEFAULT_OFFSCREEN_PAGES;
                        }
                        if (limit != this.mOffscreenPageLimit) {
                            this.mOffscreenPageLimit = limit;
                            this.populate();
                        }
                    }
                    setPageMargin(marginPixels) {
                        const oldMargin = this.mPageMargin;
                        this.mPageMargin = marginPixels;
                        const width = this.getWidth();
                        this.recomputeScrollPosition(width, width, marginPixels, oldMargin);
                        this.requestLayout();
                    }
                    getPageMargin() {
                        return this.mPageMargin;
                    }
                    setPageMarginDrawable(d) {
                        this.mMarginDrawable = d;
                        if (d != null)
                            this.refreshDrawableState();
                        this.setWillNotDraw(d == null);
                        this.invalidate();
                    }
                    verifyDrawable(who) {
                        return super.verifyDrawable(who) || who == this.mMarginDrawable;
                    }
                    drawableStateChanged() {
                        super.drawableStateChanged();
                        const d = this.mMarginDrawable;
                        if (d != null && d.isStateful()) {
                            d.setState(this.getDrawableState());
                        }
                    }
                    distanceInfluenceForSnapDuration(f) {
                        f -= 0.5;
                        f *= 0.3 * Math.PI / 2.0;
                        return Math.sin(f);
                    }
                    smoothScrollTo(x, y, velocity = 0) {
                        if (this.getChildCount() == 0) {
                            this.setScrollingCacheEnabled(false);
                            return;
                        }
                        let sx = this.getScrollX();
                        let sy = this.getScrollY();
                        let dx = x - sx;
                        let dy = y - sy;
                        if (dx == 0 && dy == 0) {
                            this.completeScroll(false);
                            this.populate();
                            this.setScrollState(ViewPager.SCROLL_STATE_IDLE);
                            return;
                        }
                        this.setScrollingCacheEnabled(true);
                        this.setScrollState(ViewPager.SCROLL_STATE_SETTLING);
                        const width = this.getClientWidth();
                        const halfWidth = width / 2;
                        const distanceRatio = Math.min(1, 1.0 * Math.abs(dx) / width);
                        const distance = halfWidth + halfWidth *
                            this.distanceInfluenceForSnapDuration(distanceRatio);
                        let duration = 0;
                        velocity = Math.abs(velocity);
                        if (velocity > 0) {
                            duration = 4 * Math.round(1000 * Math.abs(distance / velocity));
                        }
                        else {
                            const pageWidth = width * this.mAdapter.getPageWidth(this.mCurItem);
                            const pageDelta = Math.abs(dx) / (pageWidth + this.mPageMargin);
                            duration = Math.floor((pageDelta + 1) * 100);
                        }
                        duration = Math.min(duration, ViewPager.MAX_SETTLE_DURATION);
                        this.mScroller.startScroll(sx, sy, dx, dy, duration);
                        this.postInvalidateOnAnimation();
                    }
                    addNewItem(position, index) {
                        let ii = new ItemInfo();
                        ii.position = position;
                        ii.object = this.mAdapter.instantiateItem(this, position);
                        ii.widthFactor = this.mAdapter.getPageWidth(position);
                        if (index < 0 || index >= this.mItems.size()) {
                            this.mItems.add(ii);
                        }
                        else {
                            this.mItems.add(index, ii);
                        }
                        return ii;
                    }
                    dataSetChanged() {
                        // This method only gets called if our observer is attached, so mAdapter is non-null.
                        const adapterCount = this.mAdapter.getCount();
                        this.mExpectedAdapterCount = adapterCount;
                        let needPopulate = this.mItems.size() < this.mOffscreenPageLimit * 2 + 1 &&
                            this.mItems.size() < adapterCount;
                        let newCurrItem = this.mCurItem;
                        let isUpdating = false;
                        for (let i = 0; i < this.mItems.size(); i++) {
                            const ii = this.mItems.get(i);
                            const newPos = this.mAdapter.getItemPosition(ii.object);
                            if (newPos == PagerAdapter.POSITION_UNCHANGED) {
                                continue;
                            }
                            if (newPos == PagerAdapter.POSITION_NONE) {
                                this.mItems.remove(i);
                                i--;
                                if (!isUpdating) {
                                    this.mAdapter.startUpdate(this);
                                    isUpdating = true;
                                }
                                this.mAdapter.destroyItem(this, ii.position, ii.object);
                                needPopulate = true;
                                if (this.mCurItem == ii.position) {
                                    newCurrItem = Math.max(0, Math.min(this.mCurItem, adapterCount - 1));
                                    needPopulate = true;
                                }
                                continue;
                            }
                            if (ii.position != newPos) {
                                if (ii.position == this.mCurItem) {
                                    newCurrItem = newPos;
                                }
                                ii.position = newPos;
                                needPopulate = true;
                            }
                        }
                        if (isUpdating) {
                            this.mAdapter.finishUpdate(this);
                        }
                        this.mItems.sort(ViewPager.COMPARATOR);
                        if (needPopulate) {
                            const childCount = this.getChildCount();
                            for (let i = 0; i < childCount; i++) {
                                const child = this.getChildAt(i);
                                const lp = child.getLayoutParams();
                                if (!lp.isDecor) {
                                    lp.widthFactor = 0;
                                }
                            }
                            this.setCurrentItemInternal(newCurrItem, false, true);
                            this.requestLayout();
                        }
                    }
                    populate(newCurrentItem = this.mCurItem) {
                        let oldCurInfo = null;
                        let focusDirection = View.FOCUS_FORWARD;
                        if (this.mCurItem != newCurrentItem) {
                            focusDirection = this.mCurItem < newCurrentItem ? View.FOCUS_RIGHT : View.FOCUS_LEFT;
                            oldCurInfo = this.infoForPosition(this.mCurItem);
                            this.mCurItem = newCurrentItem;
                        }
                        if (this.mAdapter == null) {
                            this.sortChildDrawingOrder();
                            return;
                        }
                        if (this.mPopulatePending) {
                            if (DEBUG)
                                Log.i(TAG, "populate is pending, skipping for now...");
                            this.sortChildDrawingOrder();
                            return;
                        }
                        if (!this.isAttachedToWindow()) {
                            return;
                        }
                        this.mAdapter.startUpdate(this);
                        const pageLimit = this.mOffscreenPageLimit;
                        const startPos = Math.max(0, this.mCurItem - pageLimit);
                        const N = this.mAdapter.getCount();
                        const endPos = Math.min(N - 1, this.mCurItem + pageLimit);
                        if (N != this.mExpectedAdapterCount) {
                            throw new Error("The application's PagerAdapter changed the adapter's" +
                                " contents without calling PagerAdapter#notifyDataSetChanged!" +
                                " Expected adapter item count: " + this.mExpectedAdapterCount + ", found: " + N +
                                " Pager id: " + this.getId() +
                                " Pager class: " + this.constructor.name +
                                " Problematic adapter: " + this.mAdapter.constructor.name);
                        }
                        let curIndex = -1;
                        let curItem = null;
                        for (curIndex = 0; curIndex < this.mItems.size(); curIndex++) {
                            const ii = this.mItems.get(curIndex);
                            if (ii.position >= this.mCurItem) {
                                if (ii.position == this.mCurItem)
                                    curItem = ii;
                                break;
                            }
                        }
                        if (curItem == null && N > 0) {
                            curItem = this.addNewItem(this.mCurItem, curIndex);
                        }
                        if (curItem != null) {
                            let extraWidthLeft = 0;
                            let itemIndex = curIndex - 1;
                            let ii = itemIndex >= 0 ? this.mItems.get(itemIndex) : null;
                            const clientWidth = this.getClientWidth();
                            const leftWidthNeeded = clientWidth <= 0 ? 0 :
                                2 - curItem.widthFactor + this.getPaddingLeft() / clientWidth;
                            for (let pos = this.mCurItem - 1; pos >= 0; pos--) {
                                if (extraWidthLeft >= leftWidthNeeded && pos < startPos) {
                                    if (ii == null) {
                                        break;
                                    }
                                    if (pos == ii.position && !ii.scrolling) {
                                        this.mItems.remove(itemIndex);
                                        this.mAdapter.destroyItem(this, pos, ii.object);
                                        if (DEBUG) {
                                            Log.i(TAG, "populate() - destroyItem() with pos: " + pos +
                                                " view: " + ii.object);
                                        }
                                        itemIndex--;
                                        curIndex--;
                                        ii = itemIndex >= 0 ? this.mItems.get(itemIndex) : null;
                                    }
                                }
                                else if (ii != null && pos == ii.position) {
                                    extraWidthLeft += ii.widthFactor;
                                    itemIndex--;
                                    ii = itemIndex >= 0 ? this.mItems.get(itemIndex) : null;
                                }
                                else {
                                    ii = this.addNewItem(pos, itemIndex + 1);
                                    extraWidthLeft += ii.widthFactor;
                                    curIndex++;
                                    ii = itemIndex >= 0 ? this.mItems.get(itemIndex) : null;
                                }
                            }
                            let extraWidthRight = curItem.widthFactor;
                            itemIndex = curIndex + 1;
                            if (extraWidthRight < 2) {
                                ii = itemIndex < this.mItems.size() ? this.mItems.get(itemIndex) : null;
                                const rightWidthNeeded = clientWidth <= 0 ? 0 :
                                    this.getPaddingRight() / clientWidth + 2;
                                for (let pos = this.mCurItem + 1; pos < N; pos++) {
                                    if (extraWidthRight >= rightWidthNeeded && pos > endPos) {
                                        if (ii == null) {
                                            break;
                                        }
                                        if (pos == ii.position && !ii.scrolling) {
                                            this.mItems.remove(itemIndex);
                                            this.mAdapter.destroyItem(this, pos, ii.object);
                                            if (DEBUG) {
                                                Log.i(TAG, "populate() - destroyItem() with pos: " + pos +
                                                    " view: " + ii.object);
                                            }
                                            ii = itemIndex < this.mItems.size() ? this.mItems.get(itemIndex) : null;
                                        }
                                    }
                                    else if (ii != null && pos == ii.position) {
                                        extraWidthRight += ii.widthFactor;
                                        itemIndex++;
                                        ii = itemIndex < this.mItems.size() ? this.mItems.get(itemIndex) : null;
                                    }
                                    else {
                                        ii = this.addNewItem(pos, itemIndex);
                                        itemIndex++;
                                        extraWidthRight += ii.widthFactor;
                                        ii = itemIndex < this.mItems.size() ? this.mItems.get(itemIndex) : null;
                                    }
                                }
                            }
                            this.calculatePageOffsets(curItem, curIndex, oldCurInfo);
                        }
                        if (DEBUG) {
                            Log.i(TAG, "Current page list:");
                            for (let i = 0; i < this.mItems.size(); i++) {
                                Log.i(TAG, "#" + i + ": page " + this.mItems.get(i).position);
                            }
                        }
                        this.mAdapter.setPrimaryItem(this, this.mCurItem, curItem != null ? curItem.object : null);
                        this.mAdapter.finishUpdate(this);
                        const childCount = this.getChildCount();
                        for (let i = 0; i < childCount; i++) {
                            const child = this.getChildAt(i);
                            const lp = child.getLayoutParams();
                            lp.childIndex = i;
                            if (!lp.isDecor && lp.widthFactor == 0) {
                                const ii = this.infoForChild(child);
                                if (ii != null) {
                                    lp.widthFactor = ii.widthFactor;
                                    lp.position = ii.position;
                                }
                            }
                        }
                        this.sortChildDrawingOrder();
                        if (this.hasFocus()) {
                            let currentFocused = this.findFocus();
                            let ii = currentFocused != null ? this.infoForAnyChild(currentFocused) : null;
                            if (ii == null || ii.position != this.mCurItem) {
                                for (let i = 0; i < this.getChildCount(); i++) {
                                    let child = this.getChildAt(i);
                                    ii = this.infoForChild(child);
                                    if (ii != null && ii.position == this.mCurItem) {
                                        if (child.requestFocus(focusDirection)) {
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    sortChildDrawingOrder() {
                        if (this.mDrawingOrder != ViewPager.DRAW_ORDER_DEFAULT) {
                            if (this.mDrawingOrderedChildren == null) {
                                this.mDrawingOrderedChildren = new ArrayList();
                            }
                            else {
                                this.mDrawingOrderedChildren.clear();
                            }
                            const childCount = this.getChildCount();
                            for (let i = 0; i < childCount; i++) {
                                const child = this.getChildAt(i);
                                this.mDrawingOrderedChildren.add(child);
                            }
                            this.mDrawingOrderedChildren.sort(ViewPager.sPositionComparator);
                        }
                    }
                    calculatePageOffsets(curItem, curIndex, oldCurInfo) {
                        const N = this.mAdapter.getCount();
                        const width = this.getClientWidth();
                        const marginOffset = width > 0 ? this.mPageMargin / width : 0;
                        if (oldCurInfo != null) {
                            const oldCurPosition = oldCurInfo.position;
                            if (oldCurPosition < curItem.position) {
                                let itemIndex = 0;
                                let ii = null;
                                let offset = oldCurInfo.offset + oldCurInfo.widthFactor + marginOffset;
                                for (let pos = oldCurPosition + 1; pos <= curItem.position && itemIndex < this.mItems.size(); pos++) {
                                    ii = this.mItems.get(itemIndex);
                                    while (pos > ii.position && itemIndex < this.mItems.size() - 1) {
                                        itemIndex++;
                                        ii = this.mItems.get(itemIndex);
                                    }
                                    while (pos < ii.position) {
                                        offset += this.mAdapter.getPageWidth(pos) + marginOffset;
                                        pos++;
                                    }
                                    ii.offset = offset;
                                    offset += ii.widthFactor + marginOffset;
                                }
                            }
                            else if (oldCurPosition > curItem.position) {
                                let itemIndex = this.mItems.size() - 1;
                                let ii = null;
                                let offset = oldCurInfo.offset;
                                for (let pos = oldCurPosition - 1; pos >= curItem.position && itemIndex >= 0; pos--) {
                                    ii = this.mItems.get(itemIndex);
                                    while (pos < ii.position && itemIndex > 0) {
                                        itemIndex--;
                                        ii = this.mItems.get(itemIndex);
                                    }
                                    while (pos > ii.position) {
                                        offset -= this.mAdapter.getPageWidth(pos) + marginOffset;
                                        pos--;
                                    }
                                    offset -= ii.widthFactor + marginOffset;
                                    ii.offset = offset;
                                }
                            }
                        }
                        const itemCount = this.mItems.size();
                        let offset = curItem.offset;
                        let pos = curItem.position - 1;
                        this.mFirstOffset = curItem.position == 0 ? curItem.offset : -Number.MAX_VALUE;
                        this.mLastOffset = curItem.position == N - 1 ?
                            curItem.offset + curItem.widthFactor - 1 : Number.MAX_VALUE;
                        for (let i = curIndex - 1; i >= 0; i--, pos--) {
                            const ii = this.mItems.get(i);
                            while (pos > ii.position) {
                                offset -= this.mAdapter.getPageWidth(pos--) + marginOffset;
                            }
                            offset -= ii.widthFactor + marginOffset;
                            ii.offset = offset;
                            if (ii.position == 0)
                                this.mFirstOffset = offset;
                        }
                        offset = curItem.offset + curItem.widthFactor + marginOffset;
                        pos = curItem.position + 1;
                        for (let i = curIndex + 1; i < itemCount; i++, pos++) {
                            const ii = this.mItems.get(i);
                            while (pos < ii.position) {
                                offset += this.mAdapter.getPageWidth(pos++) + marginOffset;
                            }
                            if (ii.position == N - 1) {
                                this.mLastOffset = offset + ii.widthFactor - 1;
                            }
                            ii.offset = offset;
                            offset += ii.widthFactor + marginOffset;
                        }
                        this.mNeedCalculatePageOffsets = false;
                    }
                    addView(...args) {
                        if (args.length === 3 && args[2] instanceof ViewGroup.LayoutParams) {
                            this._addViewOverride(args[0], args[1], args[2]);
                        }
                        else {
                            super.addView(...args);
                        }
                    }
                    _addViewOverride(child, index, params) {
                        if (!this.checkLayoutParams(params)) {
                            params = this.generateLayoutParams(params);
                        }
                        const lp = params;
                        lp.isDecor = lp.isDecor || ViewPager.isImplDecor(child);
                        if (this.mInLayout) {
                            if (lp != null && lp.isDecor) {
                                throw new Error("Cannot add pager decor view during layout");
                            }
                            lp.needsMeasure = true;
                            this.addViewInLayout(child, index, params);
                        }
                        else {
                            super.addView(child, index, params);
                        }
                        if (ViewPager.USE_CACHE) {
                            if (child.getVisibility() != View.GONE) {
                                child.setDrawingCacheEnabled(this.mScrollingCacheEnabled);
                            }
                            else {
                                child.setDrawingCacheEnabled(false);
                            }
                        }
                    }
                    removeView(view) {
                        if (this.mInLayout) {
                            this.removeViewInLayout(view);
                        }
                        else {
                            super.removeView(view);
                        }
                    }
                    infoForChild(child) {
                        for (let i = 0; i < this.mItems.size(); i++) {
                            let ii = this.mItems.get(i);
                            if (this.mAdapter.isViewFromObject(child, ii.object)) {
                                return ii;
                            }
                        }
                        return null;
                    }
                    infoForAnyChild(child) {
                        let parent;
                        while ((parent = child.getParent()) != this) {
                            if (parent == null || !(parent instanceof View)) {
                                return null;
                            }
                            child = parent;
                        }
                        return this.infoForChild(child);
                    }
                    infoForPosition(position) {
                        for (let i = 0; i < this.mItems.size(); i++) {
                            let ii = this.mItems.get(i);
                            if (ii.position == position) {
                                return ii;
                            }
                        }
                        return null;
                    }
                    onAttachedToWindow() {
                        super.onAttachedToWindow();
                        this.mFirstLayout = true;
                    }
                    onMeasure(widthMeasureSpec, heightMeasureSpec) {
                        this.setMeasuredDimension(ViewPager.getDefaultSize(0, widthMeasureSpec), ViewPager.getDefaultSize(0, heightMeasureSpec));
                        const measuredWidth = this.getMeasuredWidth();
                        const maxGutterSize = measuredWidth / 10;
                        this.mGutterSize = Math.min(maxGutterSize, this.mDefaultGutterSize);
                        let childWidthSize = measuredWidth - this.getPaddingLeft() - this.getPaddingRight();
                        let childHeightSize = this.getMeasuredHeight() - this.getPaddingTop() - this.getPaddingBottom();
                        let size = this.getChildCount();
                        for (let i = 0; i < size; ++i) {
                            const child = this.getChildAt(i);
                            if (child.getVisibility() != View.GONE) {
                                const lp = child.getLayoutParams();
                                if (lp != null && lp.isDecor) {
                                    const hgrav = lp.gravity & Gravity.HORIZONTAL_GRAVITY_MASK;
                                    const vgrav = lp.gravity & Gravity.VERTICAL_GRAVITY_MASK;
                                    let widthMode = MeasureSpec.AT_MOST;
                                    let heightMode = MeasureSpec.AT_MOST;
                                    let consumeVertical = vgrav == Gravity.TOP || vgrav == Gravity.BOTTOM;
                                    let consumeHorizontal = hgrav == Gravity.LEFT || hgrav == Gravity.RIGHT;
                                    if (consumeVertical) {
                                        widthMode = MeasureSpec.EXACTLY;
                                    }
                                    else if (consumeHorizontal) {
                                        heightMode = MeasureSpec.EXACTLY;
                                    }
                                    let widthSize = childWidthSize;
                                    let heightSize = childHeightSize;
                                    if (lp.width != ViewPager.LayoutParams.WRAP_CONTENT) {
                                        widthMode = MeasureSpec.EXACTLY;
                                        if (lp.width != ViewPager.LayoutParams.FILL_PARENT) {
                                            widthSize = lp.width;
                                        }
                                    }
                                    if (lp.height != ViewPager.LayoutParams.WRAP_CONTENT) {
                                        heightMode = MeasureSpec.EXACTLY;
                                        if (lp.height != ViewPager.LayoutParams.FILL_PARENT) {
                                            heightSize = lp.height;
                                        }
                                    }
                                    const widthSpec = MeasureSpec.makeMeasureSpec(widthSize, widthMode);
                                    const heightSpec = MeasureSpec.makeMeasureSpec(heightSize, heightMode);
                                    child.measure(widthSpec, heightSpec);
                                    if (consumeVertical) {
                                        childHeightSize -= child.getMeasuredHeight();
                                    }
                                    else if (consumeHorizontal) {
                                        childWidthSize -= child.getMeasuredWidth();
                                    }
                                }
                            }
                        }
                        this.mChildWidthMeasureSpec = MeasureSpec.makeMeasureSpec(childWidthSize, MeasureSpec.EXACTLY);
                        this.mChildHeightMeasureSpec = MeasureSpec.makeMeasureSpec(childHeightSize, MeasureSpec.EXACTLY);
                        this.mInLayout = true;
                        this.populate();
                        this.mInLayout = false;
                        size = this.getChildCount();
                        for (let i = 0; i < size; ++i) {
                            const child = this.getChildAt(i);
                            if (child.getVisibility() != View.GONE) {
                                if (DEBUG)
                                    Log.v(TAG, "Measuring #" + i + " " + child
                                        + ": " + this.mChildWidthMeasureSpec);
                                const lp = child.getLayoutParams();
                                if (lp == null || !lp.isDecor) {
                                    const widthSpec = MeasureSpec.makeMeasureSpec((childWidthSize * lp.widthFactor), MeasureSpec.EXACTLY);
                                    child.measure(widthSpec, this.mChildHeightMeasureSpec);
                                }
                            }
                        }
                    }
                    onSizeChanged(w, h, oldw, oldh) {
                        super.onSizeChanged(w, h, oldw, oldh);
                        if (w != oldw) {
                            this.recomputeScrollPosition(w, oldw, this.mPageMargin, this.mPageMargin);
                        }
                    }
                    recomputeScrollPosition(width, oldWidth, margin, oldMargin) {
                        if (oldWidth > 0 && !this.mItems.isEmpty()) {
                            const widthWithMargin = width - this.getPaddingLeft() - this.getPaddingRight() + margin;
                            const oldWidthWithMargin = oldWidth - this.getPaddingLeft() - this.getPaddingRight()
                                + oldMargin;
                            const xpos = this.getScrollX();
                            const pageOffset = xpos / oldWidthWithMargin;
                            const newOffsetPixels = Math.floor(pageOffset * widthWithMargin);
                            this.scrollTo(newOffsetPixels, this.getScrollY());
                            if (!this.mScroller.isFinished()) {
                                const newDuration = this.mScroller.getDuration() - this.mScroller.timePassed();
                                let targetInfo = this.infoForPosition(this.mCurItem);
                                this.mScroller.startScroll(newOffsetPixels, 0, Math.floor(targetInfo.offset * width), 0, newDuration);
                            }
                        }
                        else {
                            const ii = this.infoForPosition(this.mCurItem);
                            const scrollOffset = ii != null ? Math.min(ii.offset, this.mLastOffset) : 0;
                            const scrollPos = Math.floor(scrollOffset *
                                (width - this.getPaddingLeft() - this.getPaddingRight()));
                            if (scrollPos != this.getScrollX()) {
                                this.completeScroll(false);
                                this.scrollTo(scrollPos, this.getScrollY());
                            }
                        }
                    }
                    onLayout(changed, l, t, r, b) {
                        const count = this.getChildCount();
                        let width = r - l;
                        let height = b - t;
                        let paddingLeft = this.getPaddingLeft();
                        let paddingTop = this.getPaddingTop();
                        let paddingRight = this.getPaddingRight();
                        let paddingBottom = this.getPaddingBottom();
                        const scrollX = this.getScrollX();
                        let decorCount = 0;
                        for (let i = 0; i < count; i++) {
                            const child = this.getChildAt(i);
                            if (child.getVisibility() != View.GONE) {
                                const lp = child.getLayoutParams();
                                let childLeft = 0;
                                let childTop = 0;
                                if (lp.isDecor) {
                                    const hgrav = lp.gravity & Gravity.HORIZONTAL_GRAVITY_MASK;
                                    const vgrav = lp.gravity & Gravity.VERTICAL_GRAVITY_MASK;
                                    switch (hgrav) {
                                        default:
                                            childLeft = paddingLeft;
                                            break;
                                        case Gravity.LEFT:
                                            childLeft = paddingLeft;
                                            paddingLeft += child.getMeasuredWidth();
                                            break;
                                        case Gravity.CENTER_HORIZONTAL:
                                            childLeft = Math.max((width - child.getMeasuredWidth()) / 2, paddingLeft);
                                            break;
                                        case Gravity.RIGHT:
                                            childLeft = width - paddingRight - child.getMeasuredWidth();
                                            paddingRight += child.getMeasuredWidth();
                                            break;
                                    }
                                    switch (vgrav) {
                                        default:
                                            childTop = paddingTop;
                                            break;
                                        case Gravity.TOP:
                                            childTop = paddingTop;
                                            paddingTop += child.getMeasuredHeight();
                                            break;
                                        case Gravity.CENTER_VERTICAL:
                                            childTop = Math.max((height - child.getMeasuredHeight()) / 2, paddingTop);
                                            break;
                                        case Gravity.BOTTOM:
                                            childTop = height - paddingBottom - child.getMeasuredHeight();
                                            paddingBottom += child.getMeasuredHeight();
                                            break;
                                    }
                                    childLeft += scrollX;
                                    child.layout(childLeft, childTop, childLeft + child.getMeasuredWidth(), childTop + child.getMeasuredHeight());
                                    decorCount++;
                                }
                            }
                        }
                        const childWidth = width - paddingLeft - paddingRight;
                        for (let i = 0; i < count; i++) {
                            const child = this.getChildAt(i);
                            if (child.getVisibility() != View.GONE) {
                                const lp = child.getLayoutParams();
                                let ii;
                                if (!lp.isDecor && (ii = this.infoForChild(child)) != null) {
                                    let loff = Math.floor(childWidth * ii.offset);
                                    let childLeft = paddingLeft + loff;
                                    let childTop = paddingTop;
                                    if (lp.needsMeasure) {
                                        lp.needsMeasure = false;
                                        const widthSpec = MeasureSpec.makeMeasureSpec(Math.floor(childWidth * lp.widthFactor), MeasureSpec.EXACTLY);
                                        const heightSpec = MeasureSpec.makeMeasureSpec(Math.floor(height - paddingTop - paddingBottom), MeasureSpec.EXACTLY);
                                        child.measure(widthSpec, heightSpec);
                                    }
                                    if (DEBUG)
                                        Log.v(TAG, "Positioning #" + i + " " + child + " f=" + ii.object
                                            + ":" + childLeft + "," + childTop + " " + child.getMeasuredWidth()
                                            + "x" + child.getMeasuredHeight());
                                    child.layout(childLeft, childTop, childLeft + child.getMeasuredWidth(), childTop + child.getMeasuredHeight());
                                }
                            }
                        }
                        this.mTopPageBounds = paddingTop;
                        this.mBottomPageBounds = height - paddingBottom;
                        this.mDecorChildCount = decorCount;
                        if (this.mFirstLayout) {
                            this.scrollToItem(this.mCurItem, false, 0, false);
                        }
                        this.mFirstLayout = false;
                    }
                    computeScroll() {
                        if (!this.mScroller.isFinished() && this.mScroller.computeScrollOffset()) {
                            let oldX = this.getScrollX();
                            let oldY = this.getScrollY();
                            let x = this.mScroller.getCurrX();
                            let y = this.mScroller.getCurrY();
                            if (oldX != x || oldY != y) {
                                this.scrollTo(x, y);
                                if (!this.pageScrolled(x)) {
                                    this.mScroller.abortAnimation();
                                    this.scrollTo(0, y);
                                }
                            }
                            this.postInvalidateOnAnimation();
                            return;
                        }
                        this.completeScroll(true);
                    }
                    pageScrolled(xpos) {
                        if (this.mItems.size() == 0) {
                            this.mCalledSuper = false;
                            this.onPageScrolled(0, 0, 0);
                            if (!this.mCalledSuper) {
                                throw new Error("onPageScrolled did not call superclass implementation");
                            }
                            return false;
                        }
                        const ii = this.infoForCurrentScrollPosition();
                        const width = this.getClientWidth();
                        const widthWithMargin = width + this.mPageMargin;
                        const marginOffset = this.mPageMargin / width;
                        const currentPage = ii.position;
                        const pageOffset = ((xpos / width) - ii.offset) / (ii.widthFactor + marginOffset);
                        const offsetPixels = Math.floor(pageOffset * widthWithMargin);
                        this.mCalledSuper = false;
                        this.onPageScrolled(currentPage, pageOffset, offsetPixels);
                        if (!this.mCalledSuper) {
                            throw new Error("onPageScrolled did not call superclass implementation");
                        }
                        return true;
                    }
                    onPageScrolled(position, offset, offsetPixels) {
                        if (this.mDecorChildCount > 0) {
                            const scrollX = this.getScrollX();
                            let paddingLeft = this.getPaddingLeft();
                            let paddingRight = this.getPaddingRight();
                            const width = this.getWidth();
                            const childCount = this.getChildCount();
                            for (let i = 0; i < childCount; i++) {
                                const child = this.getChildAt(i);
                                const lp = child.getLayoutParams();
                                if (!lp.isDecor)
                                    continue;
                                const hgrav = lp.gravity & Gravity.HORIZONTAL_GRAVITY_MASK;
                                let childLeft = 0;
                                switch (hgrav) {
                                    default:
                                        childLeft = paddingLeft;
                                        break;
                                    case Gravity.LEFT:
                                        childLeft = paddingLeft;
                                        paddingLeft += child.getWidth();
                                        break;
                                    case Gravity.CENTER_HORIZONTAL:
                                        childLeft = Math.max((width - child.getMeasuredWidth()) / 2, paddingLeft);
                                        break;
                                    case Gravity.RIGHT:
                                        childLeft = width - paddingRight - child.getMeasuredWidth();
                                        paddingRight += child.getMeasuredWidth();
                                        break;
                                }
                                childLeft += scrollX;
                                const childOffset = childLeft - child.getLeft();
                                if (childOffset != 0) {
                                    child.offsetLeftAndRight(childOffset);
                                }
                            }
                        }
                        this.dispatchOnPageScrolled(position, offset, offsetPixels);
                        if (this.mPageTransformer != null) {
                            const scrollX = this.getScrollX();
                            const childCount = this.getChildCount();
                            for (let i = 0; i < childCount; i++) {
                                const child = this.getChildAt(i);
                                const lp = child.getLayoutParams();
                                if (lp.isDecor)
                                    continue;
                                const transformPos = (child.getLeft() - scrollX) / this.getClientWidth();
                                this.mPageTransformer.transformPage(child, transformPos);
                            }
                        }
                        this.mCalledSuper = true;
                    }
                    dispatchOnPageScrolled(position, offset, offsetPixels) {
                        if (this.mOnPageChangeListener != null) {
                            this.mOnPageChangeListener.onPageScrolled(position, offset, offsetPixels);
                        }
                        if (this.mOnPageChangeListeners != null) {
                            for (let i = 0, z = this.mOnPageChangeListeners.size(); i < z; i++) {
                                let listener = this.mOnPageChangeListeners.get(i);
                                if (listener != null) {
                                    listener.onPageScrolled(position, offset, offsetPixels);
                                }
                            }
                        }
                        if (this.mInternalPageChangeListener != null) {
                            this.mInternalPageChangeListener.onPageScrolled(position, offset, offsetPixels);
                        }
                    }
                    dispatchOnPageSelected(position) {
                        if (this.mOnPageChangeListener != null) {
                            this.mOnPageChangeListener.onPageSelected(position);
                        }
                        if (this.mOnPageChangeListeners != null) {
                            for (let i = 0, z = this.mOnPageChangeListeners.size(); i < z; i++) {
                                let listener = this.mOnPageChangeListeners.get(i);
                                if (listener != null) {
                                    listener.onPageSelected(position);
                                }
                            }
                        }
                        if (this.mInternalPageChangeListener != null) {
                            this.mInternalPageChangeListener.onPageSelected(position);
                        }
                    }
                    dispatchOnScrollStateChanged(state) {
                        if (this.mOnPageChangeListener != null) {
                            this.mOnPageChangeListener.onPageScrollStateChanged(state);
                        }
                        if (this.mOnPageChangeListeners != null) {
                            for (let i = 0, z = this.mOnPageChangeListeners.size(); i < z; i++) {
                                let listener = this.mOnPageChangeListeners.get(i);
                                if (listener != null) {
                                    listener.onPageScrollStateChanged(state);
                                }
                            }
                        }
                        if (this.mInternalPageChangeListener != null) {
                            this.mInternalPageChangeListener.onPageScrollStateChanged(state);
                        }
                    }
                    completeScroll(postEvents) {
                        let needPopulate = this.mScrollState == ViewPager.SCROLL_STATE_SETTLING;
                        if (needPopulate) {
                            this.setScrollingCacheEnabled(false);
                            this.mScroller.abortAnimation();
                            let oldX = this.getScrollX();
                            let oldY = this.getScrollY();
                            let x = this.mScroller.getCurrX();
                            let y = this.mScroller.getCurrY();
                            if (oldX != x || oldY != y) {
                                this.scrollTo(x, y);
                                if (x != oldX) {
                                    this.pageScrolled(x);
                                }
                            }
                        }
                        this.mPopulatePending = false;
                        for (let i = 0; i < this.mItems.size(); i++) {
                            let ii = this.mItems.get(i);
                            if (ii.scrolling) {
                                needPopulate = true;
                                ii.scrolling = false;
                            }
                        }
                        if (needPopulate) {
                            if (postEvents) {
                                this.postOnAnimation(this.mEndScrollRunnable);
                            }
                            else {
                                this.mEndScrollRunnable.run();
                            }
                        }
                    }
                    isGutterDrag(x, dx) {
                        return (x < this.mGutterSize && dx > 0) || (x > this.getWidth() - this.mGutterSize && dx < 0);
                    }
                    enableLayers(enable) {
                    }
                    onInterceptTouchEvent(ev) {
                        /*
                         * This method JUST determines whether we want to intercept the motion.
                         * If we return true, onMotionEvent will be called and we do the actual
                         * scrolling there.
                         */
                        const action = ev.getAction() & MotionEvent.ACTION_MASK;
                        if (action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_UP) {
                            if (DEBUG)
                                Log.v(TAG, "Intercept done!");
                            this.resetTouch();
                            return false;
                        }
                        if (action != MotionEvent.ACTION_DOWN) {
                            if (this.mIsBeingDragged) {
                                if (DEBUG)
                                    Log.v(TAG, "Intercept returning true!");
                                return true;
                            }
                            if (this.mIsUnableToDrag) {
                                if (DEBUG)
                                    Log.v(TAG, "Intercept returning false!");
                                return false;
                            }
                        }
                        switch (action) {
                            case MotionEvent.ACTION_MOVE: {
                                const activePointerId = this.mActivePointerId;
                                if (activePointerId == ViewPager.INVALID_POINTER) {
                                    break;
                                }
                                const pointerIndex = ev.findPointerIndex(activePointerId);
                                const x = ev.getX(pointerIndex);
                                const dx = x - this.mLastMotionX;
                                const xDiff = Math.abs(dx);
                                const y = ev.getY(pointerIndex);
                                const yDiff = Math.abs(y - this.mInitialMotionY);
                                if (DEBUG)
                                    Log.v(TAG, "Moved x to " + x + "," + y + " diff=" + xDiff + "," + yDiff);
                                if (dx != 0 && !this.isGutterDrag(this.mLastMotionX, dx) &&
                                    this.canScroll(this, false, Math.floor(dx), Math.floor(x), Math.floor(y))) {
                                    this.mLastMotionX = x;
                                    this.mLastMotionY = y;
                                    this.mIsUnableToDrag = true;
                                    return false;
                                }
                                if (xDiff > this.mTouchSlop && xDiff * 0.5 > yDiff) {
                                    if (DEBUG)
                                        Log.v(TAG, "Starting drag!");
                                    this.mIsBeingDragged = true;
                                    this.requestParentDisallowInterceptTouchEvent(true);
                                    this.setScrollState(ViewPager.SCROLL_STATE_DRAGGING);
                                    this.mLastMotionX = dx > 0 ? this.mInitialMotionX + this.mTouchSlop :
                                        this.mInitialMotionX - this.mTouchSlop;
                                    this.mLastMotionY = y;
                                    this.setScrollingCacheEnabled(true);
                                }
                                else if (yDiff > this.mTouchSlop) {
                                    if (DEBUG)
                                        Log.v(TAG, "Starting unable to drag!");
                                    this.mIsUnableToDrag = true;
                                }
                                if (this.mIsBeingDragged) {
                                    if (this.performDrag(x)) {
                                        this.postInvalidateOnAnimation();
                                    }
                                }
                                break;
                            }
                            case MotionEvent.ACTION_DOWN: {
                                this.mLastMotionX = this.mInitialMotionX = ev.getX();
                                this.mLastMotionY = this.mInitialMotionY = ev.getY();
                                this.mActivePointerId = ev.getPointerId(0);
                                this.mIsUnableToDrag = false;
                                this.mScroller.computeScrollOffset();
                                if (this.mScrollState == ViewPager.SCROLL_STATE_SETTLING &&
                                    Math.abs(this.mScroller.getFinalX() - this.mScroller.getCurrX()) > this.mCloseEnough) {
                                    this.mScroller.abortAnimation();
                                    this.mPopulatePending = false;
                                    this.populate();
                                    this.mIsBeingDragged = true;
                                    this.requestParentDisallowInterceptTouchEvent(true);
                                    this.setScrollState(ViewPager.SCROLL_STATE_DRAGGING);
                                }
                                else {
                                    this.completeScroll(false);
                                    this.mIsBeingDragged = false;
                                }
                                if (DEBUG)
                                    Log.v(TAG, "Down at " + this.mLastMotionX + "," + this.mLastMotionY
                                        + " mIsBeingDragged=" + this.mIsBeingDragged
                                        + "mIsUnableToDrag=" + this.mIsUnableToDrag);
                                break;
                            }
                            case MotionEvent.ACTION_POINTER_UP:
                                this.onSecondaryPointerUp(ev);
                                break;
                        }
                        if (this.mVelocityTracker == null) {
                            this.mVelocityTracker = VelocityTracker.obtain();
                        }
                        this.mVelocityTracker.addMovement(ev);
                        return this.mIsBeingDragged;
                    }
                    onTouchEvent(ev) {
                        if (this.mFakeDragging) {
                            return true;
                        }
                        if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
                            return false;
                        }
                        if (this.mAdapter == null || this.mAdapter.getCount() == 0) {
                            return false;
                        }
                        if (this.mVelocityTracker == null) {
                            this.mVelocityTracker = VelocityTracker.obtain();
                        }
                        this.mVelocityTracker.addMovement(ev);
                        const action = ev.getAction();
                        let needsInvalidate = false;
                        switch (action & MotionEvent.ACTION_MASK) {
                            case MotionEvent.ACTION_DOWN: {
                                this.mScroller.abortAnimation();
                                this.mPopulatePending = false;
                                this.populate();
                                this.mLastMotionX = this.mInitialMotionX = ev.getX();
                                this.mLastMotionY = this.mInitialMotionY = ev.getY();
                                this.mActivePointerId = ev.getPointerId(0);
                                break;
                            }
                            case MotionEvent.ACTION_MOVE:
                                if (!this.mIsBeingDragged) {
                                    const pointerIndex = ev.findPointerIndex(this.mActivePointerId);
                                    if (pointerIndex == -1) {
                                        needsInvalidate = this.resetTouch();
                                        break;
                                    }
                                    const x = ev.getX(pointerIndex);
                                    const xDiff = Math.abs(x - this.mLastMotionX);
                                    const y = ev.getY(pointerIndex);
                                    const yDiff = Math.abs(y - this.mLastMotionY);
                                    if (DEBUG)
                                        Log.v(TAG, "Moved x to " + x + "," + y + " diff=" + xDiff + "," + yDiff);
                                    if (xDiff > this.mTouchSlop && xDiff > yDiff) {
                                        if (DEBUG)
                                            Log.v(TAG, "Starting drag!");
                                        this.mIsBeingDragged = true;
                                        this.requestParentDisallowInterceptTouchEvent(true);
                                        this.mLastMotionX = x - this.mInitialMotionX > 0 ? this.mInitialMotionX + this.mTouchSlop :
                                            this.mInitialMotionX - this.mTouchSlop;
                                        this.mLastMotionY = y;
                                        this.setScrollState(ViewPager.SCROLL_STATE_DRAGGING);
                                        this.setScrollingCacheEnabled(true);
                                        let parent = this.getParent();
                                        if (parent != null) {
                                            parent.requestDisallowInterceptTouchEvent(true);
                                        }
                                    }
                                }
                                if (this.mIsBeingDragged) {
                                    const activePointerIndex = ev.findPointerIndex(this.mActivePointerId);
                                    const x = ev.getX(activePointerIndex);
                                    needsInvalidate = needsInvalidate || this.performDrag(x);
                                }
                                break;
                            case MotionEvent.ACTION_UP:
                                if (this.mIsBeingDragged) {
                                    const velocityTracker = this.mVelocityTracker;
                                    velocityTracker.computeCurrentVelocity(1000, this.mMaximumVelocity);
                                    let initialVelocity = velocityTracker.getXVelocity(this.mActivePointerId);
                                    this.mPopulatePending = true;
                                    const width = this.getClientWidth();
                                    const scrollX = this.getScrollX();
                                    const ii = this.infoForCurrentScrollPosition();
                                    const currentPage = ii.position;
                                    const pageOffset = ((scrollX / width) - ii.offset) / ii.widthFactor;
                                    const activePointerIndex = ev.findPointerIndex(this.mActivePointerId);
                                    const x = ev.getX(activePointerIndex);
                                    const totalDelta = (x - this.mInitialMotionX);
                                    let nextPage = this.determineTargetPage(currentPage, pageOffset, initialVelocity, totalDelta);
                                    this.setCurrentItemInternal(nextPage, true, true, initialVelocity);
                                    needsInvalidate = this.resetTouch();
                                }
                                break;
                            case MotionEvent.ACTION_CANCEL:
                                if (this.mIsBeingDragged) {
                                    this.scrollToItem(this.mCurItem, true, 0, false);
                                    needsInvalidate = this.resetTouch();
                                }
                                break;
                            case MotionEvent.ACTION_POINTER_DOWN: {
                                const index = ev.getActionIndex();
                                const x = ev.getX(index);
                                this.mLastMotionX = x;
                                this.mActivePointerId = ev.getPointerId(index);
                                break;
                            }
                            case MotionEvent.ACTION_POINTER_UP:
                                this.onSecondaryPointerUp(ev);
                                this.mLastMotionX = ev.getX(ev.findPointerIndex(this.mActivePointerId));
                                break;
                        }
                        if (needsInvalidate) {
                            this.postInvalidateOnAnimation();
                        }
                        return true;
                    }
                    resetTouch() {
                        let needsInvalidate = false;
                        this.mActivePointerId = ViewPager.INVALID_POINTER;
                        this.endDrag();
                        return needsInvalidate;
                    }
                    requestParentDisallowInterceptTouchEvent(disallowIntercept) {
                        const parent = this.getParent();
                        if (parent != null) {
                            parent.requestDisallowInterceptTouchEvent(disallowIntercept);
                        }
                    }
                    performDrag(x) {
                        let needsInvalidate = false;
                        const deltaX = this.mLastMotionX - x;
                        this.mLastMotionX = x;
                        let oldScrollX = this.getScrollX();
                        let scrollX = oldScrollX + deltaX;
                        const width = this.getClientWidth();
                        let leftBound = width * this.mFirstOffset;
                        let rightBound = width * this.mLastOffset;
                        let leftAbsolute = true;
                        let rightAbsolute = true;
                        const firstItem = this.mItems.get(0);
                        const lastItem = this.mItems.get(this.mItems.size() - 1);
                        if (firstItem.position != 0) {
                            leftAbsolute = false;
                            leftBound = firstItem.offset * width;
                        }
                        if (lastItem.position != this.mAdapter.getCount() - 1) {
                            rightAbsolute = false;
                            rightBound = lastItem.offset * width;
                        }
                        if (scrollX < leftBound) {
                            if (leftAbsolute) {
                                let over = leftBound - scrollX;
                                needsInvalidate = false;
                            }
                            scrollX -= deltaX / 2;
                        }
                        else if (scrollX > rightBound) {
                            if (rightAbsolute) {
                                let over = scrollX - rightBound;
                                needsInvalidate = false;
                            }
                            scrollX -= deltaX / 2;
                        }
                        this.mLastMotionX += scrollX - Math.floor(scrollX);
                        this.scrollTo(scrollX, this.getScrollY());
                        this.pageScrolled(scrollX);
                        return needsInvalidate;
                    }
                    infoForCurrentScrollPosition() {
                        const width = this.getClientWidth();
                        const scrollOffset = width > 0 ? this.getScrollX() / width : 0;
                        const marginOffset = width > 0 ? this.mPageMargin / width : 0;
                        let lastPos = -1;
                        let lastOffset = 0;
                        let lastWidth = 0;
                        let first = true;
                        let lastItem = null;
                        for (let i = 0; i < this.mItems.size(); i++) {
                            let ii = this.mItems.get(i);
                            let offset;
                            if (!first && ii.position != lastPos + 1) {
                                ii = this.mTempItem;
                                ii.offset = lastOffset + lastWidth + marginOffset;
                                ii.position = lastPos + 1;
                                ii.widthFactor = this.mAdapter.getPageWidth(ii.position);
                                i--;
                            }
                            offset = ii.offset;
                            const leftBound = offset;
                            const rightBound = offset + ii.widthFactor + marginOffset;
                            if (first || scrollOffset >= leftBound) {
                                if (scrollOffset < rightBound || i == this.mItems.size() - 1) {
                                    return ii;
                                }
                            }
                            else {
                                return lastItem;
                            }
                            first = false;
                            lastPos = ii.position;
                            lastOffset = offset;
                            lastWidth = ii.widthFactor;
                            lastItem = ii;
                        }
                        return lastItem;
                    }
                    determineTargetPage(currentPage, pageOffset, velocity, deltaX) {
                        let targetPage;
                        if (Math.abs(deltaX) > this.mFlingDistance && Math.abs(velocity) > this.mMinimumVelocity) {
                            targetPage = velocity > 0 ? currentPage : currentPage + 1;
                        }
                        else {
                            const truncator = currentPage >= this.mCurItem ? 0.4 : 0.6;
                            targetPage = Math.floor(currentPage + pageOffset + truncator);
                        }
                        if (this.mItems.size() > 0) {
                            const firstItem = this.mItems.get(0);
                            const lastItem = this.mItems.get(this.mItems.size() - 1);
                            targetPage = Math.max(firstItem.position, Math.min(targetPage, lastItem.position));
                        }
                        return targetPage;
                    }
                    draw(canvas) {
                        super.draw(canvas);
                        let needsInvalidate = false;
                        if (needsInvalidate) {
                            this.postInvalidateOnAnimation();
                        }
                    }
                    onDraw(canvas) {
                        super.onDraw(canvas);
                        if (this.mPageMargin > 0 && this.mMarginDrawable != null && this.mItems.size() > 0 && this.mAdapter != null) {
                            const scrollX = this.getScrollX();
                            const width = this.getWidth();
                            const marginOffset = this.mPageMargin / width;
                            let itemIndex = 0;
                            let ii = this.mItems.get(0);
                            let offset = ii.offset;
                            const itemCount = this.mItems.size();
                            const firstPos = ii.position;
                            const lastPos = this.mItems.get(itemCount - 1).position;
                            for (let pos = firstPos; pos < lastPos; pos++) {
                                while (pos > ii.position && itemIndex < itemCount) {
                                    ii = this.mItems.get(++itemIndex);
                                }
                                let drawAt;
                                if (pos == ii.position) {
                                    drawAt = (ii.offset + ii.widthFactor) * width;
                                    offset = ii.offset + ii.widthFactor + marginOffset;
                                }
                                else {
                                    let widthFactor = this.mAdapter.getPageWidth(pos);
                                    drawAt = (offset + widthFactor) * width;
                                    offset += widthFactor + marginOffset;
                                }
                                if (drawAt + this.mPageMargin > scrollX) {
                                    this.mMarginDrawable.setBounds(drawAt, this.mTopPageBounds, drawAt + this.mPageMargin, this.mBottomPageBounds);
                                    this.mMarginDrawable.draw(canvas);
                                }
                                if (drawAt > scrollX + width) {
                                    break;
                                }
                            }
                        }
                    }
                    beginFakeDrag() {
                        if (this.mIsBeingDragged) {
                            return false;
                        }
                        this.mFakeDragging = true;
                        this.setScrollState(ViewPager.SCROLL_STATE_DRAGGING);
                        this.mInitialMotionX = this.mLastMotionX = 0;
                        if (this.mVelocityTracker == null) {
                            this.mVelocityTracker = VelocityTracker.obtain();
                        }
                        else {
                            this.mVelocityTracker.clear();
                        }
                        const time = android.os.SystemClock.uptimeMillis();
                        const ev = MotionEvent.obtainWithAction(time, time, MotionEvent.ACTION_DOWN, 0, 0, 0);
                        this.mVelocityTracker.addMovement(ev);
                        ev.recycle();
                        this.mFakeDragBeginTime = time;
                        return true;
                    }
                    endFakeDrag() {
                        if (!this.mFakeDragging) {
                            throw new Error("No fake drag in progress. Call beginFakeDrag first.");
                        }
                        const velocityTracker = this.mVelocityTracker;
                        velocityTracker.computeCurrentVelocity(1000, this.mMaximumVelocity);
                        let initialVelocity = Math.floor(velocityTracker.getXVelocity(this.mActivePointerId));
                        this.mPopulatePending = true;
                        const width = this.getClientWidth();
                        const scrollX = this.getScrollX();
                        const ii = this.infoForCurrentScrollPosition();
                        const currentPage = ii.position;
                        const pageOffset = ((scrollX / width) - ii.offset) / ii.widthFactor;
                        const totalDelta = Math.floor(this.mLastMotionX - this.mInitialMotionX);
                        let nextPage = this.determineTargetPage(currentPage, pageOffset, initialVelocity, totalDelta);
                        this.setCurrentItemInternal(nextPage, true, true, initialVelocity);
                        this.endDrag();
                        this.mFakeDragging = false;
                    }
                    fakeDragBy(xOffset) {
                        if (!this.mFakeDragging) {
                            throw new Error("No fake drag in progress. Call beginFakeDrag first.");
                        }
                        this.mLastMotionX += xOffset;
                        let oldScrollX = this.getScrollX();
                        let scrollX = oldScrollX - xOffset;
                        const width = this.getClientWidth();
                        let leftBound = width * this.mFirstOffset;
                        let rightBound = width * this.mLastOffset;
                        const firstItem = this.mItems.get(0);
                        const lastItem = this.mItems.get(this.mItems.size() - 1);
                        if (firstItem.position != 0) {
                            leftBound = firstItem.offset * width;
                        }
                        if (lastItem.position != this.mAdapter.getCount() - 1) {
                            rightBound = lastItem.offset * width;
                        }
                        if (scrollX < leftBound) {
                            scrollX = leftBound;
                        }
                        else if (scrollX > rightBound) {
                            scrollX = rightBound;
                        }
                        this.mLastMotionX += scrollX - Math.floor(scrollX);
                        this.scrollTo(Math.floor(scrollX), this.getScrollY());
                        this.pageScrolled(Math.floor(scrollX));
                        const time = android.os.SystemClock.uptimeMillis();
                        const ev = MotionEvent.obtainWithAction(this.mFakeDragBeginTime, time, MotionEvent.ACTION_MOVE, this.mLastMotionX, 0, 0);
                        this.mVelocityTracker.addMovement(ev);
                        ev.recycle();
                    }
                    isFakeDragging() {
                        return this.mFakeDragging;
                    }
                    onSecondaryPointerUp(ev) {
                        const pointerIndex = ev.getActionIndex();
                        const pointerId = ev.getPointerId(pointerIndex);
                        if (pointerId == this.mActivePointerId) {
                            const newPointerIndex = pointerIndex == 0 ? 1 : 0;
                            this.mLastMotionX = ev.getX(newPointerIndex);
                            this.mActivePointerId = ev.getPointerId(newPointerIndex);
                            if (this.mVelocityTracker != null) {
                                this.mVelocityTracker.clear();
                            }
                        }
                    }
                    endDrag() {
                        this.mIsBeingDragged = false;
                        this.mIsUnableToDrag = false;
                        if (this.mVelocityTracker != null) {
                            this.mVelocityTracker.recycle();
                            this.mVelocityTracker = null;
                        }
                    }
                    setScrollingCacheEnabled(enabled) {
                        if (this.mScrollingCacheEnabled != enabled) {
                            this.mScrollingCacheEnabled = enabled;
                            if (ViewPager.USE_CACHE) {
                                const size = this.getChildCount();
                                for (let i = 0; i < size; ++i) {
                                    const child = this.getChildAt(i);
                                    if (child.getVisibility() != View.GONE) {
                                        child.setDrawingCacheEnabled(enabled);
                                    }
                                }
                            }
                        }
                    }
                    canScrollHorizontally(direction) {
                        if (this.mAdapter == null) {
                            return false;
                        }
                        const width = this.getClientWidth();
                        const scrollX = this.getScrollX();
                        if (direction < 0) {
                            return (scrollX > (width * this.mFirstOffset));
                        }
                        else if (direction > 0) {
                            return (scrollX < (width * this.mLastOffset));
                        }
                        else {
                            return false;
                        }
                    }
                    canScroll(v, checkV, dx, x, y) {
                        if (v instanceof ViewGroup) {
                            const group = v;
                            const scrollX = v.getScrollX();
                            const scrollY = v.getScrollY();
                            const count = group.getChildCount();
                            for (let i = count - 1; i >= 0; i--) {
                                const child = group.getChildAt(i);
                                if (x + scrollX >= child.getLeft() && x + scrollX < child.getRight() &&
                                    y + scrollY >= child.getTop() && y + scrollY < child.getBottom() &&
                                    this.canScroll(child, true, dx, x + scrollX - child.getLeft(), y + scrollY - child.getTop())) {
                                    return true;
                                }
                            }
                        }
                        return checkV && v.canScrollHorizontally(-dx);
                    }
                    dispatchKeyEvent(event) {
                        return super.dispatchKeyEvent(event) || this.executeKeyEvent(event);
                    }
                    executeKeyEvent(event) {
                        let handled = false;
                        if (event.getAction() == KeyEvent.ACTION_DOWN) {
                            switch (event.getKeyCode()) {
                                case KeyEvent.KEYCODE_DPAD_LEFT:
                                    handled = this.arrowScroll(View.FOCUS_LEFT);
                                    break;
                                case KeyEvent.KEYCODE_DPAD_RIGHT:
                                    handled = this.arrowScroll(View.FOCUS_RIGHT);
                                    break;
                                case KeyEvent.KEYCODE_TAB:
                                    if (event.isShiftPressed()) {
                                        handled = this.arrowScroll(View.FOCUS_BACKWARD);
                                    }
                                    else {
                                        handled = this.arrowScroll(View.FOCUS_FORWARD);
                                    }
                                    break;
                            }
                        }
                        return handled;
                    }
                    arrowScroll(direction) {
                        let currentFocused = this.findFocus();
                        if (currentFocused == this) {
                            currentFocused = null;
                        }
                        else if (currentFocused != null) {
                            let isChild = false;
                            for (let parent = currentFocused.getParent(); parent instanceof ViewGroup; parent = parent.getParent()) {
                                if (parent == this) {
                                    isChild = true;
                                    break;
                                }
                            }
                            if (!isChild) {
                                const sb = new java.lang.StringBuilder();
                                sb.append(currentFocused.toString());
                                for (let parent = currentFocused.getParent(); parent instanceof ViewGroup; parent = parent.getParent()) {
                                    sb.append(" => ").append(parent.toString());
                                }
                                Log.e(TAG, "arrowScroll tried to find focus based on non-child " +
                                    "current focused view " + sb.toString());
                                currentFocused = null;
                            }
                        }
                        let handled = false;
                        let nextFocused = android.view.FocusFinder.getInstance().findNextFocus(this, currentFocused, direction);
                        if (nextFocused != null && nextFocused != currentFocused) {
                            if (direction == View.FOCUS_LEFT) {
                                const nextLeft = this.getChildRectInPagerCoordinates(this.mTempRect, nextFocused).left;
                                const currLeft = this.getChildRectInPagerCoordinates(this.mTempRect, currentFocused).left;
                                if (currentFocused != null && nextLeft >= currLeft) {
                                    handled = this.pageLeft();
                                }
                                else {
                                    handled = nextFocused.requestFocus();
                                }
                            }
                            else if (direction == View.FOCUS_RIGHT) {
                                const nextLeft = this.getChildRectInPagerCoordinates(this.mTempRect, nextFocused).left;
                                const currLeft = this.getChildRectInPagerCoordinates(this.mTempRect, currentFocused).left;
                                if (currentFocused != null && nextLeft <= currLeft) {
                                    handled = this.pageRight();
                                }
                                else {
                                    handled = nextFocused.requestFocus();
                                }
                            }
                        }
                        else if (direction == View.FOCUS_LEFT || direction == View.FOCUS_BACKWARD) {
                            handled = this.pageLeft();
                        }
                        else if (direction == View.FOCUS_RIGHT || direction == View.FOCUS_FORWARD) {
                            handled = this.pageRight();
                        }
                        return handled;
                    }
                    getChildRectInPagerCoordinates(outRect, child) {
                        if (outRect == null) {
                            outRect = new Rect();
                        }
                        if (child == null) {
                            outRect.set(0, 0, 0, 0);
                            return outRect;
                        }
                        outRect.left = child.getLeft();
                        outRect.right = child.getRight();
                        outRect.top = child.getTop();
                        outRect.bottom = child.getBottom();
                        let parent = child.getParent();
                        while (parent instanceof ViewGroup && parent != this) {
                            const group = parent;
                            outRect.left += group.getLeft();
                            outRect.right += group.getRight();
                            outRect.top += group.getTop();
                            outRect.bottom += group.getBottom();
                            parent = group.getParent();
                        }
                        return outRect;
                    }
                    pageLeft() {
                        if (this.mCurItem > 0) {
                            this.setCurrentItem(this.mCurItem - 1, true);
                            return true;
                        }
                        return false;
                    }
                    pageRight() {
                        if (this.mAdapter != null && this.mCurItem < (this.mAdapter.getCount() - 1)) {
                            this.setCurrentItem(this.mCurItem + 1, true);
                            return true;
                        }
                        return false;
                    }
                    addFocusables(views, direction, focusableMode) {
                        const focusableCount = views.size();
                        const descendantFocusability = this.getDescendantFocusability();
                        if (descendantFocusability != ViewGroup.FOCUS_BLOCK_DESCENDANTS) {
                            for (let i = 0; i < this.getChildCount(); i++) {
                                const child = this.getChildAt(i);
                                if (child.getVisibility() == View.VISIBLE) {
                                    let ii = this.infoForChild(child);
                                    if (ii != null && ii.position == this.mCurItem) {
                                        child.addFocusables(views, direction, focusableMode);
                                    }
                                }
                            }
                        }
                        if (descendantFocusability != ViewGroup.FOCUS_AFTER_DESCENDANTS ||
                            (focusableCount == views.size())) {
                            if (!this.isFocusable()) {
                                return;
                            }
                            if ((focusableMode & ViewGroup.FOCUSABLES_TOUCH_MODE) == ViewGroup.FOCUSABLES_TOUCH_MODE &&
                                this.isInTouchMode() && !this.isFocusableInTouchMode()) {
                                return;
                            }
                            if (views != null) {
                                views.add(this);
                            }
                        }
                    }
                    addTouchables(views) {
                        for (let i = 0; i < this.getChildCount(); i++) {
                            const child = this.getChildAt(i);
                            if (child.getVisibility() == View.VISIBLE) {
                                let ii = this.infoForChild(child);
                                if (ii != null && ii.position == this.mCurItem) {
                                    child.addTouchables(views);
                                }
                            }
                        }
                    }
                    onRequestFocusInDescendants(direction, previouslyFocusedRect) {
                        let index;
                        let increment;
                        let end;
                        let count = this.getChildCount();
                        if ((direction & View.FOCUS_FORWARD) != 0) {
                            index = 0;
                            increment = 1;
                            end = count;
                        }
                        else {
                            index = count - 1;
                            increment = -1;
                            end = -1;
                        }
                        for (let i = index; i != end; i += increment) {
                            let child = this.getChildAt(i);
                            if (child.getVisibility() == View.VISIBLE) {
                                let ii = this.infoForChild(child);
                                if (ii != null && ii.position == this.mCurItem) {
                                    if (child.requestFocus(direction, previouslyFocusedRect)) {
                                        return true;
                                    }
                                }
                            }
                        }
                        return false;
                    }
                    generateDefaultLayoutParams() {
                        return new ViewPager.LayoutParams();
                    }
                    generateLayoutParams(p) {
                        return this.generateDefaultLayoutParams();
                    }
                    checkLayoutParams(p) {
                        return p instanceof ViewPager.LayoutParams && super.checkLayoutParams(p);
                    }
                    static isImplDecor(view) {
                        return view[SymbolDecor] || view.constructor[SymbolDecor];
                    }
                    static setClassImplDecor(clazz) {
                        clazz[SymbolDecor] = true;
                    }
                }
                ViewPager.COMPARATOR = (lhs, rhs) => {
                    return lhs.position - rhs.position;
                };
                ViewPager.USE_CACHE = false;
                ViewPager.DEFAULT_OFFSCREEN_PAGES = 1;
                ViewPager.MAX_SETTLE_DURATION = 600;
                ViewPager.MIN_DISTANCE_FOR_FLING = 25;
                ViewPager.DEFAULT_GUTTER_SIZE = 16;
                ViewPager.MIN_FLING_VELOCITY = 400;
                ViewPager.sInterpolator = {
                    getInterpolation(t) {
                        t -= 1.0;
                        return t * t * t * t * t + 1.0;
                    }
                };
                ViewPager.INVALID_POINTER = -1;
                ViewPager.CLOSE_ENOUGH = 2;
                ViewPager.DRAW_ORDER_DEFAULT = 0;
                ViewPager.DRAW_ORDER_FORWARD = 1;
                ViewPager.DRAW_ORDER_REVERSE = 2;
                ViewPager.sPositionComparator = (lhs, rhs) => {
                    let llp = lhs.getLayoutParams();
                    let rlp = rhs.getLayoutParams();
                    if (llp.isDecor != rlp.isDecor) {
                        return llp.isDecor ? 1 : -1;
                    }
                    return llp.position - rlp.position;
                };
                ViewPager.SCROLL_STATE_IDLE = 0;
                ViewPager.SCROLL_STATE_DRAGGING = 1;
                ViewPager.SCROLL_STATE_SETTLING = 2;
                view_6.ViewPager = ViewPager;
                (function (ViewPager) {
                    class SimpleOnPageChangeListener {
                        onPageScrolled(position, positionOffset, positionOffsetPixels) {
                        }
                        onPageSelected(position) {
                        }
                        onPageScrollStateChanged(state) {
                        }
                    }
                    ViewPager.SimpleOnPageChangeListener = SimpleOnPageChangeListener;
                    class LayoutParams extends ViewGroup.LayoutParams {
                        constructor() {
                            super(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
                            this.isDecor = false;
                            this.gravity = 0;
                            this.widthFactor = 0;
                            this.needsMeasure = false;
                            this.position = 0;
                            this.childIndex = 0;
                            this._attrBinder.addAttr('gravity', (value) => {
                                this.gravity = this._attrBinder.parseGravity(value, this.gravity);
                            }, () => {
                                return this.gravity;
                            });
                        }
                    }
                    ViewPager.LayoutParams = LayoutParams;
                })(ViewPager = view_6.ViewPager || (view_6.ViewPager = {}));
                class ItemInfo {
                    constructor() {
                        this.position = 0;
                        this.scrolling = false;
                        this.widthFactor = 0;
                        this.offset = 0;
                    }
                }
                class PagerObserver extends DataSetObserver {
                    constructor(viewPager) {
                        super();
                        this.ViewPager_this = viewPager;
                    }
                    onChanged() {
                        this.ViewPager_this.dataSetChanged();
                    }
                    onInvalidated() {
                        this.ViewPager_this.dataSetChanged();
                    }
                }
            })(view = v4.view || (v4.view = {}));
        })(v4 = support.v4 || (support.v4 = {}));
    })(support = android.support || (android.support = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2013 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../../android/view/MotionEvent.ts"/>
///<reference path="../../../../android/view/VelocityTracker.ts"/>
///<reference path="../../../../android/view/View.ts"/>
///<reference path="../../../../android/view/ViewConfiguration.ts"/>
///<reference path="../../../../android/view/ViewGroup.ts"/>
///<reference path="../../../../android/widget/OverScroller.ts"/>
///<reference path="../../../../android/view/animation/Interpolator.ts"/>
///<reference path="../../../../java/lang/System.ts"/>
var android;
(function (android) {
    var support;
    (function (support) {
        var v4;
        (function (v4) {
            var widget;
            (function (widget) {
                var MotionEvent = android.view.MotionEvent;
                var VelocityTracker = android.view.VelocityTracker;
                var ViewConfiguration = android.view.ViewConfiguration;
                var ViewGroup = android.view.ViewGroup;
                var OverScroller = android.widget.OverScroller;
                var System = java.lang.System;
                class ViewDragHelper {
                    constructor(forParent, cb) {
                        this.mDragState = 0;
                        this.mTouchSlop = 0;
                        this.mActivePointerId = ViewDragHelper.INVALID_POINTER;
                        this.mPointersDown = 0;
                        this.mMaxVelocity = 0;
                        this.mMinVelocity = 0;
                        this.mEdgeSize = 0;
                        this.mTrackingEdges = 0;
                        this.mSetIdleRunnable = (() => {
                            const _this = this;
                            class _Inner {
                                run() {
                                    _this.setDragState(ViewDragHelper.STATE_IDLE);
                                }
                            }
                            return new _Inner();
                        })();
                        if (forParent == null) {
                            throw Error(`new IllegalArgumentException("Parent view may not be null")`);
                        }
                        if (cb == null) {
                            throw Error(`new IllegalArgumentException("Callback may not be null")`);
                        }
                        this.mParentView = forParent;
                        this.mCallback = cb;
                        const vc = ViewConfiguration.get();
                        const density = android.content.res.Resources.getDisplayMetrics().density;
                        this.mEdgeSize = Math.floor((ViewDragHelper.EDGE_SIZE * density + 0.5));
                        this.mTouchSlop = vc.getScaledTouchSlop();
                        this.mMaxVelocity = vc.getScaledMaximumFlingVelocity();
                        this.mMinVelocity = vc.getScaledMinimumFlingVelocity();
                        this.mScroller = new OverScroller(ViewDragHelper.sInterpolator);
                    }
                    static create(...args) {
                        if (args.length === 2)
                            return new ViewDragHelper(args[0], args[1]);
                        else if (args.length === 3) {
                            let [forParent, sensitivity, cb] = args;
                            const helper = ViewDragHelper.create(forParent, cb);
                            helper.mTouchSlop = Math.floor((helper.mTouchSlop * (1 / sensitivity)));
                            return helper;
                        }
                    }
                    setMinVelocity(minVel) {
                        this.mMinVelocity = minVel;
                    }
                    getMinVelocity() {
                        return this.mMinVelocity;
                    }
                    getViewDragState() {
                        return this.mDragState;
                    }
                    setEdgeTrackingEnabled(edgeFlags) {
                        this.mTrackingEdges = edgeFlags;
                    }
                    getEdgeSize() {
                        return this.mEdgeSize;
                    }
                    captureChildView(childView, activePointerId) {
                        if (childView.getParent() != this.mParentView) {
                            throw Error(`new IllegalArgumentException("captureChildView: parameter must be a descendant " + "of the ViewDragHelper's tracked parent view (" + this.mParentView + ")")`);
                        }
                        this.mCapturedView = childView;
                        this.mActivePointerId = activePointerId;
                        this.mCallback.onViewCaptured(childView, activePointerId);
                        this.setDragState(ViewDragHelper.STATE_DRAGGING);
                    }
                    getCapturedView() {
                        return this.mCapturedView;
                    }
                    getActivePointerId() {
                        return this.mActivePointerId;
                    }
                    getTouchSlop() {
                        return this.mTouchSlop;
                    }
                    cancel() {
                        this.mActivePointerId = ViewDragHelper.INVALID_POINTER;
                        this.clearMotionHistory();
                        if (this.mVelocityTracker != null) {
                            this.mVelocityTracker.recycle();
                            this.mVelocityTracker = null;
                        }
                    }
                    abort() {
                        this.cancel();
                        if (this.mDragState == ViewDragHelper.STATE_SETTLING) {
                            const oldX = this.mScroller.getCurrX();
                            const oldY = this.mScroller.getCurrY();
                            this.mScroller.abortAnimation();
                            const newX = this.mScroller.getCurrX();
                            const newY = this.mScroller.getCurrY();
                            this.mCallback.onViewPositionChanged(this.mCapturedView, newX, newY, newX - oldX, newY - oldY);
                        }
                        this.setDragState(ViewDragHelper.STATE_IDLE);
                    }
                    smoothSlideViewTo(child, finalLeft, finalTop) {
                        this.mCapturedView = child;
                        this.mActivePointerId = ViewDragHelper.INVALID_POINTER;
                        return this.forceSettleCapturedViewAt(finalLeft, finalTop, 0, 0);
                    }
                    settleCapturedViewAt(finalLeft, finalTop) {
                        if (!this.mReleaseInProgress) {
                            throw Error(`new IllegalStateException("Cannot settleCapturedViewAt outside of a call to " + "Callback#onViewReleased")`);
                        }
                        return this.forceSettleCapturedViewAt(finalLeft, finalTop, Math.floor(this.mVelocityTracker.getXVelocity(this.mActivePointerId)), Math.floor(this.mVelocityTracker.getYVelocity(this.mActivePointerId)));
                    }
                    forceSettleCapturedViewAt(finalLeft, finalTop, xvel, yvel) {
                        const startLeft = this.mCapturedView.getLeft();
                        const startTop = this.mCapturedView.getTop();
                        const dx = finalLeft - startLeft;
                        const dy = finalTop - startTop;
                        if (dx == 0 && dy == 0) {
                            this.mScroller.abortAnimation();
                            this.setDragState(ViewDragHelper.STATE_IDLE);
                            return false;
                        }
                        const duration = this.computeSettleDuration(this.mCapturedView, dx, dy, xvel, yvel);
                        this.mScroller.startScroll(startLeft, startTop, dx, dy, duration);
                        this.setDragState(ViewDragHelper.STATE_SETTLING);
                        return true;
                    }
                    computeSettleDuration(child, dx, dy, xvel, yvel) {
                        xvel = this.clampMag(xvel, Math.floor(this.mMinVelocity), Math.floor(this.mMaxVelocity));
                        yvel = this.clampMag(yvel, Math.floor(this.mMinVelocity), Math.floor(this.mMaxVelocity));
                        const absDx = Math.abs(dx);
                        const absDy = Math.abs(dy);
                        const absXVel = Math.abs(xvel);
                        const absYVel = Math.abs(yvel);
                        const addedVel = absXVel + absYVel;
                        const addedDistance = absDx + absDy;
                        const xweight = xvel != 0 ? absXVel / addedVel : absDx / addedDistance;
                        const yweight = yvel != 0 ? absYVel / addedVel : absDy / addedDistance;
                        let xduration = this.computeAxisDuration(dx, xvel, this.mCallback.getViewHorizontalDragRange(child));
                        let yduration = this.computeAxisDuration(dy, yvel, this.mCallback.getViewVerticalDragRange(child));
                        return Math.floor((xduration * xweight + yduration * yweight));
                    }
                    computeAxisDuration(delta, velocity, motionRange) {
                        if (delta == 0) {
                            return 0;
                        }
                        const width = this.mParentView.getWidth();
                        const halfWidth = width / 2;
                        const distanceRatio = Math.min(1, Math.abs(delta) / width);
                        const distance = halfWidth + halfWidth * this.distanceInfluenceForSnapDuration(distanceRatio);
                        let duration;
                        velocity = Math.abs(velocity);
                        if (velocity > 0) {
                            duration = 4 * Math.round(1000 * Math.abs(distance / velocity));
                        }
                        else {
                            const range = Math.abs(delta) / motionRange;
                            duration = Math.floor(((range + 1) * ViewDragHelper.BASE_SETTLE_DURATION));
                        }
                        return Math.min(duration, ViewDragHelper.MAX_SETTLE_DURATION);
                    }
                    clampMag(value, absMin, absMax) {
                        const absValue = Math.abs(value);
                        if (absValue < absMin)
                            return 0;
                        if (absValue > absMax)
                            return value > 0 ? absMax : -absMax;
                        return value;
                    }
                    distanceInfluenceForSnapDuration(f) {
                        f -= 0.5;
                        f *= 0.3 * Math.PI / 2.0;
                        return Math.sin(f);
                    }
                    flingCapturedView(minLeft, minTop, maxLeft, maxTop) {
                        if (!this.mReleaseInProgress) {
                            throw Error(`new IllegalStateException("Cannot flingCapturedView outside of a call to " + "Callback#onViewReleased")`);
                        }
                        this.mScroller.fling(this.mCapturedView.getLeft(), this.mCapturedView.getTop(), Math.floor(this.mVelocityTracker.getXVelocity(this.mActivePointerId)), Math.floor(this.mVelocityTracker.getYVelocity(this.mActivePointerId)), minLeft, maxLeft, minTop, maxTop);
                        this.setDragState(ViewDragHelper.STATE_SETTLING);
                    }
                    continueSettling(deferCallbacks) {
                        if (this.mDragState == ViewDragHelper.STATE_SETTLING) {
                            let keepGoing = this.mScroller.computeScrollOffset();
                            const x = this.mScroller.getCurrX();
                            const y = this.mScroller.getCurrY();
                            const dx = x - this.mCapturedView.getLeft();
                            const dy = y - this.mCapturedView.getTop();
                            if (dx != 0) {
                                this.mCapturedView.offsetLeftAndRight(dx);
                            }
                            if (dy != 0) {
                                this.mCapturedView.offsetTopAndBottom(dy);
                            }
                            if (dx != 0 || dy != 0) {
                                this.mCallback.onViewPositionChanged(this.mCapturedView, x, y, dx, dy);
                            }
                            if (keepGoing && x == this.mScroller.getFinalX() && y == this.mScroller.getFinalY()) {
                                this.mScroller.abortAnimation();
                                keepGoing = this.mScroller.isFinished();
                            }
                            if (!keepGoing) {
                                if (deferCallbacks) {
                                    this.mParentView.post(this.mSetIdleRunnable);
                                }
                                else {
                                    this.setDragState(ViewDragHelper.STATE_IDLE);
                                }
                            }
                        }
                        return this.mDragState == ViewDragHelper.STATE_SETTLING;
                    }
                    dispatchViewReleased(xvel, yvel) {
                        this.mReleaseInProgress = true;
                        this.mCallback.onViewReleased(this.mCapturedView, xvel, yvel);
                        this.mReleaseInProgress = false;
                        if (this.mDragState == ViewDragHelper.STATE_DRAGGING) {
                            this.setDragState(ViewDragHelper.STATE_IDLE);
                        }
                    }
                    clearMotionHistory(pointerId) {
                        if (this.mInitialMotionX == null) {
                            return;
                        }
                        if (pointerId == null) {
                            this.mInitialMotionX = [];
                            this.mInitialMotionY = [];
                            this.mLastMotionX = [];
                            this.mLastMotionY = [];
                            this.mInitialEdgesTouched = [];
                            this.mEdgeDragsInProgress = [];
                            this.mEdgeDragsLocked = [];
                            this.mPointersDown = 0;
                        }
                        else {
                            this.mInitialMotionX[pointerId] = 0;
                            this.mInitialMotionY[pointerId] = 0;
                            this.mLastMotionX[pointerId] = 0;
                            this.mLastMotionY[pointerId] = 0;
                            this.mInitialEdgesTouched[pointerId] = 0;
                            this.mEdgeDragsInProgress[pointerId] = 0;
                            this.mEdgeDragsLocked[pointerId] = 0;
                            this.mPointersDown &= ~(1 << pointerId);
                        }
                    }
                    ensureMotionHistorySizeForId(pointerId) {
                        if (this.mInitialMotionX == null || this.mInitialMotionX.length <= pointerId) {
                            let imx = new Array(pointerId + 1);
                            let imy = new Array(pointerId + 1);
                            let lmx = new Array(pointerId + 1);
                            let lmy = new Array(pointerId + 1);
                            let iit = new Array(pointerId + 1);
                            let edip = new Array(pointerId + 1);
                            let edl = new Array(pointerId + 1);
                            if (this.mInitialMotionX != null) {
                                System.arraycopy(this.mInitialMotionX, 0, imx, 0, this.mInitialMotionX.length);
                                System.arraycopy(this.mInitialMotionY, 0, imy, 0, this.mInitialMotionY.length);
                                System.arraycopy(this.mLastMotionX, 0, lmx, 0, this.mLastMotionX.length);
                                System.arraycopy(this.mLastMotionY, 0, lmy, 0, this.mLastMotionY.length);
                                System.arraycopy(this.mInitialEdgesTouched, 0, iit, 0, this.mInitialEdgesTouched.length);
                                System.arraycopy(this.mEdgeDragsInProgress, 0, edip, 0, this.mEdgeDragsInProgress.length);
                                System.arraycopy(this.mEdgeDragsLocked, 0, edl, 0, this.mEdgeDragsLocked.length);
                            }
                            this.mInitialMotionX = imx;
                            this.mInitialMotionY = imy;
                            this.mLastMotionX = lmx;
                            this.mLastMotionY = lmy;
                            this.mInitialEdgesTouched = iit;
                            this.mEdgeDragsInProgress = edip;
                            this.mEdgeDragsLocked = edl;
                        }
                    }
                    saveInitialMotion(x, y, pointerId) {
                        this.ensureMotionHistorySizeForId(pointerId);
                        this.mInitialMotionX[pointerId] = this.mLastMotionX[pointerId] = x;
                        this.mInitialMotionY[pointerId] = this.mLastMotionY[pointerId] = y;
                        this.mInitialEdgesTouched[pointerId] = this.getEdgesTouched(Math.floor(x), Math.floor(y));
                        this.mPointersDown |= 1 << pointerId;
                    }
                    saveLastMotion(ev) {
                        const pointerCount = ev.getPointerCount();
                        for (let i = 0; i < pointerCount; i++) {
                            const pointerId = ev.getPointerId(i);
                            const x = ev.getX(i);
                            const y = ev.getY(i);
                            this.mLastMotionX[pointerId] = x;
                            this.mLastMotionY[pointerId] = y;
                        }
                    }
                    isPointerDown(pointerId) {
                        return (this.mPointersDown & 1 << pointerId) != 0;
                    }
                    setDragState(state) {
                        if (this.mDragState != state) {
                            this.mDragState = state;
                            this.mCallback.onViewDragStateChanged(state);
                            if (state == ViewDragHelper.STATE_IDLE) {
                                this.mCapturedView = null;
                            }
                        }
                    }
                    tryCaptureViewForDrag(toCapture, pointerId) {
                        if (toCapture == this.mCapturedView && this.mActivePointerId == pointerId) {
                            return true;
                        }
                        if (toCapture != null && this.mCallback.tryCaptureView(toCapture, pointerId)) {
                            this.mActivePointerId = pointerId;
                            this.captureChildView(toCapture, pointerId);
                            return true;
                        }
                        return false;
                    }
                    canScroll(v, checkV, dx, dy, x, y) {
                        if (v instanceof ViewGroup) {
                            const group = v;
                            const scrollX = v.getScrollX();
                            const scrollY = v.getScrollY();
                            const count = group.getChildCount();
                            for (let i = count - 1; i >= 0; i--) {
                                const child = group.getChildAt(i);
                                if (x + scrollX >= child.getLeft() && x + scrollX < child.getRight()
                                    && y + scrollY >= child.getTop() && y + scrollY < child.getBottom()
                                    && this.canScroll(child, true, dx, dy, x + scrollX - child.getLeft(), y + scrollY - child.getTop())) {
                                    return true;
                                }
                            }
                        }
                        return checkV && (v.canScrollHorizontally(-dx) || v.canScrollVertically(-dy));
                    }
                    shouldInterceptTouchEvent(ev) {
                        const action = ev.getActionMasked();
                        const actionIndex = ev.getActionIndex();
                        if (action == MotionEvent.ACTION_DOWN) {
                            this.cancel();
                        }
                        if (this.mVelocityTracker == null) {
                            this.mVelocityTracker = VelocityTracker.obtain();
                        }
                        this.mVelocityTracker.addMovement(ev);
                        switch (action) {
                            case MotionEvent.ACTION_DOWN:
                                {
                                    const x = ev.getX();
                                    const y = ev.getY();
                                    const pointerId = ev.getPointerId(0);
                                    this.saveInitialMotion(x, y, pointerId);
                                    const toCapture = this.findTopChildUnder(Math.floor(x), Math.floor(y));
                                    if (toCapture == this.mCapturedView && this.mDragState == ViewDragHelper.STATE_SETTLING) {
                                        this.tryCaptureViewForDrag(toCapture, pointerId);
                                    }
                                    const edgesTouched = this.mInitialEdgesTouched[pointerId];
                                    if ((edgesTouched & this.mTrackingEdges) != 0) {
                                        this.mCallback.onEdgeTouched(edgesTouched & this.mTrackingEdges, pointerId);
                                    }
                                    break;
                                }
                            case MotionEvent.ACTION_POINTER_DOWN:
                                {
                                    const pointerId = ev.getPointerId(actionIndex);
                                    const x = ev.getX(actionIndex);
                                    const y = ev.getY(actionIndex);
                                    this.saveInitialMotion(x, y, pointerId);
                                    if (this.mDragState == ViewDragHelper.STATE_IDLE) {
                                        const edgesTouched = this.mInitialEdgesTouched[pointerId];
                                        if ((edgesTouched & this.mTrackingEdges) != 0) {
                                            this.mCallback.onEdgeTouched(edgesTouched & this.mTrackingEdges, pointerId);
                                        }
                                    }
                                    else if (this.mDragState == ViewDragHelper.STATE_SETTLING) {
                                        const toCapture = this.findTopChildUnder(Math.floor(x), Math.floor(y));
                                        if (toCapture == this.mCapturedView) {
                                            this.tryCaptureViewForDrag(toCapture, pointerId);
                                        }
                                    }
                                    break;
                                }
                            case MotionEvent.ACTION_MOVE:
                                {
                                    const pointerCount = ev.getPointerCount();
                                    for (let i = 0; i < pointerCount; i++) {
                                        const pointerId = ev.getPointerId(i);
                                        const x = ev.getX(i);
                                        const y = ev.getY(i);
                                        const dx = x - this.mInitialMotionX[pointerId];
                                        const dy = y - this.mInitialMotionY[pointerId];
                                        this.reportNewEdgeDrags(dx, dy, pointerId);
                                        if (this.mDragState == ViewDragHelper.STATE_DRAGGING) {
                                            break;
                                        }
                                        const toCapture = this.findTopChildUnder(Math.floor(x), Math.floor(y));
                                        if (toCapture != null && this.checkTouchSlop(toCapture, dx, dy) && this.tryCaptureViewForDrag(toCapture, pointerId)) {
                                            break;
                                        }
                                    }
                                    this.saveLastMotion(ev);
                                    break;
                                }
                            case MotionEvent.ACTION_POINTER_UP:
                                {
                                    const pointerId = ev.getPointerId(actionIndex);
                                    this.clearMotionHistory(pointerId);
                                    break;
                                }
                            case MotionEvent.ACTION_UP:
                            case MotionEvent.ACTION_CANCEL:
                                {
                                    this.cancel();
                                    break;
                                }
                        }
                        return this.mDragState == ViewDragHelper.STATE_DRAGGING;
                    }
                    processTouchEvent(ev) {
                        const action = ev.getActionMasked();
                        const actionIndex = ev.getActionIndex();
                        if (action == MotionEvent.ACTION_DOWN) {
                            this.cancel();
                        }
                        if (this.mVelocityTracker == null) {
                            this.mVelocityTracker = VelocityTracker.obtain();
                        }
                        this.mVelocityTracker.addMovement(ev);
                        switch (action) {
                            case MotionEvent.ACTION_DOWN:
                                {
                                    const x = ev.getX();
                                    const y = ev.getY();
                                    const pointerId = ev.getPointerId(0);
                                    const toCapture = this.findTopChildUnder(Math.floor(x), Math.floor(y));
                                    this.saveInitialMotion(x, y, pointerId);
                                    this.tryCaptureViewForDrag(toCapture, pointerId);
                                    const edgesTouched = this.mInitialEdgesTouched[pointerId];
                                    if ((edgesTouched & this.mTrackingEdges) != 0) {
                                        this.mCallback.onEdgeTouched(edgesTouched & this.mTrackingEdges, pointerId);
                                    }
                                    break;
                                }
                            case MotionEvent.ACTION_POINTER_DOWN:
                                {
                                    const pointerId = ev.getPointerId(actionIndex);
                                    const x = ev.getX(actionIndex);
                                    const y = ev.getY(actionIndex);
                                    this.saveInitialMotion(x, y, pointerId);
                                    if (this.mDragState == ViewDragHelper.STATE_IDLE) {
                                        const toCapture = this.findTopChildUnder(Math.floor(x), Math.floor(y));
                                        this.tryCaptureViewForDrag(toCapture, pointerId);
                                        const edgesTouched = this.mInitialEdgesTouched[pointerId];
                                        if ((edgesTouched & this.mTrackingEdges) != 0) {
                                            this.mCallback.onEdgeTouched(edgesTouched & this.mTrackingEdges, pointerId);
                                        }
                                    }
                                    else if (this.isCapturedViewUnder(Math.floor(x), Math.floor(y))) {
                                        this.tryCaptureViewForDrag(this.mCapturedView, pointerId);
                                    }
                                    break;
                                }
                            case MotionEvent.ACTION_MOVE:
                                {
                                    if (this.mDragState == ViewDragHelper.STATE_DRAGGING) {
                                        const index = ev.findPointerIndex(this.mActivePointerId);
                                        const x = ev.getX(index);
                                        const y = ev.getY(index);
                                        const idx = Math.floor((x - this.mLastMotionX[this.mActivePointerId]));
                                        const idy = Math.floor((y - this.mLastMotionY[this.mActivePointerId]));
                                        this.dragTo(this.mCapturedView.getLeft() + idx, this.mCapturedView.getTop() + idy, idx, idy);
                                        this.saveLastMotion(ev);
                                    }
                                    else {
                                        const pointerCount = ev.getPointerCount();
                                        for (let i = 0; i < pointerCount; i++) {
                                            const pointerId = ev.getPointerId(i);
                                            const x = ev.getX(i);
                                            const y = ev.getY(i);
                                            const dx = x - this.mInitialMotionX[pointerId];
                                            const dy = y - this.mInitialMotionY[pointerId];
                                            this.reportNewEdgeDrags(dx, dy, pointerId);
                                            if (this.mDragState == ViewDragHelper.STATE_DRAGGING) {
                                                break;
                                            }
                                            const toCapture = this.findTopChildUnder(Math.floor(x), Math.floor(y));
                                            if (this.checkTouchSlop(toCapture, dx, dy) && this.tryCaptureViewForDrag(toCapture, pointerId)) {
                                                break;
                                            }
                                        }
                                        this.saveLastMotion(ev);
                                    }
                                    break;
                                }
                            case MotionEvent.ACTION_POINTER_UP:
                                {
                                    const pointerId = ev.getPointerId(actionIndex);
                                    if (this.mDragState == ViewDragHelper.STATE_DRAGGING && pointerId == this.mActivePointerId) {
                                        let newActivePointer = ViewDragHelper.INVALID_POINTER;
                                        const pointerCount = ev.getPointerCount();
                                        for (let i = 0; i < pointerCount; i++) {
                                            const id = ev.getPointerId(i);
                                            if (id == this.mActivePointerId) {
                                                continue;
                                            }
                                            const x = ev.getX(i);
                                            const y = ev.getY(i);
                                            if (this.findTopChildUnder(Math.floor(x), Math.floor(y)) == this.mCapturedView && this.tryCaptureViewForDrag(this.mCapturedView, id)) {
                                                newActivePointer = this.mActivePointerId;
                                                break;
                                            }
                                        }
                                        if (newActivePointer == ViewDragHelper.INVALID_POINTER) {
                                            this.releaseViewForPointerUp();
                                        }
                                    }
                                    this.clearMotionHistory(pointerId);
                                    break;
                                }
                            case MotionEvent.ACTION_UP:
                                {
                                    if (this.mDragState == ViewDragHelper.STATE_DRAGGING) {
                                        this.releaseViewForPointerUp();
                                    }
                                    this.cancel();
                                    break;
                                }
                            case MotionEvent.ACTION_CANCEL:
                                {
                                    if (this.mDragState == ViewDragHelper.STATE_DRAGGING) {
                                        this.dispatchViewReleased(0, 0);
                                    }
                                    this.cancel();
                                    break;
                                }
                        }
                    }
                    reportNewEdgeDrags(dx, dy, pointerId) {
                        let dragsStarted = 0;
                        if (this.checkNewEdgeDrag(dx, dy, pointerId, ViewDragHelper.EDGE_LEFT)) {
                            dragsStarted |= ViewDragHelper.EDGE_LEFT;
                        }
                        if (this.checkNewEdgeDrag(dy, dx, pointerId, ViewDragHelper.EDGE_TOP)) {
                            dragsStarted |= ViewDragHelper.EDGE_TOP;
                        }
                        if (this.checkNewEdgeDrag(dx, dy, pointerId, ViewDragHelper.EDGE_RIGHT)) {
                            dragsStarted |= ViewDragHelper.EDGE_RIGHT;
                        }
                        if (this.checkNewEdgeDrag(dy, dx, pointerId, ViewDragHelper.EDGE_BOTTOM)) {
                            dragsStarted |= ViewDragHelper.EDGE_BOTTOM;
                        }
                        if (dragsStarted != 0) {
                            this.mEdgeDragsInProgress[pointerId] |= dragsStarted;
                            this.mCallback.onEdgeDragStarted(dragsStarted, pointerId);
                        }
                    }
                    checkNewEdgeDrag(delta, odelta, pointerId, edge) {
                        const absDelta = Math.abs(delta);
                        const absODelta = Math.abs(odelta);
                        if ((this.mInitialEdgesTouched[pointerId] & edge) != edge || (this.mTrackingEdges & edge) == 0 || (this.mEdgeDragsLocked[pointerId] & edge) == edge || (this.mEdgeDragsInProgress[pointerId] & edge) == edge || (absDelta <= this.mTouchSlop && absODelta <= this.mTouchSlop)) {
                            return false;
                        }
                        if (absDelta < absODelta * 0.5 && this.mCallback.onEdgeLock(edge)) {
                            this.mEdgeDragsLocked[pointerId] |= edge;
                            return false;
                        }
                        return (this.mEdgeDragsInProgress[pointerId] & edge) == 0 && absDelta > this.mTouchSlop;
                    }
                    checkTouchSlop(...args) {
                        if (args.length === 1)
                            return this._checkTouchSlop_1(args[0]);
                        if (args.length === 2)
                            return this._checkTouchSlop_2(args[0], args[1]);
                        if (args.length === 3)
                            return this._checkTouchSlop_3(args[0], args[2], args[3]);
                        return false;
                    }
                    _checkTouchSlop_3(child, dx, dy) {
                        if (child == null) {
                            return false;
                        }
                        const checkHorizontal = this.mCallback.getViewHorizontalDragRange(child) > 0;
                        const checkVertical = this.mCallback.getViewVerticalDragRange(child) > 0;
                        if (checkHorizontal && checkVertical) {
                            return dx * dx + dy * dy > this.mTouchSlop * this.mTouchSlop;
                        }
                        else if (checkHorizontal) {
                            return Math.abs(dx) > this.mTouchSlop;
                        }
                        else if (checkVertical) {
                            return Math.abs(dy) > this.mTouchSlop;
                        }
                        return false;
                    }
                    _checkTouchSlop_1(directions) {
                        const count = this.mInitialMotionX.length;
                        for (let i = 0; i < count; i++) {
                            if (this.checkTouchSlop(directions, i)) {
                                return true;
                            }
                        }
                        return false;
                    }
                    _checkTouchSlop_2(directions, pointerId) {
                        if (!this.isPointerDown(pointerId)) {
                            return false;
                        }
                        const checkHorizontal = (directions & ViewDragHelper.DIRECTION_HORIZONTAL) == ViewDragHelper.DIRECTION_HORIZONTAL;
                        const checkVertical = (directions & ViewDragHelper.DIRECTION_VERTICAL) == ViewDragHelper.DIRECTION_VERTICAL;
                        const dx = this.mLastMotionX[pointerId] - this.mInitialMotionX[pointerId];
                        const dy = this.mLastMotionY[pointerId] - this.mInitialMotionY[pointerId];
                        if (checkHorizontal && checkVertical) {
                            return dx * dx + dy * dy > this.mTouchSlop * this.mTouchSlop;
                        }
                        else if (checkHorizontal) {
                            return Math.abs(dx) > this.mTouchSlop;
                        }
                        else if (checkVertical) {
                            return Math.abs(dy) > this.mTouchSlop;
                        }
                        return false;
                    }
                    isEdgeTouched(edges, pointerId) {
                        if (pointerId == null) {
                            const count = this.mInitialEdgesTouched.length;
                            for (let i = 0; i < count; i++) {
                                if (this.isEdgeTouched(edges, i)) {
                                    return true;
                                }
                            }
                        }
                        return this.isPointerDown(pointerId) && (this.mInitialEdgesTouched[pointerId] & edges) != 0;
                    }
                    releaseViewForPointerUp() {
                        this.mVelocityTracker.computeCurrentVelocity(1000, this.mMaxVelocity);
                        const xvel = this.clampMag(this.mVelocityTracker.getXVelocity(this.mActivePointerId), this.mMinVelocity, this.mMaxVelocity);
                        const yvel = this.clampMag(this.mVelocityTracker.getYVelocity(this.mActivePointerId), this.mMinVelocity, this.mMaxVelocity);
                        this.dispatchViewReleased(xvel, yvel);
                    }
                    dragTo(left, top, dx, dy) {
                        let clampedX = left;
                        let clampedY = top;
                        const oldLeft = this.mCapturedView.getLeft();
                        const oldTop = this.mCapturedView.getTop();
                        if (dx != 0) {
                            clampedX = this.mCallback.clampViewPositionHorizontal(this.mCapturedView, left, dx);
                            this.mCapturedView.offsetLeftAndRight(clampedX - oldLeft);
                        }
                        if (dy != 0) {
                            clampedY = this.mCallback.clampViewPositionVertical(this.mCapturedView, top, dy);
                            this.mCapturedView.offsetTopAndBottom(clampedY - oldTop);
                        }
                        if (dx != 0 || dy != 0) {
                            const clampedDx = clampedX - oldLeft;
                            const clampedDy = clampedY - oldTop;
                            this.mCallback.onViewPositionChanged(this.mCapturedView, clampedX, clampedY, clampedDx, clampedDy);
                        }
                    }
                    isCapturedViewUnder(x, y) {
                        return this.isViewUnder(this.mCapturedView, x, y);
                    }
                    isViewUnder(view, x, y) {
                        if (view == null) {
                            return false;
                        }
                        return x >= view.getLeft() && x < view.getRight() && y >= view.getTop() && y < view.getBottom();
                    }
                    findTopChildUnder(x, y) {
                        const childCount = this.mParentView.getChildCount();
                        for (let i = childCount - 1; i >= 0; i--) {
                            const child = this.mParentView.getChildAt(this.mCallback.getOrderedChildIndex(i));
                            if (x >= child.getLeft() && x < child.getRight() && y >= child.getTop() && y < child.getBottom()) {
                                return child;
                            }
                        }
                        return null;
                    }
                    getEdgesTouched(x, y) {
                        let result = 0;
                        if (x < this.mParentView.getLeft() + this.mEdgeSize)
                            result |= ViewDragHelper.EDGE_LEFT;
                        if (y < this.mParentView.getTop() + this.mEdgeSize)
                            result |= ViewDragHelper.EDGE_TOP;
                        if (x > this.mParentView.getRight() - this.mEdgeSize)
                            result |= ViewDragHelper.EDGE_RIGHT;
                        if (y > this.mParentView.getBottom() - this.mEdgeSize)
                            result |= ViewDragHelper.EDGE_BOTTOM;
                        return result;
                    }
                }
                ViewDragHelper.TAG = "ViewDragHelper";
                ViewDragHelper.INVALID_POINTER = -1;
                ViewDragHelper.STATE_IDLE = 0;
                ViewDragHelper.STATE_DRAGGING = 1;
                ViewDragHelper.STATE_SETTLING = 2;
                ViewDragHelper.EDGE_LEFT = 1 << 0;
                ViewDragHelper.EDGE_RIGHT = 1 << 1;
                ViewDragHelper.EDGE_TOP = 1 << 2;
                ViewDragHelper.EDGE_BOTTOM = 1 << 3;
                ViewDragHelper.EDGE_ALL = ViewDragHelper.EDGE_LEFT | ViewDragHelper.EDGE_TOP | ViewDragHelper.EDGE_RIGHT | ViewDragHelper.EDGE_BOTTOM;
                ViewDragHelper.DIRECTION_HORIZONTAL = 1 << 0;
                ViewDragHelper.DIRECTION_VERTICAL = 1 << 1;
                ViewDragHelper.DIRECTION_ALL = ViewDragHelper.DIRECTION_HORIZONTAL | ViewDragHelper.DIRECTION_VERTICAL;
                ViewDragHelper.EDGE_SIZE = 20;
                ViewDragHelper.BASE_SETTLE_DURATION = 256;
                ViewDragHelper.MAX_SETTLE_DURATION = 600;
                ViewDragHelper.sInterpolator = (() => {
                    class _Inner {
                        getInterpolation(t) {
                            t -= 1.0;
                            return t * t * t * t * t + 1.0;
                        }
                    }
                    return new _Inner();
                })();
                widget.ViewDragHelper = ViewDragHelper;
                (function (ViewDragHelper) {
                    class Callback {
                        onViewDragStateChanged(state) {
                        }
                        onViewPositionChanged(changedView, left, top, dx, dy) {
                        }
                        onViewCaptured(capturedChild, activePointerId) {
                        }
                        onViewReleased(releasedChild, xvel, yvel) {
                        }
                        onEdgeTouched(edgeFlags, pointerId) {
                        }
                        onEdgeLock(edgeFlags) {
                            return false;
                        }
                        onEdgeDragStarted(edgeFlags, pointerId) {
                        }
                        getOrderedChildIndex(index) {
                            return index;
                        }
                        getViewHorizontalDragRange(child) {
                            return 0;
                        }
                        getViewVerticalDragRange(child) {
                            return 0;
                        }
                        clampViewPositionHorizontal(child, left, dx) {
                            return 0;
                        }
                        clampViewPositionVertical(child, top, dy) {
                            return 0;
                        }
                    }
                    ViewDragHelper.Callback = Callback;
                })(ViewDragHelper = widget.ViewDragHelper || (widget.ViewDragHelper = {}));
            })(widget = v4.widget || (v4.widget = {}));
        })(v4 = support.v4 || (support.v4 = {}));
    })(support = android.support || (android.support = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/6.
 */
///<reference path="../../../../android/view/View.ts"/>
///<reference path="../../../../android/view/ViewGroup.ts"/>
///<reference path="../../../../android/support/v4/view/ViewPager.ts"/>
///<reference path="../../../../android/support/v4/view/PagerAdapter.ts"/>
var com;
(function (com) {
    var jakewharton;
    (function (jakewharton) {
        var salvage;
        (function (salvage) {
            var SparseArray = android.util.SparseArray;
            var PagerAdapter = android.support.v4.view.PagerAdapter;
            class RecyclingPagerAdapter extends PagerAdapter {
                constructor() {
                    super();
                    this.recycleBin = new RecycleBin();
                    this.recycleBin.setViewTypeCount(this.getViewTypeCount());
                }
                notifyDataSetChanged() {
                    this.recycleBin.scrapActiveViews();
                    super.notifyDataSetChanged();
                }
                instantiateItem(container, position) {
                    let viewType = this.getItemViewType(position);
                    let view = null;
                    if (viewType != RecyclingPagerAdapter.IGNORE_ITEM_VIEW_TYPE) {
                        view = this.recycleBin.getScrapView(position, viewType);
                    }
                    view = this.getView(position, view, container);
                    container.addView(view);
                    return view;
                }
                destroyItem(container, position, object) {
                    let view = object;
                    container.removeView(view);
                    let viewType = this.getItemViewType(position);
                    if (viewType != RecyclingPagerAdapter.IGNORE_ITEM_VIEW_TYPE) {
                        this.recycleBin.addScrapView(view, position, viewType);
                    }
                }
                isViewFromObject(view, object) {
                    return view === object;
                }
                getViewTypeCount() {
                    return 1;
                }
                getItemViewType(position) {
                    return 0;
                }
            }
            RecyclingPagerAdapter.IGNORE_ITEM_VIEW_TYPE = -1;
            salvage.RecyclingPagerAdapter = RecyclingPagerAdapter;
            class RecycleBin {
                constructor() {
                    this.activeViews = [];
                    this.activeViewTypes = [];
                    this.viewTypeCount = 0;
                }
                setViewTypeCount(viewTypeCount) {
                    if (viewTypeCount < 1) {
                        throw new Error("Can't have a viewTypeCount < 1");
                    }
                    let scrapViews = new Array(viewTypeCount);
                    for (let i = 0; i < viewTypeCount; i++) {
                        scrapViews[i] = new SparseArray();
                    }
                    this.viewTypeCount = viewTypeCount;
                    this.currentScrapViews = scrapViews[0];
                    this.scrapViews = scrapViews;
                }
                shouldRecycleViewType(viewType) {
                    return viewType >= 0;
                }
                getScrapView(position, viewType) {
                    if (this.viewTypeCount == 1) {
                        return this.retrieveFromScrap(this.currentScrapViews, position);
                    }
                    else if (viewType >= 0 && viewType < this.scrapViews.length) {
                        return this.retrieveFromScrap(this.scrapViews[viewType], position);
                    }
                    return null;
                }
                addScrapView(scrap, position, viewType) {
                    if (this.viewTypeCount == 1) {
                        this.currentScrapViews.put(position, scrap);
                    }
                    else {
                        this.scrapViews[viewType].put(position, scrap);
                    }
                }
                scrapActiveViews() {
                    const activeViews = this.activeViews;
                    const activeViewTypes = this.activeViewTypes;
                    const multipleScraps = this.viewTypeCount > 1;
                    let scrapViews = this.currentScrapViews;
                    const count = activeViews.length;
                    for (let i = count - 1; i >= 0; i--) {
                        const victim = activeViews[i];
                        if (victim != null) {
                            let whichScrap = activeViewTypes[i];
                            activeViews[i] = null;
                            activeViewTypes[i] = -1;
                            if (!this.shouldRecycleViewType(whichScrap)) {
                                continue;
                            }
                            if (multipleScraps) {
                                scrapViews = this.scrapViews[whichScrap];
                            }
                            scrapViews.put(i, victim);
                        }
                    }
                    this.pruneScrapViews();
                }
                pruneScrapViews() {
                    const maxViews = this.activeViews.length;
                    const viewTypeCount = this.viewTypeCount;
                    const scrapViews = this.scrapViews;
                    for (let i = 0; i < viewTypeCount; ++i) {
                        const scrapPile = scrapViews[i];
                        let size = scrapPile.size();
                        const extras = size - maxViews;
                        size--;
                        for (let j = 0; j < extras; j++) {
                            scrapPile.remove(scrapPile.keyAt(size--));
                        }
                    }
                }
                retrieveFromScrap(scrapViews, position) {
                    let size = scrapViews.size();
                    if (size > 0) {
                        for (let i = 0; i < size; i++) {
                            let fromPosition = scrapViews.keyAt(i);
                            let view = scrapViews.get(fromPosition);
                            if (fromPosition == position) {
                                scrapViews.remove(fromPosition);
                                return view;
                            }
                        }
                        let index = size - 1;
                        let r = scrapViews.valueAt(index);
                        scrapViews.remove(scrapViews.keyAt(index));
                        return r;
                    }
                    else {
                        return null;
                    }
                }
            }
        })(salvage = jakewharton.salvage || (jakewharton.salvage = {}));
    })(jakewharton = com.jakewharton || (com.jakewharton = {}));
})(com || (com = {}));
/**
 * Created by linfaxin on 15/10/23.
 */
///<reference path="../android/view/View.ts"/>
///<reference path="../android/view/ViewGroup.ts"/>
///<reference path="../android/view/ViewRootImpl.ts"/>
///<reference path="../android/widget/FrameLayout.ts"/>
///<reference path="../android/view/MotionEvent.ts"/>
///<reference path="../android/view/KeyEvent.ts"/>
var androidui;
(function (androidui) {
    var View = android.view.View;
    var ViewGroup = android.view.ViewGroup;
    var ViewRootImpl = android.view.ViewRootImpl;
    var FrameLayout = android.widget.FrameLayout;
    var MotionEvent = android.view.MotionEvent;
    var KeyEvent = android.view.KeyEvent;
    let sNextAndroidID = 0;
    class AndroidUI {
        constructor(element) {
            this._windowBound = new android.graphics.Rect();
            this.tempRect = new android.graphics.Rect();
            this.touchEvent = new MotionEvent();
            this.touchAvailable = false;
            this.ketEvent = new KeyEvent();
            this.element = element;
            if (element[AndroidUI.BindTOElementName]) {
                throw Error('already init a AndroidUI with this element');
            }
            element[AndroidUI.BindTOElementName] = this;
            this.init();
        }
        get windowBound() {
            return this._windowBound;
        }
        init() {
            this.AndroidID = sNextAndroidID++;
            this.element.classList.add(AndroidUI.DomClassName);
            this.element.classList.add('id-' + this.AndroidID);
            this._viewRootImpl = new ViewRootImpl();
            this._viewRootImpl.rootElement = this.element;
            this._rootLayout = new RootLayout();
            this._canvas = document.createElement("canvas");
            this.initInflateView();
            this.element.innerHTML = '';
            this.initElementStyle();
            if (this.rootResourceElement)
                this.element.appendChild(this.rootResourceElement);
            if (this.rootStyleElement)
                this.element.appendChild(this.rootStyleElement);
            this.element.appendChild(this._canvas);
            this.element.appendChild(this._rootLayout.bindElement);
            this._viewRootImpl.setView(this._rootLayout);
            this._viewRootImpl.initSurface(this._canvas);
            this.initFocus();
            this.initEvent();
            this.initListenSizeChange();
        }
        initInflateView() {
            Array.from(this.element.children).forEach((item) => {
                if (item.tagName.toLowerCase() === 'resources') {
                    this.rootResourceElement = item;
                }
                else if (item instanceof HTMLStyleElement) {
                    this.rootStyleElement = item;
                }
                else if (item instanceof HTMLElement) {
                    let view = View.inflate(item, this.element, this._rootLayout);
                    if (view)
                        this._rootLayout.addView(view);
                }
            });
        }
        initElementStyle() {
            if (!this.rootStyleElement) {
                this.rootStyleElement = document.createElement("style");
            }
            this.rootStyleElement.setAttribute('scoped', '');
            if (this.element.style.display === 'none') {
                this.element.style.display = '';
            }
            if (this.rootStyleElement.innerHTML.length == 0) {
                this.rootStyleElement = null;
            }
        }
        refreshWindowBound() {
            let rootViewBound = this.element.getBoundingClientRect();
            this._windowBound.set(rootViewBound.left, rootViewBound.top, rootViewBound.right, rootViewBound.bottom);
        }
        initFocus() {
            this.element.setAttribute('tabindex', '0');
            this.element.focus();
        }
        initEvent() {
            this.initTouchEvent();
            this.initMouseEvent();
            this.initKeyEvent();
            this.initGenericEvent();
        }
        initTouchEvent() {
            this.element.addEventListener('touchstart', (e) => {
                this.touchAvailable = true;
                this.refreshWindowBound();
                this.element.focus();
                this.touchEvent.initWithTouch(e, MotionEvent.ACTION_DOWN, this._windowBound);
                if (this._viewRootImpl.dispatchInputEvent(this.touchEvent)) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            }, true);
            this.element.addEventListener('touchmove', (e) => {
                this.touchEvent.initWithTouch(e, MotionEvent.ACTION_MOVE, this._windowBound);
                if (this._viewRootImpl.dispatchInputEvent(this.touchEvent)) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            }, true);
            this.element.addEventListener('touchend', (e) => {
                this.touchEvent.initWithTouch(e, MotionEvent.ACTION_UP, this._windowBound);
                if (this._viewRootImpl.dispatchInputEvent(this.touchEvent)) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            }, true);
            this.element.addEventListener('touchcancel', (e) => {
                this.touchEvent.initWithTouch(e, MotionEvent.ACTION_CANCEL, this._windowBound);
                if (this._viewRootImpl.dispatchInputEvent(this.touchEvent)) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            }, true);
        }
        initMouseEvent() {
            function mouseToTouchEvent(e) {
                let touch = {
                    identifier: 0,
                    target: null,
                    screenX: e.screenX,
                    screenY: e.screenY,
                    clientX: e.clientX,
                    clientY: e.clientY,
                    pageX: e.pageX,
                    pageY: e.pageY
                };
                return {
                    changedTouches: [touch],
                    targetTouches: [touch],
                    touches: e.type === 'mouseup' ? [] : [touch],
                    timeStamp: e.timeStamp
                };
            }
            let isMouseDown = false;
            this.element.addEventListener('mousedown', (e) => {
                if (this.touchAvailable)
                    return;
                isMouseDown = true;
                this.refreshWindowBound();
                this.element.focus();
                this.touchEvent.initWithTouch(mouseToTouchEvent(e), MotionEvent.ACTION_DOWN, this._windowBound);
                if (this._viewRootImpl.dispatchInputEvent(this.touchEvent)) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            }, true);
            this.element.addEventListener('mousemove', (e) => {
                if (this.touchAvailable)
                    return;
                if (!isMouseDown)
                    return;
                this.touchEvent.initWithTouch(mouseToTouchEvent(e), MotionEvent.ACTION_MOVE, this._windowBound);
                if (this._viewRootImpl.dispatchInputEvent(this.touchEvent)) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            }, true);
            this.element.addEventListener('mouseup', (e) => {
                if (this.touchAvailable)
                    return;
                isMouseDown = false;
                this.touchEvent.initWithTouch(mouseToTouchEvent(e), MotionEvent.ACTION_UP, this._windowBound);
                if (this._viewRootImpl.dispatchInputEvent(this.touchEvent)) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            }, true);
            this.element.addEventListener('mouseleave', (e) => {
                if (this.touchAvailable)
                    return;
                if (e.fromElement === this.element) {
                    isMouseDown = false;
                    this.touchEvent.initWithTouch(mouseToTouchEvent(e), MotionEvent.ACTION_CANCEL, this._windowBound);
                    if (this._viewRootImpl.dispatchInputEvent(this.touchEvent)) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                }
            }, true);
            let scrollEvent = new MotionEvent();
            this.element.addEventListener('mousewheel', (e) => {
                scrollEvent.initWithMouseWheel(e);
                if (this._viewRootImpl.dispatchInputEvent(scrollEvent)) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            }, true);
        }
        initKeyEvent() {
            this.element.addEventListener('keydown', (e) => {
                this.ketEvent.appendKeyEvent(e, KeyEvent.ACTION_DOWN);
                if (this._viewRootImpl.dispatchInputEvent(this.ketEvent)) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            }, true);
            this.element.addEventListener('keyup', (e) => {
                this.ketEvent.appendKeyEvent(e, KeyEvent.ACTION_UP);
                if (this._viewRootImpl.dispatchInputEvent(this.ketEvent)) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            }, true);
        }
        initGenericEvent() {
        }
        initListenSizeChange() {
            const _this = this;
            window.addEventListener('resize', () => {
                _this.notifySizeChange();
            });
            let lastWidth = this.element.offsetWidth;
            let lastHeight = this.element.offsetHeight;
            if (lastWidth > 0 && lastHeight > 0)
                this.notifySizeChange();
            setInterval(() => {
                let width = _this.element.offsetWidth;
                let height = _this.element.offsetHeight;
                if (lastHeight !== height || lastWidth !== width) {
                    lastWidth = width;
                    lastHeight = height;
                    _this.notifySizeChange();
                }
            }, 500);
        }
        notifySizeChange() {
            this.refreshWindowBound();
            let density = android.content.res.Resources.getDisplayMetrics().density;
            this.tempRect.set(this._windowBound.left * density, this._windowBound.top * density, this._windowBound.right * density, this._windowBound.bottom * density);
            this._viewRootImpl.dispatchResized(this.tempRect);
            let width = this._windowBound.width();
            let height = this._windowBound.height();
            this._canvas.width = width * density;
            this._canvas.height = height * density;
            this._canvas.style.width = width + "px";
            this._canvas.style.height = height + "px";
        }
        setContentView(view) {
            this._rootLayout.removeAllViews();
            this._rootLayout.addView(view, -1, -1);
        }
        addContentView(view, params = new ViewGroup.LayoutParams(-1, -1)) {
            this._rootLayout.addView(view, params);
        }
        findViewById(id) {
            return this._rootLayout.findViewById(id);
        }
    }
    AndroidUI.DomClassName = 'AndroidUI';
    AndroidUI.BindTOElementName = 'AndroidUI';
    androidui.AndroidUI = AndroidUI;
    let styleElement = document.createElement('style');
    styleElement.innerHTML += `
        .${AndroidUI.DomClassName} {
            position : relative;
            overflow : hidden;
            display : block;
            outline: none;
        }
        .${AndroidUI.DomClassName} * {
            overflow : hidden;
            border : none;
            outline: none;
        }
        .${AndroidUI.DomClassName} resources {
            display: none;
        }
        .${AndroidUI.DomClassName} Button {
            border: none;
            background: none;
        }
        .${AndroidUI.DomClassName} > canvas {
            position: absolute;
            left: 0;
            top: 0;
        }
        `;
    document.head.appendChild(styleElement);
    class RootLayout extends FrameLayout {
        _syncBoundToElement() {
            let change = super._syncBoundToElement();
            let density = android.content.res.Resources.getDisplayMetrics().density;
            if (change && density !== 1) {
                this.bindElement.style.cssText += `transform:scale(${1 / density},${1 / density});
                    -webkit-transform:scale(${1 / density},${1 / density});
                    transform-origin:0 0;
                    -webkit-transform-origin:0 0;`;
            }
            return change;
        }
    }
})(androidui || (androidui = {}));
/**
 * Created by linfaxin on 15/10/11.
 */
///<reference path="../view/View.ts"/>
///<reference path="../view/ViewRootImpl.ts"/>
///<reference path="../widget/FrameLayout.ts"/>
///<reference path="../view/MotionEvent.ts"/>
///<reference path="../../androidui/AndroidUI.ts"/>
var android;
(function (android) {
    var app;
    (function (app) {
        var AndroidUI = androidui.AndroidUI;
        if (typeof HTMLDivElement !== 'function') {
            var _HTMLDivElement = function () { };
            _HTMLDivElement.prototype = HTMLDivElement.prototype;
            HTMLDivElement = _HTMLDivElement;
        }
        class Activity extends HTMLDivElement {
            onCreate() {
            }
            createdCallback() {
                requestAnimationFrame(() => {
                    this.AndroidUI = new AndroidUI(this);
                    this.onCreate();
                    let onCreateFunc = this.getAttribute('oncreate');
                    if (onCreateFunc && typeof window[onCreateFunc] === "function") {
                        window[onCreateFunc].call(this, this);
                    }
                });
            }
            attachedCallback() {
                if (this.AndroidUI) {
                    this.AndroidUI.notifySizeChange();
                }
                else {
                    setTimeout(() => {
                        this.AndroidUI.notifySizeChange();
                    }, 50);
                }
            }
            detachedCallback() {
            }
            attributeChangedCallback(attributeName, oldVal, newVal) {
            }
            setContentView(view) {
                this.AndroidUI.setContentView(view);
            }
            addContentView(view) {
                this.AndroidUI.addContentView(view);
            }
            findViewById(id) {
                return this.AndroidUI.findViewById(id);
            }
            static registerCustomElement() {
                document.registerElement("android-" + this.name, this);
            }
        }
        app.Activity = Activity;
        Activity.registerCustomElement();
    })(app = android.app || (android.app = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/26.
 */
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/Gravity.ts"/>
///<reference path="../../android/content/res/Resources.ts"/>
///<reference path="../../android/graphics/Color.ts"/>
///<reference path="../../android/content/res/ColorStateList.ts"/>
///<reference path="../../android/util/TypedValue.ts"/>
///<reference path="../../android/R/attr.ts"/>
var androidui;
(function (androidui) {
    var widget;
    (function (widget) {
        var View = android.view.View;
        var Gravity = android.view.Gravity;
        var Resources = android.content.res.Resources;
        var Color = android.graphics.Color;
        var ColorStateList = android.content.res.ColorStateList;
        var MeasureSpec = View.MeasureSpec;
        var TypedValue = android.util.TypedValue;
        class HtmlView extends View {
            constructor(bindElement, rootElement) {
                super(bindElement, rootElement);
                this.mGravity = Gravity.TOP | Gravity.LEFT;
                this.mSingleLine = false;
                this.mTextColor = ColorStateList.valueOf(Color.BLACK);
                this.mCurTextColor = Color.BLACK;
                this.mHintColor = Color.LTGRAY;
                this.mSpacingMult = 1.2;
                this.mSpacingAdd = 0;
                this.mMaxWidth = Number.MAX_SAFE_INTEGER;
                this.mMaxHeight = Number.MAX_SAFE_INTEGER;
                this.mMaxLineCount = Number.MAX_SAFE_INTEGER;
                this.mMinLineCount = 0;
                this.initTextElement();
                this._attrBinder.addAttr('enabled', (value) => {
                    this.setEnabled(this._attrBinder.parseBoolean(value, true));
                }, () => {
                    return this.isEnabled();
                });
                this._attrBinder.addAttr('textColorHighlight', (value) => {
                });
                this._attrBinder.addAttr('textColor', (value) => {
                    let colorList = this._attrBinder.parseColorList(value);
                    if (colorList instanceof ColorStateList) {
                        this.setTextColor(colorList);
                        return;
                    }
                    let color = this._attrBinder.parseColor(value);
                    if (Number.isInteger(color))
                        this.setTextColor(color);
                }, () => {
                    if (this.mTextColor.isStateful())
                        return this.mTextColor;
                    return this.mTextColor.getDefaultColor();
                });
                this._attrBinder.addAttr('textColorHint', (value) => {
                });
                this._attrBinder.addAttr('textSize', (value) => {
                    if (value !== undefined && value !== null) {
                        value = TypedValue.complexToDimensionPixelSize(value, 0, Resources.getDisplayMetrics());
                        this.setTextSizeInPx(value);
                    }
                }, () => {
                    return this.mTextSize;
                });
                this._attrBinder.addAttr('textStyle', (value) => {
                });
                this._attrBinder.addAttr('textAllCaps', (value) => {
                });
                this._attrBinder.addAttr('drawableLeft', (value) => {
                });
                this._attrBinder.addAttr('drawableTop', (value) => {
                });
                this._attrBinder.addAttr('drawableRight', (value) => {
                });
                this._attrBinder.addAttr('drawableBottom', (value) => {
                });
                this._attrBinder.addAttr('drawablePadding', (value) => {
                });
                this._attrBinder.addAttr('maxLines', (value) => {
                    value = Number.parseInt(value);
                    if (Number.isInteger(value))
                        this.setMaxLines(value);
                }, () => {
                    return this.mMaxLineCount;
                });
                this._attrBinder.addAttr('maxHeight', (value) => {
                    value = Number.parseInt(value);
                    if (Number.isInteger(value))
                        this.setMaxHeight(value);
                }, () => {
                    return this.mMaxHeight;
                });
                this._attrBinder.addAttr('lines', (value) => {
                    value = Number.parseInt(value);
                    if (Number.isInteger(value))
                        this.setLines(value);
                }, () => {
                    if (this.mMaxLineCount === this.mMinLineCount)
                        return this.mMaxLineCount;
                    return null;
                });
                this._attrBinder.addAttr('height', (value) => {
                    value = Number.parseInt(value);
                    if (Number.isInteger(value))
                        this.setHeight(value);
                }, () => {
                    if (this.mMaxHeight === this.getMinimumHeight())
                        return this.mMaxHeight;
                    return null;
                });
                this._attrBinder.addAttr('minLines', (value) => {
                    value = Number.parseInt(value);
                    if (Number.isInteger(value))
                        this.setMinLines(value);
                }, () => {
                    return this.mMinLineCount;
                });
                this._attrBinder.addAttr('minHeight', (value) => {
                    value = Number.parseInt(value);
                    if (Number.isInteger(value))
                        this.setMinimumHeight(value);
                });
                this._attrBinder.addAttr('maxWidth', (value) => {
                    value = Number.parseInt(value);
                    if (Number.isInteger(value))
                        this.setMaxWidth(value);
                }, () => {
                    return this.mMaxWidth;
                });
                this._attrBinder.addAttr('width', (value) => {
                    value = Number.parseInt(value);
                    if (Number.isInteger(value))
                        this.setWidth(value);
                }, () => {
                    if (this.mMinWidth === this.mMaxWidth)
                        return this.mMinWidth;
                    return null;
                });
                this._attrBinder.addAttr('gravity', (value) => {
                    this.setGravity(this._attrBinder.parseGravity(value, this.mGravity));
                }, () => {
                    return this.mGravity;
                });
                this._attrBinder.addAttr('text', (value) => {
                    this.setText(value);
                }, () => {
                    return this.getText();
                });
                this._attrBinder.addAttr('singleLine', (value) => {
                    if (this._attrBinder.parseBoolean(value, false))
                        this.setSingleLine();
                }, () => {
                    if (this.mMinLineCount === 1 && this.mMaxLineCount === 1)
                        return true;
                    return false;
                });
                this._attrBinder.addAttr('textScaleX', (value) => {
                });
                this._attrBinder.addAttr('lineSpacingExtra', (value) => {
                    value = Number.parseInt(value);
                    if (Number.isInteger(value))
                        this.setLineSpacing(value, this.mSpacingMult);
                }, () => {
                    return this.mSpacingAdd;
                });
                this._attrBinder.addAttr('lineSpacingMultiplier', (value) => {
                    value = Number.parseInt(value);
                    if (Number.isInteger(value))
                        this.setLineSpacing(this.mSpacingAdd, value);
                }, () => {
                    return this.mSpacingMult;
                });
                this.applyDefaultAttributes(android.R.attr.textViewStyle);
            }
            initTextElement() {
                this.mTextElement = document.createElement('div');
                this.mTextElement.style.position = "absolute";
                this.mTextElement.style.boxSizing = "border-box";
                this.mTextElement.style.overflow = "hidden";
                this.mTextElement.style.opacity = "0";
                this.bindElement.appendChild(this.mTextElement);
            }
            onLayout(changed, left, top, right, bottom) {
                super.onLayout(changed, left, top, right, bottom);
                this.mTextElement.style.opacity = "";
            }
            onFinishInflate() {
                super.onFinishInflate();
                Array.from(this.bindElement.childNodes).forEach((item) => {
                    if (item === this.mTextElement)
                        return;
                    this.bindElement.removeChild(item);
                    this.mTextElement.appendChild(item);
                });
            }
            onMeasure(widthMeasureSpec, heightMeasureSpec) {
                let widthMode = MeasureSpec.getMode(widthMeasureSpec);
                let heightMode = MeasureSpec.getMode(heightMeasureSpec);
                let widthSize = MeasureSpec.getSize(widthMeasureSpec);
                let heightSize = MeasureSpec.getSize(heightMeasureSpec);
                let width, height;
                let padLeft = this.getCompoundPaddingLeft();
                let padTop = this.getCompoundPaddingTop();
                let padRight = this.getCompoundPaddingRight();
                let padBottom = this.getCompoundPaddingBottom();
                this.mTextElement.style.height = "";
                this.mTextElement.style.width = "";
                this.mTextElement.style.left = -Resources.getDisplayMetrics().widthPixels * Resources.getDisplayMetrics().density + 'px';
                this.mTextElement.style.top = "";
                if (widthMode == MeasureSpec.EXACTLY) {
                    width = widthSize;
                }
                else {
                    width = this.mTextElement.offsetWidth + 2;
                    width += padLeft + padRight;
                    width = Math.min(width, this.mMaxWidth);
                    width = Math.max(width, this.getSuggestedMinimumWidth());
                    if (widthMode == MeasureSpec.AT_MOST) {
                        width = Math.min(widthSize, width);
                    }
                }
                let unpaddedWidth = width - padLeft - padRight;
                this.mTextElement.style.width = unpaddedWidth + "px";
                this.mTextElement.style.left = padLeft + "px";
                if (heightMode == MeasureSpec.EXACTLY) {
                    height = heightSize;
                    let pad = this.getCompoundPaddingTop() + this.getCompoundPaddingBottom();
                    if (this.mMaxLineCount < Number.MAX_SAFE_INTEGER) {
                        let maxHeightWithLineCount = pad + this.mMaxLineCount * this.getLineHeight();
                        height = Math.min(maxHeightWithLineCount, height);
                    }
                }
                else {
                    let desired = this.getDesiredHeight();
                    height = desired;
                    if (heightMode == MeasureSpec.AT_MOST) {
                        height = Math.min(desired, heightSize);
                    }
                }
                let contextHeight = height - padTop - padBottom;
                const verticalGravity = this.mGravity & Gravity.VERTICAL_GRAVITY_MASK;
                let finalTop = padTop;
                if (verticalGravity !== Gravity.TOP) {
                    let textHeight = this.mTextElement.offsetHeight;
                    if (textHeight < contextHeight) {
                        switch (verticalGravity) {
                            case Gravity.CENTER_VERTICAL:
                                finalTop += (contextHeight - textHeight) / 2;
                                break;
                            case Gravity.BOTTOM:
                                finalTop += (contextHeight - textHeight);
                                break;
                            case Gravity.TOP:
                                break;
                        }
                        contextHeight = textHeight;
                    }
                }
                this.mTextElement.style.height = contextHeight + "px";
                this.mTextElement.style.top = finalTop + "px";
                this.setMeasuredDimension(width, height);
            }
            getDesiredHeight() {
                let desired = this.mTextElement.offsetHeight;
                let pad = this.getCompoundPaddingTop() + this.getCompoundPaddingBottom();
                desired += pad;
                desired = Math.min(this.mMaxHeight, desired);
                if (this.mMaxLineCount < Number.MAX_SAFE_INTEGER) {
                    let maxHeightWithLineCount = pad + this.mMaxLineCount * this.getLineHeight();
                    desired = Math.min(maxHeightWithLineCount, desired);
                }
                if (this.mMinLineCount > 0) {
                    let minHeightWithLineCount = pad + this.mMinLineCount * this.getLineHeight();
                    desired = Math.max(minHeightWithLineCount, desired);
                }
                desired = Math.max(desired, this.getSuggestedMinimumHeight());
                return desired;
            }
            setTextColor(color) {
                if (Number.isInteger(color)) {
                    this.mTextColor = ColorStateList.valueOf(color);
                }
                else {
                    if (color === null || color === undefined) {
                        throw new Error('colors is null');
                    }
                    this.mTextColor = color;
                }
                this.updateTextColors();
            }
            getTextColors() {
                return this.mTextColor;
            }
            getCurrentTextColor() {
                return this.mCurTextColor;
            }
            updateTextColors() {
                let inval = false;
                let color = this.mTextColor.getColorForState(this.getDrawableState(), 0);
                if (color != this.mCurTextColor) {
                    this.mCurTextColor = color;
                    let r = Color.red(this.mCurTextColor);
                    let g = Color.green(this.mCurTextColor);
                    let b = Color.blue(this.mCurTextColor);
                    let a = Color.alpha(this.mCurTextColor);
                    this.mTextElement.style.color = `rgba(${r}, ${g}, ${b}, ${a / 255})`;
                    inval = false;
                }
                if (inval) {
                    this.invalidate();
                }
            }
            drawableStateChanged() {
                super.drawableStateChanged();
                if (this.mTextColor != null && this.mTextColor.isStateful()) {
                    this.updateTextColors();
                }
            }
            getCompoundPaddingTop() {
                return this.mPaddingTop;
            }
            getCompoundPaddingBottom() {
                return this.mPaddingBottom;
            }
            getCompoundPaddingLeft() {
                return this.mPaddingLeft;
            }
            getCompoundPaddingRight() {
                return this.mPaddingRight;
            }
            setGravity(gravity) {
                switch (gravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
                    case Gravity.CENTER_HORIZONTAL:
                        this.mTextElement.style.textAlign = "center";
                        break;
                    case Gravity.RIGHT:
                        this.mTextElement.style.textAlign = "right";
                        break;
                    case Gravity.LEFT:
                        this.mTextElement.style.textAlign = "left";
                        break;
                }
                if ((gravity & Gravity.VERTICAL_GRAVITY_MASK) !=
                    (this.mGravity & Gravity.VERTICAL_GRAVITY_MASK)) {
                    this.requestLayout();
                }
                this.mGravity = gravity;
            }
            setLineSpacing(add, mult) {
                if (this.mSpacingAdd != add || this.mSpacingMult != mult) {
                    this.mSpacingAdd = add;
                    this.mSpacingMult = mult;
                    this.setTextSize(this.mTextSize);
                }
            }
            setTextSizeInPx(sizeInPx) {
                if (this.mTextSize !== sizeInPx) {
                    this.mTextSize = sizeInPx;
                    this.mTextElement.style.fontSize = sizeInPx + "px";
                    this.mTextElement.style.lineHeight = this.getLineHeight() + "px";
                    this.requestLayout();
                }
            }
            setTextSize(size) {
                let sizeInPx = size * Resources.getDisplayMetrics().density;
                this.setTextSizeInPx(sizeInPx);
            }
            getLineHeight() {
                return Math.ceil(this.mTextSize * this.mSpacingMult + this.mSpacingAdd);
            }
            setHeight(pixels) {
                this.mMaxHeight = pixels;
                this.setMinimumHeight(pixels);
                this.requestLayout();
                this.invalidate();
            }
            setMaxLines(max) {
                this.mMaxLineCount = max;
                this.requestLayout();
                this.invalidate();
            }
            getMaxLines() {
                return this.mMaxLineCount;
            }
            setMaxHeight(maxHeight) {
                this.mMaxHeight = maxHeight;
                this.requestLayout();
                this.invalidate();
            }
            getMaxHeight() {
                return this.mMaxHeight;
            }
            setMaxWidth(maxpixels) {
                this.mMaxWidth = maxpixels;
                this.requestLayout();
                this.invalidate();
            }
            getMaxWidth() {
                return this.mMaxWidth;
            }
            setWidth(pixels) {
                this.mMaxWidth = pixels;
                this.setMinimumWidth(pixels);
                this.requestLayout();
                this.invalidate();
            }
            setMinLines(min) {
                this.mMinLineCount = min;
                this.requestLayout();
                this.invalidate();
            }
            getMinLines() {
                return this.mMinLineCount;
            }
            setSingleLine(singleLine = true) {
                if (singleLine)
                    this.setLines(1);
                else {
                    this.mMaxLineCount = Number.MAX_SAFE_INTEGER;
                    this.mMinLineCount = 0;
                    this.requestLayout();
                    this.invalidate();
                }
            }
            setLines(lines) {
                this.mMaxLineCount = this.mMinLineCount = lines;
                this.requestLayout();
                this.invalidate();
            }
            setText(text = '') {
                this.mTextElement.innerText = text;
                this.requestLayout();
            }
            getText() {
                return this.mTextElement.innerText;
            }
            setHtml(html) {
                this.mTextElement.innerHTML = html;
                this.requestLayout();
            }
            getHtml() {
                return this.mTextElement.innerHTML;
            }
            getTextElement() {
                return this.mTextElement;
            }
        }
        widget.HtmlView = HtmlView;
    })(widget = androidui.widget || (androidui.widget = {}));
})(androidui || (androidui = {}));
/**
 * Created by linfaxin on 15/11/16.
 */
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../android/widget/AbsListView.ts"/>
///<reference path="../../android/widget/ListAdapter.ts"/>
///<reference path="../../android/widget/BaseAdapter.ts"/>
///<reference path="../../android/widget/AdapterView.ts"/>
///<reference path="../../android/widget/SpinnerAdapter.ts"/>
///<reference path="../../android/database/DataSetObservable.ts"/>
///<reference path="../../android/database/DataSetObserver.ts"/>
var androidui;
(function (androidui) {
    var widget;
    (function (widget) {
        var View = android.view.View;
        var AbsListView = android.widget.AbsListView;
        var BaseAdapter = android.widget.BaseAdapter;
        var AdapterView = android.widget.AdapterView;
        class HtmlDataListAdapter extends BaseAdapter {
            onInflateAdapter(bindElement, rootElement, parent) {
                this.bindElementData = bindElement;
                this.rootElement = rootElement;
                if (parent instanceof AbsListView) {
                    parent.setAdapter(this);
                }
                bindElement[HtmlDataListAdapter.BindAdapterProperty] = this;
                this.registerHtmlDataObserver();
            }
            registerHtmlDataObserver() {
                const adapter = this;
                function callBack(arr, observer) {
                    adapter.notifyDataSetChanged();
                }
                let observer = new MutationObserver(callBack);
                observer.observe(this.bindElementData, { childList: true });
            }
            getItemViewType(position) {
                return AdapterView.ITEM_VIEW_TYPE_IGNORE;
            }
            getView(position, convertView, parent) {
                let element = this.getItem(position);
                let view = element[View.AndroidViewProperty];
                this.checkReplaceWithRef(element);
                if (!view) {
                    view = View.inflate(element, this.rootElement, parent);
                    element[View.AndroidViewProperty] = view;
                }
                return view;
            }
            getCount() {
                return this.bindElementData.children.length;
            }
            getItem(position) {
                let element = this.bindElementData.children[position];
                if (element.tagName === HtmlDataListAdapter.RefElementTag) {
                    element = element[HtmlDataListAdapter.RefElementProperty];
                    if (!element)
                        throw Error('Reference element is ' + element);
                }
                return element;
            }
            checkReplaceWithRef(element) {
                let refElement = element[HtmlDataListAdapter.RefElementProperty] || document.createElement(HtmlDataListAdapter.RefElementTag);
                refElement[HtmlDataListAdapter.RefElementProperty] = element;
                element[HtmlDataListAdapter.RefElementProperty] = refElement;
                if (element.parentNode === this.bindElementData) {
                    this.bindElementData.insertBefore(refElement, element);
                    this.bindElementData.removeChild(element);
                }
                return refElement;
            }
            removeElementRefAndRestoreToAdapter(childElement) {
                if (childElement.tagName === HtmlDataListAdapter.RefElementTag) {
                    let element = childElement[HtmlDataListAdapter.RefElementProperty];
                    this.bindElementData.insertBefore(element, childElement);
                    this.bindElementData.removeChild(childElement);
                }
            }
            notifyDataSizeWillChange() {
                for (let i = 0, count = this.bindElementData.children.length; i < count; i++) {
                    this.removeElementRefAndRestoreToAdapter(this.bindElementData.children[i]);
                }
                this.notifyDataSetChanged();
            }
            getItemId(position) {
                let id = this.getItem(position).id;
                let idNumber = Number.parseInt(id);
                if (Number.isInteger(idNumber))
                    return idNumber;
                return -1;
            }
        }
        HtmlDataListAdapter.RefElementTag = "ref-element".toUpperCase();
        HtmlDataListAdapter.RefElementProperty = "RefElement";
        HtmlDataListAdapter.BindAdapterProperty = "BindAdapter";
        widget.HtmlDataListAdapter = HtmlDataListAdapter;
    })(widget = androidui.widget || (androidui.widget = {}));
})(androidui || (androidui = {}));
/**
 * Created by linfaxin on 15/11/16.
 */
///<reference path="../../android/database/DataSetObservable.ts"/>
///<reference path="../../android/database/Observable.ts"/>
///<reference path="../../android/database/DataSetObserver.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../android/support/v4/view/ViewPager.ts"/>
///<reference path="../../android/support/v4/view/PagerAdapter.ts"/>
var androidui;
(function (androidui) {
    var widget;
    (function (widget) {
        var View = android.view.View;
        var ViewPager = android.support.v4.view.ViewPager;
        var PagerAdapter = android.support.v4.view.PagerAdapter;
        class HtmlDataPagerAdapter extends PagerAdapter {
            onInflateAdapter(bindElement, rootElement, parent) {
                this.bindElementData = bindElement;
                this.rootElement = rootElement;
                if (parent instanceof ViewPager) {
                    parent.setAdapter(this);
                }
                bindElement[HtmlDataPagerAdapter.BindAdapterProperty] = this;
                this.registerHtmlDataObserver();
            }
            registerHtmlDataObserver() {
                const adapter = this;
                function callBack(arr, observer) {
                    adapter.notifyDataSetChanged();
                }
                let observer = new MutationObserver(callBack);
                observer.observe(this.bindElementData, { childList: true });
            }
            getCount() {
                return this.bindElementData.children.length;
            }
            instantiateItem(container, position) {
                let element = this.getItem(position);
                let view = element[View.AndroidViewProperty];
                this.checkReplaceWithRef(element);
                if (!view) {
                    view = View.inflate(element, this.rootElement, container);
                    element[View.AndroidViewProperty] = view;
                }
                container.addView(view);
                return view;
            }
            getItem(position) {
                let element = this.bindElementData.children[position];
                if (element.tagName === HtmlDataPagerAdapter.RefElementTag) {
                    element = element[HtmlDataPagerAdapter.RefElementProperty];
                    if (!element)
                        throw Error('Reference element is ' + element);
                }
                return element;
            }
            checkReplaceWithRef(element) {
                let refElement = element[HtmlDataPagerAdapter.RefElementProperty] || document.createElement(HtmlDataPagerAdapter.RefElementTag);
                refElement[HtmlDataPagerAdapter.RefElementProperty] = element;
                element[HtmlDataPagerAdapter.RefElementProperty] = refElement;
                if (element.parentNode === this.bindElementData) {
                    this.bindElementData.insertBefore(refElement, element);
                    this.bindElementData.removeChild(element);
                }
                return refElement;
            }
            removeElementRefAndRestoreToAdapter(childElement) {
                if (childElement.tagName === HtmlDataPagerAdapter.RefElementTag) {
                    let element = childElement[HtmlDataPagerAdapter.RefElementProperty];
                    this.bindElementData.insertBefore(element, childElement);
                    this.bindElementData.removeChild(childElement);
                }
            }
            notifyDataSizeWillChange() {
                for (let i = 0, count = this.bindElementData.children.length; i < count; i++) {
                    this.removeElementRefAndRestoreToAdapter(this.bindElementData.children[i]);
                }
                this.notifyDataSetChanged();
            }
            destroyItem(container, position, object) {
                let view = object;
                container.removeView(view);
            }
            isViewFromObject(view, object) {
                return view === object;
            }
            getItemPosition(object) {
                let position = PagerAdapter.POSITION_NONE;
                if (object == null)
                    return position;
                for (let i = 0, count = this.getCount(); i < count; i++) {
                    if (object === this.getItem(i)[View.AndroidViewProperty]) {
                        position = i;
                        break;
                    }
                }
                return position;
            }
        }
        HtmlDataPagerAdapter.RefElementTag = "ref-element".toUpperCase();
        HtmlDataPagerAdapter.RefElementProperty = "RefElement";
        HtmlDataPagerAdapter.BindAdapterProperty = "BindAdapter";
        widget.HtmlDataPagerAdapter = HtmlDataPagerAdapter;
    })(widget = androidui.widget || (androidui.widget = {}));
})(androidui || (androidui = {}));
/**
 * Created by linfaxin on 15/11/16.
 */
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../android/widget/NumberPicker.ts"/>
var androidui;
(function (androidui) {
    var widget;
    (function (widget) {
        var NumberPicker = android.widget.NumberPicker;
        class HtmlDataPickerAdapter {
            onInflateAdapter(bindElement, rootElement, parent) {
                this.bindElementData = bindElement;
                this.rootElement = rootElement;
                if (parent instanceof NumberPicker) {
                    const callBack = (arr, observer) => {
                        const values = [];
                        for (let child of Array.from(this.bindElementData.children)) {
                            values.push(child.innerText);
                        }
                        parent.setDisplayedValues(values);
                    };
                    callBack.call(this);
                    let observer = new MutationObserver(callBack);
                    observer.observe(this.bindElementData, { childList: true });
                }
            }
        }
        widget.HtmlDataPickerAdapter = HtmlDataPickerAdapter;
    })(widget = androidui.widget || (androidui.widget = {}));
})(androidui || (androidui = {}));
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/widget/ScrollView.ts"/>
var androidui;
(function (androidui) {
    var widget;
    (function (widget) {
        var View = android.view.View;
        var ScrollView = android.widget.ScrollView;
        class NativeScrollView extends ScrollView {
            constructor(...args) {
                super(...args);
                this.isTouching = false;
            }
            initBindElement(bindElement, rootElement) {
                super.initBindElement(bindElement, rootElement);
                this.bindElement.style.cssText += ";overflow-y:auto;-webkit-overflow-scrolling:touch;";
                const density = this.getResources().getDisplayMetrics().density;
                this.bindElement.addEventListener('scroll', (e) => {
                    let oldX = this.mScrollX;
                    let oldY = this.mScrollY;
                    let x = this.bindElement.scrollLeft * density;
                    let y = this.bindElement.scrollTop * density;
                    if (oldX != x || oldY != y) {
                        const range = this.getScrollRange();
                        this.overScrollBy(x - oldX, y - oldY, oldX, oldY, 0, range, 0, this.mOverflingDistance, this.isTouching);
                        this.onScrollChanged(this.mScrollX, this.mScrollY, oldX, oldY);
                    }
                    this.awakenScrollBars();
                });
                this.bindElement.addEventListener("touchstart", () => {
                    var maxScroll = this.bindElement.scrollHeight - this.bindElement.offsetHeight;
                    if (this.bindElement.scrollTop === 0)
                        this.bindElement.scrollTop = 1;
                    else if (this.bindElement.scrollTop === maxScroll)
                        this.bindElement.scrollTop = maxScroll - 1;
                });
                this.bindElement.addEventListener('click', (e) => {
                    if (e[View.AndroidViewProperty])
                        return;
                    e.preventDefault();
                    e.stopPropagation();
                }, true);
            }
            onMeasure(widthMeasureSpec, heightMeasureSpec) {
                super.onMeasure(widthMeasureSpec, heightMeasureSpec);
                if (this.getChildCount() > 0) {
                    const child = this.getChildAt(0);
                    let height = this.getMeasuredHeight();
                    if (child.getMeasuredHeight() < height) {
                        const lp = child.getLayoutParams();
                        let childWidthMeasureSpec = android.widget.FrameLayout.getChildMeasureSpec(widthMeasureSpec, this.mPaddingLeft + this.mPaddingRight, lp.width);
                        height -= this.mPaddingTop;
                        height -= this.mPaddingBottom;
                        height += 3;
                        let childHeightMeasureSpec = View.MeasureSpec.makeMeasureSpec(height, View.MeasureSpec.EXACTLY);
                        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
                    }
                }
            }
            onInterceptTouchEvent(ev) {
                const parent = this.getParent();
                var func;
                if (parent != null) {
                    func = parent.requestDisallowInterceptTouchEvent;
                    parent.requestDisallowInterceptTouchEvent = () => { };
                }
                try {
                    return super.onInterceptTouchEvent(ev);
                }
                finally {
                    if (parent != null && func) {
                        parent.requestDisallowInterceptTouchEvent = func;
                    }
                }
            }
            onTouchEvent(ev) {
                switch (ev.getAction()) {
                    case android.view.MotionEvent.ACTION_CANCEL:
                    case android.view.MotionEvent.ACTION_UP:
                        this.isTouching = false;
                        break;
                    case android.view.MotionEvent.ACTION_DOWN:
                    case android.view.MotionEvent.ACTION_MOVE:
                        this.isTouching = true;
                        break;
                }
                return true;
            }
            _syncScrollToElement() {
                return false;
            }
            onDrawVerticalScrollBar(canvas, scrollBar, l, t, r, b) {
            }
        }
        widget.NativeScrollView = NativeScrollView;
    })(widget = androidui.widget || (androidui.widget = {}));
})(androidui || (androidui = {}));
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/Gravity.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../android/view/MotionEvent.ts"/>
///<reference path="../../android/widget/FrameLayout.ts"/>
///<reference path="../../android/widget/AbsListView.ts"/>
///<reference path="../../android/widget/ScrollView.ts"/>
///<reference path="../../android/widget/OverScroller.ts"/>
///<reference path="../../androidui/widget/NativeScrollView.ts"/>
///<reference path="../../java/lang/Integer.ts"/>
var androidui;
(function (androidui) {
    var widget;
    (function (widget) {
        var MotionEvent = android.view.MotionEvent;
        var AbsListView = android.widget.AbsListView;
        var ScrollView = android.widget.ScrollView;
        var Integer = java.lang.Integer;
        var OverScrollLocker;
        (function (OverScrollLocker) {
            const InstanceMap = new WeakMap();
            function getFrom(view) {
                let scrollLocker = InstanceMap.get(view);
                if (!scrollLocker) {
                    if (view instanceof AbsListView) {
                        scrollLocker = new ListViewOverScrollLocker(view);
                    }
                    else if (view instanceof ScrollView) {
                        scrollLocker = new ScrollViewScrollLocker(view);
                    }
                    if (scrollLocker)
                        InstanceMap.set(view, scrollLocker);
                }
                return scrollLocker;
            }
            OverScrollLocker.getFrom = getFrom;
            class BaseOverScrollLocker {
                constructor(view) {
                    this.view = view;
                    const onTouchEventFunc = view.onTouchEvent;
                    view.onTouchEvent = (event) => {
                        let result = onTouchEventFunc.call(view, event);
                        switch (event.getAction()) {
                            case MotionEvent.ACTION_DOWN:
                            case MotionEvent.ACTION_MOVE:
                                this.isInTouch = true;
                                break;
                            case MotionEvent.ACTION_UP:
                            case MotionEvent.ACTION_CANCEL:
                                this.isInTouch = false;
                                break;
                        }
                        return result;
                    };
                }
                lockOverScrollTop(lockTop) {
                    this.lockTop = lockTop;
                    if (!this.isInTouch && this.getOverScrollY() < -lockTop) {
                        this.springBackToLockTop();
                    }
                }
                lockOverScrollBottom(lockBottom) {
                    this.lockBottom = lockBottom;
                    if (!this.isInTouch && this.getOverScrollY() > lockBottom) {
                        this.springBackToLockBottom();
                    }
                }
            }
            class ListViewOverScrollLocker extends BaseOverScrollLocker {
                constructor(listView) {
                    super(listView);
                    this.listView = listView;
                    this.configListView();
                }
                configListView() {
                    let listView = this.listView;
                    if (!listView.mFlingRunnable)
                        listView.mFlingRunnable = new AbsListView.FlingRunnable(listView);
                    const scroller = listView.mFlingRunnable.mScroller;
                    listView.mFlingRunnable.startOverfling = (initialVelocity) => {
                        scroller.setInterpolator(null);
                        let minY = Integer.MIN_VALUE, maxY = Integer.MAX_VALUE;
                        if (listView.mScrollY < 0)
                            minY = -this.lockTop;
                        else if (listView.mScrollY > 0)
                            maxY = this.lockBottom;
                        scroller.fling(0, listView.mScrollY, 0, initialVelocity, 0, 0, minY, maxY, 0, listView._mOverflingDistance);
                        listView.mTouchMode = AbsListView.TOUCH_MODE_OVERFLING;
                        listView.invalidate();
                        listView.postOnAnimation(listView.mFlingRunnable);
                    };
                    const layoutChildrenFunc = listView.layoutChildren;
                    listView.layoutChildren = () => {
                        const overScrollY = this.getOverScrollY();
                        layoutChildrenFunc.call(listView);
                        if (overScrollY !== 0) {
                            listView.overScrollBy(0, -overScrollY, 0, listView.mScrollY, 0, 0, 0, listView.mOverscrollDistance, false);
                            const atEdge = listView.trackMotionScroll(-overScrollY, -overScrollY);
                            if (atEdge) {
                                listView.overScrollBy(0, overScrollY, 0, listView.mScrollY, 0, 0, 0, listView.mOverscrollDistance, false);
                            }
                            else {
                                listView.mFlingRunnable.mScroller.abortAnimation();
                            }
                        }
                    };
                    listView.checkOverScrollStartScrollIfNeeded = () => {
                        return listView.mScrollY > this.lockBottom || listView.mScrollY < this.lockTop;
                    };
                    listView.mFlingRunnable.edgeReached = (delta) => {
                        let initialVelocity = listView.mFlingRunnable.mScroller.getCurrVelocity();
                        if (delta > 0)
                            initialVelocity = -initialVelocity;
                        listView.mFlingRunnable.startOverfling(initialVelocity);
                    };
                    const oldSpringBack = scroller.springBack;
                    scroller.springBack = (startX, startY, minX, maxX, minY, maxY) => {
                        minY = -this.lockTop;
                        maxY = this.lockBottom;
                        return oldSpringBack.call(scroller, startX, startY, minX, maxX, minY, maxY);
                    };
                    const oldFling = scroller.fling;
                    scroller.fling = (startX, startY, velocityX, velocityY, minX, maxX, minY, maxY, overX = 0, overY = 0) => {
                        if (velocityY > 0)
                            overY += this.lockBottom;
                        else
                            overY += this.lockTop;
                        oldFling.call(scroller, startX, startY, velocityX, velocityY, minX, maxX, minY, maxY, overX, overY);
                    };
                }
                getScrollContentBottom() {
                    let childCount = this.listView.getChildCount();
                    let maxBottom = 0;
                    let minTop = 0;
                    for (let i = 0; i < childCount; i++) {
                        let child = this.listView.getChildAt(i);
                        let childBottom = child.getBottom();
                        let childTop = child.getTop();
                        if (childBottom > maxBottom) {
                            maxBottom = childBottom;
                        }
                        if (childTop < minTop) {
                            minTop = childTop;
                        }
                    }
                    if (minTop > 0)
                        minTop = 0;
                    if (this.listView.getAdapter() && childCount > 0) {
                        return (maxBottom - minTop) * this.listView.getAdapter().getCount() / childCount;
                    }
                    return 0;
                }
                getOverScrollY() {
                    return this.listView.mScrollY;
                }
                startSpringBack() {
                    this.listView.reportScrollStateChange(AbsListView.OnScrollListener.SCROLL_STATE_FLING);
                    this.listView.mFlingRunnable.mScroller.springBack(0, this.listView.mScrollY, 0, 0, 0, 0);
                    this.listView.mTouchMode = AbsListView.TOUCH_MODE_OVERFLING;
                    this.listView.postOnAnimation(this.listView.mFlingRunnable);
                }
                springBackToLockTop() {
                    this.startSpringBack();
                }
                springBackToLockBottom() {
                    this.startSpringBack();
                }
            }
            class ScrollViewScrollLocker extends BaseOverScrollLocker {
                constructor(scrollView) {
                    super(scrollView);
                    this.scrollView = scrollView;
                    const scroller = scrollView.mScroller;
                    const oldSpringBack = scroller.springBack;
                    scroller.springBack = (startX, startY, minX, maxX, minY, maxY) => {
                        minY = -this.lockTop;
                        maxY = this.scrollView.getScrollRange() + this.lockBottom;
                        return oldSpringBack.call(scroller, startX, startY, minX, maxX, minY, maxY);
                    };
                    const oldFling = scroller.fling;
                    scroller.fling = (startX, startY, velocityX, velocityY, minX, maxX, minY, maxY, overX = 0, overY = 0) => {
                        if (velocityY > 0)
                            overY += this.lockBottom;
                        else
                            overY += this.lockTop;
                        minY -= this.lockTop;
                        maxY += this.lockBottom;
                        oldFling.call(scroller, startX, startY, velocityX, velocityY, minX, maxX, minY, maxY, overX, overY);
                    };
                    this.listenScrollContentHeightChange();
                }
                listenScrollContentHeightChange() {
                    const listenHeightChange = (v) => {
                        const onSizeChangedFunc = v.onSizeChanged;
                        v.onSizeChanged = (w, h, oldw, oldh) => {
                            onSizeChangedFunc.call(v, w, h, oldw, oldh);
                            this.scrollView.overScrollBy(0, 0, 0, this.scrollView.mScrollY, 0, this.scrollView.getScrollRange(), 0, this.scrollView.mOverscrollDistance, false);
                        };
                    };
                    if (this.scrollView.getChildCount() > 0) {
                        listenHeightChange(this.scrollView.getChildAt(0));
                    }
                    else {
                        const onViewAddedFunc = this.scrollView.onViewAdded;
                        this.scrollView.onViewAdded = (v) => {
                            onViewAddedFunc.call(this.scrollView, v);
                            listenHeightChange(v);
                        };
                    }
                }
                getScrollContentBottom() {
                    if (this.scrollView.getChildCount() > 0) {
                        return this.scrollView.getChildAt(0).getBottom();
                    }
                    return this.scrollView.getPaddingTop();
                }
                getOverScrollY() {
                    let scrollY = this.scrollView.getScrollY();
                    if (scrollY < 0)
                        return scrollY;
                    let scrollRange = this.scrollView.getScrollRange();
                    if (scrollY > scrollRange) {
                        return scrollY - scrollRange;
                    }
                    return 0;
                }
                startSpringBack() {
                    if (this.scrollView.mScroller.springBack(this.scrollView.mScrollX, this.scrollView.mScrollY, 0, 0, 0, this.scrollView.getScrollRange())) {
                        this.scrollView.postInvalidateOnAnimation();
                    }
                }
                springBackToLockTop() {
                    this.startSpringBack();
                }
                springBackToLockBottom() {
                    this.startSpringBack();
                }
            }
        })(OverScrollLocker = widget.OverScrollLocker || (widget.OverScrollLocker = {}));
    })(widget = androidui.widget || (androidui.widget = {}));
})(androidui || (androidui = {}));
/**
 * Created by linfaxin on 15/11/19.
 */
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/Gravity.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../android/widget/FrameLayout.ts"/>
///<reference path="../../android/widget/AbsListView.ts"/>
///<reference path="../../android/widget/ScrollView.ts"/>
///<reference path="../../android/widget/OverScroller.ts"/>
///<reference path="../../android/widget/TextView.ts"/>
///<reference path="../../android/R/string.ts"/>
///<reference path="../../java/lang/Integer.ts"/>
///<reference path="OverScrollLocker.ts"/>
var androidui;
(function (androidui) {
    var widget;
    (function (widget) {
        var Gravity = android.view.Gravity;
        var ViewGroup = android.view.ViewGroup;
        var FrameLayout = android.widget.FrameLayout;
        var TextView = android.widget.TextView;
        var R = android.R;
        class PullRefreshLoadLayout extends FrameLayout {
            constructor(bindElement, rootElement) {
                super(bindElement, rootElement);
                this.autoLoadScrollAtBottom = true;
                this.footerViewReadyDistance = 36 * android.content.res.Resources.getDisplayMetrics().density;
                this.contentOverY = 0;
                this.setHeaderView(new PullRefreshLoadLayout.DefaultHeaderView());
                this.setFooterView(new PullRefreshLoadLayout.DefaultFooterView());
                this._attrBinder.addAttr('refreshEnable', (value) => {
                    this.setRefreshEnable(this._attrBinder.parseBoolean(value, true));
                });
                this._attrBinder.addAttr('loadEnable', (value) => {
                    this.setLoadEnable(this._attrBinder.parseBoolean(value, true));
                });
            }
            onViewAdded(child) {
                super.onViewAdded(child);
                if (child instanceof PullRefreshLoadLayout.HeaderView) {
                    if (child != this.headerView)
                        this.setHeaderView(child);
                }
                else if (child instanceof PullRefreshLoadLayout.FooterView) {
                    if (child != this.footerView)
                        this.setFooterView(child);
                }
                else {
                    if (child != this.contentView)
                        this.setContentView(child);
                }
            }
            configHeaderView() {
                let headerView = this.headerView;
                let params = headerView.getLayoutParams();
                params.gravity = Gravity.TOP | Gravity.CENTER_HORIZONTAL;
                params.height = ViewGroup.LayoutParams.WRAP_CONTENT;
                params.width = ViewGroup.LayoutParams.MATCH_PARENT;
                headerView.setLayoutParams(params);
            }
            configFooterView() {
                let footerView = this.footerView;
                let params = footerView.getLayoutParams();
                params.gravity = Gravity.BOTTOM | Gravity.CENTER_HORIZONTAL;
                params.height = ViewGroup.LayoutParams.WRAP_CONTENT;
                params.width = ViewGroup.LayoutParams.WRAP_CONTENT;
                footerView.setLayoutParams(params);
            }
            configContentView() {
                let contentView = this.contentView;
                let params = contentView.getLayoutParams();
                params.height = ViewGroup.LayoutParams.MATCH_PARENT;
                params.width = ViewGroup.LayoutParams.MATCH_PARENT;
                contentView.setLayoutParams(params);
                this.overScrollLocker = widget.OverScrollLocker.getFrom(contentView);
                const overScrollByFunc = contentView.overScrollBy;
                contentView.overScrollBy = (deltaX, deltaY, scrollX, scrollY, scrollRangeX, scrollRangeY, maxOverScrollX, maxOverScrollY, isTouchEvent) => {
                    let result = overScrollByFunc.call(contentView, deltaX, deltaY, scrollX, scrollY, scrollRangeX, scrollRangeY, maxOverScrollX, maxOverScrollY, isTouchEvent);
                    if (contentView === this.contentView) {
                        this.onContentOverScroll(scrollRangeY, maxOverScrollY, isTouchEvent);
                    }
                    return result;
                };
            }
            onContentOverScroll(scrollRangeY, maxOverScrollY, isTouchEvent) {
                let newScrollY = this.contentView.mScrollY;
                const top = 0;
                const bottom = scrollRangeY;
                if (newScrollY > bottom) {
                    this.contentOverY = newScrollY - bottom;
                }
                else if (newScrollY < top) {
                    this.contentOverY = newScrollY - top;
                }
                else {
                    this.contentOverY = 0;
                }
                this.checkHeaderFooterPosition();
                if (this.headerView) {
                    if (this.contentOverY < -this.headerView.getHeight()) {
                        if (isTouchEvent) {
                            this.setHeaderState(PullRefreshLoadLayout.State_Header_ReadyToRefresh);
                        }
                        else if (this.headerView.state === PullRefreshLoadLayout.State_Header_ReadyToRefresh) {
                            this.setHeaderState(PullRefreshLoadLayout.State_Header_Refreshing);
                        }
                    }
                    else if (this.headerView.state === PullRefreshLoadLayout.State_Header_ReadyToRefresh) {
                        this.setHeaderState(this.headerView.stateBeforeReady);
                    }
                }
                if (this.footerView) {
                    const footerState = this.footerView.state;
                    if (this.contentOverY > this.footerView.getHeight() + this.footerViewReadyDistance) {
                        if (isTouchEvent) {
                            this.setFooterState(PullRefreshLoadLayout.State_Footer_ReadyToLoad);
                        }
                        else if (footerState === PullRefreshLoadLayout.State_Footer_ReadyToLoad) {
                            this.setFooterState(PullRefreshLoadLayout.State_Footer_Loading);
                        }
                    }
                    else if (footerState === PullRefreshLoadLayout.State_Footer_ReadyToLoad) {
                        this.setFooterState(this.footerView.stateBeforeReady);
                    }
                    if (this.contentOverY > 0 && this.autoLoadScrollAtBottom
                        && footerState === PullRefreshLoadLayout.State_Footer_Normal) {
                        this.setFooterState(PullRefreshLoadLayout.State_Footer_Loading);
                    }
                }
            }
            setHeaderView(headerView) {
                if (this.headerView) {
                    this.removeView(this.headerView);
                }
                this.headerView = headerView;
                if (headerView.getParent() == null)
                    this.addView(headerView);
                this.configHeaderView();
            }
            setFooterView(footerView) {
                if (this.footerView) {
                    this.removeView(this.footerView);
                }
                this.footerView = footerView;
                if (footerView.getParent() == null)
                    this.addView(footerView);
                this.configFooterView();
            }
            setContentView(contentView) {
                if (this.contentView) {
                    this.removeView(this.contentView);
                }
                this.contentView = contentView;
                if (contentView.getParent() == null)
                    this.addView(contentView);
                this.configContentView();
            }
            setHeaderState(newState) {
                if (!this.headerView)
                    return;
                if (this.headerView.state === newState)
                    return;
                const changeLimit = PullRefreshLoadLayout.StateChangeLimit[this.headerView.state];
                if (changeLimit && changeLimit.indexOf(newState) !== -1)
                    return;
                this.headerView.setStateInner(this, newState);
                this.checkLockOverScroll();
                if (newState === PullRefreshLoadLayout.State_Header_Refreshing && this.refreshLoadListener) {
                    this.refreshLoadListener.onRefresh(this);
                }
            }
            getHeaderState() {
                if (!this.headerView)
                    return PullRefreshLoadLayout.State_Disable;
                return this.headerView.state;
            }
            setFooterState(newState) {
                if (!this.footerView)
                    return;
                if (this.footerView.state === newState)
                    return;
                const changeLimit = PullRefreshLoadLayout.StateChangeLimit[this.footerView.state];
                if (changeLimit && changeLimit.indexOf(newState) !== -1)
                    return;
                this.footerView.setStateInner(this, newState);
                this.checkLockOverScroll();
                if (newState === PullRefreshLoadLayout.State_Footer_Loading && this.refreshLoadListener) {
                    this.refreshLoadListener.onLoadMore(this);
                }
            }
            getFooterState() {
                if (!this.footerView)
                    return PullRefreshLoadLayout.State_Disable;
                return this.footerView.state;
            }
            checkLockOverScroll() {
                if (!this.overScrollLocker)
                    return;
                if (this.headerView) {
                    switch (this.headerView.state) {
                        case PullRefreshLoadLayout.State_Header_Normal:
                            this.overScrollLocker.lockOverScrollTop(0);
                            break;
                        case PullRefreshLoadLayout.State_Header_Refreshing:
                            this.overScrollLocker.lockOverScrollTop(this.headerView.getHeight());
                            break;
                        case PullRefreshLoadLayout.State_Header_ReadyToRefresh:
                            this.overScrollLocker.lockOverScrollTop(this.headerView.getHeight());
                            break;
                        case PullRefreshLoadLayout.State_Header_RefreshFail:
                            this.overScrollLocker.lockOverScrollTop(this.headerView.getHeight());
                            break;
                    }
                }
                else {
                    this.overScrollLocker.lockOverScrollTop(0);
                }
                this.overScrollLocker.lockOverScrollBottom(this.footerView ? this.footerView.getHeight() : 0);
            }
            checkHeaderFooterPosition() {
                if (this.contentOverY > 0) {
                    this.setHeaderViewAppearDistance(0);
                    this.setFooterViewAppearDistance(this.contentOverY);
                }
                else if (this.contentOverY < 0) {
                    this.setHeaderViewAppearDistance(-this.contentOverY);
                    this.setFooterViewAppearDistance(0);
                }
                else {
                    this.setHeaderViewAppearDistance(0);
                    this.setFooterViewAppearDistance(0);
                }
            }
            setHeaderViewAppearDistance(distance) {
                if (!this.headerView)
                    return;
                let offset = -this.headerView.getHeight() - this.headerView.getTop() + distance;
                this.headerView.offsetTopAndBottom(offset);
            }
            setFooterViewAppearDistance(distance) {
                if (!this.contentView || !this.footerView)
                    return;
                let bottomToParentBottom = Math.min(this.overScrollLocker.getScrollContentBottom(), this.contentView.getHeight()) - this.footerView.getBottom();
                if (this.contentOverY < 0)
                    bottomToParentBottom -= this.contentOverY;
                let offset = this.footerView.getHeight() + bottomToParentBottom - distance;
                this.footerView.offsetTopAndBottom(offset);
            }
            onLayout(changed, left, top, right, bottom) {
                super.onLayout(changed, left, top, right, bottom);
                this.checkHeaderFooterPosition();
                this.checkLockOverScroll();
            }
            setAutoLoadMoreWhenScrollBottom(autoLoad) {
                this.autoLoadScrollAtBottom = autoLoad;
            }
            setRefreshEnable(enable) {
                const oldEnable = this.headerView != null;
                if (enable === oldEnable)
                    return;
                if (!enable) {
                    this.removeView(this.headerView);
                    this.headerView = null;
                    if (this.overScrollLocker)
                        this.overScrollLocker.lockOverScrollTop(0);
                }
                else {
                    this.setHeaderView(new PullRefreshLoadLayout.DefaultHeaderView());
                }
            }
            setLoadEnable(enable) {
                const oldEnable = this.footerView != null;
                if (enable === oldEnable)
                    return;
                if (!enable) {
                    this.removeView(this.footerView);
                    this.footerView = null;
                    if (this.overScrollLocker)
                        this.overScrollLocker.lockOverScrollBottom(0);
                }
                else {
                    this.setFooterView(new PullRefreshLoadLayout.DefaultFooterView());
                }
            }
            setRefreshLoadListener(refreshLoadListener) {
                this.refreshLoadListener = refreshLoadListener;
            }
            startRefresh() {
                this.setHeaderState(PullRefreshLoadLayout.State_Header_Refreshing);
            }
            startLoadMore() {
                this.setFooterState(PullRefreshLoadLayout.State_Footer_Loading);
            }
        }
        PullRefreshLoadLayout.State_Disable = -1;
        PullRefreshLoadLayout.State_Header_Normal = 0;
        PullRefreshLoadLayout.State_Header_Refreshing = 1;
        PullRefreshLoadLayout.State_Header_ReadyToRefresh = 2;
        PullRefreshLoadLayout.State_Header_RefreshFail = 3;
        PullRefreshLoadLayout.State_Footer_Normal = 4;
        PullRefreshLoadLayout.State_Footer_Loading = 5;
        PullRefreshLoadLayout.State_Footer_ReadyToLoad = 6;
        PullRefreshLoadLayout.State_Footer_LoadFail = 7;
        PullRefreshLoadLayout.State_Footer_NoMoreToLoad = 8;
        PullRefreshLoadLayout.StateChangeLimit = {
            [PullRefreshLoadLayout.State_Header_Refreshing]: [PullRefreshLoadLayout.State_Header_ReadyToRefresh, PullRefreshLoadLayout.State_Footer_Loading,
                PullRefreshLoadLayout.State_Footer_ReadyToLoad, PullRefreshLoadLayout.State_Footer_LoadFail,
                PullRefreshLoadLayout.State_Footer_NoMoreToLoad,],
            [PullRefreshLoadLayout.State_Header_RefreshFail]: [PullRefreshLoadLayout.State_Header_ReadyToRefresh, PullRefreshLoadLayout.State_Footer_Loading,
                PullRefreshLoadLayout.State_Footer_ReadyToLoad, PullRefreshLoadLayout.State_Footer_LoadFail,
                PullRefreshLoadLayout.State_Footer_NoMoreToLoad,],
            [PullRefreshLoadLayout.State_Footer_Loading]: [PullRefreshLoadLayout.State_Header_ReadyToRefresh, PullRefreshLoadLayout.State_Header_Refreshing,
                PullRefreshLoadLayout.State_Footer_ReadyToLoad, PullRefreshLoadLayout.State_Header_RefreshFail],
            [PullRefreshLoadLayout.State_Footer_NoMoreToLoad]: [PullRefreshLoadLayout.State_Footer_ReadyToLoad]
        };
        widget.PullRefreshLoadLayout = PullRefreshLoadLayout;
        (function (PullRefreshLoadLayout) {
            class HeaderView extends FrameLayout {
                constructor(...args) {
                    super(...args);
                    this.state = PullRefreshLoadLayout.State_Header_Normal;
                    this.stateBeforeReady = PullRefreshLoadLayout.State_Header_Normal;
                }
                setStateInner(prll, state) {
                    const oldState = this.state;
                    this.state = state;
                    this.onStateChange(state, oldState);
                    const _this = this;
                    switch (state) {
                        case PullRefreshLoadLayout.State_Header_RefreshFail:
                            this.postDelayed({
                                run() {
                                    if (state === _this.state) {
                                        prll.setHeaderState(PullRefreshLoadLayout.State_Header_Normal);
                                    }
                                }
                            }, 1000);
                            break;
                        case PullRefreshLoadLayout.State_Header_ReadyToRefresh:
                            this.stateBeforeReady = oldState;
                            break;
                    }
                }
            }
            PullRefreshLoadLayout.HeaderView = HeaderView;
            class FooterView extends FrameLayout {
                constructor(...args) {
                    super(...args);
                    this.state = PullRefreshLoadLayout.State_Footer_Normal;
                    this.stateBeforeReady = PullRefreshLoadLayout.State_Footer_Normal;
                }
                setStateInner(prll, state) {
                    const oldState = this.state;
                    this.state = state;
                    this.onStateChange(state, oldState);
                    switch (state) {
                        case PullRefreshLoadLayout.State_Footer_ReadyToLoad:
                            this.stateBeforeReady = oldState;
                            break;
                    }
                }
            }
            PullRefreshLoadLayout.FooterView = FooterView;
            class DefaultHeaderView extends HeaderView {
                constructor(bindElement, rootElement) {
                    super(bindElement, rootElement);
                    this.textView = new TextView();
                    const pad = 16 * android.content.res.Resources.getDisplayMetrics().density;
                    this.textView.setPadding(pad, pad, pad, pad);
                    this.textView.setGravity(Gravity.CENTER);
                    this.addView(this.textView, -1, -2);
                    this.onStateChange(PullRefreshLoadLayout.State_Header_Normal, PullRefreshLoadLayout.State_Disable);
                }
                onStateChange(newState, oldState) {
                    switch (newState) {
                        case PullRefreshLoadLayout.State_Header_Refreshing:
                            this.textView.setText(R.string_.prll_header_state_loading);
                            break;
                        case PullRefreshLoadLayout.State_Header_ReadyToRefresh:
                            this.textView.setText(R.string_.prll_header_state_ready);
                            break;
                        case PullRefreshLoadLayout.State_Header_RefreshFail:
                            this.textView.setText(R.string_.prll_header_state_fail);
                            break;
                        default:
                            this.textView.setText(R.string_.prll_header_state_normal);
                    }
                }
            }
            PullRefreshLoadLayout.DefaultHeaderView = DefaultHeaderView;
            class DefaultFooterView extends FooterView {
                constructor(bindElement, rootElement) {
                    super(bindElement, rootElement);
                    this.textView = new TextView();
                    const pad = 16 * android.content.res.Resources.getDisplayMetrics().density;
                    this.textView.setPadding(pad, pad, pad, pad);
                    this.textView.setGravity(Gravity.CENTER);
                    this.addView(this.textView, -1, -2);
                    this.onStateChange(PullRefreshLoadLayout.State_Footer_Normal, PullRefreshLoadLayout.State_Disable);
                    this.setOnClickListener({
                        onClick(v) {
                            let parent = v.getParent();
                            if (parent instanceof PullRefreshLoadLayout) {
                                parent.setFooterState(PullRefreshLoadLayout.State_Footer_Loading);
                            }
                        }
                    });
                }
                onStateChange(newState, oldState) {
                    switch (newState) {
                        case PullRefreshLoadLayout.State_Footer_Loading:
                            this.textView.setText(R.string_.prll_footer_state_loading);
                            break;
                        case PullRefreshLoadLayout.State_Footer_ReadyToLoad:
                            this.textView.setText(R.string_.prll_footer_state_ready);
                            break;
                        case PullRefreshLoadLayout.State_Footer_LoadFail:
                            this.textView.setText(R.string_.prll_footer_state_fail);
                            break;
                        case PullRefreshLoadLayout.State_Footer_NoMoreToLoad:
                            this.textView.setText(R.string_.prll_footer_state_no_more);
                            break;
                        default:
                            this.textView.setText(R.string_.prll_footer_state_normal);
                    }
                }
            }
            PullRefreshLoadLayout.DefaultFooterView = DefaultFooterView;
        })(PullRefreshLoadLayout = widget.PullRefreshLoadLayout || (widget.PullRefreshLoadLayout = {}));
    })(widget = androidui.widget || (androidui.widget = {}));
})(androidui || (androidui = {}));
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/Gravity.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../android/widget/LinearLayout.ts"/>
///<reference path="../../android/widget/FrameLayout.ts"/>
///<reference path="../../android/widget/AbsListView.ts"/>
///<reference path="../../android/widget/ScrollView.ts"/>
///<reference path="../../android/widget/OverScroller.ts"/>
///<reference path="../../android/widget/TextView.ts"/>
///<reference path="../../android/R/string.ts"/>
///<reference path="../../java/lang/Integer.ts"/>
///<reference path="../../androidui/widget/NativeScrollView.ts"/>
var androidui;
(function (androidui) {
    var widget;
    (function (widget) {
        var NativeScrollView = androidui.widget.NativeScrollView;
        var LinearLayout = android.widget.LinearLayout;
        var FrameLayout = android.widget.FrameLayout;
        var TextView = android.widget.TextView;
        var Gravity = android.view.Gravity;
        var R = android.R;
        class PullRefreshNativeScrollView extends NativeScrollView {
            constructor(...args) {
                super(...args);
                this.contentOverY = 0;
                this.autoLoadScrollAtBottom = true;
                this.footerViewReadyDistance = 36 * android.content.res.Resources.getDisplayMetrics().density;
            }
            addView(...args) {
                args[0] = this.scrollContentWrap = new ScrollContentWrap(args[0]);
                this.headerView = this.scrollContentWrap.header;
                this.footerView = this.scrollContentWrap.footer;
                return super.addView(...args);
            }
            overScrollBy(deltaX, deltaY, scrollX, scrollY, scrollRangeX, scrollRangeY, maxOverScrollX, maxOverScrollY, isTouchEvent) {
                let newScrollY = deltaY + scrollY;
                const top = 0;
                scrollRangeY += this.scrollContentWrap.getLayoutParams().topMargin;
                const bottom = scrollRangeY - this.footerView.getHeight();
                if (newScrollY > bottom) {
                    this.contentOverY = newScrollY - bottom;
                }
                else if (newScrollY < top) {
                    this.contentOverY = newScrollY - top;
                }
                else {
                    this.contentOverY = 0;
                }
                if (this.headerView) {
                    if (this.contentOverY < -this.headerView.getHeight()) {
                        if (isTouchEvent) {
                            this.setHeaderState(PullRefreshNativeScrollView.State_Header_ReadyToRefresh);
                        }
                        else if (this.headerView.state === PullRefreshNativeScrollView.State_Header_ReadyToRefresh) {
                            this.setHeaderState(PullRefreshNativeScrollView.State_Header_Refreshing);
                        }
                    }
                    else if (this.headerView.state === PullRefreshNativeScrollView.State_Header_ReadyToRefresh) {
                        this.setHeaderState(this.headerView.stateBeforeReady);
                    }
                }
                if (this.footerView) {
                    const footerState = this.footerView.state;
                    if (this.contentOverY > this.footerView.getHeight() + this.footerViewReadyDistance) {
                        if (isTouchEvent) {
                            this.setFooterState(PullRefreshNativeScrollView.State_Footer_ReadyToLoad);
                        }
                        else if (footerState === PullRefreshNativeScrollView.State_Footer_ReadyToLoad) {
                            this.setFooterState(PullRefreshNativeScrollView.State_Footer_Loading);
                        }
                    }
                    else if (footerState === PullRefreshNativeScrollView.State_Footer_ReadyToLoad) {
                        this.setFooterState(this.footerView.stateBeforeReady);
                    }
                    if (this.contentOverY > 0 && this.autoLoadScrollAtBottom
                        && footerState === PullRefreshNativeScrollView.State_Footer_Normal) {
                        this.setFooterState(PullRefreshNativeScrollView.State_Footer_Loading);
                    }
                }
                return super.overScrollBy(deltaX, deltaY, scrollX, scrollY, scrollRangeX, scrollRangeY, maxOverScrollX, maxOverScrollY, isTouchEvent);
            }
            onTouchEvent(ev) {
                if (ev.getAction() === android.view.MotionEvent.ACTION_UP
                    && this.headerView.state === PullRefreshNativeScrollView.State_Header_ReadyToRefresh) {
                    this.setHeaderState(PullRefreshNativeScrollView.State_Header_Refreshing);
                }
                return super.onTouchEvent(ev);
            }
            setHeaderState(newState) {
                if (!this.headerView)
                    return;
                if (this.headerView.state === newState)
                    return;
                const changeLimit = PullRefreshNativeScrollView.StateChangeLimit[this.headerView.state];
                if (changeLimit && changeLimit.indexOf(newState) !== -1)
                    return;
                this.headerView.setStateInner(this, newState);
                if (newState === PullRefreshNativeScrollView.State_Header_Refreshing
                    || newState === PullRefreshNativeScrollView.State_Header_Refreshing) {
                    this.scrollContentWrap.setShowHeader(true);
                }
                else {
                    this.scrollContentWrap.setShowHeader(false);
                }
                if (newState === PullRefreshNativeScrollView.State_Header_Refreshing && this.refreshLoadListener) {
                    this.refreshLoadListener.onRefresh(this);
                }
            }
            getHeaderState() {
                if (!this.headerView)
                    return PullRefreshNativeScrollView.State_Disable;
                return this.headerView.state;
            }
            setFooterState(newState) {
                if (!this.footerView)
                    return;
                if (this.footerView.state === newState)
                    return;
                const changeLimit = PullRefreshNativeScrollView.StateChangeLimit[this.footerView.state];
                if (changeLimit && changeLimit.indexOf(newState) !== -1)
                    return;
                this.footerView.setStateInner(this, newState);
                if (newState === PullRefreshNativeScrollView.State_Footer_Loading && this.refreshLoadListener) {
                    this.refreshLoadListener.onLoadMore(this);
                }
            }
            getFooterState() {
                if (!this.footerView)
                    return PullRefreshNativeScrollView.State_Disable;
                return this.footerView.state;
            }
            setAutoLoadMoreWhenScrollBottom(autoLoad) {
                this.autoLoadScrollAtBottom = autoLoad;
            }
            setRefreshLoadListener(refreshLoadListener) {
                this.refreshLoadListener = refreshLoadListener;
            }
            startRefresh() {
                this.setHeaderState(PullRefreshNativeScrollView.State_Header_Refreshing);
            }
            startLoadMore() {
                this.setFooterState(PullRefreshNativeScrollView.State_Footer_Loading);
            }
        }
        PullRefreshNativeScrollView.State_Disable = -1;
        PullRefreshNativeScrollView.State_Header_Normal = 0;
        PullRefreshNativeScrollView.State_Header_Refreshing = 1;
        PullRefreshNativeScrollView.State_Header_ReadyToRefresh = 2;
        PullRefreshNativeScrollView.State_Header_RefreshFail = 3;
        PullRefreshNativeScrollView.State_Footer_Normal = 4;
        PullRefreshNativeScrollView.State_Footer_Loading = 5;
        PullRefreshNativeScrollView.State_Footer_ReadyToLoad = 6;
        PullRefreshNativeScrollView.State_Footer_LoadFail = 7;
        PullRefreshNativeScrollView.State_Footer_NoMoreToLoad = 8;
        PullRefreshNativeScrollView.StateChangeLimit = {
            [PullRefreshNativeScrollView.State_Header_Refreshing]: [PullRefreshNativeScrollView.State_Header_ReadyToRefresh, PullRefreshNativeScrollView.State_Footer_Loading,
                PullRefreshNativeScrollView.State_Footer_ReadyToLoad, PullRefreshNativeScrollView.State_Footer_LoadFail,
                PullRefreshNativeScrollView.State_Footer_NoMoreToLoad,],
            [PullRefreshNativeScrollView.State_Header_RefreshFail]: [PullRefreshNativeScrollView.State_Header_ReadyToRefresh, PullRefreshNativeScrollView.State_Footer_Loading,
                PullRefreshNativeScrollView.State_Footer_ReadyToLoad, PullRefreshNativeScrollView.State_Footer_LoadFail,
                PullRefreshNativeScrollView.State_Footer_NoMoreToLoad,],
            [PullRefreshNativeScrollView.State_Footer_Loading]: [PullRefreshNativeScrollView.State_Header_ReadyToRefresh, PullRefreshNativeScrollView.State_Header_Refreshing,
                PullRefreshNativeScrollView.State_Footer_ReadyToLoad, PullRefreshNativeScrollView.State_Header_RefreshFail],
            [PullRefreshNativeScrollView.State_Footer_NoMoreToLoad]: [PullRefreshNativeScrollView.State_Footer_ReadyToLoad]
        };
        widget.PullRefreshNativeScrollView = PullRefreshNativeScrollView;
        class ScrollContentWrap extends LinearLayout {
            constructor(content, bindElement, rootElement) {
                super(bindElement, rootElement);
                this.isShowHeader = false;
                this.setOrientation(LinearLayout.VERTICAL);
                this.addView(this.header = new Header());
                this.addView(content);
                this.addView(this.footer = new Footer());
            }
            measure(widthMeasureSpec, heightMeasureSpec) {
                super.measure(widthMeasureSpec, heightMeasureSpec);
                if (this.isShowHeader) {
                    this.getLayoutParams().topMargin = 0;
                }
                else {
                    this.getLayoutParams().topMargin = -this.header.getMeasuredHeight();
                }
            }
            setShowHeader(enable) {
                if (this.isShowHeader === enable)
                    return;
                this.isShowHeader = enable;
                this.requestLayout();
                this.bindElement.style.transition = 'transform 0.2s ease-out';
                this.bindElement.style.webkitTransition = '-webkit-transform 0.2s ease-out';
            }
        }
        class Header extends FrameLayout {
            constructor(bindElement, rootElement) {
                super(bindElement, rootElement);
                this.state = PullRefreshNativeScrollView.State_Header_Normal;
                this.stateBeforeReady = PullRefreshNativeScrollView.State_Header_Normal;
                this.textView = new TextView();
                const pad = 16 * android.content.res.Resources.getDisplayMetrics().density;
                this.textView.setPadding(pad, pad, pad, pad);
                this.textView.setGravity(Gravity.CENTER);
                this.addView(this.textView, -1, -2);
                this.onStateChange(PullRefreshNativeScrollView.State_Header_Normal);
            }
            setStateInner(prScroll, state) {
                const oldState = this.state;
                this.state = state;
                this.onStateChange(state, oldState);
                const _this = this;
                switch (state) {
                    case PullRefreshNativeScrollView.State_Header_RefreshFail:
                        this.postDelayed({
                            run() {
                                if (state === _this.state) {
                                    prScroll.setHeaderState(PullRefreshNativeScrollView.State_Header_Normal);
                                }
                            }
                        }, 1000);
                        break;
                    case PullRefreshNativeScrollView.State_Header_ReadyToRefresh:
                        this.stateBeforeReady = oldState;
                        break;
                }
            }
            onStateChange(newState, oldState = PullRefreshNativeScrollView.State_Disable) {
                switch (newState) {
                    case PullRefreshNativeScrollView.State_Header_Refreshing:
                        this.textView.setText(R.string_.prll_header_state_loading);
                        break;
                    case PullRefreshNativeScrollView.State_Header_ReadyToRefresh:
                        this.textView.setText(R.string_.prll_header_state_ready);
                        break;
                    case PullRefreshNativeScrollView.State_Header_RefreshFail:
                        this.textView.setText(R.string_.prll_header_state_fail);
                        break;
                    default:
                        this.textView.setText(R.string_.prll_header_state_normal);
                }
            }
        }
        class Footer extends FrameLayout {
            constructor(bindElement, rootElement) {
                super(bindElement, rootElement);
                this.state = PullRefreshNativeScrollView.State_Footer_Normal;
                this.stateBeforeReady = PullRefreshNativeScrollView.State_Footer_Normal;
                this.textView = new TextView();
                const pad = 16 * android.content.res.Resources.getDisplayMetrics().density;
                this.textView.setPadding(pad, pad, pad, pad);
                this.textView.setGravity(Gravity.CENTER);
                this.addView(this.textView, -1, -2);
                this.onStateChange(PullRefreshNativeScrollView.State_Footer_Normal);
            }
            setStateInner(prScroll, state) {
                const oldState = this.state;
                this.state = state;
                this.onStateChange(state, oldState);
                const _this = this;
                switch (state) {
                    case PullRefreshNativeScrollView.State_Footer_ReadyToLoad:
                        this.stateBeforeReady = oldState;
                        break;
                }
            }
            onStateChange(newState, oldState = PullRefreshNativeScrollView.State_Disable) {
                switch (newState) {
                    case PullRefreshNativeScrollView.State_Footer_Loading:
                        this.textView.setText(R.string_.prll_footer_state_loading);
                        break;
                    case PullRefreshNativeScrollView.State_Footer_ReadyToLoad:
                        this.textView.setText(R.string_.prll_footer_state_ready);
                        break;
                    case PullRefreshNativeScrollView.State_Footer_LoadFail:
                        this.textView.setText(R.string_.prll_footer_state_fail);
                        break;
                    case PullRefreshNativeScrollView.State_Footer_NoMoreToLoad:
                        this.textView.setText(R.string_.prll_footer_state_no_more);
                        break;
                    default:
                        this.textView.setText(R.string_.prll_footer_state_normal);
                }
            }
        }
    })(widget = androidui.widget || (androidui.widget = {}));
})(androidui || (androidui = {}));
/**
 * Created by linfaxin on 15/10/6.
 */
//use the deepest sub class as enter
///<reference path="android/view/ViewOverlay.ts"/>
///<reference path="android/view/GestureDetector.ts"/>
///<reference path="android/widget/FrameLayout.ts"/>
///<reference path="android/widget/ScrollView.ts"/>
///<reference path="android/widget/LinearLayout.ts"/>
///<reference path="android/widget/TextView.ts"/>
///<reference path="android/widget/Button.ts"/>
///<reference path="android/widget/ImageView.ts"/>
///<reference path="android/widget/ImageButton.ts"/>
///<reference path="android/widget/ListView.ts"/>
///<reference path="android/widget/GridView.ts"/>
///<reference path="android/widget/HorizontalScrollView.ts"/>
///<reference path="android/widget/NumberPicker.ts"/>
///<reference path="android/text/Layout.ts"/>
///<reference path="android/text/BoringLayout.ts"/>
///<reference path="android/text/StaticLayout.ts"/>
///<reference path="android/text/style/MetricAffectingSpan.ts"/>
///<reference path="android/support/v4/view/ViewPager.ts"/>
///<reference path="android/support/v4/widget/ViewDragHelper.ts"/>
///<reference path="lib/com/jakewharton/salvage/RecyclingPagerAdapter.ts"/>
///<reference path="android/app/Activity.ts"/>
///<reference path="androidui/AndroidUI.ts"/>
///<reference path="androidui/widget/HtmlView.ts"/>
///<reference path="androidui/widget/HtmlImageView.ts"/>
///<reference path="androidui/widget/HtmlDataListAdapter.ts"/>
///<reference path="androidui/widget/HtmlDataPagerAdapter.ts"/>
///<reference path="androidui/widget/HtmlDataPickerAdapter.ts"/>
///<reference path="androidui/widget/PullRefreshLoadLayout.ts"/>
///<reference path="androidui/widget/NativeScrollView.ts"/>
///<reference path="androidui/widget/PullRefreshNativeScrollView.ts"/>
///<reference path="androidui/util/PerformanceAdjuster.ts"/>
window[`android`] = android;
window[`java`] = java;
window[`AndroidUI`] = androidui.AndroidUI;
window.dispatchEvent(new CustomEvent("AndroidUILoadFinish"));
