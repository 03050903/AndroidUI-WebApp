var android;
(function (android) {
    var util;
    (function (util) {
        class SparseArray {
            constructor(initialCapacity) {
                this.map = new Map();
            }
            clone() {
                let clone = new SparseArray();
                clone.map = new Map(this.map);
                return clone;
            }
            get(key, valueIfKeyNotFound = null) {
                let value = this.map.get(key);
                if (value === undefined)
                    return valueIfKeyNotFound;
                return value;
            }
            delete(key) {
                this.map.delete(key);
            }
            remove(key) {
                this.delete(key);
            }
            removeAt(index) {
                this.removeAtRange(index);
            }
            removeAtRange(index, size = 1) {
                let keys = [...this.map.keys()];
                let end = Math.min(this.map.size, index + size);
                for (let i = index; i < end; i++) {
                    this.map.delete(keys[i]);
                }
            }
            put(key, value) {
                this.map.set(key, value);
            }
            size() {
                return this.map.size;
            }
            keyAt(index) {
                return [...this.map.keys()][index];
            }
            valueAt(index) {
                return [...this.map.values()][index];
            }
            setValueAt(index, value) {
                let key = this.keyAt(index);
                this.map.set(key, value);
            }
            indexOfKey(key) {
                return [...this.map.keys()].indexOf(key);
            }
            indexOfValue(value) {
                return [...this.map.values()].indexOf(value);
            }
            clear() {
                this.map.clear();
            }
            append(key, value) {
                this.put(key, value);
            }
        }
        util.SparseArray = SparseArray;
    })(util = android.util || (android.util = {}));
})(android || (android = {}));
var android;
(function (android) {
    var util;
    (function (util) {
        class Log {
            static getPriorityString(priority) {
                if (priority > Log.PriorityString.length)
                    return "";
                return Log.PriorityString[priority - 2];
            }
            static v(tag, msg, tr) {
                console.log(Log.getLogMsg(Log.VERBOSE, tag, msg));
                if (tr)
                    console.log(tr);
            }
            static d(tag, msg) {
                console.debug(Log.getLogMsg(Log.DEBUG, tag, msg));
            }
            static i(tag, msg, tr) {
                console.info(Log.getLogMsg(Log.INFO, tag, msg));
                if (tr)
                    console.info(tr);
            }
            static w(tag, msg, tr) {
                console.warn(Log.getLogMsg(Log.WARN, tag, msg));
                if (tr)
                    console.warn(tr);
            }
            static e(tag, msg, tr) {
                console.error(Log.getLogMsg(Log.ERROR, tag, msg));
                if (tr)
                    console.error(tr);
            }
            static getLogMsg(priority, tag, msg) {
                let d = new Date();
                let dateFormat = d.toLocaleTimeString() + '.' + d.getUTCMilliseconds();
                return "[" + Log.getPriorityString(priority) + "] " + dateFormat + " \t " + tag + " \t " + msg;
            }
        }
        Log.View_DBG = false;
        Log.VelocityTracker_DBG = false;
        Log.DBG_DrawableContainer = false;
        Log.DBG_StateListDrawable = false;
        Log.VERBOSE = 2;
        Log.DEBUG = 3;
        Log.INFO = 4;
        Log.WARN = 5;
        Log.ERROR = 6;
        Log.ASSERT = 7;
        Log.PriorityString = ["VERBOSE", "DEBUG", "INFO", "WARN", "ERROR", "ASSERT"];
        util.Log = Log;
    })(util = android.util || (android.util = {}));
})(android || (android = {}));
var java;
(function (java) {
    var lang;
    (function (lang) {
        class StringBuilder {
            constructor(arg) {
                this.array = [];
                if (!Number.isInteger(arg) && arg) {
                    this.append(arg);
                }
            }
            length() {
                return this.array.length;
            }
            append(str) {
                str = str + "";
                this.array.push(...str.split(''));
                return this;
            }
            setLength(length) {
                let arrayLength = this.array.length;
                if (length === arrayLength)
                    return;
                if (length < arrayLength) {
                    this.array = this.array.splice(length, arrayLength - length);
                }
                else {
                    for (let i = 0; i < arrayLength - length; i++) {
                        this.array.push(' ');
                    }
                }
            }
            toString() {
                return this.array.join("");
            }
        }
        lang.StringBuilder = StringBuilder;
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
///<reference path="../../java/lang/StringBuilder.ts"/>
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        var StringBuilder = java.lang.StringBuilder;
        class Rect {
            constructor(...args) {
                this.left = 0;
                this.top = 0;
                this.right = 0;
                this.bottom = 0;
                if (args.length === 1) {
                    let rect = args[0];
                    this.left = rect.left;
                    this.top = rect.top;
                    this.right = rect.right;
                    this.bottom = rect.bottom;
                }
                else if (args.length === 4 || args.length === 0) {
                    let [left = 0, top = 0, right = 0, bottom = 0] = args;
                    this.left = left;
                    this.top = top;
                    this.right = right;
                    this.bottom = bottom;
                }
            }
            equals(r) {
                if (this === r)
                    return true;
                if (!r || !(r instanceof Rect))
                    return false;
                return this.left === r.left && this.top === r.top
                    && this.right === r.right && this.bottom === r.bottom;
            }
            toString() {
                let sb = new StringBuilder();
                sb.append("Rect(");
                sb.append(this.left);
                sb.append(", ");
                sb.append(this.top);
                sb.append(" - ");
                sb.append(this.right);
                sb.append(", ");
                sb.append(this.bottom);
                sb.append(")");
                return sb.toString();
            }
            toShortString(sb = new StringBuilder()) {
                sb.setLength(0);
                sb.append('[');
                sb.append(this.left);
                sb.append(',');
                sb.append(this.top);
                sb.append("][");
                sb.append(this.right);
                sb.append(',');
                sb.append(this.bottom);
                sb.append(']');
                return sb.toString();
            }
            flattenToString() {
                let sb = new StringBuilder(32);
                sb.append(this.left);
                sb.append(' ');
                sb.append(this.top);
                sb.append(' ');
                sb.append(this.right);
                sb.append(' ');
                sb.append(this.bottom);
                return sb.toString();
            }
            static unflattenFromString(str) {
                let parts = str.split(" ");
                return new Rect(Number.parseInt(parts[0]), Number.parseInt(parts[1]), Number.parseInt(parts[2]), Number.parseInt(parts[3]));
            }
            isEmpty() {
                return this.left >= this.right || this.top >= this.bottom;
            }
            width() {
                return this.right - this.left;
            }
            height() {
                return this.bottom - this.top;
            }
            centerX() {
                return (this.left + this.right) >> 1;
            }
            centerY() {
                return (this.top + this.bottom) >> 1;
            }
            exactCenterX() {
                return (this.left + this.right) * 0.5;
            }
            exactCenterY() {
                return (this.top + this.bottom) * 0.5;
            }
            setEmpty() {
                this.left = this.right = this.top = this.bottom = 0;
            }
            set(...args) {
                if (args.length === 1) {
                    let rect = args[0];
                    [this.left, this.top, this.right, this.bottom] = [rect.left, rect.top, rect.right, rect.bottom];
                }
                else {
                    let [left = 0, top = 0, right = 0, bottom = 0] = args;
                    this.left = left;
                    this.top = top;
                    this.right = right;
                    this.bottom = bottom;
                }
            }
            offset(dx, dy) {
                this.left += dx;
                this.top += dy;
                this.right += dx;
                this.bottom += dy;
            }
            offsetTo(newLeft, newTop) {
                this.right += newLeft - this.left;
                this.bottom += newTop - this.top;
                this.left = newLeft;
                this.top = newTop;
            }
            inset(dx, dy) {
                this.left += dx;
                this.top += dy;
                this.right -= dx;
                this.bottom -= dy;
            }
            contains(...args) {
                if (args.length === 1) {
                    let r = args[0];
                    return this.left < this.right && this.top < this.bottom
                        && this.left <= r.left && this.top <= r.top && this.right >= r.right && this.bottom >= r.bottom;
                }
                else if (args.length === 2) {
                    let [x, y] = args;
                    return this.left < this.right && this.top < this.bottom
                        && x >= this.left && x < this.right && y >= this.top && y < this.bottom;
                }
                else {
                    let [left = 0, top = 0, right = 0, bottom = 0] = args;
                    return this.left < this.right && this.top < this.bottom
                        && this.left <= left && this.top <= top
                        && this.right >= right && this.bottom >= bottom;
                }
            }
            intersect(...args) {
                if (args.length === 1) {
                    let rect = args[0];
                    return this.intersect(rect.left, rect.top, rect.right, rect.bottom);
                }
                else {
                    let [left = 0, t = 0, right = 0, bottom = 0] = args;
                    if (this.left < right && left < this.right && this.top < bottom && t < this.bottom) {
                        if (this.left < left)
                            this.left = left;
                        if (this.top < t)
                            this.top = t;
                        if (this.right > right)
                            this.right = right;
                        if (this.bottom > bottom)
                            this.bottom = bottom;
                        return true;
                    }
                    return false;
                }
            }
            intersects(...args) {
                if (args.length === 1) {
                    let rect = args[0];
                    return this.intersects(rect.left, rect.top, rect.right, rect.bottom);
                }
                else {
                    let [left = 0, t = 0, right = 0, bottom = 0] = args;
                    return this.left < right && left < this.right && this.top < bottom && t < this.bottom;
                }
            }
            union(...args) {
                if (arguments.length === 1) {
                    let rect = args[0];
                    this.union(rect.left, rect.top, rect.right, rect.bottom);
                }
                else if (arguments.length === 2) {
                    let [x = 0, y = 0] = args;
                    if (x < this.left) {
                        this.left = x;
                    }
                    else if (x > this.right) {
                        this.right = x;
                    }
                    if (y < this.top) {
                        this.top = y;
                    }
                    else if (y > this.bottom) {
                        this.bottom = y;
                    }
                }
                else {
                    let [left = 0, top = 0, right = 0, bottom = 0] = args;
                    if ((left < right) && (top < bottom)) {
                        if ((this.left < this.right) && (this.top < this.bottom)) {
                            if (this.left > left)
                                this.left = left;
                            if (this.top > top)
                                this.top = top;
                            if (this.right < right)
                                this.right = right;
                            if (this.bottom < bottom)
                                this.bottom = bottom;
                        }
                        else {
                            this.left = left;
                            this.top = top;
                            this.right = right;
                            this.bottom = bottom;
                        }
                    }
                }
            }
            sort() {
                if (this.left > this.right) {
                    [this.left, this.right] = [this.right, this.left];
                }
                if (this.top > this.bottom) {
                    [this.top, this.bottom] = [this.bottom, this.top];
                }
            }
            scale(scale) {
                if (scale != 1) {
                    this.left = this.left * scale;
                    this.top = this.top * scale;
                    this.right = this.right * scale;
                    this.bottom = this.bottom * scale;
                }
            }
        }
        graphics.Rect = Rect;
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        class PixelFormat {
        }
        PixelFormat.UNKNOWN = 0;
        PixelFormat.TRANSLUCENT = -3;
        PixelFormat.TRANSPARENT = -2;
        PixelFormat.OPAQUE = -1;
        PixelFormat.RGBA_8888 = 1;
        PixelFormat.RGBX_8888 = 2;
        PixelFormat.RGB_888 = 3;
        PixelFormat.RGB_565 = 4;
        graphics.PixelFormat = PixelFormat;
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
var java;
(function (java) {
    var lang;
    (function (lang) {
        var ref;
        (function (ref) {
            class WeakReference {
                constructor(referent) {
                    this.weakMap = new WeakMap();
                    this.weakMap.set(this, referent);
                }
                get() {
                    return this.weakMap.get(this);
                }
                set(value) {
                    this.weakMap.set(this, value);
                }
                clear() {
                    this.weakMap.delete(this);
                }
            }
            ref.WeakReference = WeakReference;
        })(ref = lang.ref || (lang.ref = {}));
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
var java;
(function (java) {
    var lang;
    (function (lang) {
        class System {
            static currentTimeMillis() {
                return new Date().getTime();
            }
            static arraycopy(src, srcPos, dest, destPos, length) {
                let srcLength = src.length;
                let destLength = dest.length;
                for (let i = 0; i < length; i++) {
                    let srcIndex = i + srcPos;
                    if (srcIndex >= srcLength)
                        return;
                    let destIndex = i + destPos;
                    if (destIndex >= destLength)
                        return;
                    dest[destIndex] = src[srcIndex];
                }
            }
        }
        System.out = {
            println(any) {
                console.log('\n');
                console.log(any);
            },
            print(any) {
                console.log(any);
            }
        };
        lang.System = System;
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
/**
 * Created by linfaxin on 15/10/29.
 */
///<reference path="../../java/lang/System.ts"/>
var android;
(function (android) {
    var util;
    (function (util) {
        var System = java.lang.System;
        class StateSet {
            static isWildCard(stateSetOrSpec) {
                return stateSetOrSpec.length == 0 || stateSetOrSpec[0] == 0;
            }
            static stateSetMatches(stateSpec, stateSetOrState) {
                if (Number.isInteger(stateSetOrState)) {
                    return StateSet._stateSetMatches_single(stateSpec, stateSetOrState);
                }
                let stateSet = stateSetOrState;
                if (stateSet == null) {
                    return (stateSpec == null || this.isWildCard(stateSpec));
                }
                let stateSpecSize = stateSpec.length;
                let stateSetSize = stateSet.length;
                for (let i = 0; i < stateSpecSize; i++) {
                    let stateSpecState = stateSpec[i];
                    if (stateSpecState == 0) {
                        return true;
                    }
                    let mustMatch;
                    if (stateSpecState > 0) {
                        mustMatch = true;
                    }
                    else {
                        mustMatch = false;
                        stateSpecState = -stateSpecState;
                    }
                    let found = false;
                    for (let j = 0; j < stateSetSize; j++) {
                        const state = stateSet[j];
                        if (state == 0) {
                            if (mustMatch) {
                                return false;
                            }
                            else {
                                break;
                            }
                        }
                        if (state == stateSpecState) {
                            if (mustMatch) {
                                found = true;
                                break;
                            }
                            else {
                                return false;
                            }
                        }
                    }
                    if (mustMatch && !found) {
                        return false;
                    }
                }
                return true;
            }
            static _stateSetMatches_single(stateSpec, state) {
                let stateSpecSize = stateSpec.length;
                for (let i = 0; i < stateSpecSize; i++) {
                    let stateSpecState = stateSpec[i];
                    if (stateSpecState == 0) {
                        return true;
                    }
                    if (stateSpecState > 0) {
                        if (state != stateSpecState) {
                            return false;
                        }
                    }
                    else {
                        if (state == -stateSpecState) {
                            return false;
                        }
                    }
                }
                return true;
            }
            static trimStateSet(states, newSize) {
                if (states.length == newSize) {
                    return states;
                }
                let trimmedStates = new Array(newSize);
                System.arraycopy(states, 0, trimmedStates, 0, newSize);
                return trimmedStates;
            }
        }
        StateSet.WILD_CARD = [];
        StateSet.NOTHING = [0];
        util.StateSet = StateSet;
    })(util = android.util || (android.util = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/3.
 */
///<reference path="../Rect.ts"/>
///<reference path="../PixelFormat.ts"/>
///<reference path="../../../java/lang/ref/WeakReference.ts"/>
///<reference path="../../../java/lang/Runnable.ts"/>
///<reference path="../../util/StateSet.ts"/>
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        var drawable;
        (function (drawable) {
            var Rect = android.graphics.Rect;
            var PixelFormat = android.graphics.PixelFormat;
            var WeakReference = java.lang.ref.WeakReference;
            var StateSet = android.util.StateSet;
            class Drawable {
                constructor() {
                    this.mBounds = Drawable.ZERO_BOUNDS_RECT;
                    this.mStateSet = StateSet.WILD_CARD;
                    this.mLevel = 0;
                    this.mVisible = true;
                }
                draw(canvas) {
                }
                setBounds(...args) {
                    if (args.length === 1) {
                        let rect = args[0];
                        return this.setBounds(rect.left, rect.top, rect.right, rect.bottom);
                    }
                    else {
                        let [left = 0, top = 0, right = 0, bottom = 0] = args;
                        let oldBounds = this.mBounds;
                        if (oldBounds == Drawable.ZERO_BOUNDS_RECT) {
                            oldBounds = this.mBounds = new Rect();
                        }
                        if (oldBounds.left != left || oldBounds.top != top ||
                            oldBounds.right != right || oldBounds.bottom != bottom) {
                            if (!oldBounds.isEmpty()) {
                                this.invalidateSelf();
                            }
                            this.mBounds.set(left, top, right, bottom);
                            this.onBoundsChange(this.mBounds);
                        }
                    }
                }
                copyBounds(bounds = new Rect()) {
                    bounds.set(this.mBounds);
                    return bounds;
                }
                getBounds() {
                    if (this.mBounds == Drawable.ZERO_BOUNDS_RECT) {
                        this.mBounds = new Rect();
                    }
                    return this.mBounds;
                }
                setDither(dither) { }
                setCallback(cb) {
                    this.mCallback = new WeakReference(cb);
                }
                getCallback() {
                    if (this.mCallback != null) {
                        return this.mCallback.get();
                    }
                    return null;
                }
                invalidateSelf() {
                    let callback = this.getCallback();
                    if (callback != null) {
                        callback.invalidateDrawable(this);
                    }
                }
                scheduleSelf(what, when) {
                    let callback = this.getCallback();
                    if (callback != null) {
                        callback.scheduleDrawable(this, what, when);
                    }
                }
                unscheduleSelf(what) {
                    let callback = this.getCallback();
                    if (callback != null) {
                        callback.unscheduleDrawable(this, what);
                    }
                }
                setAlpha(alpha) {
                }
                getAlpha() {
                    return 0xFF;
                }
                isStateful() {
                    return false;
                }
                setState(stateSet) {
                    if (this.mStateSet + '' !== stateSet + '') {
                        this.mStateSet = stateSet;
                        return this.onStateChange(stateSet);
                    }
                    return false;
                }
                getState() {
                    return this.mStateSet;
                }
                jumpToCurrentState() {
                }
                getCurrent() {
                    return this;
                }
                setLevel(level) {
                    if (this.mLevel != level) {
                        this.mLevel = level;
                        return this.onLevelChange(level);
                    }
                    return false;
                }
                getLevel() {
                    return this.mLevel;
                }
                setVisible(visible, restart) {
                    let changed = this.mVisible != visible;
                    if (changed) {
                        this.mVisible = visible;
                        this.invalidateSelf();
                    }
                    return changed;
                }
                isVisible() {
                    return this.mVisible;
                }
                setAutoMirrored(mirrored) {
                }
                isAutoMirrored() {
                    return false;
                }
                getOpacity() {
                    return PixelFormat.TRANSLUCENT;
                }
                static resolveOpacity(op1, op2) {
                    if (op1 == op2) {
                        return op1;
                    }
                    if (op1 == PixelFormat.UNKNOWN || op2 == PixelFormat.UNKNOWN) {
                        return PixelFormat.UNKNOWN;
                    }
                    if (op1 == PixelFormat.TRANSLUCENT || op2 == PixelFormat.TRANSLUCENT) {
                        return PixelFormat.TRANSLUCENT;
                    }
                    if (op1 == PixelFormat.TRANSPARENT || op2 == PixelFormat.TRANSPARENT) {
                        return PixelFormat.TRANSPARENT;
                    }
                    return PixelFormat.OPAQUE;
                }
                onStateChange(state) {
                    return false;
                }
                onLevelChange(level) {
                    return false;
                }
                onBoundsChange(bounds) {
                }
                getIntrinsicWidth() {
                    return -1;
                }
                getIntrinsicHeight() {
                    return -1;
                }
                getMinimumWidth() {
                    let intrinsicWidth = this.getIntrinsicWidth();
                    return intrinsicWidth > 0 ? intrinsicWidth : 0;
                }
                getMinimumHeight() {
                    let intrinsicHeight = this.getIntrinsicHeight();
                    return intrinsicHeight > 0 ? intrinsicHeight : 0;
                }
                getPadding(padding) {
                    padding.set(0, 0, 0, 0);
                    return false;
                }
                mutate() {
                    return this;
                }
                getConstantState() {
                    return null;
                }
            }
            Drawable.ZERO_BOUNDS_RECT = new Rect();
            drawable.Drawable = Drawable;
        })(drawable = graphics.drawable || (graphics.drawable = {}));
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
var android;
(function (android) {
    var util;
    (function (util) {
        class Pools {
        }
        util.Pools = Pools;
        (function (Pools) {
            class SimplePool {
                constructor(maxPoolSize) {
                    this.mPoolSize = 0;
                    if (maxPoolSize <= 0) {
                        throw new Error("The max pool size must be > 0");
                    }
                    this.mPool = new Array(maxPoolSize);
                }
                acquire() {
                    if (this.mPoolSize > 0) {
                        const lastPooledIndex = this.mPoolSize - 1;
                        let instance = this.mPool[lastPooledIndex];
                        this.mPool[lastPooledIndex] = null;
                        this.mPoolSize--;
                        return instance;
                    }
                    return null;
                }
                release(instance) {
                    if (this.isInPool(instance)) {
                        throw new Error("Already in the pool!");
                    }
                    if (this.mPoolSize < this.mPool.length) {
                        this.mPool[this.mPoolSize] = instance;
                        this.mPoolSize++;
                        return true;
                    }
                    return false;
                }
                isInPool(instance) {
                    for (let i = 0; i < this.mPoolSize; i++) {
                        if (this.mPool[i] == instance) {
                            return true;
                        }
                    }
                    return false;
                }
            }
            Pools.SimplePool = SimplePool;
            class SynchronizedPool extends SimplePool {
            }
            Pools.SynchronizedPool = SynchronizedPool;
        })(Pools = util.Pools || (util.Pools = {}));
    })(util = android.util || (android.util = {}));
})(android || (android = {}));
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        class Color {
            static alpha(color) {
                return color >>> 24;
            }
            static red(color) {
                return (color >> 16) & 0xFF;
            }
            static green(color) {
                return (color >> 8) & 0xFF;
            }
            static blue(color) {
                return color & 0xFF;
            }
            static rgb(red, green, blue) {
                return (0xFF << 24) | (red << 16) | (green << 8) | blue;
            }
            static argb(alpha, red, green, blue) {
                return (alpha << 24) | (red << 16) | (green << 8) | blue;
            }
            static rgba(red, green, blue, alpha) {
                return (alpha << 24) | (red << 16) | (green << 8) | blue;
            }
            static parseColor(colorString) {
                if (colorString.charAt(0) == '#') {
                    let color = parseInt(colorString.substring(1), 16);
                    if (colorString.length == 7) {
                        color |= 0x00000000ff000000;
                    }
                    else if (colorString.length != 9) {
                        throw new Error("Unknown color");
                    }
                    return color;
                }
                else {
                    let color = Color.sColorNameMap.get(colorString.toLowerCase());
                    if (color != null) {
                        return color;
                    }
                }
                throw new Error("Unknown color");
            }
            static toRGBA(color) {
                let r = Color.red(color);
                let g = Color.green(color);
                let b = Color.blue(color);
                let a = Color.alpha(color);
                let hR = r < 16 ? '0' + r.toString(16) : r.toString(16);
                let hG = g < 16 ? '0' + g.toString(16) : g.toString(16);
                let hB = b < 16 ? '0' + b.toString(16) : b.toString(16);
                let hA = a < 16 ? '0' + a.toString(16) : a.toString(16);
                return "#" + hA + hR + hG + hB;
            }
            static getHtmlColor(color) {
                let i = Color.sColorNameMap.get(color.toLowerCase());
                return i;
            }
        }
        Color.BLACK = 0xFF000000;
        Color.DKGRAY = 0xFF444444;
        Color.GRAY = 0xFF888888;
        Color.LTGRAY = 0xFFCCCCCC;
        Color.WHITE = 0xFFFFFFFF;
        Color.RED = 0xFFFF0000;
        Color.GREEN = 0xFF00FF00;
        Color.BLUE = 0xFF0000FF;
        Color.YELLOW = 0xFFFFFF00;
        Color.CYAN = 0xFF00FFFF;
        Color.MAGENTA = 0xFFFF00FF;
        Color.TRANSPARENT = 0;
        Color.sColorNameMap = new Map();
        graphics.Color = Color;
        Color.sColorNameMap = new Map();
        Color.sColorNameMap.set("black", Color.BLACK);
        Color.sColorNameMap.set("darkgray", Color.DKGRAY);
        Color.sColorNameMap.set("gray", Color.GRAY);
        Color.sColorNameMap.set("lightgray", Color.LTGRAY);
        Color.sColorNameMap.set("white", Color.WHITE);
        Color.sColorNameMap.set("red", Color.RED);
        Color.sColorNameMap.set("green", Color.GREEN);
        Color.sColorNameMap.set("blue", Color.BLUE);
        Color.sColorNameMap.set("yellow", Color.YELLOW);
        Color.sColorNameMap.set("cyan", Color.CYAN);
        Color.sColorNameMap.set("magenta", Color.MAGENTA);
        Color.sColorNameMap.set("aqua", 0xFF00FFFF);
        Color.sColorNameMap.set("fuchsia", 0xFFFF00FF);
        Color.sColorNameMap.set("darkgrey", Color.DKGRAY);
        Color.sColorNameMap.set("grey", Color.GRAY);
        Color.sColorNameMap.set("lightgrey", Color.LTGRAY);
        Color.sColorNameMap.set("lime", 0xFF00FF00);
        Color.sColorNameMap.set("maroon", 0xFF800000);
        Color.sColorNameMap.set("navy", 0xFF000080);
        Color.sColorNameMap.set("olive", 0xFF808000);
        Color.sColorNameMap.set("purple", 0xFF800080);
        Color.sColorNameMap.set("silver", 0xFFC0C0C0);
        Color.sColorNameMap.set("teal", 0xFF008080);
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/29.
 */
///<reference path="Canvas.ts"/>
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        class Paint {
            getColor() {
                return this.mColor;
            }
            setColor(color) {
                this.mColor = color;
            }
            getAlpha() {
                return this.mAlpha;
            }
            setAlpha(alpha) {
                this.mAlpha = alpha;
            }
            _setToCanvasContent(context) {
                if (Number.isInteger(this.mColor)) {
                    let r = graphics.Color.red(this.mColor);
                    let g = graphics.Color.green(this.mColor);
                    let b = graphics.Color.blue(this.mColor);
                    let a = graphics.Color.alpha(this.mColor);
                    context.fillStyle = `rgba(${r},${g},${b},${a / 255})`;
                }
            }
        }
        graphics.Paint = Paint;
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
///<reference path="../util/Pools.ts"/>
///<reference path="../util/Log.ts"/>
///<reference path="Rect.ts"/>
///<reference path="Color.ts"/>
///<reference path="Paint.ts"/>
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        var Pools = android.util.Pools;
        var Rect = android.graphics.Rect;
        var Color = android.graphics.Color;
        class Canvas {
            constructor(...args) {
                this._saveCount = 0;
                this.shouldDoRectBeforeRestoreMap = new Map();
                this.mClipStateMap = new Map();
                this.mCanvasElement = args.length === 1 ? args[0] : document.createElement("canvas");
                if (args.length === 1) {
                    this.mCanvasElement = args[0];
                }
                else if (args.length === 2) {
                    this.mCanvasElement = document.createElement("canvas");
                    this.mCanvasElement.width = args[0];
                    this.mCanvasElement.height = args[1];
                }
                this.init();
            }
            init() {
                this._mCanvasContent = this.mCanvasElement.getContext("2d");
                this.mCurrentClip = new Rect(0, 0, this.mCanvasElement.width, this.mCanvasElement.height);
                this._saveCount = 0;
                this.fullRectForClip();
                this._mCanvasContent.clip();
                this.save();
            }
            get canvasElement() {
                return this.mCanvasElement;
            }
            getHeight() {
                return this.mCanvasElement.height;
            }
            getWidth() {
                return this.mCanvasElement.width;
            }
            translate(dx, dy) {
                if (this.mCurrentClip)
                    this.mCurrentClip.offset(-dx, -dy);
                this._mCanvasContent.translate(dx, dy);
            }
            scale(sx, sy, px, py) {
                if (px && py)
                    this.translate(px, py);
                this._mCanvasContent.scale(sx, sy);
                if (px && py)
                    this.translate(-px, -py);
            }
            rotate(degrees, px, py) {
                if (px && py)
                    this.translate(px, py);
                this._mCanvasContent.rotate(degrees);
                if (px && py)
                    this.translate(-px, -py);
            }
            drawRGB(r, g, b) {
                this._mCanvasContent.fillStyle = `rgb(${r},${g},${b})`;
                this._mCanvasContent.fillRect(this.mCurrentClip.left, this.mCurrentClip.top, this.mCurrentClip.width(), this.mCurrentClip.height());
            }
            drawARGB(a, r, g, b) {
                this._mCanvasContent.fillStyle = `rgba(${r},${g},${b},${a / 255})`;
                this._mCanvasContent.fillRect(this.mCurrentClip.left, this.mCurrentClip.top, this.mCurrentClip.width(), this.mCurrentClip.height());
            }
            drawColor(color) {
                this.drawARGB(Color.alpha(color), Color.red(color), Color.green(color), Color.blue(color));
            }
            clearColor() {
                this._mCanvasContent.clearRect(this.mCurrentClip.left, this.mCurrentClip.top, this.mCurrentClip.width(), this.mCurrentClip.height());
            }
            save() {
                this._mCanvasContent.save();
                if (this.mCurrentClip)
                    this.mClipStateMap.set(this._saveCount, new Rect(this.mCurrentClip));
                this._saveCount++;
                return this._saveCount;
            }
            restore() {
                let doRects = this.shouldDoRectBeforeRestoreMap.get(this._saveCount);
                if (doRects && doRects.length > 0) {
                    doRects.forEach((rect) => {
                        this._mCanvasContent.rect(rect.left, rect.top, rect.width(), rect.height());
                    });
                    if (doRects.length % 2 == 1) {
                        this.fullRectForClip();
                    }
                    this.shouldDoRectBeforeRestoreMap.delete(this._saveCount);
                }
                this._saveCount--;
                this._mCanvasContent.restore();
                let savedClip = this.mClipStateMap.get(this._saveCount);
                if (savedClip) {
                    this.mClipStateMap.delete(this._saveCount);
                    this.mCurrentClip.set(savedClip);
                }
            }
            restoreToCount(saveCount) {
                if (saveCount <= 0)
                    throw Error('saveCount can\'t <= 0');
                while (saveCount <= this._saveCount) {
                    this.restore();
                }
            }
            getSaveCount() {
                return this._saveCount;
            }
            fullRectForClip() {
                this._mCanvasContent.rect(Canvas.FullRect.left, Canvas.FullRect.top, Canvas.FullRect.width(), Canvas.FullRect.height());
            }
            clipRect(...args) {
                let rect = new Rect();
                if (args.length === 1) {
                    rect.set(args[0]);
                }
                else {
                    let [left = 0, top = 0, right = 0, bottom = 0] = args;
                    rect.set(left, top, right, bottom);
                }
                this._mCanvasContent.rect(Math.floor(rect.left), Math.floor(rect.top), Math.ceil(rect.width()), Math.ceil(rect.height()));
                this.fullRectForClip();
                this._mCanvasContent.clip('evenodd');
                let doRects = this.shouldDoRectBeforeRestoreMap.get(this._saveCount);
                if (!doRects) {
                    doRects = [];
                    this.shouldDoRectBeforeRestoreMap.set(this._saveCount, doRects);
                }
                doRects.push(rect);
                this.mCurrentClip.intersect(rect);
                return rect.isEmpty();
            }
            getClipBounds(bounds) {
                if (!this.mCurrentClip)
                    this.mCurrentClip = new Rect();
                let rect = bounds || new Rect();
                rect.set(this.mCurrentClip);
                return rect;
            }
            quickReject(...args) {
                if (!this.mCurrentClip)
                    return false;
                if (args.length == 1) {
                    return !this.mCurrentClip.intersects(args[0]);
                }
                else {
                    let [left = 0, t = 0, right = 0, bottom = 0] = args;
                    return !this.mCurrentClip.intersects(left, t, right, bottom);
                }
            }
            drawCanvas(canvas, offsetX, offsetY, width, height, canvasOffsetX, canvasOffsetY, canvasImageWidth, canvasImageHeight) {
                this._mCanvasContent.drawImage(canvas.canvasElement, offsetX, offsetY, width, height, canvasOffsetX, canvasOffsetY, canvasImageWidth, canvasImageHeight);
            }
            drawRect(...args) {
                if (args.length == 2) {
                    let rect = args[0];
                    this.drawRect(rect.left, rect.top, rect.right, rect.bottom, args[1]);
                }
                else {
                    let [left, top, right, bottom, paint] = args;
                    this._mCanvasContent.save();
                    paint._setToCanvasContent(this._mCanvasContent);
                    this._mCanvasContent.fillRect(left, top, right - left, bottom - top);
                    this._mCanvasContent.restore();
                }
            }
        }
        Canvas.FullRect = new Rect(-1000000000, -1000000000, 1000000000, 1000000000);
        Canvas.sPool = new Pools.SynchronizedPool(10);
        graphics.Canvas = Canvas;
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/29.
 */
///<reference path="Drawable.ts"/>
///<reference path="../Canvas.ts"/>
///<reference path="../Paint.ts"/>
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        var drawable;
        (function (drawable) {
            class ColorDrawable extends drawable.Drawable {
                constructor(color) {
                    super();
                    this.mMutated = false;
                    this.mPaint = new graphics.Paint();
                    this.mState = new ColorState();
                    if (color !== undefined) {
                        this.setColor(color);
                    }
                }
                _setStateCopyFrom(state) {
                    this.mState = new ColorState(state);
                }
                mutate() {
                    if (!this.mMutated && super.mutate() == this) {
                        this.mState = new ColorState(this.mState);
                        this.mMutated = true;
                    }
                    return this;
                }
                draw(canvas) {
                    if ((this.mState.mUseColor >>> 24) != 0) {
                        this.mPaint.setColor(this.mState.mUseColor);
                        canvas.drawRect(this.getBounds(), this.mPaint);
                    }
                }
                getColor() {
                    return this.mState.mUseColor;
                }
                setColor(color) {
                    if (this.mState.mBaseColor != color || this.mState.mUseColor != color) {
                        this.invalidateSelf();
                        this.mState.mBaseColor = this.mState.mUseColor = color;
                    }
                }
                getAlpha() {
                    return this.mState.mUseColor >>> 24;
                }
                setAlpha(alpha) {
                    alpha += alpha >> 7;
                    let baseAlpha = this.mState.mBaseColor >>> 24;
                    let useAlpha = baseAlpha * alpha >> 8;
                    let oldUseColor = this.mState.mUseColor;
                    this.mState.mUseColor = (this.mState.mBaseColor << 8 >>> 8) | (useAlpha << 24);
                    if (oldUseColor != this.mState.mUseColor) {
                        this.invalidateSelf();
                    }
                }
                getOpacity() {
                    switch (this.mState.mUseColor >>> 24) {
                        case 255:
                            return graphics.PixelFormat.OPAQUE;
                        case 0:
                            return graphics.PixelFormat.TRANSPARENT;
                    }
                    return graphics.PixelFormat.TRANSLUCENT;
                }
                getConstantState() {
                    return this.mState;
                }
            }
            drawable.ColorDrawable = ColorDrawable;
            class ColorState {
                constructor(state) {
                    this.mBaseColor = 0;
                    this.mUseColor = 0;
                    if (state != null) {
                        this.mBaseColor = state.mBaseColor;
                        this.mUseColor = state.mUseColor;
                    }
                }
                newDrawable() {
                    let c = new ColorDrawable();
                    c._setStateCopyFrom(this);
                    return c;
                }
            }
        })(drawable = graphics.drawable || (graphics.drawable = {}));
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/30.
 */
///<reference path="Drawable.ts"/>
///<reference path="../Canvas.ts"/>
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        var drawable;
        (function (drawable) {
            var Drawable = android.graphics.drawable.Drawable;
            class ScrollBarDrawable extends Drawable {
                constructor(...args) {
                    super(...args);
                    this.mRange = 0;
                    this.mOffset = 0;
                    this.mExtent = 0;
                    this.mVertical = false;
                    this.mChanged = false;
                    this.mRangeChanged = false;
                    this.mTempBounds = new graphics.Rect();
                    this.mAlwaysDrawHorizontalTrack = false;
                    this.mAlwaysDrawVerticalTrack = false;
                }
                setAlwaysDrawHorizontalTrack(alwaysDrawTrack) {
                    this.mAlwaysDrawHorizontalTrack = alwaysDrawTrack;
                }
                setAlwaysDrawVerticalTrack(alwaysDrawTrack) {
                    this.mAlwaysDrawVerticalTrack = alwaysDrawTrack;
                }
                getAlwaysDrawVerticalTrack() {
                    return this.mAlwaysDrawVerticalTrack;
                }
                getAlwaysDrawHorizontalTrack() {
                    return this.mAlwaysDrawHorizontalTrack;
                }
                setParameters(range, offset, extent, vertical) {
                    if (this.mVertical != vertical) {
                        this.mChanged = true;
                    }
                    if (this.mRange != range || this.mOffset != offset || this.mExtent != extent) {
                        this.mRangeChanged = true;
                    }
                    this.mRange = range;
                    this.mOffset = offset;
                    this.mExtent = extent;
                    this.mVertical = vertical;
                }
                draw(canvas) {
                    const vertical = this.mVertical;
                    const extent = this.mExtent;
                    const range = this.mRange;
                    let drawTrack = true;
                    let drawThumb = true;
                    if (extent <= 0 || range <= extent) {
                        drawTrack = vertical ? this.mAlwaysDrawVerticalTrack : this.mAlwaysDrawHorizontalTrack;
                        drawThumb = false;
                    }
                    let r = this.getBounds();
                    if (drawTrack) {
                        this.drawTrack(canvas, r, vertical);
                    }
                    if (drawThumb) {
                        let size = vertical ? r.height() : r.width();
                        let thickness = vertical ? r.width() : r.height();
                        let length = Math.round(size * extent / range);
                        let offset = Math.round((size - length) * this.mOffset / (range - extent));
                        let minLength = thickness * 2;
                        if (length < minLength) {
                            length = minLength;
                        }
                        if (offset + length > size) {
                            offset = size - length;
                        }
                        this.drawThumb(canvas, r, offset, length, vertical);
                    }
                }
                onBoundsChange(bounds) {
                    super.onBoundsChange(bounds);
                    this.mChanged = true;
                }
                drawTrack(canvas, bounds, vertical) {
                    let track;
                    if (vertical) {
                        track = this.mVerticalTrack;
                    }
                    else {
                        track = this.mHorizontalTrack;
                    }
                    if (track != null) {
                        if (this.mChanged) {
                            track.setBounds(bounds);
                        }
                        track.draw(canvas);
                    }
                }
                drawThumb(canvas, bounds, offset, length, vertical) {
                    const thumbRect = this.mTempBounds;
                    const changed = this.mRangeChanged || this.mChanged;
                    if (changed) {
                        if (vertical) {
                            thumbRect.set(bounds.left, bounds.top + offset, bounds.right, bounds.top + offset + length);
                        }
                        else {
                            thumbRect.set(bounds.left + offset, bounds.top, bounds.left + offset + length, bounds.bottom);
                        }
                    }
                    if (vertical) {
                        const thumb = this.mVerticalThumb;
                        if (changed)
                            thumb.setBounds(thumbRect);
                        thumb.draw(canvas);
                    }
                    else {
                        const thumb = this.mHorizontalThumb;
                        if (changed)
                            thumb.setBounds(thumbRect);
                        thumb.draw(canvas);
                    }
                }
                setVerticalThumbDrawable(thumb) {
                    if (thumb != null) {
                        this.mVerticalThumb = thumb;
                    }
                }
                setVerticalTrackDrawable(track) {
                    this.mVerticalTrack = track;
                }
                setHorizontalThumbDrawable(thumb) {
                    if (thumb != null) {
                        this.mHorizontalThumb = thumb;
                    }
                }
                setHorizontalTrackDrawable(track) {
                    this.mHorizontalTrack = track;
                }
                getSize(vertical) {
                    if (vertical) {
                        return (this.mVerticalTrack != null ?
                            this.mVerticalTrack : this.mVerticalThumb).getIntrinsicWidth();
                    }
                    else {
                        return (this.mHorizontalTrack != null ?
                            this.mHorizontalTrack : this.mHorizontalThumb).getIntrinsicHeight();
                    }
                }
                setAlpha(alpha) {
                    if (this.mVerticalTrack != null) {
                        this.mVerticalTrack.setAlpha(alpha);
                    }
                    this.mVerticalThumb.setAlpha(alpha);
                    if (this.mHorizontalTrack != null) {
                        this.mHorizontalTrack.setAlpha(alpha);
                    }
                    this.mHorizontalThumb.setAlpha(alpha);
                }
                getAlpha() {
                    return this.mVerticalThumb.getAlpha();
                }
                getOpacity() {
                    return graphics.PixelFormat.TRANSLUCENT;
                }
                toString() {
                    return "ScrollBarDrawable: range=" + this.mRange + " offset=" + this.mOffset +
                        " extent=" + this.mExtent + (this.mVertical ? " V" : " H");
                }
            }
            drawable.ScrollBarDrawable = ScrollBarDrawable;
        })(drawable = graphics.drawable || (graphics.drawable = {}));
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/2.
 */
///<reference path="Drawable.ts"/>
///<reference path="../Canvas.ts"/>
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        var drawable;
        (function (drawable_1) {
            class InsetDrawable extends drawable_1.Drawable {
                constructor(drawable, insetLeft, insetTop = insetLeft, insetRight = insetTop, insetBottom = insetRight) {
                    super();
                    this.mTmpRect = new graphics.Rect();
                    this.mMutated = false;
                    this.mInsetState = new InsetState(null, this);
                    this.mInsetState.mDrawable = drawable;
                    this.mInsetState.mInsetLeft = insetLeft;
                    this.mInsetState.mInsetTop = insetTop;
                    this.mInsetState.mInsetRight = insetRight;
                    this.mInsetState.mInsetBottom = insetBottom;
                    if (drawable != null) {
                        drawable.setCallback(this);
                    }
                }
                invalidateDrawable(who) {
                    const callback = this.getCallback();
                    if (callback != null) {
                        callback.invalidateDrawable(this);
                    }
                }
                scheduleDrawable(who, what, when) {
                    const callback = this.getCallback();
                    if (callback != null) {
                        callback.scheduleDrawable(this, what, when);
                    }
                }
                unscheduleDrawable(who, what) {
                    const callback = this.getCallback();
                    if (callback != null) {
                        callback.unscheduleDrawable(this, what);
                    }
                }
                draw(canvas) {
                    this.mInsetState.mDrawable.draw(canvas);
                }
                getPadding(padding) {
                    let pad = this.mInsetState.mDrawable.getPadding(padding);
                    padding.left += this.mInsetState.mInsetLeft;
                    padding.right += this.mInsetState.mInsetRight;
                    padding.top += this.mInsetState.mInsetTop;
                    padding.bottom += this.mInsetState.mInsetBottom;
                    if (pad || (this.mInsetState.mInsetLeft | this.mInsetState.mInsetRight |
                        this.mInsetState.mInsetTop | this.mInsetState.mInsetBottom) != 0) {
                        return true;
                    }
                    else {
                        return false;
                    }
                }
                setVisible(visible, restart) {
                    this.mInsetState.mDrawable.setVisible(visible, restart);
                    return super.setVisible(visible, restart);
                }
                setAlpha(alpha) {
                    this.mInsetState.mDrawable.setAlpha(alpha);
                }
                getAlpha() {
                    return this.mInsetState.mDrawable.getAlpha();
                }
                getOpacity() {
                    return this.mInsetState.mDrawable.getOpacity();
                }
                isStateful() {
                    return this.mInsetState.mDrawable.isStateful();
                }
                onStateChange(state) {
                    let changed = this.mInsetState.mDrawable.setState(state);
                    this.onBoundsChange(this.getBounds());
                    return changed;
                }
                onBoundsChange(bounds) {
                    const r = this.mTmpRect;
                    r.set(bounds);
                    r.left += this.mInsetState.mInsetLeft;
                    r.top += this.mInsetState.mInsetTop;
                    r.right -= this.mInsetState.mInsetRight;
                    r.bottom -= this.mInsetState.mInsetBottom;
                    this.mInsetState.mDrawable.setBounds(r.left, r.top, r.right, r.bottom);
                }
                getIntrinsicWidth() {
                    return this.mInsetState.mDrawable.getIntrinsicWidth();
                }
                getIntrinsicHeight() {
                    return this.mInsetState.mDrawable.getIntrinsicHeight();
                }
                getConstantState() {
                    if (this.mInsetState.canConstantState()) {
                        return this.mInsetState;
                    }
                    return null;
                }
                mutate() {
                    if (!this.mMutated && super.mutate() == this) {
                        this.mInsetState.mDrawable.mutate();
                        this.mMutated = true;
                    }
                    return this;
                }
                getDrawable() {
                    return this.mInsetState.mDrawable;
                }
            }
            drawable_1.InsetDrawable = InsetDrawable;
            class InsetState {
                constructor(orig, owner) {
                    this.mInsetLeft = 0;
                    this.mInsetTop = 0;
                    this.mInsetRight = 0;
                    this.mInsetBottom = 0;
                    if (orig != null) {
                        this.mDrawable = orig.mDrawable.getConstantState().newDrawable();
                        this.mDrawable.setCallback(owner);
                        this.mInsetLeft = orig.mInsetLeft;
                        this.mInsetTop = orig.mInsetTop;
                        this.mInsetRight = orig.mInsetRight;
                        this.mInsetBottom = orig.mInsetBottom;
                        this.mCheckedConstantState = this.mCanConstantState = true;
                    }
                }
                newDrawable() {
                    let drawable = new InsetDrawable(null, 0);
                    drawable.mInsetState = new InsetState(this, drawable);
                    return drawable;
                }
                canConstantState() {
                    if (!this.mCheckedConstantState) {
                        this.mCanConstantState = this.mDrawable.getConstantState() != null;
                        this.mCheckedConstantState = true;
                    }
                    return this.mCanConstantState;
                }
            }
        })(drawable = graphics.drawable || (graphics.drawable = {}));
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/18.
 */
///<reference path="Rect.ts"/>
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        class Matrix {
            isIdentity() {
                return true;
            }
            mapRect(boundingRect) {
                return false;
            }
        }
        Matrix.IDENTITY_MATRIX = new Matrix();
        graphics.Matrix = Matrix;
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
var java;
(function (java) {
    var lang;
    (function (lang) {
        var util;
        (function (util) {
            var concurrent;
            (function (concurrent) {
                class CopyOnWriteArrayList {
                    constructor() {
                        this.mData = [];
                        this.isDataNew = true;
                    }
                    iterator() {
                        this.isDataNew = false;
                        return this.mData;
                    }
                    [Symbol.iterator]() {
                        this.isDataNew = false;
                        return this.mData[Symbol.iterator]();
                    }
                    checkNewData() {
                        if (!this.isDataNew) {
                            this.isDataNew = true;
                            this.mData = [...this.mData];
                        }
                    }
                    size() {
                        return this.mData.length;
                    }
                    add(...items) {
                        this.checkNewData();
                        this.mData.push(...items);
                    }
                    addAll(array) {
                        this.checkNewData();
                        this.mData.push(...array.mData);
                    }
                    remove(item) {
                        this.checkNewData();
                        this.mData.splice(this.mData.indexOf(item), 1);
                    }
                }
                concurrent.CopyOnWriteArrayList = CopyOnWriteArrayList;
            })(concurrent = util.concurrent || (util.concurrent = {}));
        })(util = lang.util || (lang.util = {}));
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
/**
 * Created by linfaxin on 15/10/28.
 */
///<reference path="List.ts"/>
var java;
(function (java) {
    var util;
    (function (util) {
        class ArrayList {
            constructor(initialCapacity = 0) {
                this.array = [];
            }
            size() {
                return this.array.length;
            }
            isEmpty() {
                return this.size() === 0;
            }
            contains(o) {
                return this.indexOf(o) >= 0;
            }
            indexOf(o) {
                return this.array.indexOf(o);
            }
            lastIndexOf(o) {
                return this.array.lastIndexOf(o);
            }
            clone() {
                let arrayList = new ArrayList();
                arrayList.array.push(...this.array);
                return arrayList;
            }
            toArray(a = new Array(this.size())) {
                let size = this.size();
                for (let i = 0; i < size; i++) {
                    a[i] = this.array[i];
                }
                return a;
            }
            getArray() {
                return this.array;
            }
            get(index) {
                return this.array[index];
            }
            set(index, element) {
                let old = this.array[index];
                this.array[index] = element;
                return old;
            }
            add(...args) {
                let index, t;
                if (args.length === 1)
                    t = args[0];
                else if (args.length === 2) {
                    index = args[0];
                    t = args[1];
                }
                if (index === undefined)
                    this.array.push(t);
                else
                    this.array.splice(index, 0, t);
            }
            remove(o) {
                let index;
                if (Number.isInteger(o)) {
                    index = o;
                }
                else {
                    index = this.array.indexOf(o);
                }
                let old = this.array[index];
                this.array.splice(index, 1);
                return old;
            }
            clear() {
                this.array = [];
            }
            addAll(...args) {
                let index, list;
                if (args.length === 1) {
                    list = args[0];
                }
                else if (args.length === 2) {
                    index = args[0];
                    list = args[1];
                }
                if (index === undefined) {
                    this.array.push(...list.array);
                }
                else {
                    this.array.splice(index, 0, ...list.array);
                }
            }
            removeAll(list) {
                let oldSize = this.size();
                list.array.forEach((item) => {
                    let index = this.array.indexOf(item);
                    this.array.splice(index, 1);
                });
                return this.size() === oldSize;
            }
            [Symbol.iterator]() {
                return this.array[Symbol.iterator];
            }
            subList(fromIndex, toIndex) {
                let list = new ArrayList();
                for (var i = fromIndex; i < toIndex; i++) {
                    list.array.push(this.array[i]);
                }
                return list;
            }
            toString() {
                return this.array.toString();
            }
            sort(compareFn) {
                this.array.sort(compareFn);
            }
        }
        util.ArrayList = ArrayList;
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
var android;
(function (android) {
    var util;
    (function (util) {
        class Access {
            get(index) {
                return this.mData[index];
            }
            size() {
                return this.mSize;
            }
        }
        class CopyOnWriteArray {
            constructor() {
                this.mData = [];
                this.mAccess = new Access();
            }
            getArray() {
                if (this.mStart) {
                    if (this.mDataCopy == null)
                        this.mDataCopy = [...this.mData];
                    return this.mDataCopy;
                }
                return this.mData;
            }
            start() {
                if (this.mStart)
                    throw new Error("Iteration already started");
                this.mStart = true;
                this.mDataCopy = null;
                this.mAccess.mData = this.mData;
                this.mAccess.mSize = this.mData.length;
                return this.mAccess.mData;
            }
            end() {
                if (!this.mStart)
                    throw new Error("Iteration not started");
                this.mStart = false;
                if (this.mDataCopy != null) {
                    this.mData = this.mDataCopy;
                    this.mAccess.mData = [];
                    this.mAccess.mSize = 0;
                }
                this.mDataCopy = null;
            }
            size() {
                return this.getArray().length;
            }
            add(...items) {
                this.getArray().push(...items);
            }
            addAll(array) {
                this.getArray().push(...array.mData);
            }
            remove(item) {
                this.getArray().splice(this.getArray().indexOf(item), 1);
            }
        }
        util.CopyOnWriteArray = CopyOnWriteArray;
    })(util = android.util || (android.util = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/8.
 */
///<reference path="../../java/lang/util/concurrent/CopyOnWriteArrayList.ts"/>
///<reference path="../util/CopyOnWriteArray.ts"/>
///<reference path="../view/View.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var CopyOnWriteArrayList = java.lang.util.concurrent.CopyOnWriteArrayList;
        var CopyOnWriteArray = android.util.CopyOnWriteArray;
        class ViewTreeObserver {
            constructor() {
                this.mAlive = true;
            }
            addOnWindowAttachListener(listener) {
                this.checkIsAlive();
                if (this.mOnWindowAttachListeners == null) {
                    this.mOnWindowAttachListeners = new CopyOnWriteArrayList();
                }
                this.mOnWindowAttachListeners.add(listener);
            }
            removeOnWindowAttachListener(victim) {
                this.checkIsAlive();
                if (this.mOnWindowAttachListeners == null) {
                    return;
                }
                this.mOnWindowAttachListeners.remove(victim);
            }
            dispatchOnWindowAttachedChange(attached) {
                let listeners = this.mOnWindowAttachListeners;
                if (listeners != null && listeners.size() > 0) {
                    for (let listener of listeners) {
                        if (attached)
                            listener.onWindowAttached();
                        else
                            listener.onWindowDetached();
                    }
                }
            }
            addOnGlobalLayoutListener(listener) {
                this.checkIsAlive();
                if (this.mOnGlobalLayoutListeners == null) {
                    this.mOnGlobalLayoutListeners = new CopyOnWriteArray();
                }
                this.mOnGlobalLayoutListeners.add(listener);
            }
            removeGlobalOnLayoutListener(victim) {
                this.removeOnGlobalLayoutListener(victim);
            }
            removeOnGlobalLayoutListener(victim) {
                this.checkIsAlive();
                if (this.mOnGlobalLayoutListeners == null) {
                    return;
                }
                this.mOnGlobalLayoutListeners.remove(victim);
            }
            dispatchOnGlobalLayout() {
                let listeners = this.mOnGlobalLayoutListeners;
                if (listeners != null && listeners.size() > 0) {
                    let access = listeners.start();
                    try {
                        let count = access.length;
                        for (let i = 0; i < count; i++) {
                            access[i].onGlobalLayout();
                        }
                    }
                    finally {
                        listeners.end();
                    }
                }
            }
            addOnGlobalFocusChangeListener(listener) {
                this.checkIsAlive();
                if (this.mOnGlobalFocusListeners == null) {
                    this.mOnGlobalFocusListeners = new CopyOnWriteArrayList();
                }
                this.mOnGlobalFocusListeners.add(listener);
            }
            removeOnGlobalFocusChangeListener(victim) {
                this.checkIsAlive();
                if (this.mOnGlobalFocusListeners == null) {
                    return;
                }
                this.mOnGlobalFocusListeners.remove(victim);
            }
            dispatchOnGlobalFocusChange(oldFocus, newFocus) {
                const listeners = this.mOnGlobalFocusListeners;
                if (listeners != null && listeners.size() > 0) {
                    for (let listener of listeners) {
                        listener.onGlobalFocusChanged(oldFocus, newFocus);
                    }
                }
            }
            addOnPreDrawListener(listener) {
                this.checkIsAlive();
                if (this.mOnPreDrawListeners == null) {
                    this.mOnPreDrawListeners = new CopyOnWriteArray();
                }
                this.mOnPreDrawListeners.add(listener);
            }
            removeOnPreDrawListener(victim) {
                this.checkIsAlive();
                if (this.mOnPreDrawListeners == null) {
                    return;
                }
                this.mOnPreDrawListeners.remove(victim);
            }
            dispatchOnPreDraw() {
                let cancelDraw = false;
                const listeners = this.mOnPreDrawListeners;
                if (listeners != null && listeners.size() > 0) {
                    let access = listeners.start();
                    try {
                        let count = access.length;
                        for (let i = 0; i < count; i++) {
                            cancelDraw = cancelDraw || !(access[i].onPreDraw());
                        }
                    }
                    finally {
                        listeners.end();
                    }
                }
                return cancelDraw;
            }
            addOnTouchModeChangeListener(listener) {
                this.checkIsAlive();
                if (this.mOnTouchModeChangeListeners == null) {
                    this.mOnTouchModeChangeListeners = new CopyOnWriteArrayList();
                }
                this.mOnTouchModeChangeListeners.add(listener);
            }
            removeOnTouchModeChangeListener(victim) {
                this.checkIsAlive();
                if (this.mOnTouchModeChangeListeners == null) {
                    return;
                }
                this.mOnTouchModeChangeListeners.remove(victim);
            }
            dispatchOnTouchModeChanged(inTouchMode) {
                const listeners = this.mOnTouchModeChangeListeners;
                if (listeners != null && listeners.size() > 0) {
                    for (let listener of listeners) {
                        listener.onTouchModeChanged(inTouchMode);
                    }
                }
            }
            addOnScrollChangedListener(listener) {
                this.checkIsAlive();
                if (this.mOnScrollChangedListeners == null) {
                    this.mOnScrollChangedListeners = new CopyOnWriteArray();
                }
                this.mOnScrollChangedListeners.add(listener);
            }
            removeOnScrollChangedListener(victim) {
                this.checkIsAlive();
                if (this.mOnScrollChangedListeners == null) {
                    return;
                }
                this.mOnScrollChangedListeners.remove(victim);
            }
            dispatchOnScrollChanged() {
                let listeners = this.mOnScrollChangedListeners;
                if (listeners != null && listeners.size() > 0) {
                    let access = listeners.start();
                    try {
                        let count = access.length;
                        for (let i = 0; i < count; i++) {
                            access[i].onScrollChanged();
                        }
                    }
                    finally {
                        listeners.end();
                    }
                }
            }
            addOnDrawListener(listener) {
                this.checkIsAlive();
                if (this.mOnDrawListeners == null) {
                    this.mOnDrawListeners = new CopyOnWriteArrayList();
                }
                this.mOnDrawListeners.add(listener);
            }
            removeOnDrawListener(victim) {
                this.checkIsAlive();
                if (this.mOnDrawListeners == null) {
                    return;
                }
                this.mOnDrawListeners.remove(victim);
            }
            dispatchOnDraw() {
                if (this.mOnDrawListeners != null) {
                    for (let listener of this.mOnDrawListeners) {
                        listener.onDraw();
                    }
                }
            }
            merge(observer) {
                if (observer.mOnWindowAttachListeners != null) {
                    if (this.mOnWindowAttachListeners != null) {
                        this.mOnWindowAttachListeners.addAll(observer.mOnWindowAttachListeners);
                    }
                    else {
                        this.mOnWindowAttachListeners = observer.mOnWindowAttachListeners;
                    }
                }
                if (observer.mOnGlobalLayoutListeners != null) {
                    if (this.mOnGlobalLayoutListeners != null) {
                        this.mOnGlobalLayoutListeners.addAll(observer.mOnGlobalLayoutListeners);
                    }
                    else {
                        this.mOnGlobalLayoutListeners = observer.mOnGlobalLayoutListeners;
                    }
                }
                if (observer.mOnPreDrawListeners != null) {
                    if (this.mOnPreDrawListeners != null) {
                        this.mOnPreDrawListeners.addAll(observer.mOnPreDrawListeners);
                    }
                    else {
                        this.mOnPreDrawListeners = observer.mOnPreDrawListeners;
                    }
                }
                if (observer.mOnScrollChangedListeners != null) {
                    if (this.mOnScrollChangedListeners != null) {
                        this.mOnScrollChangedListeners.addAll(observer.mOnScrollChangedListeners);
                    }
                    else {
                        this.mOnScrollChangedListeners = observer.mOnScrollChangedListeners;
                    }
                }
                observer.kill();
            }
            checkIsAlive() {
                if (!this.mAlive) {
                    throw new Error("This ViewTreeObserver is not alive, call "
                        + "getViewTreeObserver() again");
                }
            }
            isAlive() {
                return this.mAlive;
            }
            kill() {
                this.mAlive = false;
            }
        }
        view.ViewTreeObserver = ViewTreeObserver;
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
var android;
(function (android) {
    var util;
    (function (util) {
        class DisplayMetrics {
        }
        DisplayMetrics.DENSITY_LOW = 120;
        DisplayMetrics.DENSITY_MEDIUM = 160;
        DisplayMetrics.DENSITY_HIGH = 240;
        DisplayMetrics.DENSITY_XHIGH = 320;
        DisplayMetrics.DENSITY_XXHIGH = 480;
        DisplayMetrics.DENSITY_XXXHIGH = 640;
        DisplayMetrics.DENSITY_DEFAULT = DisplayMetrics.DENSITY_MEDIUM;
        util.DisplayMetrics = DisplayMetrics;
    })(util = android.util || (android.util = {}));
})(android || (android = {}));
///<reference path="../../util/DisplayMetrics.ts"/>
var android;
(function (android) {
    var content;
    (function (content) {
        var res;
        (function (res) {
            var DisplayMetrics = android.util.DisplayMetrics;
            class Resources {
                static getDisplayMetrics() {
                    if (Resources.displayMetrics)
                        return Resources.displayMetrics;
                    Resources.displayMetrics = new DisplayMetrics();
                    let displayMetrics = Resources.displayMetrics;
                    let density = Resources.density;
                    displayMetrics.xdpi = window.screen.deviceXDPI || DisplayMetrics.DENSITY_DEFAULT;
                    displayMetrics.ydpi = window.screen.deviceYDPI || DisplayMetrics.DENSITY_DEFAULT;
                    displayMetrics.density = density;
                    displayMetrics.densityDpi = density * DisplayMetrics.DENSITY_DEFAULT;
                    displayMetrics.scaledDensity = density;
                    displayMetrics.widthPixels = window.innerWidth * density;
                    displayMetrics.heightPixels = window.innerHeight * density;
                    return displayMetrics;
                }
                static setDensity(density) {
                    Resources.density = density;
                    Resources.displayMetrics = null;
                }
            }
            Resources.density = 1;
            res.Resources = Resources;
        })(res = content.res || (content.res = {}));
    })(content = android.content || (android.content = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/5.
 */
///<reference path="../util/SparseArray.ts"/>
///<reference path="../content/res/Resources.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var Resources = android.content.res.Resources;
        const metrics = Resources.getDisplayMetrics();
        const density = metrics.density;
        const sizeAndDensity = density;
        class ViewConfiguration {
            constructor() {
                this.mEdgeSlop = sizeAndDensity * ViewConfiguration.EDGE_SLOP;
                this.mFadingEdgeLength = sizeAndDensity * ViewConfiguration.FADING_EDGE_LENGTH;
                this.mMinimumFlingVelocity = density * ViewConfiguration.MINIMUM_FLING_VELOCITY;
                this.mMaximumFlingVelocity = density * ViewConfiguration.MAXIMUM_FLING_VELOCITY;
                this.mScrollbarSize = density * ViewConfiguration.SCROLL_BAR_SIZE;
                this.mTouchSlop = density * ViewConfiguration.TOUCH_SLOP;
                this.mDoubleTapTouchSlop = sizeAndDensity * ViewConfiguration.DOUBLE_TAP_TOUCH_SLOP;
                this.mPagingTouchSlop = density * ViewConfiguration.PAGING_TOUCH_SLOP;
                this.mDoubleTapSlop = density * ViewConfiguration.DOUBLE_TAP_SLOP;
                this.mWindowTouchSlop = sizeAndDensity * ViewConfiguration.WINDOW_TOUCH_SLOP;
                this.mOverscrollDistance = sizeAndDensity * ViewConfiguration.OVERSCROLL_DISTANCE;
                this.mOverflingDistance = sizeAndDensity * ViewConfiguration.OVERFLING_DISTANCE;
            }
            static get(arg) {
                if (!ViewConfiguration.instance) {
                    ViewConfiguration.instance = new ViewConfiguration();
                }
                return ViewConfiguration.instance;
            }
            getScaledScrollBarSize() {
                return this.mScrollbarSize;
            }
            static getScrollBarFadeDuration() {
                return ViewConfiguration.SCROLL_BAR_FADE_DURATION;
            }
            static getScrollDefaultDelay() {
                return ViewConfiguration.SCROLL_BAR_DEFAULT_DELAY;
            }
            getScaledFadingEdgeLength() {
                return this.mFadingEdgeLength;
            }
            static getPressedStateDuration() {
                return ViewConfiguration.PRESSED_STATE_DURATION;
            }
            static getLongPressTimeout() {
                return ViewConfiguration.DEFAULT_LONG_PRESS_TIMEOUT;
            }
            static getKeyRepeatDelay() {
                return ViewConfiguration.KEY_REPEAT_DELAY;
            }
            static getTapTimeout() {
                return ViewConfiguration.TAP_TIMEOUT;
            }
            static getJumpTapTimeout() {
                return ViewConfiguration.JUMP_TAP_TIMEOUT;
            }
            static getDoubleTapTimeout() {
                return ViewConfiguration.DOUBLE_TAP_TIMEOUT;
            }
            static getDoubleTapMinTime() {
                return ViewConfiguration.DOUBLE_TAP_MIN_TIME;
            }
            getScaledEdgeSlop() {
                return this.mEdgeSlop;
            }
            getScaledTouchSlop() {
                return this.mTouchSlop;
            }
            getScaledDoubleTapTouchSlop() {
                return this.mDoubleTapTouchSlop;
            }
            getScaledPagingTouchSlop() {
                return this.mPagingTouchSlop;
            }
            getScaledDoubleTapSlop() {
                return this.mDoubleTapSlop;
            }
            getScaledWindowTouchSlop() {
                return this.mWindowTouchSlop;
            }
            getScaledMinimumFlingVelocity() {
                return this.mMinimumFlingVelocity;
            }
            getScaledMaximumFlingVelocity() {
                return this.mMaximumFlingVelocity;
            }
            getScaledOverscrollDistance() {
                return this.mOverscrollDistance;
            }
            getScaledOverflingDistance() {
                return this.mOverflingDistance;
            }
            static getScrollFriction() {
                return ViewConfiguration.SCROLL_FRICTION;
            }
        }
        ViewConfiguration.SCROLL_BAR_SIZE = 8;
        ViewConfiguration.SCROLL_BAR_FADE_DURATION = 250;
        ViewConfiguration.SCROLL_BAR_DEFAULT_DELAY = 300;
        ViewConfiguration.FADING_EDGE_LENGTH = 12;
        ViewConfiguration.PRESSED_STATE_DURATION = 64;
        ViewConfiguration.DEFAULT_LONG_PRESS_TIMEOUT = 500;
        ViewConfiguration.KEY_REPEAT_DELAY = 50;
        ViewConfiguration.GLOBAL_ACTIONS_KEY_TIMEOUT = 500;
        ViewConfiguration.TAP_TIMEOUT = 180;
        ViewConfiguration.JUMP_TAP_TIMEOUT = 500;
        ViewConfiguration.DOUBLE_TAP_TIMEOUT = 300;
        ViewConfiguration.DOUBLE_TAP_MIN_TIME = 40;
        ViewConfiguration.HOVER_TAP_TIMEOUT = 150;
        ViewConfiguration.HOVER_TAP_SLOP = 20;
        ViewConfiguration.ZOOM_CONTROLS_TIMEOUT = 3000;
        ViewConfiguration.EDGE_SLOP = 12;
        ViewConfiguration.TOUCH_SLOP = 8;
        ViewConfiguration.DOUBLE_TAP_TOUCH_SLOP = ViewConfiguration.TOUCH_SLOP;
        ViewConfiguration.PAGING_TOUCH_SLOP = ViewConfiguration.TOUCH_SLOP * 2;
        ViewConfiguration.DOUBLE_TAP_SLOP = 100;
        ViewConfiguration.WINDOW_TOUCH_SLOP = 16;
        ViewConfiguration.MINIMUM_FLING_VELOCITY = 50;
        ViewConfiguration.MAXIMUM_FLING_VELOCITY = 8000;
        ViewConfiguration.SCROLL_FRICTION = 0.015;
        ViewConfiguration.OVERSCROLL_DISTANCE = 800;
        ViewConfiguration.OVERFLING_DISTANCE = 100;
        view.ViewConfiguration = ViewConfiguration;
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/6.
 */
///<reference path="../content/res/Resources.ts"/>
///<reference path="../graphics/Rect.ts"/>
///<reference path="../view/ViewConfiguration.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var Resources = android.content.res.Resources;
        var Rect = android.graphics.Rect;
        var ViewConfiguration = android.view.ViewConfiguration;
        class MotionEvent {
            constructor() {
                this.mAction = 0;
                this.mEdgeFlags = 0;
                this.mDownTime = 0;
                this.mEventTime = 0;
                this.mActivePointerId = 0;
                this.mXOffset = 0;
                this.mYOffset = 0;
                this._axisValues = new Map();
            }
            static obtainWithTouchEvent(e, action) {
                let event = new MotionEvent();
                event.initWithTouch(e, action);
                return event;
            }
            static obtain(event) {
                let newEv = new MotionEvent();
                Object.assign(newEv, event);
                return newEv;
            }
            static obtainWithAction(downTime, eventTime, action, x, y, metaState = 0) {
                let newEv = new MotionEvent();
                newEv.mAction = action;
                newEv.mDownTime = downTime;
                newEv.mEventTime = eventTime;
                let touch = {
                    identifier: 0,
                    target: null,
                    screenX: x,
                    screenY: y,
                    clientX: x,
                    clientY: y,
                    pageX: x,
                    pageY: y
                };
                newEv.mTouchingPointers = [touch];
                return newEv;
            }
            initWithTouch(event, baseAction, windowBound = new Rect()) {
                let e = event;
                let action = baseAction;
                let actionIndex = -1;
                let activeTouch = e.changedTouches[0];
                this._activeTouch = activeTouch;
                let activePointerId = activeTouch.identifier;
                for (let i = 0, length = e.touches.length; i < length; i++) {
                    if (e.touches[i].identifier === activePointerId) {
                        actionIndex = i;
                        MotionEvent.IdIndexCache.set(activePointerId, i);
                        break;
                    }
                }
                if (actionIndex < 0 && (baseAction === MotionEvent.ACTION_UP || baseAction === MotionEvent.ACTION_CANCEL)) {
                    actionIndex = MotionEvent.IdIndexCache.get(activePointerId);
                }
                if (actionIndex < 0)
                    throw Error('not find action index');
                switch (baseAction) {
                    case MotionEvent.ACTION_DOWN:
                    case MotionEvent.ACTION_UP:
                        MotionEvent.TouchMoveRecord.set(activePointerId, []);
                        break;
                    case MotionEvent.ACTION_MOVE:
                        let moveHistory = MotionEvent.TouchMoveRecord.get(activePointerId);
                        if (moveHistory) {
                            activeTouch.mEventTime = e.timeStamp;
                            moveHistory.push(activeTouch);
                            if (moveHistory.length > MotionEvent.HistoryMaxSize)
                                moveHistory.shift();
                        }
                        break;
                }
                this.mTouchingPointers = Array.from(e.touches);
                if (baseAction === MotionEvent.ACTION_UP) {
                    this.mTouchingPointers.splice(actionIndex, 0, activeTouch);
                }
                if (this.mTouchingPointers.length > 1) {
                    switch (action) {
                        case MotionEvent.ACTION_DOWN:
                            action = MotionEvent.ACTION_POINTER_DOWN;
                            break;
                        case MotionEvent.ACTION_UP:
                            action = MotionEvent.ACTION_POINTER_UP;
                            break;
                    }
                }
                this.mAction = actionIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT | action;
                this.mActivePointerId = activePointerId;
                if (activePointerId === 0 && action == MotionEvent.ACTION_DOWN) {
                    this.mDownTime = e.timeStamp;
                }
                this.mEventTime = e.timeStamp;
                this.mXOffset = this.mYOffset = 0;
                let edgeFlag = 0;
                let unScaledX = activeTouch.clientX;
                let unScaledY = activeTouch.clientY;
                let edgeSlop = ViewConfiguration.EDGE_SLOP;
                let tempBound = new Rect();
                tempBound.set(windowBound);
                tempBound.right = tempBound.left + edgeSlop;
                if (tempBound.contains(unScaledX, unScaledY)) {
                    edgeFlag |= MotionEvent.EDGE_LEFT;
                }
                tempBound.set(windowBound);
                tempBound.bottom = tempBound.top + edgeSlop;
                if (tempBound.contains(unScaledX, unScaledY)) {
                    edgeFlag |= MotionEvent.EDGE_TOP;
                }
                tempBound.set(windowBound);
                tempBound.left = tempBound.right - edgeSlop;
                if (tempBound.contains(unScaledX, unScaledY)) {
                    edgeFlag |= MotionEvent.EDGE_RIGHT;
                }
                tempBound.set(windowBound);
                tempBound.top = tempBound.bottom - edgeSlop;
                if (tempBound.contains(unScaledX, unScaledY)) {
                    edgeFlag |= MotionEvent.EDGE_BOTTOM;
                }
                this.mEdgeFlags = edgeFlag;
            }
            initWithMouseWheel(e) {
                this.mAction = MotionEvent.ACTION_SCROLL;
                this.mActivePointerId = 0;
                let touch = {
                    identifier: 0,
                    target: null,
                    screenX: e.screenX,
                    screenY: e.screenY,
                    clientX: e.clientX,
                    clientY: e.clientY,
                    pageX: e.pageX,
                    pageY: e.pageY
                };
                this.mTouchingPointers = [touch];
                this.mDownTime = e.timeStamp;
                this.mEventTime = e.timeStamp;
                this.mXOffset = this.mYOffset = 0;
                this._axisValues.clear();
                this._axisValues.set(MotionEvent.AXIS_VSCROLL, -e.deltaY);
                this._axisValues.set(MotionEvent.AXIS_HSCROLL, -e.deltaX);
            }
            recycle() {
            }
            getAction() {
                return this.mAction;
            }
            getActionMasked() {
                return this.mAction & MotionEvent.ACTION_MASK;
            }
            getActionIndex() {
                return (this.mAction & MotionEvent.ACTION_POINTER_INDEX_MASK) >> MotionEvent.ACTION_POINTER_INDEX_SHIFT;
            }
            getDownTime() {
                return this.mDownTime;
            }
            getEventTime() {
                return this.mEventTime;
            }
            getX(pointerIndex = 0) {
                let density = Resources.getDisplayMetrics().density;
                return (this.mTouchingPointers[pointerIndex].clientX) * density + this.mXOffset;
            }
            getY(pointerIndex = 0) {
                let density = Resources.getDisplayMetrics().density;
                return (this.mTouchingPointers[pointerIndex].clientY) * density + this.mYOffset;
            }
            getPointerCount() {
                return this.mTouchingPointers.length;
            }
            getPointerId(pointerIndex) {
                return this.mTouchingPointers[pointerIndex].identifier;
            }
            findPointerIndex(pointerId) {
                for (let i = 0, length = this.mTouchingPointers.length; i < length; i++) {
                    if (this.mTouchingPointers[i].identifier === pointerId) {
                        return i;
                    }
                }
                return -1;
            }
            getRawX() {
                let density = Resources.getDisplayMetrics().density;
                return (this.mTouchingPointers[0].clientX) * density;
            }
            getRawY() {
                let density = Resources.getDisplayMetrics().density;
                return (this.mTouchingPointers[0].clientY) * density;
            }
            getHistorySize(id = this.mActivePointerId) {
                let moveHistory = MotionEvent.TouchMoveRecord.get(id);
                return moveHistory ? moveHistory.length : 0;
            }
            getHistoricalX(pointerIndex, pos) {
                let density = Resources.getDisplayMetrics().density;
                let moveHistory = MotionEvent.TouchMoveRecord.get(this.mTouchingPointers[pointerIndex].identifier);
                return (moveHistory[pos].clientX) * density + this.mXOffset;
            }
            getHistoricalY(pointerIndex, pos) {
                let density = Resources.getDisplayMetrics().density;
                let moveHistory = MotionEvent.TouchMoveRecord.get(this.mTouchingPointers[pointerIndex].identifier);
                return (moveHistory[pos].clientY) * density + this.mYOffset;
            }
            getHistoricalEventTime(...args) {
                let pos, activePointerId;
                if (args.length === 1) {
                    pos = args[0];
                    activePointerId = this.mActivePointerId;
                }
                else {
                    pos = args[1];
                    activePointerId = this.getPointerId(args[0]);
                }
                let moveHistory = MotionEvent.TouchMoveRecord.get(activePointerId);
                return moveHistory[pos].mEventTime;
            }
            getEdgeFlags() {
                return this.mEdgeFlags;
            }
            setEdgeFlags(flags) {
                this.mEdgeFlags = flags;
            }
            setAction(action) {
                this.mAction = action;
            }
            isTouchEvent() {
                let action = this.getActionMasked();
                switch (action) {
                    case MotionEvent.ACTION_DOWN:
                    case MotionEvent.ACTION_UP:
                    case MotionEvent.ACTION_MOVE:
                    case MotionEvent.ACTION_CANCEL:
                    case MotionEvent.ACTION_OUTSIDE:
                    case MotionEvent.ACTION_POINTER_DOWN:
                    case MotionEvent.ACTION_POINTER_UP:
                        return true;
                }
                return false;
            }
            isPointerEvent() {
                return true;
            }
            offsetLocation(deltaX, deltaY) {
                this.mXOffset += deltaX;
                this.mYOffset += deltaY;
            }
            setLocation(x, y) {
                this.mXOffset = x - this.getRawX();
                this.mYOffset = y - this.getRawY();
            }
            getPointerIdBits() {
                let idBits = 0;
                let pointerCount = this.getPointerCount();
                for (let i = 0; i < pointerCount; i++) {
                    idBits |= 1 << this.getPointerId(i);
                }
                return idBits;
            }
            split(idBits) {
                let ev = MotionEvent.obtain(this);
                let oldPointerCount = this.getPointerCount();
                const oldAction = this.getAction();
                const oldActionMasked = oldAction & MotionEvent.ACTION_MASK;
                let newPointerIds = [];
                for (let i = 0; i < oldPointerCount; i++) {
                    let pointerId = this.getPointerId(i);
                    let idBit = 1 << pointerId;
                    if ((idBit & idBits) != 0) {
                        newPointerIds.push(pointerId);
                    }
                }
                let newActionPointerIndex = newPointerIds.indexOf(this.mActivePointerId);
                let newPointerCount = newPointerIds.length;
                let newAction;
                if (oldActionMasked == MotionEvent.ACTION_POINTER_DOWN || oldActionMasked == MotionEvent.ACTION_POINTER_UP) {
                    if (newActionPointerIndex < 0) {
                        newAction = MotionEvent.ACTION_MOVE;
                    }
                    else if (newPointerCount == 1) {
                        newAction = oldActionMasked == MotionEvent.ACTION_POINTER_DOWN
                            ? MotionEvent.ACTION_DOWN : MotionEvent.ACTION_UP;
                    }
                    else {
                        newAction = oldActionMasked | (newActionPointerIndex << MotionEvent.ACTION_POINTER_INDEX_SHIFT);
                    }
                }
                else {
                    newAction = oldAction;
                }
                ev.mAction = newAction;
                ev.mTouchingPointers = this.mTouchingPointers.filter((item) => {
                    return newPointerIds.indexOf(item.identifier) >= 0;
                });
                return ev;
            }
            getAxisValue(axis) {
                let value = this._axisValues.get(axis);
                return value ? value : 0;
            }
            toString() {
                return "MotionEvent{action=" + this.getAction() + " x=" + this.getX()
                    + " y=" + this.getY() + "}";
            }
        }
        MotionEvent.ACTION_MASK = 0xff;
        MotionEvent.ACTION_DOWN = 0;
        MotionEvent.ACTION_UP = 1;
        MotionEvent.ACTION_MOVE = 2;
        MotionEvent.ACTION_CANCEL = 3;
        MotionEvent.ACTION_OUTSIDE = 4;
        MotionEvent.ACTION_POINTER_DOWN = 5;
        MotionEvent.ACTION_POINTER_UP = 6;
        MotionEvent.ACTION_HOVER_MOVE = 7;
        MotionEvent.ACTION_SCROLL = 8;
        MotionEvent.ACTION_HOVER_ENTER = 9;
        MotionEvent.ACTION_HOVER_EXIT = 10;
        MotionEvent.EDGE_TOP = 0x00000001;
        MotionEvent.EDGE_BOTTOM = 0x00000002;
        MotionEvent.EDGE_LEFT = 0x00000004;
        MotionEvent.EDGE_RIGHT = 0x00000008;
        MotionEvent.ACTION_POINTER_INDEX_MASK = 0xff00;
        MotionEvent.ACTION_POINTER_INDEX_SHIFT = 8;
        MotionEvent.AXIS_VSCROLL = 9;
        MotionEvent.AXIS_HSCROLL = 10;
        MotionEvent.HistoryMaxSize = 10;
        MotionEvent.TouchMoveRecord = new Map();
        MotionEvent.IdIndexCache = new Map();
        view.MotionEvent = MotionEvent;
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/16.
 */
///<reference path="View.ts"/>
///<reference path="../graphics/Rect.ts"/>
///<reference path="ViewConfiguration.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var Rect = android.graphics.Rect;
        class TouchDelegate {
            constructor(bounds, delegateView) {
                this.mDelegateTargeted = false;
                this.mSlop = 0;
                this.mBounds = bounds;
                this.mSlop = view.ViewConfiguration.get().getScaledTouchSlop();
                this.mSlopBounds = new Rect(bounds);
                this.mSlopBounds.inset(-this.mSlop, -this.mSlop);
                this.mDelegateView = delegateView;
            }
            onTouchEvent(event) {
                let x = event.getX();
                let y = event.getY();
                let sendToDelegate = false;
                let hit = true;
                let handled = false;
                switch (event.getAction()) {
                    case view.MotionEvent.ACTION_DOWN:
                        let bounds = this.mBounds;
                        if (bounds.contains(x, y)) {
                            this.mDelegateTargeted = true;
                            sendToDelegate = true;
                        }
                        break;
                    case view.MotionEvent.ACTION_UP:
                    case view.MotionEvent.ACTION_MOVE:
                        sendToDelegate = this.mDelegateTargeted;
                        if (sendToDelegate) {
                            let slopBounds = this.mSlopBounds;
                            if (!slopBounds.contains(x, y)) {
                                hit = false;
                            }
                        }
                        break;
                    case view.MotionEvent.ACTION_CANCEL:
                        sendToDelegate = this.mDelegateTargeted;
                        this.mDelegateTargeted = false;
                        break;
                }
                if (sendToDelegate) {
                    let delegateView = this.mDelegateView;
                    if (hit) {
                        event.setLocation(delegateView.getWidth() / 2, delegateView.getHeight() / 2);
                    }
                    else {
                        let slop = this.mSlop;
                        event.setLocation(-(slop * 2), -(slop * 2));
                    }
                    handled = delegateView.dispatchTouchEvent(event);
                }
                return handled;
            }
        }
        view.TouchDelegate = TouchDelegate;
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
var android;
(function (android) {
    var os;
    (function (os) {
        class SystemClock {
            static uptimeMillis() {
                return new Date().getTime();
            }
        }
        os.SystemClock = SystemClock;
    })(os = android.os || (android.os = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/5.
 */
///<reference path="Handler.ts"/>
///<reference path="../../java/lang/Runnable.ts"/>
///<reference path="../../java/lang/StringBuilder.ts"/>
///<reference path="../util/Pools.ts"/>
///<reference path="SystemClock.ts"/>
var android;
(function (android) {
    var os;
    (function (os) {
        var StringBuilder = java.lang.StringBuilder;
        var Pools = android.util.Pools;
        class Message {
            constructor() {
                this.what = 0;
                this.arg1 = 0;
                this.arg2 = 0;
                this.when = 0;
            }
            recycle() {
                this.clearForRecycle();
                Message.sPool.release(this);
            }
            copyFrom(o) {
                this.what = o.what;
                this.arg1 = o.arg1;
                this.arg2 = o.arg2;
                this.obj = o.obj;
            }
            sendToTarget() {
                this.target.sendMessage(this);
            }
            clearForRecycle() {
                this.what = 0;
                this.arg1 = 0;
                this.arg2 = 0;
                this.obj = null;
                this.when = 0;
                this.target = null;
                this.callback = null;
            }
            toString(now = os.SystemClock.uptimeMillis()) {
                let b = new StringBuilder();
                b.append("{ what=");
                b.append(this.what);
                b.append(" when=");
                b.append(this.when - now).append("ms");
                if (this.arg1 != 0) {
                    b.append(" arg1=");
                    b.append(this.arg1);
                }
                if (this.arg2 != 0) {
                    b.append(" arg2=");
                    b.append(this.arg2);
                }
                if (this.obj != null) {
                    b.append(" obj=");
                    b.append(this.obj);
                }
                b.append(" }");
                return b.toString();
            }
            static obtain(...args) {
                let m = Message.sPool.acquire();
                m = m || new Message();
                if (args.length === 1 && args[0] instanceof Message) {
                    let orig = args[0];
                    [m.target, m.what, m.arg1, m.arg2, m.obj, m.callback] =
                        [orig.target, orig.what, orig.arg1, orig.arg2, orig.obj, orig.callback];
                }
                else if (args.length === 2) {
                    [m.what = 0, m.callback] = args;
                }
                else if (args.length === 3) {
                    [m.what = 0, m.arg1 = 0, m.obj] = args;
                }
                else {
                    [m.target, m.what = 0, m.arg1 = 0, m.arg2 = 0, m.obj, m.callback] = args;
                }
                return m;
            }
        }
        Message.sPool = new Pools.SynchronizedPool(10);
        os.Message = Message;
    })(os = android.os || (android.os = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/5.
 */
///<reference path="Message.ts"/>
///<reference path="Handler.ts"/>
///<reference path="../../java/lang/Runnable.ts"/>
var android;
(function (android) {
    var os;
    (function (os) {
        class MessageQueue {
            constructor() {
                this.messages = new Map();
            }
            getMessages(h, args, object) {
                let msgs = [];
                if (h == null) {
                    return msgs;
                }
                if (typeof args === "number") {
                    let what = args;
                    for (let p of this.messages.keys()) {
                        if (p.target == h && p.what == what && (object == null || p.obj == object)) {
                            msgs.push(p);
                        }
                    }
                }
                else {
                    let r = args;
                    for (let p of this.messages.keys()) {
                        if (p.target == h && p.callback == r && (object == null || p.obj == object)) {
                            msgs.push(p);
                        }
                    }
                }
                return msgs;
            }
            hasMessages(h, args, object) {
                return this.getMessages(h, args, object).length > 0;
            }
            addMessage(handler, msg, delayHandleID) {
                this.messages.set(msg, delayHandleID);
            }
            recycleMessage(handler, message) {
                try {
                    message.recycle();
                }
                catch (e) {
                }
                let oldId = this.messages.get(message);
                if (oldId !== undefined) {
                    if (oldId > 0)
                        clearTimeout(oldId);
                    else if (oldId < 0)
                        cancelAnimationFrame(-oldId);
                    this.messages.delete(message);
                }
            }
            removeMessages(h, args, object) {
                let p = this.getMessages(h, args, object);
                if (p && p.length > 0) {
                    p.forEach((item) => this.recycleMessage(h, item));
                }
            }
            removeCallbacksAndMessages(h, object) {
                if (h == null) {
                    return;
                }
                for (let p of this.messages.keys()) {
                    if (p != null && p.target == h && (object == null || p.obj == object)) {
                        this.recycleMessage(h, p);
                    }
                }
            }
        }
        os.MessageQueue = MessageQueue;
    })(os = android.os || (android.os = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/5.
 */
///<reference path="Message.ts"/>
///<reference path="MessageQueue.ts"/>
///<reference path="../../java/lang/Runnable.ts"/>
///<reference path="SystemClock.ts"/>
var android;
(function (android) {
    var os;
    (function (os) {
        class Handler {
            constructor(mCallback) {
                this.mQueue = new os.MessageQueue();
                this.mCallback = mCallback;
            }
            handleMessage(msg) {
            }
            dispatchMessage(msg) {
                if (msg.callback != null) {
                    msg.callback.run.call(msg.callback);
                }
                else {
                    if (this.mCallback != null) {
                        if (this.mCallback.handleMessage(msg)) {
                            return;
                        }
                    }
                    this.handleMessage(msg);
                }
            }
            obtainMessage(...args) {
                if (args.length === 2) {
                    let [what, obj] = args;
                    return os.Message.obtain(this, what, obj);
                }
                else {
                    let [what, arg1, arg2, obj] = args;
                    return os.Message.obtain(this, what, arg1, arg2, obj);
                }
            }
            post(r) {
                return this.sendMessageDelayed(Handler.getPostMessage(r), 0);
            }
            postAtTime(...args) {
                if (args.length === 2) {
                    let [r, uptimeMillis] = args;
                    return this.sendMessageAtTime(Handler.getPostMessage(r), uptimeMillis);
                }
                else {
                    let [r, token, uptimeMillis] = args;
                    return this.sendMessageAtTime(Handler.getPostMessage(r, token), uptimeMillis);
                }
            }
            postDelayed(r, delayMillis) {
                return this.sendMessageDelayed(Handler.getPostMessage(r), delayMillis);
            }
            postAtFrontOfQueue(r) {
                return this.post(r);
            }
            removeCallbacks(r, token) {
                this.mQueue.removeMessages(this, r, token);
            }
            sendMessage(msg) {
                return this.sendMessageDelayed(msg, 0);
            }
            sendEmptyMessage(what) {
                return this.sendEmptyMessageDelayed(what, 0);
            }
            sendEmptyMessageDelayed(what, delayMillis) {
                let msg = os.Message.obtain();
                msg.what = what;
                return this.sendMessageDelayed(msg, delayMillis);
            }
            sendEmptyMessageAtTime(what, uptimeMillis) {
                let msg = os.Message.obtain();
                msg.what = what;
                return this.sendMessageAtTime(msg, uptimeMillis);
            }
            sendMessageDelayed(msg, delayMillis) {
                if (delayMillis < 0) {
                    delayMillis = 0;
                }
                msg.target = this;
                let func = () => {
                    this.dispatchMessage(msg);
                    this.mQueue.recycleMessage(this, msg);
                };
                if (delayMillis <= 17) {
                    var id = -requestAnimationFrame(func);
                }
                else {
                    var id = setTimeout(func, delayMillis);
                }
                this.mQueue.addMessage(this, msg, id);
                return true;
            }
            sendMessageAtTime(msg, uptimeMillis) {
                return this.sendMessageDelayed(msg, uptimeMillis - os.SystemClock.uptimeMillis());
            }
            sendMessageAtFrontOfQueue(msg) {
                return this.sendMessage(msg);
            }
            removeMessages(what, object) {
                this.mQueue.removeMessages(this, what, object);
            }
            removeCallbacksAndMessages(token) {
                this.mQueue.removeCallbacksAndMessages(this, token);
            }
            hasMessages(what, object) {
                return this.mQueue.hasMessages(this, what, object);
            }
            static getPostMessage(r, token) {
                let m = os.Message.obtain();
                m.obj = token;
                m.callback = r;
                return m;
            }
        }
        os.Handler = Handler;
    })(os = android.os || (android.os = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/29.
 */
///<reference path="../../util/SparseArray.ts"/>
///<reference path="../../../java/lang/ref/WeakReference.ts"/>
///<reference path="../../util/StateSet.ts"/>
var android;
(function (android) {
    var content;
    (function (content) {
        var res;
        (function (res) {
            var SparseArray = android.util.SparseArray;
            var StateSet = android.util.StateSet;
            var WeakReference = java.lang.ref.WeakReference;
            class ColorStateList {
                constructor(states, colors) {
                    this.mDefaultColor = 0xffff0000;
                    this.mStateSpecs = states;
                    this.mColors = colors;
                    if (states.length > 0) {
                        this.mDefaultColor = colors[0];
                        for (let i = 0; i < states.length; i++) {
                            if (states[i].length == 0) {
                                this.mDefaultColor = colors[i];
                            }
                        }
                    }
                }
                static valueOf(color) {
                    let ref = ColorStateList.sCache.get(color);
                    let csl = ref != null ? ref.get() : null;
                    if (csl != null) {
                        return csl;
                    }
                    csl = new ColorStateList(ColorStateList.EMPTY, [color]);
                    ColorStateList.sCache.put(color, new WeakReference(csl));
                    return csl;
                }
                withAlpha(alpha) {
                    let colors = new Array(this.mColors.length);
                    let len = colors.length;
                    for (let i = 0; i < len; i++) {
                        colors[i] = (this.mColors[i] & 0xFFFFFF) | (alpha << 24);
                    }
                    return new ColorStateList(this.mStateSpecs, colors);
                }
                isStateful() {
                    return this.mStateSpecs.length > 1;
                }
                getColorForState(stateSet, defaultColor) {
                    const setLength = this.mStateSpecs.length;
                    for (let i = 0; i < setLength; i++) {
                        let stateSpec = this.mStateSpecs[i];
                        if (StateSet.stateSetMatches(stateSpec, stateSet)) {
                            return this.mColors[i];
                        }
                    }
                    return defaultColor;
                }
                getDefaultColor() {
                    return this.mDefaultColor;
                }
                toString() {
                    return "ColorStateList{" +
                        "mStateSpecs=" + JSON.stringify(this.mStateSpecs) +
                        "mColors=" + JSON.stringify(this.mColors) +
                        "mDefaultColor=" + this.mDefaultColor + '}';
                }
            }
            ColorStateList.EMPTY = [[]];
            ColorStateList.sCache = new SparseArray();
            res.ColorStateList = ColorStateList;
        })(res = content.res || (content.res = {}));
    })(content = android.content || (android.content = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/27.
 */
///<reference path="DisplayMetrics.ts"/>
///<reference path="../content/res/Resources.ts"/>
var android;
(function (android) {
    var util;
    (function (util) {
        var Resources = android.content.res.Resources;
        class TypedValue {
            static initUnit() {
                this.initUnit = null;
                let temp = document.createElement('div');
                document.body.appendChild(temp);
                temp.style.height = 100 + TypedValue.COMPLEX_UNIT_PT;
                TypedValue.UNIT_SCALE_PT = temp.offsetHeight / 100;
                temp.style.height = 1 + TypedValue.COMPLEX_UNIT_IN;
                TypedValue.UNIT_SCALE_IN = temp.offsetHeight;
                temp.style.height = 100 + TypedValue.COMPLEX_UNIT_MM;
                TypedValue.UNIT_SCALE_MM = temp.offsetHeight / 100;
                temp.style.height = 10 + TypedValue.COMPLEX_UNIT_EM;
                TypedValue.UNIT_SCALE_EM = temp.offsetHeight / 10;
                temp.style.height = 10 + TypedValue.COMPLEX_UNIT_REM;
                TypedValue.UNIT_SCALE_REM = temp.offsetHeight / 10;
                document.body.removeChild(temp);
            }
            static complexToDimensionPixelSize(valueWithUnit, baseValue = 0, metrics = Resources.getDisplayMetrics()) {
                if (this.initUnit)
                    this.initUnit();
                if (valueWithUnit === undefined || valueWithUnit === null) {
                    throw Error('complexToDimensionPixelSize error: valueWithUnit is ' + valueWithUnit);
                }
                if (valueWithUnit === '' + (Number.parseInt(valueWithUnit)))
                    return Number.parseInt(valueWithUnit);
                if (typeof valueWithUnit !== 'string')
                    valueWithUnit = valueWithUnit + "";
                let scale = 1;
                if (valueWithUnit.endsWith(TypedValue.COMPLEX_UNIT_PX)) {
                    valueWithUnit = valueWithUnit.replace(TypedValue.COMPLEX_UNIT_PX, "");
                }
                else if (valueWithUnit.endsWith(TypedValue.COMPLEX_UNIT_DP)) {
                    valueWithUnit = valueWithUnit.replace(TypedValue.COMPLEX_UNIT_DP, "");
                    scale = metrics.density;
                }
                else if (valueWithUnit.endsWith(TypedValue.COMPLEX_UNIT_DIP)) {
                    valueWithUnit = valueWithUnit.replace(TypedValue.COMPLEX_UNIT_DIP, "");
                    scale = metrics.density;
                }
                else if (valueWithUnit.endsWith(TypedValue.COMPLEX_UNIT_SP)) {
                    valueWithUnit = valueWithUnit.replace(TypedValue.COMPLEX_UNIT_SP, "");
                    scale = metrics.density * TypedValue.UNIT_SCALE_SP;
                }
                else if (valueWithUnit.endsWith(TypedValue.COMPLEX_UNIT_PT)) {
                    valueWithUnit = valueWithUnit.replace(TypedValue.COMPLEX_UNIT_PT, "");
                    scale = TypedValue.UNIT_SCALE_PT;
                }
                else if (valueWithUnit.endsWith(TypedValue.COMPLEX_UNIT_IN)) {
                    valueWithUnit = valueWithUnit.replace(TypedValue.COMPLEX_UNIT_IN, "");
                    scale = TypedValue.UNIT_SCALE_IN;
                }
                else if (valueWithUnit.endsWith(TypedValue.COMPLEX_UNIT_MM)) {
                    valueWithUnit = valueWithUnit.replace(TypedValue.COMPLEX_UNIT_MM, "");
                    scale = TypedValue.UNIT_SCALE_MM;
                }
                else if (valueWithUnit.endsWith(TypedValue.COMPLEX_UNIT_EM)) {
                    valueWithUnit = valueWithUnit.replace(TypedValue.COMPLEX_UNIT_EM, "");
                    scale = TypedValue.UNIT_SCALE_EM;
                }
                else if (valueWithUnit.endsWith(TypedValue.COMPLEX_UNIT_REM)) {
                    valueWithUnit = valueWithUnit.replace(TypedValue.COMPLEX_UNIT_REM, "");
                    scale = TypedValue.UNIT_SCALE_REM;
                }
                else if (valueWithUnit.endsWith(TypedValue.COMPLEX_UNIT_VH)) {
                    valueWithUnit = valueWithUnit.replace(TypedValue.COMPLEX_UNIT_VH, "");
                    scale = metrics.heightPixels / 100;
                }
                else if (valueWithUnit.endsWith(TypedValue.COMPLEX_UNIT_VW)) {
                    valueWithUnit = valueWithUnit.replace(TypedValue.COMPLEX_UNIT_VW, "");
                    scale = metrics.widthPixels / 100;
                }
                else if (valueWithUnit.endsWith(TypedValue.COMPLEX_UNIT_FRACTION)) {
                    valueWithUnit = valueWithUnit.replace(TypedValue.COMPLEX_UNIT_FRACTION, "");
                    scale = Number.parseInt(valueWithUnit) / 100;
                    if (Number.isNaN(scale))
                        return 0;
                    valueWithUnit = baseValue;
                }
                let value = Number.parseInt(valueWithUnit);
                if (Number.isNaN(value))
                    throw Error('complexToDimensionPixelSize error: ' + valueWithUnit);
                return value * scale;
            }
        }
        TypedValue.COMPLEX_UNIT_PX = 'px';
        TypedValue.COMPLEX_UNIT_DP = 'dp';
        TypedValue.COMPLEX_UNIT_DIP = 'dip';
        TypedValue.COMPLEX_UNIT_SP = 'sp';
        TypedValue.COMPLEX_UNIT_PT = 'pt';
        TypedValue.COMPLEX_UNIT_IN = 'in';
        TypedValue.COMPLEX_UNIT_MM = 'mm';
        TypedValue.COMPLEX_UNIT_EM = 'em';
        TypedValue.COMPLEX_UNIT_REM = 'rem';
        TypedValue.COMPLEX_UNIT_VH = 'vh';
        TypedValue.COMPLEX_UNIT_VW = 'vw';
        TypedValue.COMPLEX_UNIT_FRACTION = '%';
        TypedValue.UNIT_SCALE_SP = 1;
        util.TypedValue = TypedValue;
    })(util = android.util || (android.util = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/9.
 */
///<reference path="../graphics/Rect.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        class Gravity {
            static apply(gravity, w, h, container, outRect) {
                let xAdj = 0, yAdj = 0;
                switch (gravity & ((Gravity.AXIS_PULL_BEFORE | Gravity.AXIS_PULL_AFTER) << Gravity.AXIS_X_SHIFT)) {
                    case 0:
                        outRect.left = container.left
                            + ((container.right - container.left - w) / 2) + xAdj;
                        outRect.right = outRect.left + w;
                        if ((gravity & (Gravity.AXIS_CLIP << Gravity.AXIS_X_SHIFT))
                            == (Gravity.AXIS_CLIP << Gravity.AXIS_X_SHIFT)) {
                            if (outRect.left < container.left) {
                                outRect.left = container.left;
                            }
                            if (outRect.right > container.right) {
                                outRect.right = container.right;
                            }
                        }
                        break;
                    case Gravity.AXIS_PULL_BEFORE << Gravity.AXIS_X_SHIFT:
                        outRect.left = container.left + xAdj;
                        outRect.right = outRect.left + w;
                        if ((gravity & (Gravity.AXIS_CLIP << Gravity.AXIS_X_SHIFT))
                            == (Gravity.AXIS_CLIP << Gravity.AXIS_X_SHIFT)) {
                            if (outRect.right > container.right) {
                                outRect.right = container.right;
                            }
                        }
                        break;
                    case Gravity.AXIS_PULL_AFTER << Gravity.AXIS_X_SHIFT:
                        outRect.right = container.right - xAdj;
                        outRect.left = outRect.right - w;
                        if ((gravity & (Gravity.AXIS_CLIP << Gravity.AXIS_X_SHIFT))
                            == (Gravity.AXIS_CLIP << Gravity.AXIS_X_SHIFT)) {
                            if (outRect.left < container.left) {
                                outRect.left = container.left;
                            }
                        }
                        break;
                    default:
                        outRect.left = container.left + xAdj;
                        outRect.right = container.right + xAdj;
                        break;
                }
                switch (gravity & ((Gravity.AXIS_PULL_BEFORE | Gravity.AXIS_PULL_AFTER) << Gravity.AXIS_Y_SHIFT)) {
                    case 0:
                        outRect.top = container.top
                            + ((container.bottom - container.top - h) / 2) + yAdj;
                        outRect.bottom = outRect.top + h;
                        if ((gravity & (Gravity.AXIS_CLIP << Gravity.AXIS_Y_SHIFT))
                            == (Gravity.AXIS_CLIP << Gravity.AXIS_Y_SHIFT)) {
                            if (outRect.top < container.top) {
                                outRect.top = container.top;
                            }
                            if (outRect.bottom > container.bottom) {
                                outRect.bottom = container.bottom;
                            }
                        }
                        break;
                    case Gravity.AXIS_PULL_BEFORE << Gravity.AXIS_Y_SHIFT:
                        outRect.top = container.top + yAdj;
                        outRect.bottom = outRect.top + h;
                        if ((gravity & (Gravity.AXIS_CLIP << Gravity.AXIS_Y_SHIFT))
                            == (Gravity.AXIS_CLIP << Gravity.AXIS_Y_SHIFT)) {
                            if (outRect.bottom > container.bottom) {
                                outRect.bottom = container.bottom;
                            }
                        }
                        break;
                    case Gravity.AXIS_PULL_AFTER << Gravity.AXIS_Y_SHIFT:
                        outRect.bottom = container.bottom - yAdj;
                        outRect.top = outRect.bottom - h;
                        if ((gravity & (Gravity.AXIS_CLIP << Gravity.AXIS_Y_SHIFT))
                            == (Gravity.AXIS_CLIP << Gravity.AXIS_Y_SHIFT)) {
                            if (outRect.top < container.top) {
                                outRect.top = container.top;
                            }
                        }
                        break;
                    default:
                        outRect.top = container.top + yAdj;
                        outRect.bottom = container.bottom + yAdj;
                        break;
                }
            }
        }
        Gravity.NO_GRAVITY = 0x0000;
        Gravity.AXIS_SPECIFIED = 0x0001;
        Gravity.AXIS_PULL_BEFORE = 0x0002;
        Gravity.AXIS_PULL_AFTER = 0x0004;
        Gravity.AXIS_CLIP = 0x0008;
        Gravity.AXIS_X_SHIFT = 0;
        Gravity.AXIS_Y_SHIFT = 4;
        Gravity.TOP = (Gravity.AXIS_PULL_BEFORE | Gravity.AXIS_SPECIFIED) << Gravity.AXIS_Y_SHIFT;
        Gravity.BOTTOM = (Gravity.AXIS_PULL_AFTER | Gravity.AXIS_SPECIFIED) << Gravity.AXIS_Y_SHIFT;
        Gravity.LEFT = (Gravity.AXIS_PULL_BEFORE | Gravity.AXIS_SPECIFIED) << Gravity.AXIS_X_SHIFT;
        Gravity.RIGHT = (Gravity.AXIS_PULL_AFTER | Gravity.AXIS_SPECIFIED) << Gravity.AXIS_X_SHIFT;
        Gravity.CENTER_VERTICAL = Gravity.AXIS_SPECIFIED << Gravity.AXIS_Y_SHIFT;
        Gravity.FILL_VERTICAL = Gravity.TOP | Gravity.BOTTOM;
        Gravity.CENTER_HORIZONTAL = Gravity.AXIS_SPECIFIED << Gravity.AXIS_X_SHIFT;
        Gravity.FILL_HORIZONTAL = Gravity.LEFT | Gravity.RIGHT;
        Gravity.CENTER = Gravity.CENTER_VERTICAL | Gravity.CENTER_HORIZONTAL;
        Gravity.FILL = Gravity.FILL_VERTICAL | Gravity.FILL_HORIZONTAL;
        Gravity.CLIP_VERTICAL = Gravity.AXIS_CLIP << Gravity.AXIS_Y_SHIFT;
        Gravity.CLIP_HORIZONTAL = Gravity.AXIS_CLIP << Gravity.AXIS_X_SHIFT;
        Gravity.HORIZONTAL_GRAVITY_MASK = (Gravity.AXIS_SPECIFIED |
            Gravity.AXIS_PULL_BEFORE | Gravity.AXIS_PULL_AFTER) << Gravity.AXIS_X_SHIFT;
        Gravity.VERTICAL_GRAVITY_MASK = (Gravity.AXIS_SPECIFIED |
            Gravity.AXIS_PULL_BEFORE | Gravity.AXIS_PULL_AFTER) << Gravity.AXIS_Y_SHIFT;
        Gravity.DISPLAY_CLIP_VERTICAL = 0x10000000;
        Gravity.DISPLAY_CLIP_HORIZONTAL = 0x01000000;
        view.Gravity = Gravity;
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/1.
 */
///<reference path="Interpolator.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var animation;
        (function (animation) {
            class LinearInterpolator {
                getInterpolation(input) {
                    return input;
                }
            }
            animation.LinearInterpolator = LinearInterpolator;
        })(animation = view.animation || (view.animation = {}));
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/1.
 */
///<reference path="../../os/SystemClock.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var animation;
        (function (animation) {
            var SystemClock = android.os.SystemClock;
            class AnimationUtils {
                static currentAnimationTimeMillis() {
                    return SystemClock.uptimeMillis();
                }
            }
            animation.AnimationUtils = AnimationUtils;
        })(animation = view.animation || (view.animation = {}));
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/3.
 */
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/util/StateSet.ts"/>
var androidui;
(function (androidui) {
    var attr;
    (function (attr) {
        class StateAttr {
            constructor(state) {
                this.attributes = new Map();
                this.stateSpec = state.sort();
            }
            setAttr(name, value) {
                this.attributes.set(name, value);
            }
            hasAttr(name) {
                return this.attributes.has(name);
            }
            getAttrMap() {
                return this.attributes;
            }
            putAll(stateAttr) {
                for (let [key, value] of stateAttr.attributes.entries()) {
                    this.attributes.set(key, value);
                }
            }
            isStateEquals(state) {
                if (!state)
                    return false;
                return this.stateSpec + '' === state.sort() + '';
            }
            isStateMatch(state) {
                return android.util.StateSet.stateSetMatches(this.stateSpec, state);
            }
            mergeRemovedFrom(another) {
                if (!another)
                    return this.attributes;
                let removed = new Map(another.attributes);
                for (let key of this.attributes.keys())
                    removed.delete(key);
                let merge = new Map(this.attributes);
                for (let key of removed.keys())
                    merge.set(key, null);
                return merge;
            }
            static parseStateAttrName(stateDesc) {
                if (stateDesc.startsWith('android:'))
                    stateDesc = stateDesc.substring('android:'.length);
                if (stateDesc.startsWith('state_'))
                    stateDesc = stateDesc.substring('state_'.length);
                let stateSet = new Set();
                let stateParts = stateDesc.split('&');
                for (let part of stateParts) {
                    let sign = 1;
                    while (part.startsWith('!')) {
                        sign *= -1;
                        part = part.substring(1);
                    }
                    let stateValue = android.view.View['VIEW_STATE_' + part.toUpperCase()];
                    if (stateValue !== undefined) {
                        stateSet.add(stateValue * sign);
                    }
                }
                return stateSet;
            }
        }
        attr.StateAttr = StateAttr;
    })(attr = androidui.attr || (androidui.attr = {}));
})(androidui || (androidui = {}));
/**
 * Created by linfaxin on 15/11/3.
 */
///<reference path="StateAttr.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/util/StateSet.ts"/>
var androidui;
(function (androidui) {
    var attr;
    (function (attr_1) {
        class StateAttrList {
            constructor(ele, rootElement) {
                this.list = new Array(0);
                this.match_list = new Array(0);
                this.list.push(new attr_1.StateAttr([]));
                this._initStyleAttributes(ele, [], rootElement);
            }
            _initStyleAttributes(ele, inParseState, rootElement) {
                let attributes = Array.from(ele.attributes);
                attributes.forEach((attr) => {
                    if (attr.name === 'style' || attr.name === 'android:style') {
                        this._initStyleAttr(attr, ele, inParseState, rootElement);
                    }
                });
                attributes.forEach((attr) => {
                    if (attr.name === 'style' || attr.name === 'android:style') {
                        return;
                    }
                    if (attr.name.startsWith('android:state_') || attr.name.startsWith('state_')) {
                        return;
                    }
                    this._initStyleAttr(attr, ele, inParseState, rootElement);
                });
                attributes.forEach((attr) => {
                    if (attr.name.startsWith('android:state_') || attr.name.startsWith('state_')) {
                        this._initStyleAttr(attr, ele, inParseState, rootElement);
                    }
                });
                this.list_reverse = this.list.concat().reverse();
            }
            _initStyleAttr(attr, ele, inParseState, rootElement) {
                let attrName = attr.name;
                if (!attrName.startsWith('android:'))
                    return;
                attrName = attrName.substring('android:'.length);
                if (attrName === 'id')
                    return;
                let attrValue = attr.value;
                if (attrName.startsWith('state_')) {
                    let newStateSet = attr_1.StateAttr.parseStateAttrName(attrName);
                    inParseState = inParseState.concat(Array.from(newStateSet));
                    inParseState = Array.from(new Set(inParseState)).sort();
                }
                let _stateAttr = this.optStateAttr(inParseState);
                if (attrName.startsWith('state_') || attrName === 'style') {
                    if (attrValue.startsWith('@')) {
                        let reference = android.view.View.findReference(attrValue, ele, rootElement, false);
                        this._initStyleAttributes(reference, inParseState, rootElement);
                    }
                    else {
                        for (let part of attrValue.split(';')) {
                            let [name, value] = part.split(':');
                            value = value ? android.view.View.optReferenceString(value.trim(), ele, rootElement) : '';
                            if (name)
                                _stateAttr.setAttr(name.trim().toLowerCase(), value);
                        }
                    }
                }
                else {
                    attrValue = android.view.View.optReferenceString(attrValue, ele, rootElement);
                    _stateAttr.setAttr(attrName, attrValue);
                }
            }
            getDefaultStateAttr() {
                return this.getStateAttr(StateAttrList.EmptyArray);
            }
            getStateAttr(state) {
                for (let stateAttr of this.list) {
                    if (stateAttr.isStateEquals(state))
                        return stateAttr;
                }
            }
            optStateAttr(state) {
                let stateAttr = this.getStateAttr(state);
                if (!stateAttr) {
                    stateAttr = new attr_1.StateAttr(state);
                    this.list.splice(0, 0, stateAttr);
                }
                return stateAttr;
            }
            getMatchedAttr(state) {
                for (let stateAttr of this.match_list) {
                    if (stateAttr.isStateEquals(state))
                        return stateAttr;
                }
                let matchedAttr = new attr_1.StateAttr(state);
                for (let stateAttr of this.list_reverse) {
                    if (stateAttr.isStateMatch(state))
                        matchedAttr.putAll(stateAttr);
                }
                this.match_list.push(matchedAttr);
                return matchedAttr;
            }
        }
        StateAttrList.EmptyArray = [];
        attr_1.StateAttrList = StateAttrList;
    })(attr = androidui.attr || (androidui.attr = {}));
})(androidui || (androidui = {}));
var androidui;
(function (androidui) {
    var util;
    (function (util) {
        class ClassFinder {
            static findClass(classFullName, findInRoot = window) {
                let nameParts = classFullName.split('.');
                let finding = findInRoot;
                for (let part of nameParts) {
                    let quickFind = finding[part.toLowerCase()];
                    if (quickFind) {
                        finding = quickFind;
                        continue;
                    }
                    let found = false;
                    for (let key in finding) {
                        if (key.toUpperCase() === part.toUpperCase()) {
                            finding = finding[key];
                            found = true;
                            break;
                        }
                    }
                    if (!found)
                        return null;
                }
                if (finding === findInRoot) {
                    return null;
                }
                return finding;
            }
        }
        util.ClassFinder = ClassFinder;
    })(util = androidui.util || (androidui.util = {}));
})(androidui || (androidui = {}));
/**
 * Created by linfaxin on 15/11/16.
 */
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../content/res/Resources.ts"/>
///<reference path="../graphics/Rect.ts"/>
///<reference path="../view/ViewConfiguration.ts"/>
///<reference path="../os/SystemClock.ts"/>
///<reference path="../util/Log.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var SystemClock = android.os.SystemClock;
        var Log = android.util.Log;
        const DEBUG = false;
        const TAG = "KeyEvent";
        class KeyEvent {
            constructor() {
                this._downingKeyEventMap = new Map();
            }
            appendKeyEvent(keyEvent, action) {
                this._activeKeyEvent = keyEvent;
                if (action === KeyEvent.ACTION_DOWN) {
                    this.mDownTime = SystemClock.uptimeMillis();
                    let keyEvents = this._downingKeyEventMap.get(keyEvent.keyCode);
                    if (keyEvents == null) {
                        keyEvents = [];
                        this._downingKeyEventMap.set(keyEvent.keyCode, keyEvents);
                    }
                    keyEvents.push(keyEvent);
                }
                else if (action === KeyEvent.ACTION_UP) {
                    this._downingKeyEventMap.delete(keyEvent.keyCode);
                }
                this.mAction = action;
            }
            static isConfirmKey(keyCode) {
                switch (keyCode) {
                    case KeyEvent.KEYCODE_DPAD_CENTER:
                    case KeyEvent.KEYCODE_ENTER:
                        return true;
                    default:
                        return false;
                }
            }
            isAltPressed() {
                return this._activeKeyEvent.altKey;
            }
            isShiftPressed() {
                return this._activeKeyEvent.shiftKey;
            }
            isCtrlPressed() {
                return this._activeKeyEvent.ctrlKey;
            }
            isMetaPressed() {
                return this._activeKeyEvent.metaKey;
            }
            getAction() {
                return this.mAction;
            }
            startTracking() {
                this.mFlags |= KeyEvent.FLAG_START_TRACKING;
            }
            isTracking() {
                return (this.mFlags & KeyEvent.FLAG_TRACKING) != 0;
            }
            isLongPress() {
                return this.getRepeatCount() === 1;
            }
            getKeyCode() {
                return this._activeKeyEvent.keyCode;
            }
            getRepeatCount() {
                let downArray = this._downingKeyEventMap.get(this._activeKeyEvent.keyCode);
                return downArray ? downArray.length - 1 : 0;
            }
            getDownTime() {
                return this.mDownTime;
            }
            getEventTime() {
                return this._activeKeyEvent.timeStamp;
            }
            dispatch(receiver, state, target) {
                switch (this.mAction) {
                    case KeyEvent.ACTION_DOWN: {
                        this.mFlags &= ~KeyEvent.FLAG_START_TRACKING;
                        if (DEBUG)
                            Log.v(TAG, "Key down to " + target + " in " + state
                                + ": " + this);
                        let res = receiver.onKeyDown(this.getKeyCode(), this);
                        if (state != null) {
                            if (res && this.getRepeatCount() == 0 && (this.mFlags & KeyEvent.FLAG_START_TRACKING) != 0) {
                                if (DEBUG)
                                    Log.v(TAG, "  Start tracking!");
                                state.startTracking(this, target);
                            }
                            else if (this.isLongPress() && state.isTracking(this)) {
                                if (receiver.onKeyLongPress(this.getKeyCode(), this)) {
                                    if (DEBUG)
                                        Log.v(TAG, "  Clear from long press!");
                                    state.performedLongPress(this);
                                    res = true;
                                }
                            }
                        }
                        return res;
                    }
                    case KeyEvent.ACTION_UP:
                        if (DEBUG)
                            Log.v(TAG, "Key up to " + target + " in " + state
                                + ": " + this);
                        if (state != null) {
                            state.handleUpEvent(this);
                        }
                        return receiver.onKeyUp(this.getKeyCode(), this);
                }
                return false;
            }
            hasNoModifiers() {
                if (this.isAltPressed())
                    return false;
                if (this.isShiftPressed())
                    return false;
                if (this.isCtrlPressed())
                    return false;
                if (this.isMetaPressed())
                    return false;
                return true;
            }
            hasModifiers(modifiers) {
                if ((modifiers & KeyEvent.META_ALT_ON) === KeyEvent.META_ALT_ON && this.isAltPressed())
                    return true;
                if ((modifiers & KeyEvent.META_SHIFT_ON) === KeyEvent.META_SHIFT_ON && this.isShiftPressed())
                    return true;
                if ((modifiers & KeyEvent.META_META_ON) === KeyEvent.META_META_ON && this.isMetaPressed())
                    return true;
                if ((modifiers & KeyEvent.META_CTRL_ON) === KeyEvent.META_CTRL_ON && this.isCtrlPressed())
                    return true;
            }
            getMetaState() {
                let meta = 0;
                if (this.isAltPressed())
                    meta |= KeyEvent.META_ALT_ON;
                if (this.isShiftPressed())
                    meta |= KeyEvent.META_SHIFT_ON;
                if (this.isCtrlPressed())
                    meta |= KeyEvent.META_CTRL_ON;
                if (this.isMetaPressed())
                    meta |= KeyEvent.META_META_ON;
                return meta;
            }
            toString() {
                return JSON.stringify(this._activeKeyEvent);
            }
            static actionToString(action) {
                switch (action) {
                    case KeyEvent.ACTION_DOWN:
                        return "ACTION_DOWN";
                    case KeyEvent.ACTION_UP:
                        return "ACTION_UP";
                    default:
                        return '' + (action);
                }
            }
            static keyCodeToString(keyCode) {
                return String.fromCharCode(keyCode);
            }
        }
        KeyEvent.KEYCODE_DPAD_UP = 38;
        KeyEvent.KEYCODE_DPAD_DOWN = 40;
        KeyEvent.KEYCODE_DPAD_LEFT = 37;
        KeyEvent.KEYCODE_DPAD_RIGHT = 39;
        KeyEvent.KEYCODE_DPAD_CENTER = 13;
        KeyEvent.KEYCODE_ENTER = 13;
        KeyEvent.KEYCODE_TAB = 9;
        KeyEvent.KEYCODE_SPACE = 32;
        KeyEvent.KEYCODE_ESCAPE = 27;
        KeyEvent.KEYCODE_PAGE_UP = 33;
        KeyEvent.KEYCODE_PAGE_DOWN = 34;
        KeyEvent.KEYCODE_MOVE_HOME = 36;
        KeyEvent.KEYCODE_MOVE_END = 35;
        KeyEvent.ACTION_DOWN = 0;
        KeyEvent.ACTION_UP = 1;
        KeyEvent.META_ALT_ON = 0x02;
        KeyEvent.META_SHIFT_ON = 0x1;
        KeyEvent.META_CTRL_ON = 0x1000;
        KeyEvent.META_META_ON = 0x10000;
        KeyEvent.FLAG_CANCELED = 0x20;
        KeyEvent.FLAG_CANCELED_LONG_PRESS = 0x100;
        KeyEvent.FLAG_LONG_PRESS = 0x80;
        KeyEvent.FLAG_TRACKING = 0x200;
        KeyEvent.FLAG_START_TRACKING = 0x40000000;
        view.KeyEvent = KeyEvent;
        (function (KeyEvent) {
            class DispatcherState {
                constructor() {
                    this.mActiveLongPresses = new android.util.SparseArray();
                }
                reset(target) {
                    if (target == null) {
                        if (DEBUG)
                            Log.v(TAG, "Reset: " + this);
                        this.mDownKeyCode = 0;
                        this.mDownTarget = null;
                        this.mActiveLongPresses.clear();
                    }
                    else {
                        if (this.mDownTarget == target) {
                            if (DEBUG)
                                Log.v(TAG, "Reset in " + target + ": " + this);
                            this.mDownKeyCode = 0;
                            this.mDownTarget = null;
                        }
                    }
                }
                startTracking(event, target) {
                    if (event.getAction() != KeyEvent.ACTION_DOWN) {
                        throw new Error("Can only start tracking on a down event");
                    }
                    if (DEBUG)
                        Log.v(TAG, "Start trackingt in " + target + ": " + this);
                    this.mDownKeyCode = event.getKeyCode();
                    this.mDownTarget = target;
                }
                isTracking(event) {
                    return this.mDownKeyCode == event.getKeyCode();
                }
                performedLongPress(event) {
                    this.mActiveLongPresses.put(event.getKeyCode(), 1);
                }
                handleUpEvent(event) {
                    const keyCode = event.getKeyCode();
                    if (DEBUG)
                        Log.v(TAG, "Handle key up " + event + ": " + this);
                    let index = this.mActiveLongPresses.indexOfKey(keyCode);
                    if (index >= 0) {
                        if (DEBUG)
                            Log.v(TAG, "  Index: " + index);
                        event.mFlags |= KeyEvent.FLAG_CANCELED | KeyEvent.FLAG_CANCELED_LONG_PRESS;
                        this.mActiveLongPresses.removeAt(index);
                    }
                    if (this.mDownKeyCode == keyCode) {
                        if (DEBUG)
                            Log.v(TAG, "  Tracking!");
                        event.mFlags |= KeyEvent.FLAG_TRACKING;
                        this.mDownKeyCode = 0;
                        this.mDownTarget = null;
                    }
                }
            }
            KeyEvent.DispatcherState = DispatcherState;
        })(KeyEvent = view.KeyEvent || (view.KeyEvent = {}));
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/9/27.
 */
///<reference path="../util/SparseArray.ts"/>
///<reference path="../util/Log.ts"/>
///<reference path="../graphics/drawable/Drawable.ts"/>
///<reference path="../graphics/drawable/ColorDrawable.ts"/>
///<reference path="../graphics/drawable/ScrollBarDrawable.ts"/>
///<reference path="../graphics/drawable/InsetDrawable.ts"/>
///<reference path="../graphics/PixelFormat.ts"/>
///<reference path="../graphics/Matrix.ts"/>
///<reference path="../graphics/Color.ts"/>
///<reference path="../graphics/Paint.ts"/>
///<reference path="../../java/lang/StringBuilder.ts"/>
///<reference path="../../java/lang/Runnable.ts"/>
///<reference path="../../java/lang/util/concurrent/CopyOnWriteArrayList.ts"/>
///<reference path="../../java/util/ArrayList.ts"/>
///<reference path="ViewRootImpl.ts"/>
///<reference path="ViewParent.ts"/>
///<reference path="ViewGroup.ts"/>
///<reference path="ViewOverlay.ts"/>
///<reference path="ViewTreeObserver.ts"/>
///<reference path="MotionEvent.ts"/>
///<reference path="TouchDelegate.ts"/>
///<reference path="../os/Handler.ts"/>
///<reference path="../os/SystemClock.ts"/>
///<reference path="../content/res/Resources.ts"/>
///<reference path="../content/res/ColorStateList.ts"/>
///<reference path="../graphics/Rect.ts"/>
///<reference path="../graphics/Canvas.ts"/>
///<reference path="../util/Pools.ts"/>
///<reference path="../util/TypedValue.ts"/>
///<reference path="Gravity.ts"/>
///<reference path="../view/animation/LinearInterpolator.ts"/>
///<reference path="../view/animation/AnimationUtils.ts"/>
///<reference path="../../java/lang/System.ts"/>
///<reference path="../../androidui/attr/StateAttrList.ts"/>
///<reference path="../../androidui/attr/StateAttr.ts"/>
///<reference path="../../androidui/util/ClassFinder.ts"/>
///<reference path="../../androidui/widget/HtmlDataAdapter.ts"/>
///<reference path="KeyEvent.ts"/>
var android;
(function (android) {
    var view;
    (function (view_1) {
        var ColorDrawable = android.graphics.drawable.ColorDrawable;
        var ScrollBarDrawable = android.graphics.drawable.ScrollBarDrawable;
        var InsetDrawable = android.graphics.drawable.InsetDrawable;
        var PixelFormat = android.graphics.PixelFormat;
        var Matrix = android.graphics.Matrix;
        var Color = android.graphics.Color;
        var StringBuilder = java.lang.StringBuilder;
        var System = java.lang.System;
        var SystemClock = android.os.SystemClock;
        var Log = android.util.Log;
        var Rect = android.graphics.Rect;
        var CopyOnWriteArrayList = java.lang.util.concurrent.CopyOnWriteArrayList;
        var ArrayList = java.util.ArrayList;
        var Resources = android.content.res.Resources;
        var ColorStateList = android.content.res.ColorStateList;
        var Pools = android.util.Pools;
        var TypedValue = android.util.TypedValue;
        var LinearInterpolator = android.view.animation.LinearInterpolator;
        var AnimationUtils = android.view.animation.AnimationUtils;
        var StateAttrList = androidui.attr.StateAttrList;
        var ClassFinder = androidui.util.ClassFinder;
        var KeyEvent = android.view.KeyEvent;
        class View {
            constructor() {
                this.mPrivateFlags = 0;
                this.mPrivateFlags2 = 0;
                this.mPrivateFlags3 = 0;
                this.mOldWidthMeasureSpec = Number.MIN_SAFE_INTEGER;
                this.mOldHeightMeasureSpec = Number.MIN_SAFE_INTEGER;
                this.mMeasuredWidth = 0;
                this.mMeasuredHeight = 0;
                this.mBackgroundSizeChanged = false;
                this.mHasPerformedLongPress = false;
                this.mMinWidth = 0;
                this.mMinHeight = 0;
                this.mDrawingCacheBackgroundColor = 0;
                this.mTouchSlop = 0;
                this.mVerticalScrollFactor = 0;
                this.mOverScrollMode = 0;
                this.mViewFlags = 0;
                this.mLayerType = View.LAYER_TYPE_NONE;
                this.mCachingFailed = false;
                this.mWindowAttachCount = 0;
                this.mTransientStateCount = 0;
                this.mLastIsOpaque = false;
                this._mLeft = 0;
                this._mRight = 0;
                this._mTop = 0;
                this._mBottom = 0;
                this._mScrollX = 0;
                this._mScrollY = 0;
                this.mPaddingLeft = 0;
                this.mPaddingRight = 0;
                this.mPaddingTop = 0;
                this.mPaddingBottom = 0;
                this._attrChangeHandler = new View.AttrChangeHandler(this);
                this.mTouchSlop = view_1.ViewConfiguration.get().getScaledTouchSlop();
                this.setOverScrollMode(View.OVER_SCROLL_IF_CONTENT_SCROLLS);
            }
            static get class() {
                let name = this.name;
                return {
                    getName() {
                        return name;
                    }
                };
            }
            get mID() {
                if (this._bindElement) {
                    let id = this._bindElement.id;
                    return id ? id : null;
                }
                return null;
            }
            get mLeft() { return this._mLeft; }
            set mLeft(value) { this._mLeft = Math.floor(value); }
            get mRight() { return this._mRight; }
            set mRight(value) { this._mRight = Math.floor(value); }
            get mTop() { return this._mTop; }
            set mTop(value) { this._mTop = Math.floor(value); }
            get mBottom() { return this._mBottom; }
            set mBottom(value) { this._mBottom = Math.floor(value); }
            get mScrollX() { return this._mScrollX; }
            set mScrollX(value) { this._mScrollX = Math.floor(value); }
            get mScrollY() { return this._mScrollY; }
            set mScrollY(value) { this._mScrollY = Math.floor(value); }
            createAttrChangeHandler(mergeHandler) {
                let view = this;
                mergeHandler.add({
                    set background(value) {
                        let bg = mergeHandler.parseDrawable(value);
                        view.setBackground(bg);
                    },
                    get background() {
                        if (view.mBackground instanceof ColorDrawable) {
                            return Color.toRGBA(view.mBackground.getColor());
                        }
                        return view.mBackground;
                    },
                    set padding(value) {
                        let [left, top, right, bottom] = View.AttrChangeHandler.parsePaddingMarginLTRB(value);
                        view._setPaddingWithUnit(left, top, right, bottom);
                    },
                    get padding() {
                        return view.mPaddingTop + ' ' + view.mPaddingRight + ' ' + view.mPaddingBottom + ' ' + view.mPaddingLeft;
                    },
                    set paddingLeft(value) {
                        view._setPaddingWithUnit(value, view.mPaddingTop, view.mPaddingRight, view.mPaddingBottom);
                    },
                    get paddingLeft() {
                        return view.mPaddingLeft;
                    },
                    set paddingTop(value) {
                        view._setPaddingWithUnit(view.mPaddingLeft, value, view.mPaddingRight, view.mPaddingBottom);
                    },
                    get paddingTop() {
                        return view.mPaddingTop;
                    },
                    set paddingRight(value) {
                        view._setPaddingWithUnit(view.mPaddingLeft, view.mPaddingTop, value, view.mPaddingBottom);
                    },
                    get paddingRight() {
                        return view.mPaddingRight;
                    },
                    set paddingBottom(value) {
                        view._setPaddingWithUnit(view.mPaddingLeft, view.mPaddingTop, view.mPaddingRight, value);
                    },
                    get paddingBottom() {
                        return view.mPaddingBottom;
                    },
                    set scrollX(value) {
                        value = Number.parseInt(value);
                        if (Number.isInteger(value))
                            view.scrollTo(value, view.mScrollY);
                    },
                    set scrollY(value) {
                        value = Number.parseInt(value);
                        if (Number.isInteger(value))
                            view.scrollTo(view.mScrollX, value);
                    },
                    set alpha(value) {
                        value = Number.parseInt(value);
                        if (Number.isInteger(value)) {
                        }
                        ;
                    },
                    set transformPivotX(value) {
                        value = Number.parseInt(value);
                        if (Number.isInteger(value)) {
                        }
                        ;
                    },
                    set transformPivotY(value) {
                        value = Number.parseInt(value);
                        if (Number.isInteger(value)) {
                        }
                        ;
                    },
                    set translationX(value) {
                        value = Number.parseInt(value);
                        if (Number.isInteger(value)) {
                        }
                        ;
                    },
                    set translationY(value) {
                        value = Number.parseInt(value);
                        if (Number.isInteger(value)) {
                        }
                        ;
                    },
                    set rotation(value) {
                        value = Number.parseInt(value);
                        if (Number.isInteger(value)) {
                        }
                        ;
                    },
                    set rotationX(value) {
                        value = Number.parseInt(value);
                        if (Number.isInteger(value)) {
                        }
                        ;
                    },
                    set rotationY(value) {
                        value = Number.parseInt(value);
                        if (Number.isInteger(value)) {
                        }
                        ;
                    },
                    set scaleX(value) {
                        value = Number.parseInt(value);
                        if (Number.isInteger(value)) {
                        }
                        ;
                    },
                    set scaleY(value) {
                        value = Number.parseInt(value);
                        if (Number.isInteger(value)) {
                        }
                        ;
                    },
                    set tag(value) {
                    },
                    set id(value) {
                        view.setId(value);
                    },
                    set focusable(value) {
                        if (View.AttrChangeHandler.parseBoolean(value, false)) {
                            view.setFlags(View.FOCUSABLE, View.FOCUSABLE_MASK);
                        }
                    },
                    set focusableInTouchMode(value) {
                        if (View.AttrChangeHandler.parseBoolean(value, false)) {
                            view.setFlags(View.FOCUSABLE_IN_TOUCH_MODE | View.FOCUSABLE, View.FOCUSABLE_IN_TOUCH_MODE | View.FOCUSABLE_MASK);
                        }
                    },
                    set clickable(value) {
                        if (View.AttrChangeHandler.parseBoolean(value, false)) {
                            view.setFlags(View.CLICKABLE, View.CLICKABLE);
                        }
                    },
                    set longClickable(value) {
                        if (View.AttrChangeHandler.parseBoolean(value, false)) {
                            view.setFlags(View.LONG_CLICKABLE, View.LONG_CLICKABLE);
                        }
                    },
                    set saveEnabled(value) {
                        if (View.AttrChangeHandler.parseBoolean(value, false)) {
                        }
                    },
                    set duplicateParentState(value) {
                        if (View.AttrChangeHandler.parseBoolean(value, false)) {
                            view.setFlags(View.DUPLICATE_PARENT_STATE, View.DUPLICATE_PARENT_STATE);
                        }
                    },
                    set visibility(value) {
                        if (value === 'gone')
                            view.setVisibility(View.GONE);
                        else if (value === 'invisible')
                            view.setVisibility(View.INVISIBLE);
                        else if (value === 'visible')
                            view.setVisibility(View.VISIBLE);
                    },
                    set scrollbars(value) {
                        if (value === 'none') {
                            view.setHorizontalScrollBarEnabled(false);
                            view.setVerticalScrollBarEnabled(false);
                        }
                    },
                    set isScrollContainer(value) {
                        if (View.AttrChangeHandler.parseBoolean(value, false)) {
                            this.setScrollContainer(true);
                        }
                    },
                    set minWidth(value) {
                        value = Number.parseInt(value);
                        if (Number.isInteger(value))
                            view.setMinimumWidth(value);
                    },
                    get minWidth() {
                        return view.mMinWidth;
                    },
                    set minHeight(value) {
                        view.mMinHeight = value;
                    },
                    get minHeight() {
                        return view.mMinHeight;
                    },
                    set onClick(value) {
                        view.setOnClickListener({
                            onClick(v) {
                                let activity = view.getViewRootImpl().rootElement;
                                if (activity && typeof activity[value] === 'function') {
                                    activity[value].call(activity, v);
                                }
                            }
                        });
                    },
                    set overScrollMode(value) {
                        let scrollMode = View[('OVER_SCROLL_' + value).toUpperCase()];
                        if (scrollMode === undefined)
                            scrollMode = View.OVER_SCROLL_IF_CONTENT_SCROLLS;
                        view.setOverScrollMode(scrollMode);
                    },
                    set layerType(value) {
                    },
                });
                mergeHandler.isCallSuper = true;
            }
            getWidth() {
                return this.mRight - this.mLeft;
            }
            getHeight() {
                return this.mBottom - this.mTop;
            }
            getTop() {
                return this.mTop;
            }
            setTop(top) {
                if (top != this.mTop) {
                    if (this.mAttachInfo != null) {
                        let minTop;
                        let yLoc;
                        if (top < this.mTop) {
                            minTop = top;
                            yLoc = top - this.mTop;
                        }
                        else {
                            minTop = this.mTop;
                            yLoc = 0;
                        }
                        this.invalidate(0, yLoc, this.mRight - this.mLeft, this.mBottom - minTop);
                    }
                    let width = this.mRight - this.mLeft;
                    let oldHeight = this.mBottom - this.mTop;
                    this.mTop = top;
                    this.sizeChange(width, this.mBottom - this.mTop, width, oldHeight);
                    this.mBackgroundSizeChanged = true;
                }
            }
            getBottom() {
                return this.mBottom;
            }
            setBottom(bottom) {
                if (bottom != this.mBottom) {
                    if (this.mAttachInfo != null) {
                        let maxBottom;
                        if (bottom < this.mBottom) {
                            maxBottom = this.mBottom;
                        }
                        else {
                            maxBottom = bottom;
                        }
                        this.invalidate(0, 0, this.mRight - this.mLeft, maxBottom - this.mTop);
                    }
                    let width = this.mRight - this.mLeft;
                    let oldHeight = this.mBottom - this.mTop;
                    this.mBottom = bottom;
                    this.sizeChange(width, this.mBottom - this.mTop, width, oldHeight);
                    this.mBackgroundSizeChanged = true;
                }
            }
            getLeft() {
                return this.mLeft;
            }
            setLeft(left) {
                if (left != this.mLeft) {
                    if (this.mAttachInfo != null) {
                        let minLeft;
                        let xLoc;
                        if (left < this.mLeft) {
                            minLeft = left;
                            xLoc = left - this.mLeft;
                        }
                        else {
                            minLeft = this.mLeft;
                            xLoc = 0;
                        }
                        this.invalidate(xLoc, 0, this.mRight - minLeft, this.mBottom - this.mTop);
                    }
                    let oldWidth = this.mRight - this.mLeft;
                    let height = this.mBottom - this.mTop;
                    this.mLeft = left;
                    this.sizeChange(this.mRight - this.mLeft, height, oldWidth, height);
                    this.mBackgroundSizeChanged = true;
                }
            }
            getRight() {
                return this.mRight;
            }
            setRight(right) {
                if (right != this.mRight) {
                    if (this.mAttachInfo != null) {
                        let maxRight;
                        if (right < this.mRight) {
                            maxRight = this.mRight;
                        }
                        else {
                            maxRight = right;
                        }
                        this.invalidate(0, 0, maxRight - this.mLeft, this.mBottom - this.mTop);
                    }
                    let oldWidth = this.mRight - this.mLeft;
                    let height = this.mBottom - this.mTop;
                    this.mRight = right;
                    this.sizeChange(this.mRight - this.mLeft, height, oldWidth, height);
                    this.mBackgroundSizeChanged = true;
                }
            }
            getPaddingLeft() {
                return this.mPaddingLeft;
            }
            getPaddingTop() {
                return this.mPaddingTop;
            }
            getPaddingRight() {
                return this.mPaddingRight;
            }
            getPaddingBottom() {
                return this.mPaddingBottom;
            }
            setPaddingLeft(left) {
                if (this.mPaddingLeft != left) {
                    this.mPaddingLeft = left;
                    this.requestLayout();
                }
            }
            setPaddingTop(top) {
                if (this.mPaddingTop != top) {
                    this.mPaddingTop = top;
                    this.requestLayout();
                }
            }
            setPaddingRight(right) {
                if (this.mPaddingRight != right) {
                    this.mPaddingRight = right;
                    this.requestLayout();
                }
            }
            setPaddingBottom(bottom) {
                if (this.mPaddingBottom != bottom) {
                    this.mPaddingBottom = bottom;
                    this.requestLayout();
                }
            }
            setPadding(left, top, right, bottom) {
                let changed = false;
                if (this.mPaddingLeft != left) {
                    changed = true;
                    this.mPaddingLeft = left;
                }
                if (this.mPaddingTop != top) {
                    changed = true;
                    this.mPaddingTop = top;
                }
                if (this.mPaddingRight != right) {
                    changed = true;
                    this.mPaddingRight = right;
                }
                if (this.mPaddingBottom != bottom) {
                    changed = true;
                    this.mPaddingBottom = bottom;
                }
                if (changed) {
                    this.requestLayout();
                }
            }
            _setPaddingWithUnit(left, top, right, bottom) {
                let view = this;
                let dm = Resources.getDisplayMetrics();
                let width = view.getWidth();
                let height = view.getHeight();
                let padLeft = TypedValue.complexToDimensionPixelSize(left, width, dm);
                let padTop = TypedValue.complexToDimensionPixelSize(top, height, dm);
                let padRight = TypedValue.complexToDimensionPixelSize(right, width, dm);
                let padBottom = TypedValue.complexToDimensionPixelSize(bottom, height, dm);
                view.setPadding(padLeft, padTop, padRight, padBottom);
                let unit = TypedValue.COMPLEX_UNIT_FRACTION;
                if ((typeof left === 'string' && left.endsWith(unit)) || (typeof top === 'string' && top.endsWith(unit))
                    || (typeof right === 'string' && right.endsWith(unit)) || (typeof bottom === 'string' && bottom.endsWith(unit))) {
                    view.post({
                        run: () => {
                            let width = view.getWidth();
                            let height = view.getHeight();
                            let padLeftN = TypedValue.complexToDimensionPixelSize(left, width, dm);
                            let padTopN = TypedValue.complexToDimensionPixelSize(top, height, dm);
                            let padRightN = TypedValue.complexToDimensionPixelSize(right, width, dm);
                            let padBottomN = TypedValue.complexToDimensionPixelSize(bottom, height, dm);
                            view.setPadding(padLeftN, padTopN, padRightN, padBottomN);
                        }
                    });
                }
            }
            setScrollX(value) {
                this.scrollTo(value, this.mScrollY);
            }
            setScrollY(value) {
                this.scrollTo(this.mScrollX, value);
            }
            getScrollX() {
                return this.mScrollX;
            }
            getScrollY() {
                return this.mScrollY;
            }
            getFinalAlpha() {
                return 1;
            }
            offsetTopAndBottom(offset) {
                if (offset != 0) {
                    this.updateMatrix();
                    const matrixIsIdentity = true;
                    if (matrixIsIdentity) {
                        const p = this.mParent;
                        if (p != null && this.mAttachInfo != null) {
                            const r = this.mAttachInfo.mTmpInvalRect;
                            let minTop;
                            let maxBottom;
                            let yLoc;
                            if (offset < 0) {
                                minTop = this.mTop + offset;
                                maxBottom = this.mBottom;
                                yLoc = offset;
                            }
                            else {
                                minTop = this.mTop;
                                maxBottom = this.mBottom + offset;
                                yLoc = 0;
                            }
                            r.set(0, yLoc, this.mRight - this.mLeft, maxBottom - minTop);
                            p.invalidateChild(this, r);
                        }
                    }
                    else {
                        this.invalidateViewProperty(false, false);
                    }
                    this.mTop += offset;
                    this.mBottom += offset;
                    if (!matrixIsIdentity) {
                        this.invalidateViewProperty(false, true);
                    }
                    this.invalidateParentIfNeeded();
                }
            }
            offsetLeftAndRight(offset) {
                if (offset != 0) {
                    this.updateMatrix();
                    const matrixIsIdentity = true;
                    if (matrixIsIdentity) {
                        const p = this.mParent;
                        if (p != null && this.mAttachInfo != null) {
                            const r = this.mAttachInfo.mTmpInvalRect;
                            let minLeft;
                            let maxRight;
                            if (offset < 0) {
                                minLeft = this.mLeft + offset;
                                maxRight = this.mRight;
                            }
                            else {
                                minLeft = this.mLeft;
                                maxRight = this.mRight + offset;
                            }
                            r.set(0, 0, maxRight - minLeft, this.mBottom - this.mTop);
                            p.invalidateChild(this, r);
                        }
                    }
                    else {
                        this.invalidateViewProperty(false, false);
                    }
                    this.mLeft += offset;
                    this.mRight += offset;
                    if (!matrixIsIdentity) {
                        this.invalidateViewProperty(false, true);
                    }
                    this.invalidateParentIfNeeded();
                }
            }
            setAlpha(alpha) {
                alpha &= 0xFF;
                this.bindElement.style.opacity = alpha / 255 + '';
            }
            updateMatrix() {
            }
            getMatrix() {
                return Matrix.IDENTITY_MATRIX;
            }
            hasIdentityMatrix() {
                return true;
            }
            transformRect(rect) {
                if (!this.getMatrix().isIdentity()) {
                    let boundingRect = this.mAttachInfo.mTmpTransformRect;
                    boundingRect.set(rect);
                    this.getMatrix().mapRect(boundingRect);
                    rect.set(boundingRect);
                }
            }
            pointInView(localX, localY, slop = 0) {
                return localX >= -slop && localY >= -slop && localX < ((this.mRight - this.mLeft) + slop) &&
                    localY < ((this.mBottom - this.mTop) + slop);
            }
            getHandler() {
                let attachInfo = this.mAttachInfo;
                if (attachInfo != null) {
                    return attachInfo.mHandler;
                }
                return null;
            }
            getViewRootImpl() {
                if (this.mAttachInfo != null) {
                    return this.mAttachInfo.mViewRootImpl;
                }
                return null;
            }
            post(action) {
                let attachInfo = this.mAttachInfo;
                if (attachInfo != null) {
                    return attachInfo.mHandler.post(action);
                }
                view_1.ViewRootImpl.getRunQueue().post(action);
                return true;
            }
            postDelayed(action, delayMillis) {
                let attachInfo = this.mAttachInfo;
                if (attachInfo != null) {
                    return attachInfo.mHandler.postDelayed(action, delayMillis);
                }
                view_1.ViewRootImpl.getRunQueue().postDelayed(action, delayMillis);
                return true;
            }
            postOnAnimation(action) {
                return this.post(action);
            }
            postOnAnimationDelayed(action, delayMillis) {
                return this.postDelayed(action, delayMillis);
            }
            removeCallbacks(action) {
                if (action != null) {
                    let attachInfo = this.mAttachInfo;
                    if (attachInfo != null) {
                        attachInfo.mHandler.removeCallbacks(action);
                    }
                    else {
                        view_1.ViewRootImpl.getRunQueue().removeCallbacks(action);
                    }
                }
                return true;
            }
            getParent() {
                return this.mParent;
            }
            setFlags(flags, mask) {
                let old = this.mViewFlags;
                this.mViewFlags = (this.mViewFlags & ~mask) | (flags & mask);
                let changed = this.mViewFlags ^ old;
                if (changed == 0) {
                    return;
                }
                let privateFlags = this.mPrivateFlags;
                if (((changed & View.FOCUSABLE_MASK) != 0) &&
                    ((privateFlags & View.PFLAG_HAS_BOUNDS) != 0)) {
                    if (((old & View.FOCUSABLE_MASK) == View.FOCUSABLE)
                        && ((privateFlags & View.PFLAG_FOCUSED) != 0)) {
                        this.clearFocus();
                    }
                    else if (((old & View.FOCUSABLE_MASK) == View.NOT_FOCUSABLE)
                        && ((privateFlags & View.PFLAG_FOCUSED) == 0)) {
                        if (this.mParent != null)
                            this.mParent.focusableViewAvailable(this);
                    }
                }
                const newVisibility = flags & View.VISIBILITY_MASK;
                if (newVisibility == View.VISIBLE) {
                    if ((changed & View.VISIBILITY_MASK) != 0) {
                        this.mPrivateFlags |= View.PFLAG_DRAWN;
                        this.invalidate(true);
                        if ((this.mParent != null) && (this.mBottom > this.mTop) && (this.mRight > this.mLeft)) {
                            this.mParent.focusableViewAvailable(this);
                        }
                    }
                }
                if ((changed & View.GONE) != 0) {
                    this.requestLayout();
                    if (((this.mViewFlags & View.VISIBILITY_MASK) == View.GONE)) {
                        if (this.hasFocus())
                            this.clearFocus();
                        this.destroyDrawingCache();
                        if (this.mParent instanceof View) {
                            this.mParent.invalidate(true);
                        }
                        this.mPrivateFlags |= View.PFLAG_DRAWN;
                    }
                    if (this.mAttachInfo != null) {
                        this.mAttachInfo.mViewVisibilityChanged = true;
                    }
                }
                if ((changed & View.INVISIBLE) != 0) {
                    this.mPrivateFlags |= View.PFLAG_DRAWN;
                    if (((this.mViewFlags & View.VISIBILITY_MASK) == View.INVISIBLE)) {
                        if (this.getRootView() != this) {
                            if (this.hasFocus())
                                this.clearFocus();
                        }
                    }
                    if (this.mAttachInfo != null) {
                        this.mAttachInfo.mViewVisibilityChanged = true;
                    }
                }
                if ((changed & View.VISIBILITY_MASK) != 0) {
                    if (newVisibility != View.VISIBLE) {
                        this.cleanupDraw();
                    }
                    if (this.mParent instanceof view_1.ViewGroup) {
                        this.mParent.onChildVisibilityChanged(this, (changed & View.VISIBILITY_MASK), newVisibility);
                        this.mParent.invalidate(true);
                    }
                    else if (this.mParent != null) {
                        this.mParent.invalidateChild(this, null);
                    }
                    this.dispatchVisibilityChanged(this, newVisibility);
                    this.syncVisibleToElement();
                }
                if ((changed & View.WILL_NOT_CACHE_DRAWING) != 0) {
                    this.destroyDrawingCache();
                }
                if ((changed & View.DRAWING_CACHE_ENABLED) != 0) {
                    this.destroyDrawingCache();
                    this.mPrivateFlags &= ~View.PFLAG_DRAWING_CACHE_VALID;
                    this.invalidateParentCaches();
                }
                if ((changed & View.DRAW_MASK) != 0) {
                    if ((this.mViewFlags & View.WILL_NOT_DRAW) != 0) {
                        if (this.mBackground != null) {
                            this.mPrivateFlags &= ~View.PFLAG_SKIP_DRAW;
                            this.mPrivateFlags |= View.PFLAG_ONLY_DRAWS_BACKGROUND;
                        }
                        else {
                            this.mPrivateFlags |= View.PFLAG_SKIP_DRAW;
                        }
                    }
                    else {
                        this.mPrivateFlags &= ~View.PFLAG_SKIP_DRAW;
                    }
                    this.requestLayout();
                    this.invalidate(true);
                }
            }
            bringToFront() {
                if (this.mParent != null) {
                    this.mParent.bringChildToFront(this);
                }
            }
            onScrollChanged(l, t, oldl, oldt) {
                this.mBackgroundSizeChanged = true;
                let ai = this.mAttachInfo;
                if (ai != null) {
                    ai.mViewScrollChanged = true;
                }
            }
            onSizeChanged(w, h, oldw, oldh) {
            }
            getTouchables() {
                let result = new ArrayList();
                this.addTouchables(result);
                return result;
            }
            addTouchables(views) {
                const viewFlags = this.mViewFlags;
                if (((viewFlags & View.CLICKABLE) == View.CLICKABLE || (viewFlags & View.LONG_CLICKABLE) == View.LONG_CLICKABLE)
                    && (viewFlags & View.ENABLED_MASK) == View.ENABLED) {
                    views.add(this);
                }
            }
            onFocusLost() {
                this.resetPressedState();
            }
            resetPressedState() {
                if ((this.mViewFlags & View.ENABLED_MASK) == View.DISABLED) {
                    return;
                }
                if (this.isPressed()) {
                    this.setPressed(false);
                    if (!this.mHasPerformedLongPress) {
                        this.removeLongPressCallback();
                    }
                }
            }
            isFocused() {
                return (this.mPrivateFlags & View.PFLAG_FOCUSED) != 0;
            }
            findFocus() {
                return (this.mPrivateFlags & View.PFLAG_FOCUSED) != 0 ? this : null;
            }
            getNextFocusLeftId() {
                return this.mNextFocusLeftId;
            }
            setNextFocusLeftId(nextFocusLeftId) {
                this.mNextFocusLeftId = nextFocusLeftId;
            }
            getNextFocusRightId() {
                return this.mNextFocusRightId;
            }
            setNextFocusRightId(nextFocusRightId) {
                this.mNextFocusRightId = nextFocusRightId;
            }
            getNextFocusUpId() {
                return this.mNextFocusUpId;
            }
            setNextFocusUpId(nextFocusUpId) {
                this.mNextFocusUpId = nextFocusUpId;
            }
            getNextFocusDownId() {
                return this.mNextFocusDownId;
            }
            setNextFocusDownId(nextFocusDownId) {
                this.mNextFocusDownId = nextFocusDownId;
            }
            getNextFocusForwardId() {
                return this.mNextFocusForwardId;
            }
            setNextFocusForwardId(nextFocusForwardId) {
                this.mNextFocusForwardId = nextFocusForwardId;
            }
            setFocusable(focusable) {
                if (!focusable) {
                    this.setFlags(0, View.FOCUSABLE_IN_TOUCH_MODE);
                }
                this.setFlags(focusable ? View.FOCUSABLE : View.NOT_FOCUSABLE, View.FOCUSABLE_MASK);
            }
            isFocusable() {
                return View.FOCUSABLE == (this.mViewFlags & View.FOCUSABLE_MASK);
            }
            setFocusableInTouchMode(focusableInTouchMode) {
                this.setFlags(focusableInTouchMode ? View.FOCUSABLE_IN_TOUCH_MODE : 0, View.FOCUSABLE_IN_TOUCH_MODE);
                if (focusableInTouchMode) {
                    this.setFlags(View.FOCUSABLE, View.FOCUSABLE_MASK);
                }
            }
            isFocusableInTouchMode() {
                return View.FOCUSABLE_IN_TOUCH_MODE == (this.mViewFlags & View.FOCUSABLE_IN_TOUCH_MODE);
            }
            hasFocusable() {
                return (this.mViewFlags & View.VISIBILITY_MASK) == View.VISIBLE && this.isFocusable();
            }
            clearFocus() {
                if (View.DBG) {
                    System.out.println(this + " clearFocus()");
                }
                this.clearFocusInternal(true, true);
            }
            clearFocusInternal(propagate, refocus) {
                if ((this.mPrivateFlags & View.PFLAG_FOCUSED) != 0) {
                    this.mPrivateFlags &= ~View.PFLAG_FOCUSED;
                    if (propagate && this.mParent != null) {
                        this.mParent.clearChildFocus(this);
                    }
                    this.onFocusChanged(false, 0, null);
                    this.refreshDrawableState();
                    if (propagate && (!refocus || !this.rootViewRequestFocus())) {
                        this.notifyGlobalFocusCleared(this);
                    }
                }
            }
            notifyGlobalFocusCleared(oldFocus) {
                if (oldFocus != null && this.mAttachInfo != null) {
                    this.mAttachInfo.mTreeObserver.dispatchOnGlobalFocusChange(oldFocus, null);
                }
            }
            rootViewRequestFocus() {
                const root = this.getRootView();
                return root != null && root.requestFocus();
            }
            unFocus() {
                if (View.DBG) {
                    System.out.println(this + " unFocus()");
                }
                this.clearFocusInternal(false, false);
            }
            hasFocus() {
                return (this.mPrivateFlags & View.PFLAG_FOCUSED) != 0;
            }
            onFocusChanged(gainFocus, direction, previouslyFocusedRect) {
                if (!gainFocus) {
                    if (this.isPressed()) {
                        this.setPressed(false);
                    }
                    this.onFocusLost();
                }
                this.invalidate(true);
                let li = this.mListenerInfo;
                if (li != null && li.mOnFocusChangeListener != null) {
                    li.mOnFocusChangeListener.onFocusChange(this, gainFocus);
                }
                if (this.mAttachInfo != null) {
                    this.mAttachInfo.mKeyDispatchState.reset(this);
                }
            }
            focusSearch(direction) {
                if (this.mParent != null) {
                    return this.mParent.focusSearch(this, direction);
                }
                else {
                    return null;
                }
            }
            dispatchUnhandledMove(focused, direction) {
                return false;
            }
            findUserSetNextFocus(root, direction) {
                switch (direction) {
                    case View.FOCUS_LEFT:
                        if (!this.mNextFocusLeftId)
                            return null;
                        return this.findViewInsideOutShouldExist(root, this.mNextFocusLeftId);
                    case View.FOCUS_RIGHT:
                        if (!this.mNextFocusRightId)
                            return null;
                        return this.findViewInsideOutShouldExist(root, this.mNextFocusRightId);
                    case View.FOCUS_UP:
                        if (!this.mNextFocusUpId)
                            return null;
                        return this.findViewInsideOutShouldExist(root, this.mNextFocusUpId);
                    case View.FOCUS_DOWN:
                        if (!this.mNextFocusDownId)
                            return null;
                        return this.findViewInsideOutShouldExist(root, this.mNextFocusDownId);
                    case View.FOCUS_FORWARD:
                        if (!this.mNextFocusForwardId)
                            return null;
                        return this.findViewInsideOutShouldExist(root, this.mNextFocusForwardId);
                    case View.FOCUS_BACKWARD: {
                        if (!this.mID)
                            return null;
                        let id = this.mID;
                        return root.findViewByPredicateInsideOut(this, {
                            apply(t) {
                                return t.mNextFocusForwardId == id;
                            }
                        });
                    }
                }
                return null;
            }
            findViewInsideOutShouldExist(root, id) {
                if (this.mMatchIdPredicate == null) {
                    this.mMatchIdPredicate = new MatchIdPredicate();
                }
                this.mMatchIdPredicate.mId = id;
                let result = root.findViewByPredicateInsideOut(this, this.mMatchIdPredicate);
                if (result == null) {
                    Log.w(View.VIEW_LOG_TAG, "couldn't find view with id " + id);
                }
                return result;
            }
            getFocusables(direction) {
                let result = new ArrayList(24);
                this.addFocusables(result, direction);
                return result;
            }
            addFocusables(views, direction, focusableMode = View.FOCUSABLES_TOUCH_MODE) {
                if (views == null) {
                    return;
                }
                if (!this.isFocusable()) {
                    return;
                }
                if ((focusableMode & View.FOCUSABLES_TOUCH_MODE) == View.FOCUSABLES_TOUCH_MODE
                    && this.isInTouchMode() && !this.isFocusableInTouchMode()) {
                    return;
                }
                views.add(this);
            }
            setOnFocusChangeListener(l) {
                this.getListenerInfo().mOnFocusChangeListener = l;
            }
            getOnFocusChangeListener() {
                let li = this.mListenerInfo;
                return li != null ? li.mOnFocusChangeListener : null;
            }
            requestFocus(direction = View.FOCUS_DOWN, previouslyFocusedRect = null) {
                return this.requestFocusNoSearch(direction, previouslyFocusedRect);
            }
            requestFocusNoSearch(direction, previouslyFocusedRect) {
                if ((this.mViewFlags & View.FOCUSABLE_MASK) != View.FOCUSABLE ||
                    (this.mViewFlags & View.VISIBILITY_MASK) != View.VISIBLE) {
                    return false;
                }
                if (this.isInTouchMode() &&
                    (View.FOCUSABLE_IN_TOUCH_MODE != (this.mViewFlags & View.FOCUSABLE_IN_TOUCH_MODE))) {
                    return false;
                }
                if (this.hasAncestorThatBlocksDescendantFocus()) {
                    return false;
                }
                this.handleFocusGainInternal(direction, previouslyFocusedRect);
                return true;
            }
            requestFocusFromTouch() {
                if (this.isInTouchMode()) {
                    let viewRoot = this.getViewRootImpl();
                    if (viewRoot != null) {
                        viewRoot.ensureTouchMode(false);
                    }
                }
                return this.requestFocus(View.FOCUS_DOWN);
            }
            hasAncestorThatBlocksDescendantFocus() {
                let ancestor = this.mParent;
                while (ancestor instanceof view_1.ViewGroup) {
                    const vgAncestor = ancestor;
                    if (vgAncestor.getDescendantFocusability() == view_1.ViewGroup.FOCUS_BLOCK_DESCENDANTS) {
                        return true;
                    }
                    else {
                        ancestor = vgAncestor.getParent();
                    }
                }
                return false;
            }
            handleFocusGainInternal(direction, previouslyFocusedRect) {
                if (View.DBG) {
                    System.out.println(this + " requestFocus()");
                }
                if ((this.mPrivateFlags & View.PFLAG_FOCUSED) == 0) {
                    this.mPrivateFlags |= View.PFLAG_FOCUSED;
                    let oldFocus = (this.mAttachInfo != null) ? this.getRootView().findFocus() : null;
                    if (this.mParent != null) {
                        this.mParent.requestChildFocus(this, this);
                    }
                    if (this.mAttachInfo != null) {
                        this.mAttachInfo.mTreeObserver.dispatchOnGlobalFocusChange(oldFocus, this);
                    }
                    this.onFocusChanged(true, direction, previouslyFocusedRect);
                    this.refreshDrawableState();
                }
            }
            hasTransientState() {
                return (this.mPrivateFlags2 & View.PFLAG2_HAS_TRANSIENT_STATE) == View.PFLAG2_HAS_TRANSIENT_STATE;
            }
            setHasTransientState(hasTransientState) {
                this.mTransientStateCount = hasTransientState ? this.mTransientStateCount + 1 :
                    this.mTransientStateCount - 1;
                if (this.mTransientStateCount < 0) {
                    this.mTransientStateCount = 0;
                    Log.e(View.VIEW_LOG_TAG, "hasTransientState decremented below 0: " +
                        "unmatched pair of setHasTransientState calls");
                }
                else if ((hasTransientState && this.mTransientStateCount == 1) ||
                    (!hasTransientState && this.mTransientStateCount == 0)) {
                    this.mPrivateFlags2 = (this.mPrivateFlags2 & ~View.PFLAG2_HAS_TRANSIENT_STATE) |
                        (hasTransientState ? View.PFLAG2_HAS_TRANSIENT_STATE : 0);
                    if (this.mParent != null) {
                        this.mParent.childHasTransientStateChanged(this, hasTransientState);
                    }
                }
            }
            isInTouchMode() {
                if (this.mAttachInfo != null) {
                    return this.mAttachInfo.mInTouchMode;
                }
                else {
                    return false;
                }
            }
            isShown() {
                let current = this;
                do {
                    if ((current.mViewFlags & View.VISIBILITY_MASK) != View.VISIBLE) {
                        return false;
                    }
                    let parent = current.mParent;
                    if (parent == null) {
                        return false;
                    }
                    if (!(parent instanceof View)) {
                        return true;
                    }
                    current = parent;
                } while (current != null);
                return false;
            }
            getVisibility() {
                return this.mViewFlags & View.VISIBILITY_MASK;
            }
            setVisibility(visibility) {
                this.setFlags(visibility, View.VISIBILITY_MASK);
                if (this.mBackground != null)
                    this.mBackground.setVisible(visibility == View.VISIBLE, false);
            }
            dispatchVisibilityChanged(changedView, visibility) {
                this.onVisibilityChanged(changedView, visibility);
            }
            onVisibilityChanged(changedView, visibility) {
                if (visibility == View.VISIBLE) {
                    if (this.mAttachInfo != null) {
                        this.initialAwakenScrollBars();
                    }
                    else {
                        this.mPrivateFlags |= View.PFLAG_AWAKEN_SCROLL_BARS_ON_ATTACH;
                    }
                }
            }
            dispatchDisplayHint(hint) {
                this.onDisplayHint(hint);
            }
            onDisplayHint(hint) {
            }
            dispatchWindowVisibilityChanged(visibility) {
                this.onWindowVisibilityChanged(visibility);
            }
            onWindowVisibilityChanged(visibility) {
                if (visibility == View.VISIBLE) {
                    this.initialAwakenScrollBars();
                }
            }
            getWindowVisibility() {
                return this.mAttachInfo != null ? this.mAttachInfo.mWindowVisibility : View.GONE;
            }
            isEnabled() {
                return (this.mViewFlags & View.ENABLED_MASK) == View.ENABLED;
            }
            setEnabled(enabled) {
                if (enabled == this.isEnabled())
                    return;
                this.setFlags(enabled ? View.ENABLED : View.DISABLED, View.ENABLED_MASK);
                this.refreshDrawableState();
                this.invalidate(true);
            }
            dispatchGenericMotionEvent(event) {
                if (event.isPointerEvent()) {
                    const action = event.getAction();
                    if (action == view_1.MotionEvent.ACTION_HOVER_ENTER
                        || action == view_1.MotionEvent.ACTION_HOVER_MOVE
                        || action == view_1.MotionEvent.ACTION_HOVER_EXIT) {
                    }
                    else if (this.dispatchGenericPointerEvent(event)) {
                        return true;
                    }
                }
                if (this.dispatchGenericMotionEventInternal(event)) {
                    return true;
                }
                return false;
            }
            dispatchGenericMotionEventInternal(event) {
                let li = this.mListenerInfo;
                if (li != null && li.mOnGenericMotionListener != null
                    && (this.mViewFlags & View.ENABLED_MASK) == View.ENABLED
                    && li.mOnGenericMotionListener.onGenericMotion(this, event)) {
                    return true;
                }
                if (this.onGenericMotionEvent(event)) {
                    return true;
                }
                return false;
            }
            onGenericMotionEvent(event) {
                return false;
            }
            dispatchGenericPointerEvent(event) {
                return false;
            }
            dispatchKeyEvent(event) {
                let li = this.mListenerInfo;
                if (li != null && li.mOnKeyListener != null && (this.mViewFlags & View.ENABLED_MASK) == View.ENABLED
                    && li.mOnKeyListener.onKey(this, event.getKeyCode(), event)) {
                    return true;
                }
                if (event.dispatch(this, this.mAttachInfo != null
                    ? this.mAttachInfo.mKeyDispatchState : null, this)) {
                    return true;
                }
                return false;
            }
            setOnKeyListener(l) {
                this.getListenerInfo().mOnKeyListener = l;
            }
            getKeyDispatcherState() {
                return this.mAttachInfo != null ? this.mAttachInfo.mKeyDispatchState : null;
            }
            onKeyDown(keyCode, event) {
                let result = false;
                if (KeyEvent.isConfirmKey(keyCode)) {
                    if ((this.mViewFlags & View.ENABLED_MASK) == View.DISABLED) {
                        return true;
                    }
                    if (((this.mViewFlags & View.CLICKABLE) == View.CLICKABLE ||
                        (this.mViewFlags & View.LONG_CLICKABLE) == View.LONG_CLICKABLE) &&
                        (event.getRepeatCount() == 0)) {
                        this.setPressed(true);
                        this.checkForLongClick(0);
                        return true;
                    }
                }
                return result;
            }
            onKeyLongPress(keyCode, event) {
                return false;
            }
            onKeyUp(keyCode, event) {
                if (KeyEvent.isConfirmKey(keyCode)) {
                    if ((this.mViewFlags & View.ENABLED_MASK) == View.DISABLED) {
                        return true;
                    }
                    if ((this.mViewFlags & View.CLICKABLE) == View.CLICKABLE && this.isPressed()) {
                        this.setPressed(false);
                        if (!this.mHasPerformedLongPress) {
                            this.removeLongPressCallback();
                            return this.performClick();
                        }
                    }
                }
                return false;
            }
            dispatchTouchEvent(event) {
                if (this.onFilterTouchEventForSecurity(event)) {
                    let li = this.mListenerInfo;
                    if (li != null && li.mOnTouchListener != null && (this.mViewFlags & View.ENABLED_MASK) == View.ENABLED
                        && li.mOnTouchListener.onTouch(this, event)) {
                        return true;
                    }
                    if (this.onTouchEvent(event)) {
                        return true;
                    }
                }
                return false;
            }
            onFilterTouchEventForSecurity(event) {
                return true;
            }
            onTouchEvent(event) {
                let viewFlags = this.mViewFlags;
                if ((viewFlags & View.ENABLED_MASK) == View.DISABLED) {
                    if (event.getAction() == view_1.MotionEvent.ACTION_UP && (this.mPrivateFlags & View.PFLAG_PRESSED) != 0) {
                        this.setPressed(false);
                    }
                    return (((viewFlags & View.CLICKABLE) == View.CLICKABLE ||
                        (viewFlags & View.LONG_CLICKABLE) == View.LONG_CLICKABLE));
                }
                if (this.mTouchDelegate != null) {
                    if (this.mTouchDelegate.onTouchEvent(event)) {
                        return true;
                    }
                }
                if (((viewFlags & View.CLICKABLE) == View.CLICKABLE ||
                    (viewFlags & View.LONG_CLICKABLE) == View.LONG_CLICKABLE)) {
                    switch (event.getAction()) {
                        case view_1.MotionEvent.ACTION_UP:
                            let prepressed = (this.mPrivateFlags & View.PFLAG_PREPRESSED) != 0;
                            if ((this.mPrivateFlags & View.PFLAG_PRESSED) != 0 || prepressed) {
                                let focusTaken = false;
                                if (prepressed) {
                                    this.setPressed(true);
                                }
                                if (!this.mHasPerformedLongPress) {
                                    this.removeLongPressCallback();
                                    if (!focusTaken) {
                                        if (this.mPerformClick == null) {
                                            this.mPerformClick = new PerformClick(this);
                                        }
                                        if (!this.post(this.mPerformClick)) {
                                            this.performClick(event);
                                        }
                                    }
                                }
                                if (this.mUnsetPressedState == null) {
                                    this.mUnsetPressedState = new UnsetPressedState(this);
                                }
                                if (prepressed) {
                                    this.postDelayed(this.mUnsetPressedState, view_1.ViewConfiguration.getPressedStateDuration());
                                }
                                else if (!this.post(this.mUnsetPressedState)) {
                                    this.mUnsetPressedState.run();
                                }
                                this.removeTapCallback();
                            }
                            break;
                        case view_1.MotionEvent.ACTION_DOWN:
                            this.mHasPerformedLongPress = false;
                            let isInScrollingContainer = this.isInScrollingContainer();
                            if (isInScrollingContainer) {
                                this.mPrivateFlags |= View.PFLAG_PREPRESSED;
                                if (this.mPendingCheckForTap == null) {
                                    this.mPendingCheckForTap = new CheckForTap(this);
                                }
                                this.postDelayed(this.mPendingCheckForTap, view_1.ViewConfiguration.getTapTimeout());
                            }
                            else {
                                this.setPressed(true);
                                this.checkForLongClick(0);
                            }
                            break;
                        case view_1.MotionEvent.ACTION_CANCEL:
                            this.setPressed(false);
                            this.removeTapCallback();
                            this.removeLongPressCallback();
                            break;
                        case view_1.MotionEvent.ACTION_MOVE:
                            const x = event.getX();
                            const y = event.getY();
                            if (!this.pointInView(x, y, this.mTouchSlop)) {
                                this.removeTapCallback();
                                if ((this.mPrivateFlags & View.PFLAG_PRESSED) != 0) {
                                    this.removeLongPressCallback();
                                    this.setPressed(false);
                                }
                            }
                            break;
                    }
                    return true;
                }
                return false;
            }
            isInScrollingContainer() {
                let p = this.getParent();
                while (p != null && p instanceof view_1.ViewGroup) {
                    if (p.shouldDelayChildPressedState()) {
                        return true;
                    }
                    p = p.getParent();
                }
                return false;
            }
            cancelPendingInputEvents() {
                this.dispatchCancelPendingInputEvents();
            }
            dispatchCancelPendingInputEvents() {
                this.mPrivateFlags3 &= ~View.PFLAG3_CALLED_SUPER;
                this.onCancelPendingInputEvents();
                if ((this.mPrivateFlags3 & View.PFLAG3_CALLED_SUPER) != View.PFLAG3_CALLED_SUPER) {
                    throw Error(`new SuperNotCalledException("View " + this.getClass().getSimpleName() + " did not call through to super.onCancelPendingInputEvents()")`);
                }
            }
            onCancelPendingInputEvents() {
                this.removePerformClickCallback();
                this.cancelLongPress();
                this.mPrivateFlags3 |= View.PFLAG3_CALLED_SUPER;
            }
            removeLongPressCallback() {
                if (this.mPendingCheckForLongPress != null) {
                    this.removeCallbacks(this.mPendingCheckForLongPress);
                }
            }
            removePerformClickCallback() {
                if (this.mPerformClick != null) {
                    this.removeCallbacks(this.mPerformClick);
                }
            }
            removeUnsetPressCallback() {
                if ((this.mPrivateFlags & View.PFLAG_PRESSED) != 0 && this.mUnsetPressedState != null) {
                    this.setPressed(false);
                    this.removeCallbacks(this.mUnsetPressedState);
                }
            }
            removeTapCallback() {
                if (this.mPendingCheckForTap != null) {
                    this.mPrivateFlags &= ~View.PFLAG_PREPRESSED;
                    this.removeCallbacks(this.mPendingCheckForTap);
                }
            }
            cancelLongPress() {
                this.removeLongPressCallback();
                this.removeTapCallback();
            }
            setTouchDelegate(delegate) {
                this.mTouchDelegate = delegate;
            }
            getTouchDelegate() {
                return this.mTouchDelegate;
            }
            getListenerInfo() {
                if (this.mListenerInfo != null) {
                    return this.mListenerInfo;
                }
                this.mListenerInfo = new View.ListenerInfo();
                return this.mListenerInfo;
            }
            addOnLayoutChangeListener(listener) {
                let li = this.getListenerInfo();
                if (li.mOnLayoutChangeListeners == null) {
                    li.mOnLayoutChangeListeners = new ArrayList();
                }
                if (!li.mOnLayoutChangeListeners.contains(listener)) {
                    li.mOnLayoutChangeListeners.add(listener);
                }
            }
            removeOnLayoutChangeListener(listener) {
                let li = this.mListenerInfo;
                if (li == null || li.mOnLayoutChangeListeners == null) {
                    return;
                }
                li.mOnLayoutChangeListeners.remove(listener);
            }
            addOnAttachStateChangeListener(listener) {
                let li = this.getListenerInfo();
                if (li.mOnAttachStateChangeListeners == null) {
                    li.mOnAttachStateChangeListeners
                        = new CopyOnWriteArrayList();
                }
                li.mOnAttachStateChangeListeners.add(listener);
            }
            removeOnAttachStateChangeListener(listener) {
                let li = this.mListenerInfo;
                if (li == null || li.mOnAttachStateChangeListeners == null) {
                    return;
                }
                li.mOnAttachStateChangeListeners.remove(listener);
            }
            setOnClickListener(l) {
                if (!this.isClickable()) {
                    this.setClickable(true);
                }
                this.getListenerInfo().mOnClickListener = l;
            }
            hasOnClickListeners() {
                let li = this.mListenerInfo;
                return (li != null && li.mOnClickListener != null);
            }
            setOnLongClickListener(l) {
                if (!this.isLongClickable()) {
                    this.setLongClickable(true);
                }
                this.getListenerInfo().mOnLongClickListener = l;
            }
            playSoundEffect(soundConstant) {
            }
            performHapticFeedback(feedbackConstant) {
                return false;
            }
            performClick(event) {
                this._sendClickToBindElement(event);
                let li = this.mListenerInfo;
                if (li != null && li.mOnClickListener != null) {
                    li.mOnClickListener.onClick(this);
                    return true;
                }
                return false;
            }
            _sendClickToBindElement(event) {
                let touch = event ? event._activeTouch : null;
                let screenX = touch ? touch.screenX : 0;
                let screenY = touch ? touch.screenY : 0;
                let clientX = touch ? touch.clientX : 0;
                let clientY = touch ? touch.clientY : 0;
                let clickEvent = document.createEvent('MouseEvents');
                clickEvent.initMouseEvent('click', false, true, window, 1, screenX, screenY, clientX, clientY, false, false, false, false, 0, null);
                clickEvent.forwardedTouchEvent = true;
                this.bindElement.dispatchEvent(clickEvent);
            }
            callOnClick() {
                let li = this.mListenerInfo;
                if (li != null && li.mOnClickListener != null) {
                    li.mOnClickListener.onClick(this);
                    return true;
                }
                return false;
            }
            performLongClick() {
                let handled = false;
                let li = this.mListenerInfo;
                if (li != null && li.mOnLongClickListener != null) {
                    handled = li.mOnLongClickListener.onLongClick(this);
                }
                return handled;
            }
            performButtonActionOnTouchDown(event) {
                return false;
            }
            checkForLongClick(delayOffset = 0) {
                if ((this.mViewFlags & View.LONG_CLICKABLE) == View.LONG_CLICKABLE) {
                    this.mHasPerformedLongPress = false;
                    if (this.mPendingCheckForLongPress == null) {
                        this.mPendingCheckForLongPress = new CheckForLongPress(this);
                    }
                    this.mPendingCheckForLongPress.rememberWindowAttachCount();
                    this.postDelayed(this.mPendingCheckForLongPress, view_1.ViewConfiguration.getLongPressTimeout() - delayOffset);
                }
            }
            setOnTouchListener(l) {
                this.getListenerInfo().mOnTouchListener = l;
            }
            isClickable() {
                return (this.mViewFlags & View.CLICKABLE) == View.CLICKABLE;
            }
            setClickable(clickable) {
                this.setFlags(clickable ? View.CLICKABLE : 0, View.CLICKABLE);
            }
            isLongClickable() {
                return (this.mViewFlags & View.LONG_CLICKABLE) == View.LONG_CLICKABLE;
            }
            setLongClickable(longClickable) {
                this.setFlags(longClickable ? View.LONG_CLICKABLE : 0, View.LONG_CLICKABLE);
            }
            setPressed(pressed) {
                const needsRefresh = pressed != ((this.mPrivateFlags & View.PFLAG_PRESSED) == View.PFLAG_PRESSED);
                if (pressed) {
                    this.mPrivateFlags |= View.PFLAG_PRESSED;
                }
                else {
                    this.mPrivateFlags &= ~View.PFLAG_PRESSED;
                }
                if (needsRefresh) {
                    this.refreshDrawableState();
                }
                this.dispatchSetPressed(pressed);
            }
            dispatchSetPressed(pressed) {
            }
            isPressed() {
                return (this.mPrivateFlags & View.PFLAG_PRESSED) == View.PFLAG_PRESSED;
            }
            setSelected(selected) {
                if (((this.mPrivateFlags & View.PFLAG_SELECTED) != 0) != selected) {
                    this.mPrivateFlags = (this.mPrivateFlags & ~View.PFLAG_SELECTED) | (selected ? View.PFLAG_SELECTED : 0);
                    if (!selected)
                        this.resetPressedState();
                    this.invalidate(true);
                    this.refreshDrawableState();
                    this.dispatchSetSelected(selected);
                }
            }
            dispatchSetSelected(selected) {
            }
            isSelected() {
                return (this.mPrivateFlags & View.PFLAG_SELECTED) != 0;
            }
            setActivated(activated) {
                if (((this.mPrivateFlags & View.PFLAG_ACTIVATED) != 0) != activated) {
                    this.mPrivateFlags = (this.mPrivateFlags & ~View.PFLAG_ACTIVATED) | (activated ? View.PFLAG_ACTIVATED : 0);
                    this.invalidate(true);
                    this.refreshDrawableState();
                    this.dispatchSetActivated(activated);
                }
            }
            dispatchSetActivated(activated) {
            }
            isActivated() {
                return (this.mPrivateFlags & View.PFLAG_ACTIVATED) != 0;
            }
            getViewTreeObserver() {
                if (this.mAttachInfo != null) {
                    return this.mAttachInfo.mTreeObserver;
                }
                if (this.mFloatingTreeObserver == null) {
                    this.mFloatingTreeObserver = new view_1.ViewTreeObserver();
                }
                return this.mFloatingTreeObserver;
            }
            isLayoutRtl() {
                return false;
            }
            getBaseline() {
                return -1;
            }
            isLayoutRequested() {
                return (this.mPrivateFlags & View.PFLAG_FORCE_LAYOUT) == View.PFLAG_FORCE_LAYOUT;
            }
            getLayoutParams() {
                return this.mLayoutParams;
            }
            setLayoutParams(params) {
                if (params == null) {
                    throw new Error("Layout parameters cannot be null");
                }
                this.mLayoutParams = params;
                let p = this.mParent;
                if (p instanceof view_1.ViewGroup) {
                    p.onSetLayoutParams(this, params);
                }
                this.requestLayout();
            }
            requestLayout() {
                if (this.mMeasureCache != null)
                    this.mMeasureCache.clear();
                if (this.mAttachInfo != null && this.mAttachInfo.mViewRequestingLayout == null) {
                    let viewRoot = this.getViewRootImpl();
                    if (viewRoot != null && viewRoot.isInLayout()) {
                        if (!viewRoot.requestLayoutDuringLayout(this)) {
                            return;
                        }
                    }
                    this.mAttachInfo.mViewRequestingLayout = this;
                }
                this.mPrivateFlags |= View.PFLAG_FORCE_LAYOUT;
                this.mPrivateFlags |= View.PFLAG_INVALIDATED;
                if (this.mParent != null && !this.mParent.isLayoutRequested()) {
                    this.mParent.requestLayout();
                }
            }
            forceLayout() {
                if (this.mMeasureCache != null)
                    this.mMeasureCache.clear();
                this.mPrivateFlags |= View.PFLAG_FORCE_LAYOUT;
                this.mPrivateFlags |= View.PFLAG_INVALIDATED;
            }
            isLaidOut() {
                return (this.mPrivateFlags3 & View.PFLAG3_IS_LAID_OUT) == View.PFLAG3_IS_LAID_OUT;
            }
            layout(l, t, r, b) {
                if ((this.mPrivateFlags3 & View.PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) {
                    this.onMeasure(this.mOldWidthMeasureSpec, this.mOldHeightMeasureSpec);
                    this.mPrivateFlags3 &= ~View.PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
                }
                let oldL = this.mLeft;
                let oldT = this.mTop;
                let oldB = this.mBottom;
                let oldR = this.mRight;
                let changed = this.setFrame(l, t, r, b);
                if (changed)
                    this.syncBoundToElement();
                if (changed || (this.mPrivateFlags & View.PFLAG_LAYOUT_REQUIRED) == View.PFLAG_LAYOUT_REQUIRED) {
                    this.onLayout(changed, l, t, r, b);
                    this.mPrivateFlags &= ~View.PFLAG_LAYOUT_REQUIRED;
                    let li = this.mListenerInfo;
                    if (li != null && li.mOnLayoutChangeListeners != null) {
                        let listenersCopy = li.mOnLayoutChangeListeners.clone();
                        let numListeners = listenersCopy.size();
                        for (let i = 0; i < numListeners; ++i) {
                            listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);
                        }
                    }
                }
                this.mPrivateFlags &= ~View.PFLAG_FORCE_LAYOUT;
                this.mPrivateFlags3 |= View.PFLAG3_IS_LAID_OUT;
            }
            onLayout(changed, left, top, right, bottom) {
            }
            setFrame(left, top, right, bottom) {
                let changed = false;
                if (View.DBG) {
                    Log.i("View", this + " View.setFrame(" + left + "," + top + ","
                        + right + "," + bottom + ")");
                }
                if (this.mLeft != left || this.mRight != right || this.mTop != top || this.mBottom != bottom) {
                    changed = true;
                    let drawn = this.mPrivateFlags & View.PFLAG_DRAWN;
                    let oldWidth = this.mRight - this.mLeft;
                    let oldHeight = this.mBottom - this.mTop;
                    let newWidth = right - left;
                    let newHeight = bottom - top;
                    let sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight);
                    this.invalidate(sizeChanged);
                    this.mLeft = left;
                    this.mTop = top;
                    this.mRight = right;
                    this.mBottom = bottom;
                    this.mPrivateFlags |= View.PFLAG_HAS_BOUNDS;
                    if (sizeChanged) {
                        if ((this.mPrivateFlags & View.PFLAG_PIVOT_EXPLICITLY_SET) == 0) {
                        }
                        this.sizeChange(newWidth, newHeight, oldWidth, oldHeight);
                    }
                    if ((this.mViewFlags & View.VISIBILITY_MASK) == View.VISIBLE) {
                        this.mPrivateFlags |= View.PFLAG_DRAWN;
                        this.invalidate(sizeChanged);
                    }
                    this.mPrivateFlags |= drawn;
                    this.mBackgroundSizeChanged = true;
                }
                return changed;
            }
            sizeChange(newWidth, newHeight, oldWidth, oldHeight) {
                this.onSizeChanged(newWidth, newHeight, oldWidth, oldHeight);
                if (this.mOverlay != null) {
                    this.mOverlay.getOverlayView().setRight(newWidth);
                    this.mOverlay.getOverlayView().setBottom(newHeight);
                }
            }
            getHitRect(outRect) {
                outRect.set(this.mLeft, this.mTop, this.mRight, this.mBottom);
            }
            getFocusedRect(r) {
                this.getDrawingRect(r);
            }
            getDrawingRect(outRect) {
                outRect.left = this.mScrollX;
                outRect.top = this.mScrollY;
                outRect.right = this.mScrollX + (this.mRight - this.mLeft);
                outRect.bottom = this.mScrollY + (this.mBottom - this.mTop);
            }
            getGlobalVisibleRect(r, globalOffset = null) {
                let width = this.mRight - this.mLeft;
                let height = this.mBottom - this.mTop;
                if (width > 0 && height > 0) {
                    r.set(0, 0, width, height);
                    if (globalOffset != null) {
                        globalOffset.set(-this.mScrollX, -this.mScrollY);
                    }
                    return this.mParent == null || this.mParent.getChildVisibleRect(this, r, globalOffset);
                }
                return false;
            }
            getMeasuredWidth() {
                return this.mMeasuredWidth & View.MEASURED_SIZE_MASK;
            }
            getMeasuredWidthAndState() {
                return this.mMeasuredWidth;
            }
            getMeasuredHeight() {
                return this.mMeasuredHeight & View.MEASURED_SIZE_MASK;
            }
            getMeasuredHeightAndState() {
                return this.mMeasuredHeight;
            }
            getMeasuredState() {
                return (this.mMeasuredWidth & View.MEASURED_STATE_MASK)
                    | ((this.mMeasuredHeight >> View.MEASURED_HEIGHT_STATE_SHIFT)
                        & (View.MEASURED_STATE_MASK >> View.MEASURED_HEIGHT_STATE_SHIFT));
            }
            measure(widthMeasureSpec, heightMeasureSpec) {
                let key = widthMeasureSpec + ',' + heightMeasureSpec;
                if (this.mMeasureCache == null)
                    this.mMeasureCache = new Map();
                if ((this.mPrivateFlags & View.PFLAG_FORCE_LAYOUT) == View.PFLAG_FORCE_LAYOUT ||
                    widthMeasureSpec != this.mOldWidthMeasureSpec ||
                    heightMeasureSpec != this.mOldHeightMeasureSpec) {
                    this.mPrivateFlags &= ~View.PFLAG_MEASURED_DIMENSION_SET;
                    let cacheValue = (this.mPrivateFlags & View.PFLAG_FORCE_LAYOUT) == View.PFLAG_FORCE_LAYOUT ? null : this.mMeasureCache.get(key);
                    if (cacheValue == null) {
                        this.onMeasure(widthMeasureSpec, heightMeasureSpec);
                        this.mPrivateFlags3 &= ~View.PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
                    }
                    else {
                        this.setMeasuredDimension(cacheValue[0], cacheValue[1]);
                        this.mPrivateFlags3 |= View.PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
                    }
                    if ((this.mPrivateFlags & View.PFLAG_MEASURED_DIMENSION_SET) != View.PFLAG_MEASURED_DIMENSION_SET) {
                        throw new Error("onMeasure() did not set the"
                            + " measured dimension by calling"
                            + " setMeasuredDimension()");
                    }
                    this.mPrivateFlags |= View.PFLAG_LAYOUT_REQUIRED;
                }
                this.mOldWidthMeasureSpec = widthMeasureSpec;
                this.mOldHeightMeasureSpec = heightMeasureSpec;
                this.mMeasureCache.set(key, [this.mMeasuredWidth, this.mMeasuredHeight]);
            }
            onMeasure(widthMeasureSpec, heightMeasureSpec) {
                this.setMeasuredDimension(View.getDefaultSize(this.getSuggestedMinimumWidth(), widthMeasureSpec), View.getDefaultSize(this.getSuggestedMinimumHeight(), heightMeasureSpec));
            }
            setMeasuredDimension(measuredWidth, measuredHeight) {
                this.mMeasuredWidth = measuredWidth;
                this.mMeasuredHeight = measuredHeight;
                this.mPrivateFlags |= View.PFLAG_MEASURED_DIMENSION_SET;
            }
            static combineMeasuredStates(curState, newState) {
                return curState | newState;
            }
            static resolveSize(size, measureSpec) {
                return View.resolveSizeAndState(size, measureSpec, 0) & View.MEASURED_SIZE_MASK;
            }
            static resolveSizeAndState(size, measureSpec, childMeasuredState) {
                let MeasureSpec = View.MeasureSpec;
                let result = size;
                let specMode = MeasureSpec.getMode(measureSpec);
                let specSize = MeasureSpec.getSize(measureSpec);
                switch (specMode) {
                    case MeasureSpec.UNSPECIFIED:
                        result = size;
                        break;
                    case MeasureSpec.AT_MOST:
                        if (specSize < size) {
                            result = specSize | View.MEASURED_STATE_TOO_SMALL;
                        }
                        else {
                            result = size;
                        }
                        break;
                    case MeasureSpec.EXACTLY:
                        result = specSize;
                        break;
                }
                return result | (childMeasuredState & View.MEASURED_STATE_MASK);
            }
            static getDefaultSize(size, measureSpec) {
                let MeasureSpec = View.MeasureSpec;
                let result = size;
                let specMode = MeasureSpec.getMode(measureSpec);
                let specSize = MeasureSpec.getSize(measureSpec);
                switch (specMode) {
                    case MeasureSpec.UNSPECIFIED:
                        result = size;
                        break;
                    case MeasureSpec.AT_MOST:
                    case MeasureSpec.EXACTLY:
                        result = specSize;
                        break;
                }
                return result;
            }
            getSuggestedMinimumHeight() {
                return (this.mBackground == null) ? this.mMinHeight :
                    Math.max(this.mMinHeight, this.mBackground.getMinimumHeight());
            }
            getSuggestedMinimumWidth() {
                return (this.mBackground == null) ? this.mMinWidth :
                    Math.max(this.mMinWidth, this.mBackground.getMinimumWidth());
            }
            getMinimumHeight() {
                return this.mMinHeight;
            }
            setMinimumHeight(minHeight) {
                this.mMinHeight = minHeight;
                this.requestLayout();
            }
            getMinimumWidth() {
                return this.mMinWidth;
            }
            setMinimumWidth(minWidth) {
                this.mMinWidth = minWidth;
                this.requestLayout();
            }
            _invalidateRect(l, t, r, b) {
                if (this.skipInvalidate()) {
                    return;
                }
                if ((this.mPrivateFlags & (View.PFLAG_DRAWN | View.PFLAG_HAS_BOUNDS)) == (View.PFLAG_DRAWN | View.PFLAG_HAS_BOUNDS) ||
                    (this.mPrivateFlags & View.PFLAG_DRAWING_CACHE_VALID) == View.PFLAG_DRAWING_CACHE_VALID ||
                    (this.mPrivateFlags & View.PFLAG_INVALIDATED) != View.PFLAG_INVALIDATED) {
                    this.mPrivateFlags &= ~View.PFLAG_DRAWING_CACHE_VALID;
                    this.mPrivateFlags |= View.PFLAG_INVALIDATED;
                    this.mPrivateFlags |= View.PFLAG_DIRTY;
                    const p = this.mParent;
                    const ai = this.mAttachInfo;
                    if (p != null && ai != null && l < r && t < b) {
                        const scrollX = this.mScrollX;
                        const scrollY = this.mScrollY;
                        const tmpr = ai.mTmpInvalRect;
                        tmpr.set(l - scrollX, t - scrollY, r - scrollX, b - scrollY);
                        p.invalidateChild(this, tmpr);
                    }
                }
            }
            _invalidateCache(invalidateCache = true) {
                if (this.skipInvalidate()) {
                    return;
                }
                if ((this.mPrivateFlags & (View.PFLAG_DRAWN | View.PFLAG_HAS_BOUNDS)) == (View.PFLAG_DRAWN | View.PFLAG_HAS_BOUNDS) ||
                    (invalidateCache && (this.mPrivateFlags & View.PFLAG_DRAWING_CACHE_VALID) == View.PFLAG_DRAWING_CACHE_VALID) ||
                    (this.mPrivateFlags & View.PFLAG_INVALIDATED) != View.PFLAG_INVALIDATED || this.isOpaque() != this.mLastIsOpaque) {
                    this.mLastIsOpaque = this.isOpaque();
                    this.mPrivateFlags &= ~View.PFLAG_DRAWN;
                    this.mPrivateFlags |= View.PFLAG_DIRTY;
                    if (invalidateCache) {
                        this.mPrivateFlags |= View.PFLAG_INVALIDATED;
                        this.mPrivateFlags &= ~View.PFLAG_DRAWING_CACHE_VALID;
                    }
                    const ai = this.mAttachInfo;
                    const p = this.mParent;
                    if (p != null && ai != null) {
                        const r = ai.mTmpInvalRect;
                        r.set(0, 0, this.mRight - this.mLeft, this.mBottom - this.mTop);
                        p.invalidateChild(this, r);
                    }
                }
            }
            invalidate(...args) {
                if (args.length === 0 || (args.length === 1 && typeof args[0] === 'boolean')) {
                    this._invalidateCache(args[0]);
                }
                else if (args.length === 1 && args[0] instanceof Rect) {
                    let rect = args[0];
                    this._invalidateRect(rect.left, rect.top, rect.right, rect.bottom);
                }
                else if (args.length === 4) {
                    this._invalidateRect(...args);
                }
            }
            invalidateViewProperty(invalidateParent, forceRedraw) {
                if ((this.mPrivateFlags & View.PFLAG_DRAW_ANIMATION) == View.PFLAG_DRAW_ANIMATION) {
                    if (invalidateParent) {
                        this.invalidateParentCaches();
                    }
                    if (forceRedraw) {
                        this.mPrivateFlags |= View.PFLAG_DRAWN;
                    }
                    this.invalidate(false);
                }
                else {
                    const ai = this.mAttachInfo;
                    const p = this.mParent;
                    if (p != null && ai != null) {
                        const r = ai.mTmpInvalRect;
                        r.set(0, 0, this.mRight - this.mLeft, this.mBottom - this.mTop);
                        if (this.mParent instanceof view_1.ViewGroup) {
                            this.mParent.invalidateChildFast(this, r);
                        }
                        else {
                            this.mParent.invalidateChild(this, r);
                        }
                    }
                }
            }
            invalidateParentCaches() {
                if (this.mParent instanceof View) {
                    this.mParent.mPrivateFlags |= View.PFLAG_INVALIDATED;
                }
            }
            invalidateParentIfNeeded() {
            }
            postInvalidate(l, t, r, b) {
                this.postInvalidateDelayed(0, l, t, r, b);
            }
            postInvalidateDelayed(delayMilliseconds, left, top, right, bottom) {
                const attachInfo = this.mAttachInfo;
                if (attachInfo != null) {
                    if (!Number.isInteger(left) || !Number.isInteger(top) || !Number.isInteger(right) || !Number.isInteger(bottom)) {
                        attachInfo.mViewRootImpl.dispatchInvalidateDelayed(this, delayMilliseconds);
                    }
                    else {
                        const info = View.AttachInfo.InvalidateInfo.obtain();
                        info.target = this;
                        info.left = left;
                        info.top = top;
                        info.right = right;
                        info.bottom = bottom;
                        attachInfo.mViewRootImpl.dispatchInvalidateRectDelayed(info, delayMilliseconds);
                    }
                }
            }
            postInvalidateOnAnimation(left, top, right, bottom) {
                const attachInfo = this.mAttachInfo;
                if (attachInfo != null) {
                    if (!Number.isInteger(left) || !Number.isInteger(top) || !Number.isInteger(right) || !Number.isInteger(bottom)) {
                        attachInfo.mViewRootImpl.dispatchInvalidateOnAnimation(this);
                    }
                    else {
                        const info = View.AttachInfo.InvalidateInfo.obtain();
                        info.target = this;
                        info.left = left;
                        info.top = top;
                        info.right = right;
                        info.bottom = bottom;
                        attachInfo.mViewRootImpl.dispatchInvalidateRectOnAnimation(info);
                    }
                }
            }
            skipInvalidate() {
                return (this.mViewFlags & View.VISIBILITY_MASK) != View.VISIBLE;
            }
            isOpaque() {
                return (this.mPrivateFlags & View.PFLAG_OPAQUE_MASK) == View.PFLAG_OPAQUE_MASK &&
                    this.getFinalAlpha() >= 1;
            }
            computeOpaqueFlags() {
                // Opaque if:
                //   - Has a background
                //   - Background is opaque
                //   - Doesn't have scrollbars or scrollbars overlay
                if (this.mBackground != null && this.mBackground.getOpacity() == PixelFormat.OPAQUE) {
                    this.mPrivateFlags |= View.PFLAG_OPAQUE_BACKGROUND;
                }
                else {
                    this.mPrivateFlags &= ~View.PFLAG_OPAQUE_BACKGROUND;
                }
                const flags = this.mViewFlags;
                if (((flags & View.SCROLLBARS_VERTICAL) == 0 && (flags & View.SCROLLBARS_HORIZONTAL) == 0)) {
                    this.mPrivateFlags |= View.PFLAG_OPAQUE_SCROLLBARS;
                }
                else {
                    this.mPrivateFlags &= ~View.PFLAG_OPAQUE_SCROLLBARS;
                }
            }
            getLayerType() {
                return this.mLayerType;
            }
            setClipBounds(clipBounds) {
                if (clipBounds != null) {
                    if (clipBounds.equals(this.mClipBounds)) {
                        return;
                    }
                    if (this.mClipBounds == null) {
                        this.invalidate();
                        this.mClipBounds = new Rect(clipBounds);
                    }
                    else {
                        this.invalidate(Math.min(this.mClipBounds.left, clipBounds.left), Math.min(this.mClipBounds.top, clipBounds.top), Math.max(this.mClipBounds.right, clipBounds.right), Math.max(this.mClipBounds.bottom, clipBounds.bottom));
                        this.mClipBounds.set(clipBounds);
                    }
                }
                else {
                    if (this.mClipBounds != null) {
                        this.invalidate();
                        this.mClipBounds = null;
                    }
                }
            }
            getClipBounds() {
                return (this.mClipBounds != null) ? new Rect(this.mClipBounds) : null;
            }
            getDrawingTime() {
                return this.mAttachInfo != null ? this.mAttachInfo.mDrawingTime : 0;
            }
            drawFromParent(canvas, parent, drawingTime) {
                let useDisplayListProperties = false;
                let more = false;
                let childHasIdentityMatrix = true;
                let flags = parent.mGroupFlags;
                let scalingRequired = false;
                let concatMatrix = false;
                let caching = false;
                let layerType = this.getLayerType();
                if ((flags & view_1.ViewGroup.FLAG_CHILDREN_DRAWN_WITH_CACHE) != 0 ||
                    (flags & view_1.ViewGroup.FLAG_ALWAYS_DRAWN_WITH_CACHE) != 0) {
                    caching = true;
                }
                else {
                    caching = (layerType != View.LAYER_TYPE_NONE);
                }
                concatMatrix == concatMatrix || !childHasIdentityMatrix;
                this.mPrivateFlags |= View.PFLAG_DRAWN;
                if (!concatMatrix &&
                    (flags & (view_1.ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS |
                        view_1.ViewGroup.FLAG_CLIP_CHILDREN)) == view_1.ViewGroup.FLAG_CLIP_CHILDREN &&
                    canvas.quickReject(this.mLeft, this.mTop, this.mRight, this.mBottom) &&
                    (this.mPrivateFlags & View.PFLAG_DRAW_ANIMATION) == 0) {
                    this.mPrivateFlags2 |= View.PFLAG2_VIEW_QUICK_REJECTED;
                    return more;
                }
                this.mPrivateFlags2 &= ~View.PFLAG2_VIEW_QUICK_REJECTED;
                let cache = null;
                if (caching) {
                    if (layerType != View.LAYER_TYPE_NONE) {
                        layerType = View.LAYER_TYPE_SOFTWARE;
                    }
                }
                this.computeScroll();
                let sx = this.mScrollX;
                let sy = this.mScrollY;
                this.syncScrollToElement();
                let hasNoCache = cache == null;
                let offsetForScroll = cache == null;
                let restoreTo = canvas.save();
                if (offsetForScroll) {
                    canvas.translate(this.mLeft - sx, this.mTop - sy);
                }
                else {
                    canvas.translate(this.mLeft, this.mTop);
                }
                let alpha = 1;
                if ((flags & view_1.ViewGroup.FLAG_CLIP_CHILDREN) == view_1.ViewGroup.FLAG_CLIP_CHILDREN &&
                    !useDisplayListProperties && cache == null) {
                    if (offsetForScroll) {
                        canvas.clipRect(sx, sy, sx + (this.mRight - this.mLeft), sy + (this.mBottom - this.mTop));
                    }
                    else {
                        if (!scalingRequired || cache == null) {
                            canvas.clipRect(0, 0, this.mRight - this.mLeft, this.mBottom - this.mTop);
                        }
                        else {
                            canvas.clipRect(0, 0, cache.getWidth(), cache.getHeight());
                        }
                    }
                }
                if (hasNoCache) {
                    if ((this.mPrivateFlags & View.PFLAG_SKIP_DRAW) == View.PFLAG_SKIP_DRAW) {
                        this.mPrivateFlags &= ~View.PFLAG_DIRTY_MASK;
                        this.dispatchDraw(canvas);
                    }
                    else {
                        this.draw(canvas);
                    }
                }
                else if (cache != null) {
                    this.mPrivateFlags &= ~View.PFLAG_DIRTY_MASK;
                    if (alpha < 1) {
                        parent.mGroupFlags |= view_1.ViewGroup.FLAG_ALPHA_LOWER_THAN_ONE;
                    }
                    else if ((flags & view_1.ViewGroup.FLAG_ALPHA_LOWER_THAN_ONE) != 0) {
                        parent.mGroupFlags &= ~view_1.ViewGroup.FLAG_ALPHA_LOWER_THAN_ONE;
                    }
                    canvas.drawCanvas(cache, 0, 0);
                }
                if (restoreTo >= 0) {
                    canvas.restoreToCount(restoreTo);
                }
                return more;
            }
            draw(canvas) {
                if (this.mClipBounds != null) {
                    canvas.clipRect(this.mClipBounds);
                }
                let privateFlags = this.mPrivateFlags;
                const dirtyOpaque = (privateFlags & View.PFLAG_DIRTY_MASK) == View.PFLAG_DIRTY_OPAQUE &&
                    (this.mAttachInfo == null || !this.mAttachInfo.mIgnoreDirtyState);
                this.mPrivateFlags = (privateFlags & ~View.PFLAG_DIRTY_MASK) | View.PFLAG_DRAWN;
                if (!dirtyOpaque) {
                    let background = this.mBackground;
                    if (background != null) {
                        let scrollX = this.mScrollX;
                        let scrollY = this.mScrollY;
                        if (this.mBackgroundSizeChanged) {
                            background.setBounds(0, 0, this.mRight - this.mLeft, this.mBottom - this.mTop);
                            this.mBackgroundSizeChanged = false;
                        }
                        if ((scrollX | scrollY) == 0) {
                            background.draw(canvas);
                        }
                        else {
                            canvas.translate(scrollX, scrollY);
                            background.draw(canvas);
                            canvas.translate(-scrollX, -scrollY);
                        }
                    }
                }
                if (!dirtyOpaque)
                    this.onDraw(canvas);
                this.dispatchDraw(canvas);
                this.onDrawScrollBars(canvas);
                if (this.mOverlay != null && !this.mOverlay.isEmpty()) {
                    this.mOverlay.getOverlayView().dispatchDraw(canvas);
                }
            }
            onDraw(canvas) {
            }
            dispatchDraw(canvas) {
            }
            onDrawScrollBars(canvas) {
                const cache = this.mScrollCache;
                if (cache != null) {
                    let state = cache.state;
                    if (state == ScrollabilityCache.OFF) {
                        return;
                    }
                    let invalidate = false;
                    if (state == ScrollabilityCache.FADING) {
                        cache._computeAlphaToScrollBar();
                        invalidate = true;
                    }
                    else {
                        cache.scrollBar.setAlpha(255);
                    }
                    const viewFlags = this.mViewFlags;
                    const drawHorizontalScrollBar = (viewFlags & View.SCROLLBARS_HORIZONTAL) == View.SCROLLBARS_HORIZONTAL;
                    const drawVerticalScrollBar = (viewFlags & View.SCROLLBARS_VERTICAL) == View.SCROLLBARS_VERTICAL
                        && !this.isVerticalScrollBarHidden();
                    if (drawVerticalScrollBar || drawHorizontalScrollBar) {
                        const width = this.mRight - this.mLeft;
                        const height = this.mBottom - this.mTop;
                        const scrollBar = cache.scrollBar;
                        const scrollX = this.mScrollX;
                        const scrollY = this.mScrollY;
                        const inside = true;
                        let left;
                        let top;
                        let right;
                        let bottom;
                        if (drawHorizontalScrollBar) {
                            let size = scrollBar.getSize(false);
                            if (size <= 0) {
                                size = cache.scrollBarSize;
                            }
                            scrollBar.setParameters(this.computeHorizontalScrollRange(), this.computeHorizontalScrollOffset(), this.computeHorizontalScrollExtent(), false);
                            const verticalScrollBarGap = drawVerticalScrollBar ?
                                this.getVerticalScrollbarWidth() : 0;
                            top = scrollY + height - size;
                            left = scrollX + (this.mPaddingLeft);
                            right = scrollX + width - -verticalScrollBarGap;
                            bottom = top + size;
                            this.onDrawHorizontalScrollBar(canvas, scrollBar, left, top, right, bottom);
                            if (invalidate) {
                                this.invalidate(left, top, right, bottom);
                            }
                        }
                        if (drawVerticalScrollBar) {
                            let size = scrollBar.getSize(true);
                            if (size <= 0) {
                                size = cache.scrollBarSize;
                            }
                            scrollBar.setParameters(this.computeVerticalScrollRange(), this.computeVerticalScrollOffset(), this.computeVerticalScrollExtent(), true);
                            left = scrollX + width - size;
                            top = scrollY + (this.mPaddingTop);
                            right = left + size;
                            bottom = scrollY + height;
                            this.onDrawVerticalScrollBar(canvas, scrollBar, left, top, right, bottom);
                            if (invalidate) {
                                this.invalidate(left, top, right, bottom);
                            }
                        }
                    }
                }
            }
            isVerticalScrollBarHidden() {
                return false;
            }
            onDrawHorizontalScrollBar(canvas, scrollBar, l, t, r, b) {
                scrollBar.setBounds(l, t, r, b);
                scrollBar.draw(canvas);
            }
            onDrawVerticalScrollBar(canvas, scrollBar, l, t, r, b) {
                scrollBar.setBounds(l, t, r, b);
                scrollBar.draw(canvas);
            }
            isHardwareAccelerated() {
                return false;
            }
            setDrawingCacheEnabled(enabled) {
                this.mCachingFailed = false;
                this.setFlags(enabled ? View.DRAWING_CACHE_ENABLED : 0, View.DRAWING_CACHE_ENABLED);
            }
            isDrawingCacheEnabled() {
                return (this.mViewFlags & View.DRAWING_CACHE_ENABLED) == View.DRAWING_CACHE_ENABLED;
            }
            setDrawingCacheBackgroundColor(color) {
                if (color != this.mDrawingCacheBackgroundColor) {
                    this.mDrawingCacheBackgroundColor = color;
                    this.mPrivateFlags &= ~View.PFLAG_DRAWING_CACHE_VALID;
                }
            }
            getDrawingCacheBackgroundColor() {
                return this.mDrawingCacheBackgroundColor;
            }
            destroyDrawingCache() {
            }
            setWillNotDraw(willNotDraw) {
                this.setFlags(willNotDraw ? View.WILL_NOT_DRAW : 0, View.DRAW_MASK);
            }
            willNotDraw() {
                return (this.mViewFlags & View.DRAW_MASK) == View.WILL_NOT_DRAW;
            }
            setWillNotCacheDrawing(willNotCacheDrawing) {
                this.setFlags(willNotCacheDrawing ? View.WILL_NOT_CACHE_DRAWING : 0, View.WILL_NOT_CACHE_DRAWING);
            }
            willNotCacheDrawing() {
                return (this.mViewFlags & View.WILL_NOT_CACHE_DRAWING) == View.WILL_NOT_CACHE_DRAWING;
            }
            invalidateDrawable(drawable) {
                if (this.verifyDrawable(drawable)) {
                    const dirty = drawable.getBounds();
                    const scrollX = this.mScrollX;
                    const scrollY = this.mScrollY;
                    this.invalidate(dirty.left + scrollX, dirty.top + scrollY, dirty.right + scrollX, dirty.bottom + scrollY);
                }
            }
            scheduleDrawable(who, what, when) {
                if (this.verifyDrawable(who) && what != null) {
                    const delay = when - SystemClock.uptimeMillis();
                    if (this.mAttachInfo != null) {
                        this.mAttachInfo.mHandler.postAtTime(what, who, when);
                    }
                    else {
                        view_1.ViewRootImpl.getRunQueue().postDelayed(what, delay);
                    }
                }
            }
            unscheduleDrawable(who, what) {
                if (this.verifyDrawable(who) && what != null) {
                    if (this.mAttachInfo != null) {
                        this.mAttachInfo.mHandler.removeCallbacks(what, who);
                    }
                    else {
                        view_1.ViewRootImpl.getRunQueue().removeCallbacks(what);
                    }
                }
                else if (what === null) {
                    if (this.mAttachInfo != null && who != null) {
                        this.mAttachInfo.mHandler.removeCallbacksAndMessages(who);
                    }
                }
            }
            verifyDrawable(who) {
                return who == this.mBackground;
            }
            drawableStateChanged() {
                this.getDrawableState();
                let d = this.mBackground;
                if (d != null && d.isStateful()) {
                    d.setState(this.getDrawableState());
                }
            }
            refreshDrawableState() {
                this.mPrivateFlags |= View.PFLAG_DRAWABLE_STATE_DIRTY;
                this.drawableStateChanged();
                let parent = this.mParent;
                if (parent != null) {
                    parent.childDrawableStateChanged(this);
                }
            }
            getDrawableState() {
                if ((this.mDrawableState != null) && ((this.mPrivateFlags & View.PFLAG_DRAWABLE_STATE_DIRTY) == 0)) {
                    return this.mDrawableState;
                }
                else {
                    let oldDrawableState = this.mDrawableState;
                    this.mDrawableState = this.onCreateDrawableState(0);
                    this.mPrivateFlags &= ~View.PFLAG_DRAWABLE_STATE_DIRTY;
                    this._fireStateChangeToAttribute(oldDrawableState, this.mDrawableState);
                    return this.mDrawableState;
                }
            }
            onCreateDrawableState(extraSpace) {
                if ((this.mViewFlags & View.DUPLICATE_PARENT_STATE) == View.DUPLICATE_PARENT_STATE &&
                    this.mParent instanceof View) {
                    return this.mParent.onCreateDrawableState(extraSpace);
                }
                let drawableState;
                let privateFlags = this.mPrivateFlags;
                let viewStateIndex = 0;
                if ((privateFlags & View.PFLAG_PRESSED) != 0)
                    viewStateIndex |= View.VIEW_STATE_PRESSED;
                if ((this.mViewFlags & View.ENABLED_MASK) == View.ENABLED)
                    viewStateIndex |= View.VIEW_STATE_ENABLED;
                if (this.isFocused())
                    viewStateIndex |= View.VIEW_STATE_FOCUSED;
                if ((privateFlags & View.PFLAG_SELECTED) != 0)
                    viewStateIndex |= View.VIEW_STATE_SELECTED;
                if ((privateFlags & View.PFLAG_ACTIVATED) != 0)
                    viewStateIndex |= View.VIEW_STATE_ACTIVATED;
                const privateFlags2 = this.mPrivateFlags2;
                drawableState = View.VIEW_STATE_SETS[viewStateIndex];
                if (extraSpace == 0) {
                    return drawableState;
                }
                let fullState;
                if (drawableState != null) {
                    fullState = new Array(drawableState.length + extraSpace);
                    System.arraycopy(drawableState, 0, fullState, 0, drawableState.length);
                }
                else {
                    fullState = new Array(extraSpace);
                }
                return fullState;
            }
            static mergeDrawableStates(baseState, additionalState) {
                const N = baseState.length;
                let i = N - 1;
                while (i >= 0 && baseState[i] == 0) {
                    i--;
                }
                System.arraycopy(additionalState, 0, baseState, i + 1, additionalState.length);
                return baseState;
            }
            jumpDrawablesToCurrentState() {
                if (this.mBackground != null) {
                    this.mBackground.jumpToCurrentState();
                }
            }
            setBackgroundColor(color) {
                if (this.mBackground instanceof ColorDrawable) {
                    this.mBackground.mutate().setColor(color);
                    this.computeOpaqueFlags();
                }
                else {
                    this.setBackground(new ColorDrawable(color));
                }
            }
            setBackground(background) {
                this.setBackgroundDrawable(background);
            }
            setBackgroundDrawable(background) {
                this.computeOpaqueFlags();
                if (background == this.mBackground) {
                    return;
                }
                let requestLayout = false;
                if (this.mBackground != null) {
                    this.mBackground.setCallback(null);
                    this.unscheduleDrawable(this.mBackground);
                }
                if (background != null) {
                    let padding = new Rect();
                    if (background.getPadding(padding)) {
                        this.setPadding(padding.left, padding.top, padding.right, padding.bottom);
                    }
                    if (this.mBackground == null || this.mBackground.getMinimumHeight() != background.getMinimumHeight() ||
                        this.mBackground.getMinimumWidth() != background.getMinimumWidth()) {
                        requestLayout = true;
                    }
                    background.setCallback(this);
                    if (background.isStateful()) {
                        background.setState(this.getDrawableState());
                    }
                    background.setVisible(this.getVisibility() == View.VISIBLE, false);
                    this.mBackground = background;
                    if ((this.mPrivateFlags & View.PFLAG_SKIP_DRAW) != 0) {
                        this.mPrivateFlags &= ~View.PFLAG_SKIP_DRAW;
                        this.mPrivateFlags |= View.PFLAG_ONLY_DRAWS_BACKGROUND;
                        requestLayout = true;
                    }
                }
                else {
                    this.mBackground = null;
                    if ((this.mPrivateFlags & View.PFLAG_ONLY_DRAWS_BACKGROUND) != 0) {
                        this.mPrivateFlags &= ~View.PFLAG_ONLY_DRAWS_BACKGROUND;
                        this.mPrivateFlags |= View.PFLAG_SKIP_DRAW;
                    }
                    requestLayout = true;
                }
                this.computeOpaqueFlags();
                if (requestLayout) {
                    this.requestLayout();
                }
                this.mBackgroundSizeChanged = true;
                this.invalidate(true);
            }
            getAnimation() {
                return null;
            }
            computeHorizontalScrollRange() {
                return this.getWidth();
            }
            computeHorizontalScrollOffset() {
                return this.mScrollX;
            }
            computeHorizontalScrollExtent() {
                return this.getWidth();
            }
            computeVerticalScrollRange() {
                return this.getHeight();
            }
            computeVerticalScrollOffset() {
                return this.mScrollY;
            }
            computeVerticalScrollExtent() {
                return this.getHeight();
            }
            canScrollHorizontally(direction) {
                const offset = this.computeHorizontalScrollOffset();
                const range = this.computeHorizontalScrollRange() - this.computeHorizontalScrollExtent();
                if (range == 0)
                    return false;
                if (direction < 0) {
                    return offset > 0;
                }
                else {
                    return offset < range - 1;
                }
            }
            canScrollVertically(direction) {
                const offset = this.computeVerticalScrollOffset();
                const range = this.computeVerticalScrollRange() - this.computeVerticalScrollExtent();
                if (range == 0)
                    return false;
                if (direction < 0) {
                    return offset > 0;
                }
                else {
                    return offset < range - 1;
                }
            }
            overScrollBy(deltaX, deltaY, scrollX, scrollY, scrollRangeX, scrollRangeY, maxOverScrollX, maxOverScrollY, isTouchEvent) {
                const overScrollMode = this.mOverScrollMode;
                const canScrollHorizontal = this.computeHorizontalScrollRange() > this.computeHorizontalScrollExtent();
                const canScrollVertical = this.computeVerticalScrollRange() > this.computeVerticalScrollExtent();
                const overScrollHorizontal = overScrollMode == View.OVER_SCROLL_ALWAYS ||
                    (overScrollMode == View.OVER_SCROLL_IF_CONTENT_SCROLLS && canScrollHorizontal);
                const overScrollVertical = overScrollMode == View.OVER_SCROLL_ALWAYS ||
                    (overScrollMode == View.OVER_SCROLL_IF_CONTENT_SCROLLS && canScrollVertical);
                if (isTouchEvent) {
                    if ((deltaX < 0 && scrollX <= 0) || (deltaX > 0 && scrollX >= scrollRangeX)) {
                        deltaX /= 2;
                    }
                    if ((deltaY < 0 && scrollY <= 0) || (deltaY > 0 && scrollY >= scrollRangeY)) {
                        deltaY /= 2;
                    }
                }
                let newScrollX = scrollX + deltaX;
                if (!overScrollHorizontal) {
                    maxOverScrollX = 0;
                }
                let newScrollY = scrollY + deltaY;
                if (!overScrollVertical) {
                    maxOverScrollY = 0;
                }
                const left = -maxOverScrollX;
                const right = maxOverScrollX + scrollRangeX;
                const top = -maxOverScrollY;
                const bottom = maxOverScrollY + scrollRangeY;
                let clampedX = false;
                if (newScrollX > right) {
                    newScrollX = right;
                    clampedX = true;
                }
                else if (newScrollX < left) {
                    newScrollX = left;
                    clampedX = true;
                }
                let clampedY = false;
                if (newScrollY > bottom) {
                    newScrollY = bottom;
                    clampedY = true;
                }
                else if (newScrollY < top) {
                    newScrollY = top;
                    clampedY = true;
                }
                this.onOverScrolled(newScrollX, newScrollY, clampedX, clampedY);
                return clampedX || clampedY;
            }
            onOverScrolled(scrollX, scrollY, clampedX, clampedY) {
            }
            getOverScrollMode() {
                return this.mOverScrollMode;
            }
            setOverScrollMode(overScrollMode) {
                if (overScrollMode != View.OVER_SCROLL_ALWAYS &&
                    overScrollMode != View.OVER_SCROLL_IF_CONTENT_SCROLLS &&
                    overScrollMode != View.OVER_SCROLL_NEVER) {
                    throw new Error("Invalid overscroll mode " + overScrollMode);
                }
                this.mOverScrollMode = overScrollMode;
            }
            getVerticalScrollFactor() {
                if (this.mVerticalScrollFactor == 0) {
                    this.mVerticalScrollFactor = Resources.getDisplayMetrics().density * 1;
                }
                return this.mVerticalScrollFactor;
            }
            getHorizontalScrollFactor() {
                return this.getVerticalScrollFactor();
            }
            computeScroll() {
            }
            scrollTo(x, y) {
                if (this.mScrollX != x || this.mScrollY != y) {
                    let oldX = this.mScrollX;
                    let oldY = this.mScrollY;
                    this.mScrollX = x;
                    this.mScrollY = y;
                    this.invalidateParentCaches();
                    this.onScrollChanged(this.mScrollX, this.mScrollY, oldX, oldY);
                    if (!this.awakenScrollBars()) {
                        this.postInvalidateOnAnimation();
                    }
                }
            }
            scrollBy(x, y) {
                this.scrollTo(this.mScrollX + x, this.mScrollY + y);
            }
            initialAwakenScrollBars() {
                return this.mScrollCache != null &&
                    this.awakenScrollBars(this.mScrollCache.scrollBarDefaultDelayBeforeFade * 4, true);
            }
            awakenScrollBars(startDelay, invalidate = true) {
                const scrollCache = this.mScrollCache;
                if (scrollCache == null)
                    return false;
                startDelay = startDelay || scrollCache.scrollBarDefaultDelayBeforeFade;
                if (scrollCache == null || !scrollCache.fadeScrollBars) {
                    return false;
                }
                if (scrollCache.scrollBar == null) {
                    scrollCache.scrollBar = new ScrollBarDrawable();
                }
                if (this.isHorizontalScrollBarEnabled() || this.isVerticalScrollBarEnabled()) {
                    if (invalidate) {
                        this.postInvalidateOnAnimation();
                    }
                    if (scrollCache.state == ScrollabilityCache.OFF) {
                        const KEY_REPEAT_FIRST_DELAY = 750;
                        startDelay = Math.max(KEY_REPEAT_FIRST_DELAY, startDelay);
                    }
                    let fadeStartTime = AnimationUtils.currentAnimationTimeMillis() + startDelay;
                    scrollCache.fadeStartTime = fadeStartTime;
                    scrollCache.state = ScrollabilityCache.ON;
                    if (this.mAttachInfo != null) {
                        this.mAttachInfo.mHandler.removeCallbacks(scrollCache);
                        this.mAttachInfo.mHandler.postAtTime(scrollCache, fadeStartTime);
                    }
                    return true;
                }
                return false;
            }
            getVerticalFadingEdgeLength() {
                return 0;
            }
            setFadingEdgeLength(length) {
            }
            getHorizontalFadingEdgeLength() {
                return 0;
            }
            getVerticalScrollbarWidth() {
                let cache = this.mScrollCache;
                if (cache != null) {
                    let scrollBar = cache.scrollBar;
                    if (scrollBar != null) {
                        let size = scrollBar.getSize(true);
                        if (size <= 0) {
                            size = cache.scrollBarSize;
                        }
                        return size;
                    }
                    return 0;
                }
                return 0;
            }
            getHorizontalScrollbarHeight() {
                let cache = this.mScrollCache;
                if (cache != null) {
                    let scrollBar = cache.scrollBar;
                    if (scrollBar != null) {
                        let size = scrollBar.getSize(false);
                        if (size <= 0) {
                            size = cache.scrollBarSize;
                        }
                        return size;
                    }
                    return 0;
                }
                return 0;
            }
            initializeScrollbars(a) {
                this.initScrollCache();
            }
            initScrollCache() {
                if (this.mScrollCache == null) {
                    this.mScrollCache = new ScrollabilityCache(this);
                }
            }
            getScrollCache() {
                this.initScrollCache();
                return this.mScrollCache;
            }
            isHorizontalScrollBarEnabled() {
                return (this.mViewFlags & View.SCROLLBARS_HORIZONTAL) == View.SCROLLBARS_HORIZONTAL;
            }
            setHorizontalScrollBarEnabled(horizontalScrollBarEnabled) {
                if (this.isHorizontalScrollBarEnabled() != horizontalScrollBarEnabled) {
                    this.mViewFlags ^= View.SCROLLBARS_HORIZONTAL;
                    this.computeOpaqueFlags();
                }
            }
            isVerticalScrollBarEnabled() {
                return (this.mViewFlags & View.SCROLLBARS_VERTICAL) == View.SCROLLBARS_VERTICAL;
            }
            setVerticalScrollBarEnabled(verticalScrollBarEnabled) {
                if (this.isVerticalScrollBarEnabled() != verticalScrollBarEnabled) {
                    this.mViewFlags ^= View.SCROLLBARS_VERTICAL;
                    this.computeOpaqueFlags();
                }
            }
            setScrollbarFadingEnabled(fadeScrollbars) {
                this.initScrollCache();
                const scrollabilityCache = this.mScrollCache;
                scrollabilityCache.fadeScrollBars = fadeScrollbars;
                if (fadeScrollbars) {
                    scrollabilityCache.state = ScrollabilityCache.OFF;
                }
                else {
                    scrollabilityCache.state = ScrollabilityCache.ON;
                }
            }
            setVerticalScrollbarPosition(position) {
            }
            setHorizontalScrollbarPosition(position) {
            }
            setScrollBarStyle(position) {
            }
            getTopFadingEdgeStrength() {
                return 0;
            }
            getBottomFadingEdgeStrength() {
                return 0;
            }
            getLeftFadingEdgeStrength() {
                return 0;
            }
            getRightFadingEdgeStrength() {
                return 0;
            }
            isScrollbarFadingEnabled() {
                return this.mScrollCache != null && this.mScrollCache.fadeScrollBars;
            }
            getScrollBarDefaultDelayBeforeFade() {
                return this.mScrollCache == null ? view_1.ViewConfiguration.getScrollDefaultDelay() :
                    this.mScrollCache.scrollBarDefaultDelayBeforeFade;
            }
            setScrollBarDefaultDelayBeforeFade(scrollBarDefaultDelayBeforeFade) {
                this.getScrollCache().scrollBarDefaultDelayBeforeFade = scrollBarDefaultDelayBeforeFade;
            }
            getScrollBarFadeDuration() {
                return this.mScrollCache == null ? view_1.ViewConfiguration.getScrollBarFadeDuration() :
                    this.mScrollCache.scrollBarFadeDuration;
            }
            setScrollBarFadeDuration(scrollBarFadeDuration) {
                this.getScrollCache().scrollBarFadeDuration = scrollBarFadeDuration;
            }
            getScrollBarSize() {
                return this.mScrollCache == null ? view_1.ViewConfiguration.get().getScaledScrollBarSize() :
                    this.mScrollCache.scrollBarSize;
            }
            setScrollBarSize(scrollBarSize) {
                this.getScrollCache().scrollBarSize = scrollBarSize;
            }
            hasOpaqueScrollbars() {
                return true;
            }
            assignParent(parent) {
                if (this.mParent == null) {
                    this.mParent = parent;
                }
                else if (parent == null) {
                    this.mParent = null;
                }
                else {
                    throw new Error("view " + this + " being added, but"
                        + " it already has a parent");
                }
            }
            onFinishInflate() {
            }
            dispatchStartTemporaryDetach() {
                this.onStartTemporaryDetach();
            }
            onStartTemporaryDetach() {
                this.removeUnsetPressCallback();
                this.mPrivateFlags |= View.PFLAG_CANCEL_NEXT_UP_EVENT;
            }
            dispatchFinishTemporaryDetach() {
                this.onFinishTemporaryDetach();
            }
            onFinishTemporaryDetach() {
            }
            dispatchWindowFocusChanged(hasFocus) {
                this.onWindowFocusChanged(hasFocus);
            }
            onWindowFocusChanged(hasWindowFocus) {
                if (!hasWindowFocus) {
                    if (this.isPressed()) {
                        this.setPressed(false);
                    }
                    this.removeLongPressCallback();
                    this.removeTapCallback();
                    this.onFocusLost();
                }
                this.refreshDrawableState();
            }
            hasWindowFocus() {
                return this.mAttachInfo != null && this.mAttachInfo.mHasWindowFocus;
            }
            getWindowAttachCount() {
                return this.mWindowAttachCount;
            }
            isAttachedToWindow() {
                return this.mAttachInfo != null;
            }
            dispatchAttachedToWindow(info, visibility) {
                this.mAttachInfo = info;
                if (this.mOverlay != null) {
                    this.mOverlay.getOverlayView().dispatchAttachedToWindow(info, visibility);
                }
                this.mWindowAttachCount++;
                this.mPrivateFlags |= View.PFLAG_DRAWABLE_STATE_DIRTY;
                if (this.mFloatingTreeObserver != null) {
                    info.mTreeObserver.merge(this.mFloatingTreeObserver);
                    this.mFloatingTreeObserver = null;
                }
                if ((this.mPrivateFlags & View.PFLAG_SCROLL_CONTAINER) != 0) {
                    this.mAttachInfo.mScrollContainers.add(this);
                    this.mPrivateFlags |= View.PFLAG_SCROLL_CONTAINER_ADDED;
                }
                this.onAttachedToWindow();
                let li = this.mListenerInfo;
                let listeners = li != null ? li.mOnAttachStateChangeListeners : null;
                if (listeners != null && listeners.size() > 0) {
                    for (let listener of listeners) {
                        listener.onViewAttachedToWindow(this);
                    }
                }
                let vis = info.mWindowVisibility;
                if (vis != View.GONE) {
                    this.onWindowVisibilityChanged(vis);
                }
                if ((this.mPrivateFlags & View.PFLAG_DRAWABLE_STATE_DIRTY) != 0) {
                    this.refreshDrawableState();
                }
            }
            onAttachedToWindow() {
                //if ((this.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
                //    this.mParent.requestTransparentRegion(this);
                //}
                if ((this.mPrivateFlags & View.PFLAG_AWAKEN_SCROLL_BARS_ON_ATTACH) != 0) {
                    this.initialAwakenScrollBars();
                    this.mPrivateFlags &= ~View.PFLAG_AWAKEN_SCROLL_BARS_ON_ATTACH;
                }
                this.mPrivateFlags3 &= ~View.PFLAG3_IS_LAID_OUT;
                this.jumpDrawablesToCurrentState();
            }
            dispatchDetachedFromWindow() {
                let info = this.mAttachInfo;
                if (info != null) {
                    let vis = info.mWindowVisibility;
                    if (vis != View.GONE) {
                        this.onWindowVisibilityChanged(View.GONE);
                    }
                }
                this.onDetachedFromWindow();
                let li = this.mListenerInfo;
                let listeners = li != null ? li.mOnAttachStateChangeListeners : null;
                if (listeners != null && listeners.size() > 0) {
                    for (let listener of listeners) {
                        listener.onViewDetachedFromWindow(this);
                    }
                }
                if ((this.mPrivateFlags & View.PFLAG_SCROLL_CONTAINER_ADDED) != 0) {
                    this.mAttachInfo.mScrollContainers.delete(this);
                    this.mPrivateFlags &= ~View.PFLAG_SCROLL_CONTAINER_ADDED;
                }
                this.mAttachInfo = null;
                if (this.mOverlay != null) {
                    this.mOverlay.getOverlayView().dispatchDetachedFromWindow();
                }
            }
            onDetachedFromWindow() {
                this.mPrivateFlags &= ~View.PFLAG_CANCEL_NEXT_UP_EVENT;
                this.mPrivateFlags3 &= ~View.PFLAG3_IS_LAID_OUT;
                this.removeUnsetPressCallback();
                this.removeLongPressCallback();
                this.removePerformClickCallback();
                this.destroyDrawingCache();
                this.cleanupDraw();
            }
            cleanupDraw() {
                if (this.mAttachInfo != null) {
                    this.mAttachInfo.mViewRootImpl.cancelInvalidate(this);
                }
            }
            debug(depth = 0) {
                let originProto = Object.getPrototypeOf(this);
                console.dir(Object.assign(Object.create(originProto), this));
            }
            toString() {
                return this.tagName();
            }
            getRootView() {
                if (this.mAttachInfo != null) {
                    let v = this.mAttachInfo.mRootView;
                    if (v != null) {
                        return v;
                    }
                }
                let parent = this;
                while (parent.mParent != null && parent.mParent instanceof View) {
                    parent = parent.mParent;
                }
                return parent;
            }
            findViewByPredicateTraversal(predicate, childToSkip) {
                if (predicate.apply(this)) {
                    return this;
                }
                return null;
            }
            findViewById(id) {
                if (!id)
                    return null;
                if (id == this.bindElement.id) {
                    return this;
                }
                return this.findViewTraversal(id);
            }
            findViewTraversal(id) {
                let bindEle = this.bindElement.querySelector('#' + id);
                return bindEle ? bindEle[View.AndroidViewProperty] : null;
            }
            findViewByPredicate(predicate) {
                return this.findViewByPredicateTraversal(predicate, null);
            }
            findViewByPredicateInsideOut(start, predicate) {
                let childToSkip = null;
                for (;;) {
                    let view = start.findViewByPredicateTraversal(predicate, childToSkip);
                    if (view != null || start == this) {
                        return view;
                    }
                    let parent = start.getParent();
                    if (parent == null || !(parent instanceof View)) {
                        return null;
                    }
                    childToSkip = start;
                    start = parent;
                }
            }
            setId(id) {
                if (this._bindElement)
                    this._bindElement.id = id;
            }
            getId() {
                return this.mID;
            }
            setIsRootNamespace(isRoot) {
                if (isRoot) {
                    this.mPrivateFlags |= View.PFLAG_IS_ROOT_NAMESPACE;
                }
                else {
                    this.mPrivateFlags &= ~View.PFLAG_IS_ROOT_NAMESPACE;
                }
            }
            isRootNamespace() {
                return (this.mPrivateFlags & View.PFLAG_IS_ROOT_NAMESPACE) != 0;
            }
            static inflate(eleOrRef, rootElement, viewParent) {
                let domtree;
                if (typeof eleOrRef === "string") {
                    let ref = View.findReference(eleOrRef, rootElement);
                    if (ref == null) {
                        console.warn('not find Reference :' + eleOrRef);
                        return null;
                    }
                    domtree = ref.firstElementChild;
                }
                else {
                    domtree = eleOrRef;
                }
                let className = domtree.tagName;
                if (className.toLowerCase() === 'android-layout') {
                    let child = domtree.firstElementChild;
                    if (child)
                        return View.inflate(child, rootElement, viewParent);
                    return null;
                }
                if (className.startsWith('ANDROID-')) {
                    className = className.substring('ANDROID-'.length);
                }
                let rootViewClass = ClassFinder.findClass(className, android.view);
                if (!rootViewClass)
                    rootViewClass = ClassFinder.findClass(className, android['widget']);
                if (!rootViewClass)
                    rootViewClass = ClassFinder.findClass(className);
                if (!rootViewClass) {
                    console.warn('not find class ' + className);
                    return null;
                }
                let rootView = new rootViewClass();
                if (rootView['onInflateAdapter']) {
                    rootView.onInflateAdapter(domtree, rootElement, viewParent);
                    domtree.parentNode.removeChild(domtree);
                }
                if (!(rootView instanceof View))
                    return rootView;
                rootView.initBindElement(domtree, rootElement);
                let params;
                if (viewParent) {
                    params = viewParent.generateDefaultLayoutParams();
                    this._generateLayoutParamsFromAttribute(domtree, params);
                }
                else {
                    params = this._generateLayoutParamsFromAttribute(domtree);
                }
                rootView.setLayoutParams(params);
                rootView._initAttrObserver();
                if (rootView instanceof view_1.ViewGroup) {
                    let parent = rootView;
                    Array.from(domtree.children).forEach((item) => {
                        if (item instanceof HTMLElement) {
                            let view = View.inflate(item, rootElement, parent);
                            if (view instanceof View)
                                parent.addView(view);
                        }
                    });
                }
                rootView.onFinishInflate();
                return rootView;
            }
            static optReferenceString(refString, currentElement = document, rootElement = document) {
                return View.findReferenceString(refString, currentElement, rootElement) || refString;
            }
            static findReferenceString(refString, currentElement = document, rootElement = document) {
                if (!refString.startsWith('@'))
                    return null;
                let referenceArray = [];
                let attrValue = refString;
                while (attrValue && attrValue.startsWith('@')) {
                    let reference = View.findReference(attrValue, currentElement, rootElement, false);
                    if (referenceArray.indexOf(reference) >= 0)
                        throw Error('findReference Error: circle reference');
                    referenceArray.push(reference);
                    attrValue = reference.innerText;
                }
                return attrValue;
            }
            static findReference(refString, currentElement = document, rootElement = document, cloneNode = true) {
                if (refString && refString.startsWith('@')) {
                    let [tagName, ...refIds] = refString.split('/');
                    tagName = tagName.substring(1);
                    if (!refIds || refIds.length === 0)
                        return null;
                    if (!tagName.startsWith('android-'))
                        tagName = 'android-' + tagName;
                    let q = 'resources ' + tagName + '#' + refIds.join(' #');
                    let el = currentElement.querySelector(q) || rootElement.querySelector(q) || document.querySelector(q);
                    return cloneNode ? el.cloneNode(true) : el;
                }
                return null;
            }
            get bindElement() {
                if (!this._bindElement)
                    this.initBindElement();
                return this._bindElement;
            }
            get rootElement() {
                if (this._rootElement)
                    return this._rootElement;
                if (this.getViewRootImpl())
                    return this.getViewRootImpl().rootElement;
                return null;
            }
            _AttrObserverCallBack(arr, observer) {
                arr.forEach((record) => {
                    let target = record.target;
                    let androidView = target[View.AndroidViewProperty];
                    if (!androidView)
                        return;
                    let attrName = record.attributeName;
                    let newValue = target.getAttribute(attrName);
                    let oldValue = record.oldValue;
                    if (newValue === oldValue)
                        return;
                    androidView.onBindElementAttributeChanged(attrName, record.oldValue, newValue);
                });
            }
            initBindElement(bindElement, rootElement) {
                if (this._bindElement)
                    this._bindElement[View.AndroidViewProperty] = null;
                this._bindElement = bindElement || document.createElement(this.tagName());
                this._bindElement.style.position = 'absolute';
                let oldBindView = this._bindElement[View.AndroidViewProperty];
                if (oldBindView) {
                    if (oldBindView._AttrObserver)
                        oldBindView._AttrObserver.disconnect();
                }
                this._bindElement[View.AndroidViewProperty] = this;
                this._rootElement = rootElement;
                this._stateAttrList = new StateAttrList(this.bindElement, rootElement);
                this._initAttrChangeHandler();
                this._initBindElementDefaultAttribute();
            }
            syncBoundToElement() {
                let bind = this.bindElement;
                bind.style.cssText += `transform: translate(${this.mLeft}px, ${this.mTop}px);
            -webkit-transform: translate(${this.mLeft}px, ${this.mTop}px);`;
                bind.style.width = this.getWidth() + 'px';
                bind.style.height = this.getHeight() + 'px';
            }
            syncScrollToElement() {
                let sx = this.mScrollX;
                let sy = this.mScrollY;
                if (this instanceof view_1.ViewGroup) {
                    let group = this;
                    for (let i = 0, count = group.getChildCount(); i < count; i++) {
                        let child = group.getChildAt(i);
                        let item = child.bindElement;
                        item.style.cssText += `transform: translate(${child.mLeft - sx}px, ${child.mTop - sy}px);
                    -webkit-transform: translate(${child.mLeft - sx}px, ${child.mTop - sy}px);`;
                    }
                }
            }
            syncVisibleToElement() {
                let visibility = this.getVisibility();
                if (visibility === View.VISIBLE) {
                    this.bindElement.style.display = '';
                    this.bindElement.style.visibility = '';
                }
                else if (visibility === View.INVISIBLE) {
                    this.bindElement.style.display = '';
                    this.bindElement.style.visibility = 'hidden';
                }
                else {
                    this.bindElement.style.display = 'none';
                    this.bindElement.style.visibility = '';
                }
            }
            _initAttrChangeHandler() {
                this.createAttrChangeHandler(this._attrChangeHandler);
                if (!this._attrChangeHandler.isCallSuper) {
                    throw Error('must call super when override createAttrChangeHandler!');
                }
            }
            _initAttrObserver() {
                this._fireInitBindElementAttribute();
                if (!this._AttrObserver)
                    this._AttrObserver = new MutationObserver(this._AttrObserverCallBack);
                else
                    this._AttrObserver.disconnect();
                this._AttrObserver.observe(this._bindElement, { attributes: true, attributeOldValue: true });
            }
            _initBindElementDefaultAttribute() {
                for (let [key, value] of this._stateAttrList.getDefaultStateAttr().getAttrMap().entries()) {
                    key = 'android:' + key;
                    if ((value === null || value === undefined) && this.bindElement.hasAttribute(key)) {
                        this.bindElement.removeAttribute(key);
                    }
                    else {
                        this.bindElement.setAttribute(key, value);
                    }
                }
                let id = this.bindElement.getAttribute('android:id');
                if (id)
                    this.bindElement.id = id;
            }
            _fireInitBindElementAttribute() {
                for (let attr of Array.from(this.bindElement.attributes)) {
                    this.onBindElementAttributeChanged(attr.name, null, attr.value);
                }
            }
            _fireStateChangeToAttribute(oldState, newState) {
                if (!this._stateAttrList)
                    return;
                if (oldState + '' === newState + '')
                    return;
                let oldMatchedAttr = oldState ? this._stateAttrList.getMatchedAttr(oldState) : null;
                let matchedAttr = this._stateAttrList.getMatchedAttr(newState);
                let attrMap = matchedAttr.mergeRemovedFrom(oldMatchedAttr);
                for (let [key, value] of attrMap.entries()) {
                    if (oldMatchedAttr) {
                        let oldValue;
                        if (key.startsWith('layout_')) {
                            let params = this.getLayoutParams();
                            if (params) {
                                let attrName = key.substring('layout_'.length);
                                oldValue = params._attrChangeHandler.getViewAttrValue(attrName);
                            }
                        }
                        else {
                            oldValue = this._attrChangeHandler.getViewAttrValue(key);
                        }
                        if (oldValue != null) {
                            oldMatchedAttr.setAttr(key, oldValue);
                        }
                    }
                    key = 'android:' + key;
                    if ((value === null || value === undefined)) {
                        if (this.bindElement.hasAttribute(key)) {
                            this.bindElement.removeAttribute(key);
                        }
                        else {
                            this.onBindElementAttributeChanged(key, null, null);
                        }
                    }
                    else {
                        this.bindElement.setAttribute(key, value);
                    }
                }
            }
            onBindElementAttributeChanged(attributeName, oldVal, newVal) {
                let parts = attributeName.split(":");
                let attrName = parts[parts.length - 1].toLowerCase();
                if (newVal === 'true')
                    newVal = true;
                else if (newVal === 'false')
                    newVal = false;
                if (attrName.startsWith('layout_')) {
                    attrName = attrName.substring('layout_'.length);
                    let params = this.getLayoutParams();
                    if (params) {
                        params._attrChangeHandler.handle(attrName, newVal);
                    }
                    this.requestLayout();
                    return;
                }
                this._attrChangeHandler.handle(attrName, newVal);
            }
            static _generateLayoutParamsFromAttribute(node, dest = new view_1.ViewGroup.LayoutParams(-2, -2)) {
                Array.from(node.attributes).forEach((attr) => {
                    let layoutParamFiled = attr.name.split("layout_")[1];
                    dest._attrChangeHandler.handle(layoutParamFiled, attr.value);
                });
                return dest;
            }
            tagName() {
                return "ANDROID-" + this.constructor.name;
            }
        }
        View.DBG = Log.View_DBG;
        View.VIEW_LOG_TAG = "View";
        View.PFLAG_WANTS_FOCUS = 0x00000001;
        View.PFLAG_FOCUSED = 0x00000002;
        View.PFLAG_SELECTED = 0x00000004;
        View.PFLAG_IS_ROOT_NAMESPACE = 0x00000008;
        View.PFLAG_HAS_BOUNDS = 0x00000010;
        View.PFLAG_DRAWN = 0x00000020;
        View.PFLAG_DRAW_ANIMATION = 0x00000040;
        View.PFLAG_SKIP_DRAW = 0x00000080;
        View.PFLAG_ONLY_DRAWS_BACKGROUND = 0x00000100;
        View.PFLAG_REQUEST_TRANSPARENT_REGIONS = 0x00000200;
        View.PFLAG_DRAWABLE_STATE_DIRTY = 0x00000400;
        View.PFLAG_MEASURED_DIMENSION_SET = 0x00000800;
        View.PFLAG_FORCE_LAYOUT = 0x00001000;
        View.PFLAG_LAYOUT_REQUIRED = 0x00002000;
        View.PFLAG_PRESSED = 0x00004000;
        View.PFLAG_DRAWING_CACHE_VALID = 0x00008000;
        View.PFLAG_ANIMATION_STARTED = 0x00010000;
        View.PFLAG_ALPHA_SET = 0x00040000;
        View.PFLAG_SCROLL_CONTAINER = 0x00080000;
        View.PFLAG_SCROLL_CONTAINER_ADDED = 0x00100000;
        View.PFLAG_DIRTY = 0x00200000;
        View.PFLAG_DIRTY_OPAQUE = 0x00400000;
        View.PFLAG_DIRTY_MASK = 0x00600000;
        View.PFLAG_OPAQUE_BACKGROUND = 0x00800000;
        View.PFLAG_OPAQUE_SCROLLBARS = 0x01000000;
        View.PFLAG_OPAQUE_MASK = 0x01800000;
        View.PFLAG_PREPRESSED = 0x02000000;
        View.PFLAG_CANCEL_NEXT_UP_EVENT = 0x04000000;
        View.PFLAG_AWAKEN_SCROLL_BARS_ON_ATTACH = 0x08000000;
        View.PFLAG_HOVERED = 0x10000000;
        View.PFLAG_PIVOT_EXPLICITLY_SET = 0x20000000;
        View.PFLAG_ACTIVATED = 0x40000000;
        View.PFLAG_INVALIDATED = 0x80000000;
        View.PFLAG2_VIEW_QUICK_REJECTED = 0x10000000;
        View.PFLAG2_HAS_TRANSIENT_STATE = 0x80000000;
        View.PFLAG3_VIEW_IS_ANIMATING_TRANSFORM = 0x1;
        View.PFLAG3_VIEW_IS_ANIMATING_ALPHA = 0x2;
        View.PFLAG3_IS_LAID_OUT = 0x4;
        View.PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT = 0x8;
        View.PFLAG3_CALLED_SUPER = 0x10;
        View.NOT_FOCUSABLE = 0x00000000;
        View.FOCUSABLE = 0x00000001;
        View.FOCUSABLE_MASK = 0x00000001;
        View.OVER_SCROLL_ALWAYS = 0;
        View.OVER_SCROLL_IF_CONTENT_SCROLLS = 1;
        View.OVER_SCROLL_NEVER = 2;
        View.MEASURED_SIZE_MASK = 0x00ffffff;
        View.MEASURED_STATE_MASK = 0xff000000;
        View.MEASURED_HEIGHT_STATE_SHIFT = 16;
        View.MEASURED_STATE_TOO_SMALL = 0x01000000;
        View.VISIBILITY_MASK = 0x0000000C;
        View.VISIBLE = 0x00000000;
        View.INVISIBLE = 0x00000004;
        View.GONE = 0x00000008;
        View.ENABLED = 0x00000000;
        View.DISABLED = 0x00000020;
        View.ENABLED_MASK = 0x00000020;
        View.WILL_NOT_DRAW = 0x00000080;
        View.DRAW_MASK = 0x00000080;
        View.SCROLLBARS_NONE = 0x00000000;
        View.SCROLLBARS_HORIZONTAL = 0x00000100;
        View.SCROLLBARS_VERTICAL = 0x00000200;
        View.SCROLLBARS_MASK = 0x00000300;
        View.FOCUSABLES_ALL = 0x00000000;
        View.FOCUSABLES_TOUCH_MODE = 0x00000001;
        View.FOCUS_BACKWARD = 0x00000001;
        View.FOCUS_FORWARD = 0x00000002;
        View.FOCUS_LEFT = 0x00000011;
        View.FOCUS_UP = 0x00000021;
        View.FOCUS_RIGHT = 0x00000042;
        View.FOCUS_DOWN = 0x00000082;
        View.VIEW_STATE_WINDOW_FOCUSED = 1;
        View.VIEW_STATE_SELECTED = 1 << 1;
        View.VIEW_STATE_FOCUSED = 1 << 2;
        View.VIEW_STATE_ENABLED = 1 << 3;
        View.VIEW_STATE_DISABLE = -View.VIEW_STATE_ENABLED;
        View.VIEW_STATE_PRESSED = 1 << 4;
        View.VIEW_STATE_ACTIVATED = 1 << 5;
        View.VIEW_STATE_HOVERED = 1 << 7;
        View.VIEW_STATE_IDS = [
            View.VIEW_STATE_WINDOW_FOCUSED, View.VIEW_STATE_WINDOW_FOCUSED,
            View.VIEW_STATE_SELECTED, View.VIEW_STATE_SELECTED,
            View.VIEW_STATE_FOCUSED, View.VIEW_STATE_FOCUSED,
            View.VIEW_STATE_ENABLED, View.VIEW_STATE_ENABLED,
            View.VIEW_STATE_PRESSED, View.VIEW_STATE_PRESSED,
            View.VIEW_STATE_ACTIVATED, View.VIEW_STATE_ACTIVATED,
            View.VIEW_STATE_HOVERED, View.VIEW_STATE_HOVERED,
        ];
        View._static = (() => {
            function Integer_bitCount(i) {
                i = i - ((i >>> 1) & 0x55555555);
                i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);
                i = (i + (i >>> 4)) & 0x0f0f0f0f;
                i = i + (i >>> 8);
                i = i + (i >>> 16);
                return i & 0x3f;
            }
            let orderedIds = View.VIEW_STATE_IDS;
            const NUM_BITS = View.VIEW_STATE_IDS.length / 2;
            View.VIEW_STATE_SETS = new Array(1 << NUM_BITS);
            for (let i = 0; i < View.VIEW_STATE_SETS.length; i++) {
                let numBits = Integer_bitCount(i);
                const stataSet = new Array(numBits);
                let pos = 0;
                for (let j = 0; j < orderedIds.length; j += 2) {
                    if ((i & orderedIds[j + 1]) != 0) {
                        stataSet[pos++] = orderedIds[j];
                    }
                }
                View.VIEW_STATE_SETS[i] = stataSet;
            }
            View.EMPTY_STATE_SET = View.VIEW_STATE_SETS[0];
            View.WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED];
            View.SELECTED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_SELECTED];
            View.SELECTED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_SELECTED];
            View.FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_FOCUSED];
            View.FOCUSED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_FOCUSED];
            View.FOCUSED_SELECTED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_SELECTED | View.VIEW_STATE_FOCUSED];
            View.FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_SELECTED | View.VIEW_STATE_FOCUSED];
            View.ENABLED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_ENABLED];
            View.ENABLED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_ENABLED];
            View.ENABLED_SELECTED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_SELECTED | View.VIEW_STATE_ENABLED];
            View.ENABLED_SELECTED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_SELECTED | View.VIEW_STATE_ENABLED];
            View.ENABLED_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_FOCUSED | View.VIEW_STATE_ENABLED];
            View.ENABLED_FOCUSED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_FOCUSED | View.VIEW_STATE_ENABLED];
            View.ENABLED_FOCUSED_SELECTED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_SELECTED | View.VIEW_STATE_FOCUSED | View.VIEW_STATE_ENABLED];
            View.ENABLED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_SELECTED | View.VIEW_STATE_FOCUSED | View.VIEW_STATE_ENABLED];
            View.PRESSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_PRESSED];
            View.PRESSED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_PRESSED];
            View.PRESSED_SELECTED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_SELECTED | View.VIEW_STATE_PRESSED];
            View.PRESSED_SELECTED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_SELECTED | View.VIEW_STATE_PRESSED];
            View.PRESSED_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_FOCUSED | View.VIEW_STATE_PRESSED];
            View.PRESSED_FOCUSED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_FOCUSED | View.VIEW_STATE_PRESSED];
            View.PRESSED_FOCUSED_SELECTED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_SELECTED | View.VIEW_STATE_FOCUSED | View.VIEW_STATE_PRESSED];
            View.PRESSED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_SELECTED | View.VIEW_STATE_FOCUSED | View.VIEW_STATE_PRESSED];
            View.PRESSED_ENABLED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_ENABLED | View.VIEW_STATE_PRESSED];
            View.PRESSED_ENABLED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_ENABLED | View.VIEW_STATE_PRESSED];
            View.PRESSED_ENABLED_SELECTED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_SELECTED | View.VIEW_STATE_ENABLED | View.VIEW_STATE_PRESSED];
            View.PRESSED_ENABLED_SELECTED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_SELECTED | View.VIEW_STATE_ENABLED | View.VIEW_STATE_PRESSED];
            View.PRESSED_ENABLED_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_FOCUSED | View.VIEW_STATE_ENABLED | View.VIEW_STATE_PRESSED];
            View.PRESSED_ENABLED_FOCUSED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_FOCUSED | View.VIEW_STATE_ENABLED | View.VIEW_STATE_PRESSED];
            View.PRESSED_ENABLED_FOCUSED_SELECTED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_SELECTED | View.VIEW_STATE_FOCUSED | View.VIEW_STATE_ENABLED | View.VIEW_STATE_PRESSED];
            View.PRESSED_ENABLED_FOCUSED_SELECTED_WINDOW_FOCUSED_STATE_SET = View.VIEW_STATE_SETS[View.VIEW_STATE_WINDOW_FOCUSED | View.VIEW_STATE_SELECTED | View.VIEW_STATE_FOCUSED | View.VIEW_STATE_ENABLED | View.VIEW_STATE_PRESSED];
        })();
        View.CLICKABLE = 0x00004000;
        View.DRAWING_CACHE_ENABLED = 0x00008000;
        View.WILL_NOT_CACHE_DRAWING = 0x000020000;
        View.FOCUSABLE_IN_TOUCH_MODE = 0x00040000;
        View.LONG_CLICKABLE = 0x00200000;
        View.DUPLICATE_PARENT_STATE = 0x00400000;
        View.LAYER_TYPE_NONE = 0;
        View.LAYER_TYPE_SOFTWARE = 1;
        View.AndroidViewProperty = 'AndroidView';
        view_1.View = View;
        (function (View) {
            class MeasureSpec {
                static makeMeasureSpec(size, mode) {
                    return (size & ~MeasureSpec.MODE_MASK) | (mode & MeasureSpec.MODE_MASK);
                }
                static getMode(measureSpec) {
                    return (measureSpec & MeasureSpec.MODE_MASK);
                }
                static getSize(measureSpec) {
                    return (measureSpec & ~MeasureSpec.MODE_MASK);
                }
                static adjust(measureSpec, delta) {
                    return MeasureSpec.makeMeasureSpec(MeasureSpec.getSize(measureSpec + delta), MeasureSpec.getMode(measureSpec));
                }
                static toString(measureSpec) {
                    let mode = MeasureSpec.getMode(measureSpec);
                    let size = MeasureSpec.getSize(measureSpec);
                    let sb = new StringBuilder("MeasureSpec: ");
                    if (mode == MeasureSpec.UNSPECIFIED)
                        sb.append("UNSPECIFIED ");
                    else if (mode == MeasureSpec.EXACTLY)
                        sb.append("EXACTLY ");
                    else if (mode == MeasureSpec.AT_MOST)
                        sb.append("AT_MOST ");
                    else
                        sb.append(mode).append(" ");
                    sb.append(size);
                    return sb.toString();
                }
            }
            MeasureSpec.MODE_SHIFT = 30;
            MeasureSpec.MODE_MASK = 0x3 << MeasureSpec.MODE_SHIFT;
            MeasureSpec.UNSPECIFIED = 0 << MeasureSpec.MODE_SHIFT;
            MeasureSpec.EXACTLY = 1 << MeasureSpec.MODE_SHIFT;
            MeasureSpec.AT_MOST = 2 << MeasureSpec.MODE_SHIFT;
            View.MeasureSpec = MeasureSpec;
            class AttachInfo {
                constructor(mViewRootImpl, mHandler) {
                    this.mWindowLeft = 0;
                    this.mWindowTop = 0;
                    this.mKeyDispatchState = new KeyEvent.DispatcherState();
                    this.mDrawingTime = 0;
                    this.mTmpInvalRect = new Rect();
                    this.mTmpTransformRect = new Rect();
                    this.mScrollContainers = new Set();
                    this.mViewScrollChanged = false;
                    this.mTreeObserver = new view_1.ViewTreeObserver();
                    this.mViewVisibilityChanged = false;
                    this.mInvalidateChildLocation = new Array(2);
                    this.mIgnoreDirtyState = false;
                    this.mSetIgnoreDirtyState = false;
                    this.mHasWindowFocus = false;
                    this.mWindowVisibility = 0;
                    this.mInTouchMode = false;
                    this.mViewRootImpl = mViewRootImpl;
                    this.mHandler = mHandler;
                }
            }
            View.AttachInfo = AttachInfo;
            class ListenerInfo {
            }
            View.ListenerInfo = ListenerInfo;
            class AttrChangeHandler {
                constructor(view) {
                    this.isCallSuper = false;
                    this.handlers = [];
                    this.objectRefs = [];
                    this.view = view;
                }
                add(handler) {
                    this.handlers.push(handler);
                }
                handle(name, value) {
                    for (let handler of this.handlers) {
                        for (let key in handler) {
                            if (key.toLowerCase() === name) {
                                handler[key] = value;
                            }
                        }
                    }
                }
                getViewAttrValue(attrName) {
                    for (let handler of this.handlers) {
                        for (let key in handler) {
                            if (key.toLowerCase() === attrName.toLowerCase()) {
                                let value = handler[key];
                                if (value == null)
                                    return null;
                                if (typeof value === "number")
                                    return value + '';
                                if (typeof value === "boolean")
                                    return value + '';
                                if (typeof value === "string")
                                    return value;
                                return this.setRefObject(value);
                            }
                        }
                    }
                    return null;
                }
                getRefObject(ref, recycel = true) {
                    if (ref && ref.startsWith('@ref/')) {
                        ref = ref.substring(5);
                        let index = Number.parseInt(ref);
                        if (Number.isInteger(index)) {
                            let obj = this.objectRefs[index];
                            if (recycel)
                                this.objectRefs[index] = null;
                            return obj;
                        }
                    }
                }
                setRefObject(obj) {
                    let length = this.objectRefs.length;
                    for (let i = 0; i < length; i++) {
                        if (this.objectRefs[i] == null) {
                            this.objectRefs[i] = obj;
                            return '@ref/' + i;
                        }
                    }
                    this.objectRefs.push(obj);
                    return '@ref/' + length;
                }
                static parsePaddingMarginLTRB(value) {
                    value = (value + '');
                    let parts = [];
                    for (let part of value.split(' ')) {
                        if (part)
                            parts.push(part);
                    }
                    switch (parts.length) {
                        case 1: return [parts[0], parts[0], parts[0], parts[0]];
                        case 2: return [parts[1], parts[0], parts[1], parts[0]];
                        case 3: return [parts[1], parts[0], parts[1], parts[2]];
                        case 4: return [parts[3], parts[0], parts[1], parts[2]];
                    }
                    throw Error('not a padding or margin value : ' + value);
                }
                static parseBoolean(value, defaultValue = true) {
                    if (value === false || value === 'fales' || value === '0')
                        return false;
                    else if (value === true || value === 'true' || value === '1' || value === '')
                        return true;
                    return defaultValue;
                }
                parseBoolean(value, defaultValue = true) {
                    return AttrChangeHandler.parseBoolean(value, defaultValue);
                }
                static parseGravity(s, defaultValue = view_1.Gravity.NO_GRAVITY) {
                    let gravity = Number.parseInt(s);
                    if (Number.isInteger(gravity))
                        return gravity;
                    gravity = view_1.Gravity.NO_GRAVITY;
                    try {
                        let parts = s.split("|");
                        parts.forEach((part) => {
                            let g = view_1.Gravity[part.toUpperCase()];
                            if (Number.isInteger(g))
                                gravity |= g;
                        });
                    }
                    catch (e) {
                        console.error(e);
                    }
                    if (Number.isNaN(gravity) || gravity === view_1.Gravity.NO_GRAVITY)
                        gravity = defaultValue;
                    return gravity;
                }
                parseGravity(s, defaultValue = view_1.Gravity.NO_GRAVITY) {
                    return AttrChangeHandler.parseGravity(s, defaultValue);
                }
                parseDrawable(s) {
                    if (!s)
                        return null;
                    if (s.startsWith('@')) {
                        let refObj = this.getRefObject(s);
                        if (refObj)
                            return refObj;
                    }
                    else {
                        let color = this.parseColor(s);
                        return new ColorDrawable(color);
                    }
                }
                parseColor(value) {
                    let color = Number.parseInt(value);
                    if (Number.isInteger(color))
                        return color;
                    if (value.startsWith('rgb(')) {
                        value = value.replace('rgb(', '').replace(')', '');
                        let parts = value.split(',');
                        return Color.rgb(Number.parseInt(parts[0]), Number.parseInt(parts[1]), Number.parseInt(parts[2]));
                    }
                    else if (value.startsWith('rgba(')) {
                        value = value.replace('rgba(', '').replace(')', '');
                        let parts = value.split(',');
                        return Color.rgba(Number.parseInt(parts[0]), Number.parseInt(parts[1]), Number.parseInt(parts[2]), Number.parseInt(parts[2]) * 255);
                    }
                    else {
                        if (value.startsWith('#') && value.length === 4) {
                            value = '#' + value[1] + value[1] + value[2] + value[2] + value[2] + value[2];
                        }
                        try {
                            return Color.parseColor(value);
                        }
                        catch (e) {
                        }
                    }
                }
                parseColorList(value) {
                    if (!value)
                        return null;
                    if (value.startsWith('@')) {
                        let refObj = this.getRefObject(value);
                        if (refObj)
                            return refObj;
                    }
                    else {
                        let color = this.parseColor(value);
                        return ColorStateList.valueOf(color);
                    }
                    return null;
                }
                parseNumber(value, defaultValue = 0) {
                    try {
                        return TypedValue.complexToDimensionPixelSize(value);
                    }
                    catch (e) {
                        return defaultValue;
                    }
                }
            }
            View.AttrChangeHandler = AttrChangeHandler;
        })(View = view_1.View || (view_1.View = {}));
        (function (View) {
            var AttachInfo;
            (function (AttachInfo) {
                class InvalidateInfo {
                    constructor() {
                        this.left = 0;
                        this.top = 0;
                        this.right = 0;
                        this.bottom = 0;
                    }
                    static obtain() {
                        let instance = InvalidateInfo.sPool.acquire();
                        return (instance != null) ? instance : new InvalidateInfo();
                    }
                    recycle() {
                        this.target = null;
                        InvalidateInfo.sPool.release(this);
                    }
                }
                InvalidateInfo.POOL_LIMIT = 10;
                InvalidateInfo.sPool = new Pools.SynchronizedPool(InvalidateInfo.POOL_LIMIT);
                AttachInfo.InvalidateInfo = InvalidateInfo;
            })(AttachInfo = View.AttachInfo || (View.AttachInfo = {}));
        })(View = view_1.View || (view_1.View = {}));
        class CheckForLongPress {
            constructor(View_this) {
                this.mOriginalWindowAttachCount = 0;
                this.View_this = View_this;
            }
            run() {
                if (this.View_this.isPressed() && (this.View_this.mParent != null)
                    && this.mOriginalWindowAttachCount == this.View_this.mWindowAttachCount) {
                    if (this.View_this.performLongClick()) {
                        this.View_this.mHasPerformedLongPress = true;
                    }
                }
            }
            rememberWindowAttachCount() {
                this.mOriginalWindowAttachCount = this.View_this.mWindowAttachCount;
            }
        }
        class CheckForTap {
            constructor(View_this) {
                this.View_this = View_this;
            }
            run() {
                this.View_this.mPrivateFlags &= ~View.PFLAG_PREPRESSED;
                this.View_this.setPressed(true);
                this.View_this.checkForLongClick(view_1.ViewConfiguration.getTapTimeout());
            }
        }
        class PerformClick {
            constructor(View_this) {
                this.View_this = View_this;
            }
            run() {
                this.View_this.performClick();
            }
        }
        class UnsetPressedState {
            constructor(View_this) {
                this.View_this = View_this;
            }
            run() {
                this.View_this.setPressed(false);
            }
        }
        class ScrollabilityCache {
            constructor(host) {
                this.fadeScrollBars = true;
                this.fadingEdgeLength = view_1.ViewConfiguration.get().getScaledFadingEdgeLength();
                this.scrollBarDefaultDelayBeforeFade = view_1.ViewConfiguration.getScrollDefaultDelay();
                this.scrollBarFadeDuration = view_1.ViewConfiguration.getScrollBarFadeDuration();
                this.scrollBarSize = view_1.ViewConfiguration.get().getScaledScrollBarSize();
                this.interpolator = new LinearInterpolator();
                this.state = ScrollabilityCache.OFF;
                this.host = host;
                this.scrollBar = new ScrollBarDrawable();
                let thumbColor = new ColorDrawable(0x44000000);
                let density = Resources.getDisplayMetrics().density;
                let thumb = new InsetDrawable(thumbColor, 0, 2 * density, view_1.ViewConfiguration.get().getScaledScrollBarSize() / 2, 2 * density);
                this.scrollBar.setHorizontalThumbDrawable(thumb);
                this.scrollBar.setVerticalThumbDrawable(thumb);
            }
            run() {
                let now = AnimationUtils.currentAnimationTimeMillis();
                if (now >= this.fadeStartTime) {
                    this.state = ScrollabilityCache.FADING;
                    this.host.invalidate(true);
                }
            }
            _computeAlphaToScrollBar() {
                let now = AnimationUtils.currentAnimationTimeMillis();
                let factor = (now - this.fadeStartTime) / this.scrollBarFadeDuration;
                if (factor >= 1) {
                    this.state = ScrollabilityCache.OFF;
                    factor = 1;
                }
                let alpha = 1 - this.interpolator.getInterpolation(factor);
                this.scrollBar.setAlpha(255 * alpha);
            }
        }
        ScrollabilityCache.OFF = 0;
        ScrollabilityCache.ON = 1;
        ScrollabilityCache.FADING = 2;
        class MatchIdPredicate {
            apply(view) {
                return view.mID === this.mId;
            }
        }
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        class Point {
            constructor(...args) {
                this.x = 0;
                this.y = 0;
                if (args.length === 1) {
                    let src = args[0];
                    this.x = src.x;
                    this.y = src.y;
                }
                else {
                    let [x = 0, y = 0] = args;
                    this.x = x;
                    this.y = y;
                }
            }
            set(x, y) {
                this.x = x;
                this.y = y;
            }
            negate() {
                this.x = -this.x;
                this.y = -this.y;
            }
            offset(dx, dy) {
                this.x += dx;
                this.y += dy;
            }
            equals(...args) {
                if (args.length === 2) {
                    let [x = 0, y = 0] = args;
                    return this.x == x && this.y == y;
                }
                else {
                    let o = args[0];
                    if (this === o)
                        return true;
                    if (!o || !(o instanceof Point))
                        return false;
                    let point = o;
                    if (this.x != point.x)
                        return false;
                    if (this.y != point.y)
                        return false;
                    return true;
                }
            }
            toString() {
                return "Point(" + this.x + ", " + this.y + ")";
            }
        }
        graphics.Point = Point;
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/5.
 */
///<reference path="View.ts"/>
///<reference path="../graphics/Point.ts"/>
///<reference path="../graphics/Rect.ts"/>
/**
 * Created by linfaxin on 15/10/13.
 */
///<reference path="../graphics/Rect.ts"/>
///<reference path="../graphics/Canvas.ts"/>
///<reference path="../graphics/Canvas.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var Rect = android.graphics.Rect;
        var Canvas = android.graphics.Canvas;
        class Surface {
            constructor(canvasElement) {
                this.mLockedCanvasMap = new WeakMap();
                this.mCanvasElement = canvasElement;
            }
            lockCanvas(dirty) {
                let fullWidth = this.mCanvasElement.width;
                let fullHeight = this.mCanvasElement.height;
                let rect;
                if (dirty.isEmpty()) {
                    rect = new Rect(0, 0, fullWidth, fullHeight);
                }
                else {
                    rect = new Rect(Math.floor(dirty.left - 1), Math.floor(dirty.top - 1), Math.ceil(dirty.right + 1), Math.ceil(dirty.bottom + 1));
                }
                let width = rect.width();
                let height = rect.height();
                let canvas = new Canvas(width, height);
                canvas.translate(-rect.left, -rect.top);
                this.mLockedCanvasMap.set(canvas, rect);
                let mCanvasContent = this.mCanvasElement.getContext('2d');
                mCanvasContent.clearRect(rect.left, rect.top, width, height);
                return canvas;
            }
            unlockCanvasAndPost(canvas) {
                let rect = this.mLockedCanvasMap.get(canvas);
                if (rect) {
                    let mCanvasContent = this.mCanvasElement.getContext('2d');
                    mCanvasContent.drawImage(canvas.canvasElement, rect.left, rect.top);
                }
            }
        }
        view.Surface = Surface;
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
///<reference path="ViewParent.ts"/>
///<reference path="View.ts"/>
///<reference path="Surface.ts"/>
///<reference path="../util/Log.ts"/>
///<reference path="../util/Log.ts"/>
///<reference path="../os/Handler.ts"/>
///<reference path="../os/Message.ts"/>
///<reference path="../os/SystemClock.ts"/>
///<reference path="../content/res/Resources.ts"/>
///<reference path="../graphics/Point.ts"/>
///<reference path="../graphics/Rect.ts"/>
///<reference path="../graphics/Canvas.ts"/>
///<reference path="../../java/lang/Runnable.ts"/>
///<reference path="../../java/lang/System.ts"/>
var android;
(function (android) {
    var view;
    (function (view_2) {
        var View = android.view.View;
        var Resources = android.content.res.Resources;
        var Rect = android.graphics.Rect;
        var Handler = android.os.Handler;
        var SystemClock = android.os.SystemClock;
        var System = java.lang.System;
        var Log = android.util.Log;
        var Surface = android.view.Surface;
        class ViewRootImpl {
            constructor() {
                this.mViewVisibility = View.GONE;
                this.mStopped = false;
                this.mWidth = -1;
                this.mHeight = -1;
                this.mDirty = new Rect();
                this.mTempRect = new Rect();
                this.mVisRect = new Rect();
                this.mTraversalScheduled = false;
                this.mWillDrawSoon = false;
                this.mIsInTraversal = false;
                this.mLayoutRequested = false;
                this.mFirst = true;
                this.mFullRedrawNeeded = false;
                this.mIsDrawing = false;
                this.mAdded = false;
                this.mAddedTouchMode = false;
                this.mWinFrame = new Rect();
                this.mLayoutRequesters = [];
                this.mHandler = new ViewRootHandler();
                this.mFpsStartTime = -1;
                this.mFpsPrevTime = -1;
                this.mFpsNumFrames = 0;
                this.mInvalidateOnAnimationRunnable = new InvalidateOnAnimationRunnable(this.mHandler);
                this.mAttachInfo = new View.AttachInfo(this, this.mHandler);
                this.mTraversalRunnable = new TraversalRunnable(this);
            }
            initSurface(canvasElement) {
                this.mSurface = new Surface(canvasElement);
            }
            setView(view) {
                if (this.mView == null) {
                    this.mView = view;
                    this.mAttachInfo.mRootView = view;
                    this.mAdded = true;
                    this.requestLayout();
                    view.assignParent(this);
                    this.mAddedTouchMode = true;
                    let syntheticInputStage = new SyntheticInputStage(this);
                    let viewPostImeStage = new ViewPostImeInputStage(this, syntheticInputStage);
                    let earlyPostImeStage = new EarlyPostImeInputStage(this, viewPostImeStage);
                    this.mFirstInputStage = earlyPostImeStage;
                }
            }
            getView() {
                return this.mView;
            }
            getHostVisibility() {
                return this.mView.getVisibility();
            }
            scheduleTraversals() {
                if (!this.mTraversalScheduled) {
                    this.mTraversalScheduled = true;
                    this.mHandler.post(this.mTraversalRunnable);
                }
            }
            unscheduleTraversals() {
                if (this.mTraversalScheduled) {
                    this.mTraversalScheduled = false;
                    this.mHandler.removeCallbacks(this.mTraversalRunnable);
                }
            }
            doTraversal() {
                if (this.mTraversalScheduled) {
                    this.mTraversalScheduled = false;
                    this.performTraversals();
                }
            }
            measureHierarchy(host, lp, desiredWindowWidth, desiredWindowHeight) {
                let windowSizeMayChange = false;
                if (ViewRootImpl.DEBUG_ORIENTATION || ViewRootImpl.DEBUG_LAYOUT)
                    Log.v(ViewRootImpl.TAG, "Measuring " + host + " in display " + desiredWindowWidth
                        + "x" + desiredWindowHeight + "...");
                let childWidthMeasureSpec = ViewRootImpl.getRootMeasureSpec(desiredWindowWidth, lp.width);
                let childHeightMeasureSpec = ViewRootImpl.getRootMeasureSpec(desiredWindowHeight, lp.height);
                this.performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
                if (this.mWidth != host.getMeasuredWidth() || this.mHeight != host.getMeasuredHeight()) {
                    windowSizeMayChange = true;
                }
                if (ViewRootImpl.DBG) {
                    System.out.println("======================================");
                    System.out.println("performTraversals -- after measure");
                    host.debug();
                }
                return windowSizeMayChange;
            }
            static getRootMeasureSpec(windowSize, rootDimension) {
                let MeasureSpec = View.MeasureSpec;
                let measureSpec;
                switch (rootDimension) {
                    case view_2.ViewGroup.LayoutParams.MATCH_PARENT:
                        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);
                        break;
                    case view_2.ViewGroup.LayoutParams.WRAP_CONTENT:
                        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);
                        break;
                    default:
                        measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);
                        break;
                }
                return measureSpec;
            }
            performTraversals() {
                let host = this.mView;
                if (ViewRootImpl.DBG) {
                    System.out.println("======================================");
                    System.out.println("performTraversals");
                    host.debug();
                }
                if (host == null || !this.mAdded)
                    return;
                this.mIsInTraversal = true;
                this.mWillDrawSoon = true;
                let windowSizeMayChange = false;
                let newSurface = false;
                let surfaceChanged = false;
                let lp = new view_2.ViewGroup.LayoutParams(view_2.ViewGroup.LayoutParams.MATCH_PARENT, view_2.ViewGroup.LayoutParams.MATCH_PARENT);
                let desiredWindowWidth;
                let desiredWindowHeight;
                let attachInfo = this.mAttachInfo;
                let viewVisibility = this.getHostVisibility();
                let viewVisibilityChanged = this.mViewVisibility != viewVisibility;
                let params = null;
                let frame = this.mWinFrame;
                if (this.mFirst) {
                    this.mFullRedrawNeeded = true;
                    this.mLayoutRequested = true;
                    let packageMetrics = Resources.getDisplayMetrics();
                    desiredWindowWidth = packageMetrics.widthPixels;
                    desiredWindowHeight = packageMetrics.heightPixels;
                    attachInfo.mHasWindowFocus = true;
                    attachInfo.mWindowVisibility = viewVisibility;
                    viewVisibilityChanged = false;
                    host.dispatchAttachedToWindow(attachInfo, 0);
                    attachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true);
                }
                else {
                    desiredWindowWidth = frame.width();
                    desiredWindowHeight = frame.height();
                    if (desiredWindowWidth != this.mWidth || desiredWindowHeight != this.mHeight) {
                        if (ViewRootImpl.DEBUG_ORIENTATION) {
                            Log.v(ViewRootImpl.TAG, "View " + host + " resized to: " + frame);
                        }
                        this.mFullRedrawNeeded = true;
                        this.mLayoutRequested = true;
                        windowSizeMayChange = true;
                    }
                }
                if (viewVisibilityChanged) {
                    attachInfo.mWindowVisibility = viewVisibility;
                    host.dispatchWindowVisibilityChanged(viewVisibility);
                }
                ViewRootImpl.getRunQueue(this).executeActions(attachInfo.mHandler);
                let layoutRequested = this.mLayoutRequested;
                if (layoutRequested) {
                    if (this.mFirst) {
                        this.mAttachInfo.mInTouchMode = !this.mAddedTouchMode;
                        this.ensureTouchModeLocally(this.mAddedTouchMode);
                    }
                    else {
                        if (lp.width < 0 || lp.height < 0) {
                            windowSizeMayChange = true;
                            let packageMetrics = Resources.getDisplayMetrics();
                            desiredWindowWidth = packageMetrics.widthPixels;
                            desiredWindowHeight = packageMetrics.heightPixels;
                        }
                    }
                    windowSizeMayChange == this.measureHierarchy(host, lp, desiredWindowWidth, desiredWindowHeight) || windowSizeMayChange;
                }
                if (this.mFirst || attachInfo.mViewVisibilityChanged) {
                    attachInfo.mViewVisibilityChanged = false;
                }
                if (layoutRequested) {
                    this.mLayoutRequested = false;
                }
                let windowShouldResize = layoutRequested && windowSizeMayChange
                    && ((this.mWidth != host.getMeasuredWidth() || this.mHeight != host.getMeasuredHeight())
                        || (lp.width < 0 && frame.width() !== desiredWindowWidth && frame.width() !== this.mWidth)
                        || (lp.height < 0 && frame.height() !== desiredWindowHeight && frame.height() !== this.mHeight));
                if (this.mFirst || windowShouldResize || viewVisibilityChanged) {
                    if (ViewRootImpl.DEBUG_LAYOUT) {
                        Log.i(ViewRootImpl.TAG, "host=w:" + host.getMeasuredWidth() + ", h:" +
                            host.getMeasuredHeight() + ", params=" + params);
                    }
                    if (ViewRootImpl.DEBUG_ORIENTATION)
                        Log.v(ViewRootImpl.TAG, "Relayout returned: frame=" + frame);
                    attachInfo.mWindowLeft = frame.left;
                    attachInfo.mWindowTop = frame.top;
                    if (this.mWidth != frame.width() || this.mHeight != frame.height()) {
                        this.mWidth = frame.width();
                        this.mHeight = frame.height();
                    }
                    if (this.mWidth != host.getMeasuredWidth()
                        || this.mHeight != host.getMeasuredHeight()) {
                        let childWidthMeasureSpec = ViewRootImpl.getRootMeasureSpec(this.mWidth, lp.width);
                        let childHeightMeasureSpec = ViewRootImpl.getRootMeasureSpec(this.mHeight, lp.height);
                        if (ViewRootImpl.DEBUG_LAYOUT)
                            Log.v(ViewRootImpl.TAG, "Ooops, something changed!  mWidth="
                                + this.mWidth + " measuredWidth=" + host.getMeasuredWidth()
                                + " mHeight=" + this.mHeight
                                + " measuredHeight=" + host.getMeasuredHeight());
                        this.performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
                        layoutRequested = true;
                    }
                }
                else {
                    const windowMoved = (attachInfo.mWindowLeft != frame.left
                        || attachInfo.mWindowTop != frame.top);
                    if (windowMoved) {
                        attachInfo.mWindowLeft = frame.left;
                        attachInfo.mWindowTop = frame.top;
                    }
                }
                const didLayout = layoutRequested;
                let triggerGlobalLayoutListener = didLayout;
                if (didLayout) {
                    this.performLayout(lp, desiredWindowWidth, desiredWindowHeight);
                    if (ViewRootImpl.DBG) {
                        System.out.println("======================================");
                        System.out.println("performTraversals -- after setFrame");
                        host.debug();
                    }
                }
                if (triggerGlobalLayoutListener) {
                    attachInfo.mTreeObserver.dispatchOnGlobalLayout();
                }
                let skipDraw = false;
                if (this.mFirst) {
                    if (ViewRootImpl.DEBUG_INPUT_RESIZE)
                        Log.v(ViewRootImpl.TAG, "First: mView.hasFocus()="
                            + this.mView.hasFocus());
                    if (this.mView != null) {
                        if (!this.mView.hasFocus()) {
                            this.mView.requestFocus(View.FOCUS_FORWARD);
                            if (ViewRootImpl.DEBUG_INPUT_RESIZE)
                                Log.v(ViewRootImpl.TAG, "First: requested focused view="
                                    + this.mView.findFocus());
                        }
                        else {
                            if (ViewRootImpl.DEBUG_INPUT_RESIZE)
                                Log.v(ViewRootImpl.TAG, "First: existing focused view="
                                    + this.mView.findFocus());
                        }
                    }
                }
                this.mFirst = false;
                this.mWillDrawSoon = false;
                this.mViewVisibility = viewVisibility;
                let cancelDraw = attachInfo.mTreeObserver.dispatchOnPreDraw() ||
                    viewVisibility != View.VISIBLE;
                if (!cancelDraw) {
                    if (!skipDraw) {
                        this.performDraw();
                    }
                }
                else {
                    if (viewVisibility == View.VISIBLE) {
                        this.scheduleTraversals();
                    }
                }
                this.mIsInTraversal = false;
            }
            performLayout(lp, desiredWindowWidth, desiredWindowHeight) {
                this.mLayoutRequested = false;
                this.mInLayout = true;
                let host = this.mView;
                if (ViewRootImpl.DEBUG_ORIENTATION || ViewRootImpl.DEBUG_LAYOUT) {
                    Log.v(ViewRootImpl.TAG, "Laying out " + host + " to (" +
                        host.getMeasuredWidth() + ", " + host.getMeasuredHeight() + ")");
                }
                host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());
                this.mInLayout = false;
                let numViewsRequestingLayout = this.mLayoutRequesters.length;
                if (numViewsRequestingLayout > 0) {
                    let validLayoutRequesters = this.getValidLayoutRequesters(this.mLayoutRequesters, false);
                    if (validLayoutRequesters != null) {
                        this.mHandlingLayoutInLayoutRequest = true;
                        let numValidRequests = validLayoutRequesters.length;
                        for (let i = 0; i < numValidRequests; ++i) {
                            let view = validLayoutRequesters[i];
                            Log.w("View", "requestLayout() improperly called by " + view +
                                " during layout: running second layout pass");
                            view.requestLayout();
                        }
                        this.measureHierarchy(host, lp, desiredWindowWidth, desiredWindowHeight);
                        this.mInLayout = true;
                        host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());
                        this.mHandlingLayoutInLayoutRequest = false;
                        validLayoutRequesters = this.getValidLayoutRequesters(this.mLayoutRequesters, true);
                        if (validLayoutRequesters != null) {
                            let finalRequesters = validLayoutRequesters;
                            ViewRootImpl.getRunQueue(this).post({
                                run() {
                                    let numValidRequests = finalRequesters.length;
                                    for (let i = 0; i < numValidRequests; ++i) {
                                        const view = finalRequesters[i];
                                        Log.w("View", "requestLayout() improperly called by " + view +
                                            " during second layout pass: posting in next frame");
                                        view.requestLayout();
                                    }
                                }
                            });
                        }
                    }
                }
                this.mInLayout = false;
            }
            getValidLayoutRequesters(layoutRequesters, secondLayoutRequests) {
                let numViewsRequestingLayout = layoutRequesters.length;
                let validLayoutRequesters = null;
                for (let i = 0; i < numViewsRequestingLayout; ++i) {
                    let view = layoutRequesters[i];
                    if (view != null && view.mAttachInfo != null && view.mParent != null &&
                        (secondLayoutRequests || (view.mPrivateFlags & View.PFLAG_FORCE_LAYOUT) ==
                            View.PFLAG_FORCE_LAYOUT)) {
                        let gone = false;
                        let parent = view;
                        while (parent != null) {
                            if ((parent.mViewFlags & View.VISIBILITY_MASK) == View.GONE) {
                                gone = true;
                                break;
                            }
                            if (parent.mParent instanceof View) {
                                parent = parent.mParent;
                            }
                            else {
                                parent = null;
                            }
                        }
                        if (!gone) {
                            if (validLayoutRequesters == null) {
                                validLayoutRequesters = [];
                            }
                            validLayoutRequesters.push(view);
                        }
                    }
                }
                if (!secondLayoutRequests) {
                    for (let i = 0; i < numViewsRequestingLayout; ++i) {
                        let view = layoutRequesters[i];
                        while (view != null &&
                            (view.mPrivateFlags & View.PFLAG_FORCE_LAYOUT) != 0) {
                            view.mPrivateFlags &= ~View.PFLAG_FORCE_LAYOUT;
                            if (view.mParent instanceof View) {
                                view = view.mParent;
                            }
                            else {
                                view = null;
                            }
                        }
                    }
                }
                layoutRequesters.splice(0, layoutRequesters.length);
                return validLayoutRequesters;
            }
            performMeasure(childWidthMeasureSpec, childHeightMeasureSpec) {
                this.mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);
            }
            isInLayout() {
                return this.mInLayout;
            }
            requestLayoutDuringLayout(view) {
                if (view.mParent == null || view.mAttachInfo == null) {
                    return true;
                }
                if (this.mLayoutRequesters.indexOf(view) === -1) {
                    this.mLayoutRequesters.push(view);
                }
                if (!this.mHandlingLayoutInLayoutRequest) {
                    return true;
                }
                else {
                    return false;
                }
            }
            trackFPS() {
                let nowTime = System.currentTimeMillis();
                if (this.mFpsStartTime < 0) {
                    this.mFpsStartTime = this.mFpsPrevTime = nowTime;
                    this.mFpsNumFrames = 0;
                }
                else {
                    this.mFpsNumFrames++;
                    let frameTime = nowTime - this.mFpsPrevTime;
                    let totalTime = nowTime - this.mFpsStartTime;
                    Log.v(ViewRootImpl.TAG, "Frame time:\t" + frameTime);
                    this.mFpsPrevTime = nowTime;
                    if (totalTime > 1000) {
                        let fps = this.mFpsNumFrames * 1000 / totalTime;
                        Log.v(ViewRootImpl.TAG, "FPS:\t" + fps);
                        this.mFpsStartTime = nowTime;
                        this.mFpsNumFrames = 0;
                    }
                }
            }
            performDraw() {
                let fullRedrawNeeded = this.mFullRedrawNeeded;
                this.mFullRedrawNeeded = false;
                this.mIsDrawing = true;
                try {
                    this.draw(fullRedrawNeeded);
                }
                finally {
                    this.mIsDrawing = false;
                }
            }
            draw(fullRedrawNeeded) {
                if (ViewRootImpl.DEBUG_FPS) {
                    this.trackFPS();
                }
                let attachInfo = this.mAttachInfo;
                if (attachInfo.mViewScrollChanged) {
                    attachInfo.mViewScrollChanged = false;
                    attachInfo.mTreeObserver.dispatchOnScrollChanged();
                }
                if (fullRedrawNeeded) {
                    attachInfo.mIgnoreDirtyState = true;
                    this.mDirty.set(0, 0, this.mWidth, this.mHeight);
                }
                if (ViewRootImpl.DEBUG_ORIENTATION || ViewRootImpl.DEBUG_DRAW) {
                    Log.v(ViewRootImpl.TAG, "Draw " + this.mView + ", width=" + this.mWidth + ", height=" + this.mHeight + ", dirty=" + this.mDirty);
                }
                attachInfo.mTreeObserver.dispatchOnDraw();
                this.drawSoftware();
            }
            drawSoftware() {
                let canvas = this.mSurface.lockCanvas(this.mDirty);
                this.mDirty.setEmpty();
                let attachInfo = this.mAttachInfo;
                attachInfo.mDrawingTime = SystemClock.uptimeMillis();
                this.mView.mPrivateFlags |= View.PFLAG_DRAWN;
                attachInfo.mSetIgnoreDirtyState = false;
                this.mView.draw(canvas);
                if (!attachInfo.mSetIgnoreDirtyState) {
                    attachInfo.mIgnoreDirtyState = false;
                }
                this.mSurface.unlockCanvasAndPost(canvas);
                if (ViewRootImpl.LOCAL_LOGV) {
                    Log.v(ViewRootImpl.TAG, "Surface unlockCanvasAndPost");
                }
            }
            isLayoutRequested() {
                return this.mLayoutRequested;
            }
            dispatchInvalidateDelayed(view, delayMilliseconds) {
                let msg = this.mHandler.obtainMessage(ViewRootHandler.MSG_INVALIDATE, view);
                this.mHandler.sendMessageDelayed(msg, delayMilliseconds);
            }
            dispatchInvalidateRectDelayed(info, delayMilliseconds) {
                let msg = this.mHandler.obtainMessage(ViewRootHandler.MSG_INVALIDATE_RECT, info);
                this.mHandler.sendMessageDelayed(msg, delayMilliseconds);
            }
            dispatchInvalidateOnAnimation(view) {
                this.mInvalidateOnAnimationRunnable.addView(view);
            }
            dispatchInvalidateRectOnAnimation(info) {
                this.mInvalidateOnAnimationRunnable.addViewRect(info);
            }
            cancelInvalidate(view) {
                this.mHandler.removeMessages(ViewRootHandler.MSG_INVALIDATE, view);
                this.mHandler.removeMessages(ViewRootHandler.MSG_INVALIDATE_RECT, view);
                this.mInvalidateOnAnimationRunnable.removeView(view);
            }
            getParent() {
                return null;
            }
            requestLayout() {
                if (!this.mHandlingLayoutInLayoutRequest) {
                    this.mLayoutRequested = true;
                    this.scheduleTraversals();
                }
            }
            invalidate() {
                this.mDirty.set(0, 0, this.mWidth, this.mHeight);
                this.scheduleTraversals();
            }
            invalidateWorld(view) {
                view.invalidate();
                if (view instanceof view_2.ViewGroup) {
                    let parent = view;
                    for (let i = 0; i < parent.getChildCount(); i++) {
                        this.invalidateWorld(parent.getChildAt(i));
                    }
                }
            }
            invalidateChild(child, dirty) {
                this.invalidateChildInParent(null, dirty);
            }
            invalidateChildInParent(location, dirty) {
                if (ViewRootImpl.DEBUG_DRAW)
                    Log.v(ViewRootImpl.TAG, "Invalidate child: " + dirty);
                if (dirty == null) {
                    this.invalidate();
                    return null;
                }
                else if (dirty.isEmpty()) {
                    return null;
                }
                const localDirty = this.mDirty;
                if (!localDirty.isEmpty() && !localDirty.contains(dirty)) {
                    this.mAttachInfo.mSetIgnoreDirtyState = true;
                    this.mAttachInfo.mIgnoreDirtyState = true;
                }
                localDirty.union(dirty.left, dirty.top, dirty.right, dirty.bottom);
                const intersected = localDirty.intersect(0, 0, this.mWidth, this.mHeight);
                if (!intersected) {
                    localDirty.setEmpty();
                }
                if (!this.mWillDrawSoon && (intersected)) {
                    this.scheduleTraversals();
                }
                return null;
            }
            requestChildFocus(child, focused) {
                if (ViewRootImpl.DEBUG_INPUT_RESIZE) {
                    Log.v(ViewRootImpl.TAG, "Request child focus: focus now " + focused);
                }
                this.scheduleTraversals();
            }
            clearChildFocus(focused) {
                if (ViewRootImpl.DEBUG_INPUT_RESIZE) {
                    Log.v(ViewRootImpl.TAG, "Request child focus: focus now " + focused);
                }
                this.scheduleTraversals();
            }
            getChildVisibleRect(child, r, offset) {
                if (child != this.mView) {
                    throw new Error("child is not mine, honest!");
                }
                return r.intersect(0, 0, this.mWidth, this.mHeight);
            }
            focusSearch(focused, direction) {
                if (!(this.mView instanceof view_2.ViewGroup)) {
                    return null;
                }
                return view_2.FocusFinder.getInstance().findNextFocus(this.mView, focused, direction);
            }
            bringChildToFront(child) {
            }
            focusableViewAvailable(v) {
                if (this.mView != null) {
                    if (!this.mView.hasFocus()) {
                        v.requestFocus();
                    }
                    else {
                        let focused = this.mView.findFocus();
                        if (focused instanceof view_2.ViewGroup) {
                            let group = focused;
                            if (group.getDescendantFocusability() == view_2.ViewGroup.FOCUS_AFTER_DESCENDANTS
                                && ViewRootImpl.isViewDescendantOf(v, focused)) {
                                v.requestFocus();
                            }
                        }
                    }
                }
            }
            static isViewDescendantOf(child, parent) {
                if (child == parent) {
                    return true;
                }
                const theParent = child.getParent();
                return (theParent instanceof view_2.ViewGroup) && ViewRootImpl.isViewDescendantOf(theParent, parent);
            }
            childDrawableStateChanged(child) {
            }
            requestDisallowInterceptTouchEvent(disallowIntercept) {
            }
            requestChildRectangleOnScreen(child, rectangle, immediate) {
                return false;
            }
            childHasTransientStateChanged(child, hasTransientState) {
            }
            dispatchResized(frame) {
                this.mWinFrame.set(frame.left, frame.top, frame.right, frame.bottom);
                this.requestLayout();
            }
            dispatchInputEvent(event) {
                this.deliverInputEvent(event);
                let result = event[InputStage.FLAG_FINISHED_HANDLED];
                event[InputStage.FLAG_FINISHED] = false;
                event[InputStage.FLAG_FINISHED_HANDLED] = false;
                return result;
            }
            deliverInputEvent(event) {
                this.mFirstInputStage.deliver(event);
            }
            finishInputEvent(event) {
            }
            checkForLeavingTouchModeAndConsume(event) {
                if (!this.mAttachInfo.mInTouchMode) {
                    return false;
                }
                const action = event.getAction();
                if (action != view_2.KeyEvent.ACTION_DOWN) {
                    return false;
                }
                if (ViewRootImpl.isNavigationKey(event)) {
                    return this.ensureTouchMode(false);
                }
                if (ViewRootImpl.isTypingKey(event)) {
                    this.ensureTouchMode(false);
                    return false;
                }
                return false;
            }
            static isNavigationKey(keyEvent) {
                switch (keyEvent.getKeyCode()) {
                    case view_2.KeyEvent.KEYCODE_DPAD_LEFT:
                    case view_2.KeyEvent.KEYCODE_DPAD_RIGHT:
                    case view_2.KeyEvent.KEYCODE_DPAD_UP:
                    case view_2.KeyEvent.KEYCODE_DPAD_DOWN:
                    case view_2.KeyEvent.KEYCODE_DPAD_CENTER:
                    case view_2.KeyEvent.KEYCODE_PAGE_UP:
                    case view_2.KeyEvent.KEYCODE_PAGE_DOWN:
                    case view_2.KeyEvent.KEYCODE_MOVE_HOME:
                    case view_2.KeyEvent.KEYCODE_MOVE_END:
                    case view_2.KeyEvent.KEYCODE_TAB:
                    case view_2.KeyEvent.KEYCODE_SPACE:
                    case view_2.KeyEvent.KEYCODE_ENTER:
                        return true;
                }
                return false;
            }
            static isTypingKey(keyEvent) {
                try {
                    return keyEvent._activeKeyEvent['keyIdentifier'].startsWith('U+');
                }
                catch (e) {
                    console.warn(e);
                }
                return true;
            }
            ensureTouchMode(inTouchMode) {
                if (ViewRootImpl.DBG)
                    Log.d("touchmode", "ensureTouchMode(" + inTouchMode + "), current "
                        + "touch mode is " + this.mAttachInfo.mInTouchMode);
                if (this.mAttachInfo.mInTouchMode == inTouchMode)
                    return false;
                return this.ensureTouchModeLocally(inTouchMode);
            }
            ensureTouchModeLocally(inTouchMode) {
                if (ViewRootImpl.DBG)
                    Log.d("touchmode", "ensureTouchModeLocally(" + inTouchMode + "), current "
                        + "touch mode is " + this.mAttachInfo.mInTouchMode);
                if (this.mAttachInfo.mInTouchMode == inTouchMode)
                    return false;
                this.mAttachInfo.mInTouchMode = inTouchMode;
                this.mAttachInfo.mTreeObserver.dispatchOnTouchModeChanged(inTouchMode);
                return (inTouchMode) ? this.enterTouchMode() : this.leaveTouchMode();
            }
            enterTouchMode() {
                if (this.mView != null && this.mView.hasFocus()) {
                    const focused = this.mView.findFocus();
                    if (focused != null && !focused.isFocusableInTouchMode()) {
                        const ancestorToTakeFocus = ViewRootImpl.findAncestorToTakeFocusInTouchMode(focused);
                        if (ancestorToTakeFocus != null) {
                            return ancestorToTakeFocus.requestFocus();
                        }
                        else {
                            focused.clearFocusInternal(true, false);
                            return true;
                        }
                    }
                }
                return false;
            }
            static findAncestorToTakeFocusInTouchMode(focused) {
                let parent = focused.getParent();
                while (parent instanceof view_2.ViewGroup) {
                    const vgParent = parent;
                    if (vgParent.getDescendantFocusability() == view_2.ViewGroup.FOCUS_AFTER_DESCENDANTS
                        && vgParent.isFocusableInTouchMode()) {
                        return vgParent;
                    }
                    if (vgParent.isRootNamespace()) {
                        return null;
                    }
                    else {
                        parent = vgParent.getParent();
                    }
                }
                return null;
            }
            leaveTouchMode() {
                if (this.mView != null) {
                    if (this.mView.hasFocus()) {
                        let focusedView = this.mView.findFocus();
                        if (!(focusedView instanceof view_2.ViewGroup)) {
                            return false;
                        }
                        else if (focusedView.getDescendantFocusability() !=
                            view_2.ViewGroup.FOCUS_AFTER_DESCENDANTS) {
                            return false;
                        }
                    }
                    const focused = this.focusSearch(null, View.FOCUS_DOWN);
                    if (focused != null) {
                        return focused.requestFocus(View.FOCUS_DOWN);
                    }
                }
                return false;
            }
            static getRunQueue(viewRoot) {
                if (viewRoot) {
                    if (!viewRoot.mRunQueue)
                        viewRoot.mRunQueue = new ViewRootImpl.RunQueue();
                    return viewRoot.mRunQueue;
                }
                else {
                    if (!this.RunQueueInstance) {
                        this.RunQueueInstance = new RunQueueForNoViewRoot();
                    }
                    return this.RunQueueInstance;
                }
            }
        }
        ViewRootImpl.TAG = "ViewRootImpl";
        ViewRootImpl.DBG = Log.View_DBG;
        ViewRootImpl.LOCAL_LOGV = ViewRootImpl.DBG;
        ViewRootImpl.DEBUG_DRAW = false || ViewRootImpl.LOCAL_LOGV;
        ViewRootImpl.DEBUG_LAYOUT = false || ViewRootImpl.LOCAL_LOGV;
        ViewRootImpl.DEBUG_INPUT_RESIZE = false || ViewRootImpl.LOCAL_LOGV;
        ViewRootImpl.DEBUG_ORIENTATION = false || ViewRootImpl.LOCAL_LOGV;
        ViewRootImpl.DEBUG_CONFIGURATION = false || ViewRootImpl.LOCAL_LOGV;
        ViewRootImpl.DEBUG_FPS = false || ViewRootImpl.LOCAL_LOGV;
        view_2.ViewRootImpl = ViewRootImpl;
        (function (ViewRootImpl) {
            class RunQueue {
                constructor() {
                    this.mActions = [];
                }
                post(action) {
                    this.postDelayed(action, 0);
                }
                postDelayed(action, delayMillis) {
                    let handlerAction = {
                        action: action,
                        delay: delayMillis
                    };
                    this.mActions.push(handlerAction);
                }
                removeCallbacks(action) {
                    this.mActions = this.mActions.filter((item) => {
                        return item.action == action;
                    });
                }
                executeActions(handler) {
                    for (let handlerAction of this.mActions) {
                        handler.postDelayed(handlerAction.action, handlerAction.delay);
                    }
                    this.mActions = [];
                }
            }
            ViewRootImpl.RunQueue = RunQueue;
        })(ViewRootImpl = view_2.ViewRootImpl || (view_2.ViewRootImpl = {}));
        class RunQueueForNoViewRoot extends ViewRootImpl.RunQueue {
            postDelayed(action, delayMillis) {
                RunQueueForNoViewRoot.Handler.postDelayed(action, delayMillis);
            }
            removeCallbacks(action) {
                RunQueueForNoViewRoot.Handler.removeCallbacks(action);
            }
        }
        RunQueueForNoViewRoot.Handler = new Handler();
        class TraversalRunnable {
            constructor(impl) {
                this.ViewRootImpl_this = impl;
            }
            run() {
                this.ViewRootImpl_this.doTraversal();
            }
        }
        class InvalidateOnAnimationRunnable {
            constructor(handler) {
                this.mPosted = false;
                this.mViews = new Set();
                this.mViewRects = new Map();
                this.mHandler = handler;
            }
            addView(view) {
                this.mViews.add(view);
                this.postIfNeededLocked();
            }
            addViewRect(info) {
                this.mViewRects.set(info.target, info);
                this.postIfNeededLocked();
            }
            removeView(view) {
                this.mViews.delete(view);
                this.mViewRects.delete(view);
                if (this.mPosted && this.mViews.size === 0 && this.mViewRects.size === 0) {
                    this.mHandler.removeCallbacks(this);
                    this.mPosted = false;
                }
            }
            run() {
                this.mPosted = false;
                for (let view of this.mViews) {
                    view.invalidate();
                }
                this.mViews.clear();
                for (let info of this.mViewRects.values()) {
                    info.target.invalidate(info.left, info.top, info.right, info.bottom);
                    info.recycle();
                }
                this.mViewRects.clear();
            }
            postIfNeededLocked() {
                if (!this.mPosted) {
                    this.mHandler.post(this);
                    this.mPosted = true;
                }
            }
        }
        class ViewRootHandler extends Handler {
            handleMessage(msg) {
                switch (msg.what) {
                    case ViewRootHandler.MSG_INVALIDATE:
                        msg.obj.invalidate();
                        break;
                    case ViewRootHandler.MSG_INVALIDATE_RECT:
                        const info = msg.obj;
                        info.target.invalidate(info.left, info.top, info.right, info.bottom);
                        info.recycle();
                        break;
                }
            }
        }
        ViewRootHandler.MSG_INVALIDATE = 1;
        ViewRootHandler.MSG_INVALIDATE_RECT = 2;
        class InputStage {
            constructor(impl, next) {
                this.ViewRootImpl_this = impl;
                this.mNext = next;
            }
            deliver(event) {
                if (event[InputStage.FLAG_FINISHED]) {
                    this.forward(event);
                }
                else if (this.shouldDropInputEvent(event)) {
                    this.finish(event, false);
                }
                else {
                    this.apply(event, this.onProcess(event));
                }
            }
            finish(event, handled) {
                event[InputStage.FLAG_FINISHED] = true;
                if (handled) {
                    event[InputStage.FLAG_FINISHED_HANDLED] = true;
                }
                this.forward(event);
            }
            forward(event) {
                this.onDeliverToNext(event);
            }
            apply(event, result) {
                if (result == InputStage.FORWARD) {
                    this.forward(event);
                }
                else if (result == InputStage.FINISH_HANDLED) {
                    this.finish(event, true);
                }
                else if (result == InputStage.FINISH_NOT_HANDLED) {
                    this.finish(event, false);
                }
                else {
                    throw new Error("Invalid result: " + result);
                }
            }
            onDeliverToNext(event) {
                if (this.mNext != null) {
                    this.mNext.deliver(event);
                }
                else {
                    this.ViewRootImpl_this.finishInputEvent(event);
                }
            }
            onProcess(event) {
                return InputStage.FORWARD;
            }
            shouldDropInputEvent(event) {
                if (this.ViewRootImpl_this.mView == null || !this.ViewRootImpl_this.mAdded) {
                    Log.w(ViewRootImpl.TAG, "Dropping event due to root view being removed: " + event);
                    return true;
                }
                else if ((!this.ViewRootImpl_this.mAttachInfo.mHasWindowFocus ||
                    this.ViewRootImpl_this.mStopped)) {
                    Log.w(ViewRootImpl.TAG, "Dropping event due to no window focus: " + event);
                    return true;
                }
                return false;
            }
        }
        InputStage.FLAG_FINISHED = Symbol();
        InputStage.FLAG_FINISHED_HANDLED = Symbol();
        InputStage.FORWARD = 0;
        InputStage.FINISH_HANDLED = 1;
        InputStage.FINISH_NOT_HANDLED = 2;
        class EarlyPostImeInputStage extends InputStage {
            onProcess(event) {
                if (event instanceof view_2.MotionEvent) {
                    return this.processMotionEvent(event);
                }
                else if (event instanceof view_2.KeyEvent) {
                    return this.processKeyEvent(event);
                }
                return InputStage.FORWARD;
            }
            processKeyEvent(event) {
                if (this.ViewRootImpl_this.checkForLeavingTouchModeAndConsume(event)) {
                    return InputStage.FINISH_HANDLED;
                }
                return InputStage.FORWARD;
            }
            processMotionEvent(event) {
                const action = event.getAction();
                if (action == view_2.MotionEvent.ACTION_DOWN || action == view_2.MotionEvent.ACTION_SCROLL) {
                    this.ViewRootImpl_this.ensureTouchMode(true);
                }
                event.offsetLocation(this.ViewRootImpl_this.mWinFrame.left, this.ViewRootImpl_this.mWinFrame.top);
                return InputStage.FORWARD;
            }
        }
        class ViewPostImeInputStage extends InputStage {
            onProcess(event) {
                if (event instanceof view_2.KeyEvent) {
                    return this.processKeyEvent(event);
                }
                else if (event instanceof view_2.MotionEvent) {
                    if (event.isTouchEvent()) {
                        return this.processTouchEvent(event);
                    }
                    else {
                        return this.processGenericMotionEvent(event);
                    }
                }
                return InputStage.FORWARD;
            }
            processKeyEvent(event) {
                let mView = this.ViewRootImpl_this.mView;
                if (this.ViewRootImpl_this.mView.dispatchKeyEvent(event)) {
                    return InputStage.FINISH_HANDLED;
                }
                if (this.shouldDropInputEvent(event)) {
                    return InputStage.FINISH_NOT_HANDLED;
                }
                if (event.getAction() == view_2.KeyEvent.ACTION_DOWN
                    && event.isCtrlPressed()
                    && event.getRepeatCount() == 0) {
                    if (this.ViewRootImpl_this.shouldDropInputEvent(event)) {
                        return InputStage.FINISH_NOT_HANDLED;
                    }
                }
                if (this.shouldDropInputEvent(event)) {
                    return InputStage.FINISH_NOT_HANDLED;
                }
                if (event.getAction() == view_2.KeyEvent.ACTION_DOWN) {
                    let direction = 0;
                    switch (event.getKeyCode()) {
                        case view_2.KeyEvent.KEYCODE_DPAD_LEFT:
                            direction = View.FOCUS_LEFT;
                            break;
                        case view_2.KeyEvent.KEYCODE_DPAD_RIGHT:
                            direction = View.FOCUS_RIGHT;
                            break;
                        case view_2.KeyEvent.KEYCODE_DPAD_UP:
                            direction = View.FOCUS_UP;
                            break;
                        case view_2.KeyEvent.KEYCODE_DPAD_DOWN:
                            direction = View.FOCUS_DOWN;
                            break;
                        case view_2.KeyEvent.KEYCODE_TAB:
                            if (event.isShiftPressed()) {
                                direction = View.FOCUS_BACKWARD;
                            }
                            else {
                                direction = View.FOCUS_FORWARD;
                            }
                            break;
                    }
                    if (direction != 0) {
                        let focused = mView.findFocus();
                        if (focused != null) {
                            let v = focused.focusSearch(direction);
                            if (v != null && v != focused) {
                                focused.getFocusedRect(this.ViewRootImpl_this.mTempRect);
                                if (mView instanceof view_2.ViewGroup) {
                                    mView.offsetDescendantRectToMyCoords(focused, this.ViewRootImpl_this.mTempRect);
                                    mView.offsetRectIntoDescendantCoords(v, this.ViewRootImpl_this.mTempRect);
                                }
                                if (v.requestFocus(direction, this.ViewRootImpl_this.mTempRect)) {
                                    return InputStage.FINISH_HANDLED;
                                }
                            }
                            if (mView.dispatchUnhandledMove(focused, direction)) {
                                return InputStage.FINISH_HANDLED;
                            }
                        }
                        else {
                            let v = this.ViewRootImpl_this.focusSearch(null, direction);
                            if (v != null && v.requestFocus(direction)) {
                                return InputStage.FINISH_HANDLED;
                            }
                        }
                    }
                }
                return InputStage.FORWARD;
            }
            processGenericMotionEvent(event) {
                if (this.ViewRootImpl_this.mView.dispatchGenericMotionEvent(event)) {
                    return InputStage.FINISH_HANDLED;
                }
                return InputStage.FORWARD;
            }
            processTouchEvent(event) {
                let handled = this.ViewRootImpl_this.mView.dispatchTouchEvent(event);
                return handled ? InputStage.FINISH_HANDLED : InputStage.FORWARD;
            }
        }
        class SyntheticInputStage extends InputStage {
            onProcess(event) {
                return super.onProcess(event);
            }
        }
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/10.
 */
///<reference path="View.ts"/>
///<reference path="ViewGroup.ts"/>
var android;
(function (android) {
    var view;
    (function (view_3) {
        var View = android.view.View;
        var Rect = android.graphics.Rect;
        var ArrayList = java.util.ArrayList;
        class FocusFinder {
            constructor() {
                this.mFocusedRect = new Rect();
                this.mOtherRect = new Rect();
                this.mBestCandidateRect = new Rect();
                this.mSequentialFocusComparator = new SequentialFocusComparator();
                this.mTempList = new ArrayList();
            }
            static getInstance() {
                if (!FocusFinder.sFocusFinder) {
                    FocusFinder.sFocusFinder = new FocusFinder();
                }
                return FocusFinder.sFocusFinder;
            }
            findNextFocus(root, focused, direction) {
                return this._findNextFocus(root, focused, null, direction);
            }
            findNextFocusFromRect(root, focusedRect, direction) {
                this.mFocusedRect.set(focusedRect);
                return this._findNextFocus(root, null, this.mFocusedRect, direction);
            }
            _findNextFocus(root, focused, focusedRect, direction) {
                let next = null;
                if (focused != null) {
                    next = this.findNextUserSpecifiedFocus(root, focused, direction);
                }
                if (next != null) {
                    return next;
                }
                let focusables = this.mTempList;
                try {
                    focusables.clear();
                    root.addFocusables(focusables, direction);
                    if (!focusables.isEmpty()) {
                        next = this.__findNextFocus(root, focused, focusedRect, direction, focusables);
                    }
                }
                finally {
                    focusables.clear();
                }
                return next;
            }
            findNextUserSpecifiedFocus(root, focused, direction) {
                let userSetNextFocus = focused.findUserSetNextFocus(root, direction);
                if (userSetNextFocus != null && userSetNextFocus.isFocusable()
                    && (!userSetNextFocus.isInTouchMode()
                        || userSetNextFocus.isFocusableInTouchMode())) {
                    return userSetNextFocus;
                }
                return null;
            }
            __findNextFocus(root, focused, focusedRect, direction, focusables) {
                if (focused != null) {
                    if (focusedRect == null) {
                        focusedRect = this.mFocusedRect;
                    }
                    focused.getFocusedRect(focusedRect);
                    root.offsetDescendantRectToMyCoords(focused, focusedRect);
                }
                else {
                    if (focusedRect == null) {
                        focusedRect = this.mFocusedRect;
                        switch (direction) {
                            case View.FOCUS_RIGHT:
                            case View.FOCUS_DOWN:
                                this.setFocusTopLeft(root, focusedRect);
                                break;
                            case View.FOCUS_FORWARD:
                                this.setFocusTopLeft(root, focusedRect);
                                break;
                            case View.FOCUS_LEFT:
                            case View.FOCUS_UP:
                                this.setFocusBottomRight(root, focusedRect);
                                break;
                            case View.FOCUS_BACKWARD:
                                this.setFocusBottomRight(root, focusedRect);
                        }
                    }
                }
                switch (direction) {
                    case View.FOCUS_FORWARD:
                    case View.FOCUS_BACKWARD:
                        return this.findNextFocusInRelativeDirection(focusables, root, focused, focusedRect, direction);
                    case View.FOCUS_UP:
                    case View.FOCUS_DOWN:
                    case View.FOCUS_LEFT:
                    case View.FOCUS_RIGHT:
                        return this.findNextFocusInAbsoluteDirection(focusables, root, focused, focusedRect, direction);
                    default:
                        throw new Error("Unknown direction: " + direction);
                }
            }
            findNextFocusInRelativeDirection(focusables, root, focused, focusedRect, direction) {
                try {
                    this.mSequentialFocusComparator.setRoot(root);
                    this.mSequentialFocusComparator.sort(focusables);
                }
                finally {
                    this.mSequentialFocusComparator.recycle();
                }
                const count = focusables.size();
                switch (direction) {
                    case View.FOCUS_FORWARD:
                        return FocusFinder.getNextFocusable(focused, focusables, count);
                    case View.FOCUS_BACKWARD:
                        return FocusFinder.getPreviousFocusable(focused, focusables, count);
                }
                return focusables.get(count - 1);
            }
            setFocusBottomRight(root, focusedRect) {
                const rootBottom = root.getScrollY() + root.getHeight();
                const rootRight = root.getScrollX() + root.getWidth();
                focusedRect.set(rootRight, rootBottom, rootRight, rootBottom);
            }
            setFocusTopLeft(root, focusedRect) {
                const rootTop = root.getScrollY();
                const rootLeft = root.getScrollX();
                focusedRect.set(rootLeft, rootTop, rootLeft, rootTop);
            }
            findNextFocusInAbsoluteDirection(focusables, root, focused, focusedRect, direction) {
                this.mBestCandidateRect.set(focusedRect);
                switch (direction) {
                    case View.FOCUS_LEFT:
                        this.mBestCandidateRect.offset(focusedRect.width() + 1, 0);
                        break;
                    case View.FOCUS_RIGHT:
                        this.mBestCandidateRect.offset(-(focusedRect.width() + 1), 0);
                        break;
                    case View.FOCUS_UP:
                        this.mBestCandidateRect.offset(0, focusedRect.height() + 1);
                        break;
                    case View.FOCUS_DOWN:
                        this.mBestCandidateRect.offset(0, -(focusedRect.height() + 1));
                }
                let closest = null;
                let numFocusables = focusables.size();
                for (let i = 0; i < numFocusables; i++) {
                    let focusable = focusables.get(i);
                    if (focusable == focused || focusable == root)
                        continue;
                    focusable.getFocusedRect(this.mOtherRect);
                    root.offsetDescendantRectToMyCoords(focusable, this.mOtherRect);
                    if (this.isBetterCandidate(direction, focusedRect, this.mOtherRect, this.mBestCandidateRect)) {
                        this.mBestCandidateRect.set(this.mOtherRect);
                        closest = focusable;
                    }
                }
                return closest;
            }
            static getNextFocusable(focused, focusables, count) {
                if (focused != null) {
                    let position = focusables.lastIndexOf(focused);
                    if (position >= 0 && position + 1 < count) {
                        return focusables.get(position + 1);
                    }
                }
                if (!focusables.isEmpty()) {
                    return focusables.get(0);
                }
                return null;
            }
            static getPreviousFocusable(focused, focusables, count) {
                if (focused != null) {
                    let position = focusables.indexOf(focused);
                    if (position > 0) {
                        return focusables.get(position - 1);
                    }
                }
                if (!focusables.isEmpty()) {
                    return focusables.get(count - 1);
                }
                return null;
            }
            isBetterCandidate(direction, source, rect1, rect2) {
                if (!this.isCandidate(source, rect1, direction)) {
                    return false;
                }
                if (!this.isCandidate(source, rect2, direction)) {
                    return true;
                }
                if (this.beamBeats(direction, source, rect1, rect2)) {
                    return true;
                }
                if (this.beamBeats(direction, source, rect2, rect1)) {
                    return false;
                }
                return (this.getWeightedDistanceFor(FocusFinder.majorAxisDistance(direction, source, rect1), FocusFinder.minorAxisDistance(direction, source, rect1))
                    < this.getWeightedDistanceFor(FocusFinder.majorAxisDistance(direction, source, rect2), FocusFinder.minorAxisDistance(direction, source, rect2)));
            }
            beamBeats(direction, source, rect1, rect2) {
                const rect1InSrcBeam = this.beamsOverlap(direction, source, rect1);
                const rect2InSrcBeam = this.beamsOverlap(direction, source, rect2);
                if (rect2InSrcBeam || !rect1InSrcBeam) {
                    return false;
                }
                if (!this.isToDirectionOf(direction, source, rect2)) {
                    return true;
                }
                if ((direction == View.FOCUS_LEFT || direction == View.FOCUS_RIGHT)) {
                    return true;
                }
                return (FocusFinder.majorAxisDistance(direction, source, rect1)
                    < FocusFinder.majorAxisDistanceToFarEdge(direction, source, rect2));
            }
            getWeightedDistanceFor(majorAxisDistance, minorAxisDistance) {
                return 13 * majorAxisDistance * majorAxisDistance
                    + minorAxisDistance * minorAxisDistance;
            }
            isCandidate(srcRect, destRect, direction) {
                switch (direction) {
                    case View.FOCUS_LEFT:
                        return (srcRect.right > destRect.right || srcRect.left >= destRect.right)
                            && srcRect.left > destRect.left;
                    case View.FOCUS_RIGHT:
                        return (srcRect.left < destRect.left || srcRect.right <= destRect.left)
                            && srcRect.right < destRect.right;
                    case View.FOCUS_UP:
                        return (srcRect.bottom > destRect.bottom || srcRect.top >= destRect.bottom)
                            && srcRect.top > destRect.top;
                    case View.FOCUS_DOWN:
                        return (srcRect.top < destRect.top || srcRect.bottom <= destRect.top)
                            && srcRect.bottom < destRect.bottom;
                }
                throw new Error("direction must be one of "
                    + "{FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT}.");
            }
            beamsOverlap(direction, rect1, rect2) {
                switch (direction) {
                    case View.FOCUS_LEFT:
                    case View.FOCUS_RIGHT:
                        return (rect2.bottom >= rect1.top) && (rect2.top <= rect1.bottom);
                    case View.FOCUS_UP:
                    case View.FOCUS_DOWN:
                        return (rect2.right >= rect1.left) && (rect2.left <= rect1.right);
                }
                throw new Error("direction must be one of "
                    + "{FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT}.");
            }
            isToDirectionOf(direction, src, dest) {
                switch (direction) {
                    case View.FOCUS_LEFT:
                        return src.left >= dest.right;
                    case View.FOCUS_RIGHT:
                        return src.right <= dest.left;
                    case View.FOCUS_UP:
                        return src.top >= dest.bottom;
                    case View.FOCUS_DOWN:
                        return src.bottom <= dest.top;
                }
                throw new Error("direction must be one of "
                    + "{FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT}.");
            }
            static majorAxisDistance(direction, source, dest) {
                return Math.max(0, FocusFinder.majorAxisDistanceRaw(direction, source, dest));
            }
            static majorAxisDistanceRaw(direction, source, dest) {
                switch (direction) {
                    case View.FOCUS_LEFT:
                        return source.left - dest.right;
                    case View.FOCUS_RIGHT:
                        return dest.left - source.right;
                    case View.FOCUS_UP:
                        return source.top - dest.bottom;
                    case View.FOCUS_DOWN:
                        return dest.top - source.bottom;
                }
                throw new Error("direction must be one of "
                    + "{FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT}.");
            }
            static majorAxisDistanceToFarEdge(direction, source, dest) {
                return Math.max(1, FocusFinder.majorAxisDistanceToFarEdgeRaw(direction, source, dest));
            }
            static majorAxisDistanceToFarEdgeRaw(direction, source, dest) {
                switch (direction) {
                    case View.FOCUS_LEFT:
                        return source.left - dest.left;
                    case View.FOCUS_RIGHT:
                        return dest.right - source.right;
                    case View.FOCUS_UP:
                        return source.top - dest.top;
                    case View.FOCUS_DOWN:
                        return dest.bottom - source.bottom;
                }
                throw new Error("direction must be one of "
                    + "{FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT}.");
            }
            static minorAxisDistance(direction, source, dest) {
                switch (direction) {
                    case View.FOCUS_LEFT:
                    case View.FOCUS_RIGHT:
                        return Math.abs(((source.top + source.height() / 2) -
                            ((dest.top + dest.height() / 2))));
                    case View.FOCUS_UP:
                    case View.FOCUS_DOWN:
                        return Math.abs(((source.left + source.width() / 2) -
                            ((dest.left + dest.width() / 2))));
                }
                throw new Error("direction must be one of "
                    + "{FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT}.");
            }
            findNearestTouchable(root, x, y, direction, deltas) {
                let touchables = root.getTouchables();
                let minDistance = Number.MAX_SAFE_INTEGER;
                let closest = null;
                let numTouchables = touchables.size();
                let edgeSlop = view_3.ViewConfiguration.get().getScaledEdgeSlop();
                let closestBounds = new Rect();
                let touchableBounds = this.mOtherRect;
                for (let i = 0; i < numTouchables; i++) {
                    let touchable = touchables.get(i);
                    touchable.getDrawingRect(touchableBounds);
                    root.offsetRectBetweenParentAndChild(touchable, touchableBounds, true, true);
                    if (!this.isTouchCandidate(x, y, touchableBounds, direction)) {
                        continue;
                    }
                    let distance = Number.MAX_SAFE_INTEGER;
                    switch (direction) {
                        case View.FOCUS_LEFT:
                            distance = x - touchableBounds.right + 1;
                            break;
                        case View.FOCUS_RIGHT:
                            distance = touchableBounds.left;
                            break;
                        case View.FOCUS_UP:
                            distance = y - touchableBounds.bottom + 1;
                            break;
                        case View.FOCUS_DOWN:
                            distance = touchableBounds.top;
                            break;
                    }
                    if (distance < edgeSlop) {
                        if (closest == null ||
                            closestBounds.contains(touchableBounds) ||
                            (!touchableBounds.contains(closestBounds) && distance < minDistance)) {
                            minDistance = distance;
                            closest = touchable;
                            closestBounds.set(touchableBounds);
                            switch (direction) {
                                case View.FOCUS_LEFT:
                                    deltas[0] = -distance;
                                    break;
                                case View.FOCUS_RIGHT:
                                    deltas[0] = distance;
                                    break;
                                case View.FOCUS_UP:
                                    deltas[1] = -distance;
                                    break;
                                case View.FOCUS_DOWN:
                                    deltas[1] = distance;
                                    break;
                            }
                        }
                    }
                }
                return closest;
            }
            isTouchCandidate(x, y, destRect, direction) {
                switch (direction) {
                    case View.FOCUS_LEFT:
                        return destRect.left <= x && destRect.top <= y && y <= destRect.bottom;
                    case View.FOCUS_RIGHT:
                        return destRect.left >= x && destRect.top <= y && y <= destRect.bottom;
                    case View.FOCUS_UP:
                        return destRect.top <= y && destRect.left <= x && x <= destRect.right;
                    case View.FOCUS_DOWN:
                        return destRect.top >= y && destRect.left <= x && x <= destRect.right;
                }
                throw new Error("direction must be one of "
                    + "{FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT}.");
            }
        }
        view_3.FocusFinder = FocusFinder;
        class SequentialFocusComparator {
            constructor() {
                this.mFirstRect = new Rect();
                this.mSecondRect = new Rect();
                this.mIsLayoutRtl = false;
                this.compareFn = (first, second) => {
                    if (first == second) {
                        return 0;
                    }
                    this.getRect(first, this.mFirstRect);
                    this.getRect(second, this.mSecondRect);
                    if (this.mFirstRect.top < this.mSecondRect.top) {
                        return -1;
                    }
                    else if (this.mFirstRect.top > this.mSecondRect.top) {
                        return 1;
                    }
                    else if (this.mFirstRect.left < this.mSecondRect.left) {
                        return this.mIsLayoutRtl ? 1 : -1;
                    }
                    else if (this.mFirstRect.left > this.mSecondRect.left) {
                        return this.mIsLayoutRtl ? -1 : 1;
                    }
                    else if (this.mFirstRect.bottom < this.mSecondRect.bottom) {
                        return -1;
                    }
                    else if (this.mFirstRect.bottom > this.mSecondRect.bottom) {
                        return 1;
                    }
                    else if (this.mFirstRect.right < this.mSecondRect.right) {
                        return this.mIsLayoutRtl ? 1 : -1;
                    }
                    else if (this.mFirstRect.right > this.mSecondRect.right) {
                        return this.mIsLayoutRtl ? -1 : 1;
                    }
                    else {
                        return 0;
                    }
                };
            }
            recycle() {
                this.mRoot = null;
            }
            setRoot(root) {
                this.mRoot = root;
            }
            getRect(view, rect) {
                view.getDrawingRect(rect);
                this.mRoot.offsetDescendantRectToMyCoords(view, rect);
            }
            sort(array) {
                array.sort(this.compareFn);
            }
        }
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/5.
 */
///<reference path="ViewRootImpl.ts"/>
///<reference path="View.ts"/>
///<reference path="MotionEvent.ts"/>
///<reference path="ViewParent.ts"/>
///<reference path="../graphics/Canvas.ts"/>
///<reference path="../graphics/Point.ts"/>
///<reference path="../graphics/Matrix.ts"/>
///<reference path="../graphics/Rect.ts"/>
///<reference path="../os/SystemClock.ts"/>
///<reference path="../util/TypedValue.ts"/>
///<reference path="FocusFinder.ts"/>
var android;
(function (android) {
    var view;
    (function (view_4) {
        var Rect = android.graphics.Rect;
        var SystemClock = android.os.SystemClock;
        var TypedValue = android.util.TypedValue;
        var System = java.lang.System;
        class ViewGroup extends view_4.View {
            constructor() {
                super();
                this.mLastTouchDownTime = 0;
                this.mLastTouchDownIndex = -1;
                this.mLastTouchDownX = 0;
                this.mLastTouchDownY = 0;
                this.mGroupFlags = 0;
                this.mLayoutMode = ViewGroup.LAYOUT_MODE_UNDEFINED;
                this.mChildren = [];
                this.mSuppressLayout = false;
                this.mLayoutCalledWhileSuppressed = false;
                this.mChildCountWithTransientState = 0;
                this.initViewGroup();
            }
            get mChildrenCount() {
                return this.mChildren.length;
            }
            createAttrChangeHandler(mergeHandler) {
                super.createAttrChangeHandler(mergeHandler);
                let viewGroup = this;
                mergeHandler.add({
                    set clipChildren(value) {
                        viewGroup.setClipChildren(view_4.View.AttrChangeHandler.parseBoolean(value));
                    },
                    get clipChildren() {
                        return viewGroup.getClipChildren();
                    },
                    set clipToPadding(value) {
                        viewGroup.setClipToPadding(view_4.View.AttrChangeHandler.parseBoolean(value));
                    },
                    get clipToPadding() {
                        return viewGroup.isClipToPadding();
                    },
                    set animationCache(value) {
                    },
                    set persistentDrawingCache(value) {
                    },
                    set addStatesFromChildren(value) {
                    },
                    set alwaysDrawnWithCache(value) {
                    },
                    set layoutAnimation(value) {
                    },
                    set descendantFocusability(value) {
                    },
                    set splitMotionEvents(value) {
                    },
                    set animateLayoutChanges(value) {
                    },
                    set layoutMode(value) {
                    }
                });
            }
            initViewGroup() {
                this.setFlags(view_4.View.WILL_NOT_DRAW, view_4.View.DRAW_MASK);
                this.mGroupFlags |= ViewGroup.FLAG_CLIP_CHILDREN;
                this.mGroupFlags |= ViewGroup.FLAG_CLIP_TO_PADDING;
                this.mGroupFlags |= ViewGroup.FLAG_ANIMATION_DONE;
                this.mGroupFlags |= ViewGroup.FLAG_ANIMATION_CACHE;
                this.mGroupFlags |= ViewGroup.FLAG_ALWAYS_DRAWN_WITH_CACHE;
                this.mGroupFlags |= ViewGroup.FLAG_SPLIT_MOTION_EVENTS;
                this.setDescendantFocusability(ViewGroup.FOCUS_BEFORE_DESCENDANTS);
                this.mPersistentDrawingCache = ViewGroup.PERSISTENT_SCROLLING_CACHE;
            }
            getDescendantFocusability() {
                return this.mGroupFlags & ViewGroup.FLAG_MASK_FOCUSABILITY;
            }
            setDescendantFocusability(focusability) {
                switch (focusability) {
                    case ViewGroup.FOCUS_BEFORE_DESCENDANTS:
                    case ViewGroup.FOCUS_AFTER_DESCENDANTS:
                    case ViewGroup.FOCUS_BLOCK_DESCENDANTS:
                        break;
                    default:
                        throw new Error("must be one of FOCUS_BEFORE_DESCENDANTS, "
                            + "FOCUS_AFTER_DESCENDANTS, FOCUS_BLOCK_DESCENDANTS");
                }
                this.mGroupFlags &= ~ViewGroup.FLAG_MASK_FOCUSABILITY;
                this.mGroupFlags |= (focusability & ViewGroup.FLAG_MASK_FOCUSABILITY);
            }
            handleFocusGainInternal(direction, previouslyFocusedRect) {
                if (this.mFocused != null) {
                    this.mFocused.unFocus();
                    this.mFocused = null;
                }
                super.handleFocusGainInternal(direction, previouslyFocusedRect);
            }
            requestChildFocus(child, focused) {
                if (view_4.View.DBG) {
                    System.out.println(this + " requestChildFocus()");
                }
                if (this.getDescendantFocusability() == ViewGroup.FOCUS_BLOCK_DESCENDANTS) {
                    return;
                }
                super.unFocus();
                if (this.mFocused != child) {
                    if (this.mFocused != null) {
                        this.mFocused.unFocus();
                    }
                    this.mFocused = child;
                }
                if (this.mParent != null) {
                    this.mParent.requestChildFocus(this, focused);
                }
            }
            focusableViewAvailable(v) {
                if (this.mParent != null
                    && (this.getDescendantFocusability() != ViewGroup.FOCUS_BLOCK_DESCENDANTS)
                    && !(this.isFocused() && this.getDescendantFocusability() != ViewGroup.FOCUS_AFTER_DESCENDANTS)) {
                    this.mParent.focusableViewAvailable(v);
                }
            }
            focusSearch(...args) {
                if (arguments.length === 1) {
                    return super.focusSearch(args[0]);
                }
                let [focused, direction] = args;
                if (this.isRootNamespace()) {
                    return view_4.FocusFinder.getInstance().findNextFocus(this, focused, direction);
                }
                else if (this.mParent != null) {
                    return this.mParent.focusSearch(focused, direction);
                }
                return null;
            }
            requestChildRectangleOnScreen(child, rectangle, immediate) {
                return false;
            }
            childHasTransientStateChanged(child, childHasTransientState) {
                const oldHasTransientState = this.hasTransientState();
                if (childHasTransientState) {
                    this.mChildCountWithTransientState++;
                }
                else {
                    this.mChildCountWithTransientState--;
                }
                const newHasTransientState = this.hasTransientState();
                if (this.mParent != null && oldHasTransientState != newHasTransientState) {
                    this.mParent.childHasTransientStateChanged(this, newHasTransientState);
                }
            }
            hasTransientState() {
                return this.mChildCountWithTransientState > 0 || super.hasTransientState();
            }
            dispatchUnhandledMove(focused, direction) {
                return this.mFocused != null && this.mFocused.dispatchUnhandledMove(focused, direction);
            }
            clearChildFocus(child) {
                if (view_4.View.DBG) {
                    System.out.println(this + " clearChildFocus()");
                }
                this.mFocused = null;
                if (this.mParent != null) {
                    this.mParent.clearChildFocus(this);
                }
            }
            clearFocus() {
                if (view_4.View.DBG) {
                    System.out.println(this + " clearFocus()");
                }
                if (this.mFocused == null) {
                    super.clearFocus();
                }
                else {
                    let focused = this.mFocused;
                    this.mFocused = null;
                    focused.clearFocus();
                }
            }
            unFocus() {
                if (view_4.View.DBG) {
                    System.out.println(this + " unFocus()");
                }
                if (this.mFocused == null) {
                    super.unFocus();
                }
                else {
                    this.mFocused.unFocus();
                    this.mFocused = null;
                }
            }
            getFocusedChild() {
                return this.mFocused;
            }
            hasFocus() {
                return (this.mPrivateFlags & view_4.View.PFLAG_FOCUSED) != 0 || this.mFocused != null;
            }
            findFocus() {
                if (ViewGroup.DBG) {
                    System.out.println("Find focus in " + this + ": flags=" + this.isFocused() + ", child=" + this.mFocused);
                }
                if (this.isFocused()) {
                    return this;
                }
                if (this.mFocused != null) {
                    return this.mFocused.findFocus();
                }
                return null;
            }
            hasFocusable() {
                if ((this.mViewFlags & view_4.View.VISIBILITY_MASK) != view_4.View.VISIBLE) {
                    return false;
                }
                if (this.isFocusable()) {
                    return true;
                }
                const descendantFocusability = this.getDescendantFocusability();
                if (descendantFocusability != ViewGroup.FOCUS_BLOCK_DESCENDANTS) {
                    const count = this.mChildrenCount;
                    const children = this.mChildren;
                    for (let i = 0; i < count; i++) {
                        const child = children[i];
                        if (child.hasFocusable()) {
                            return true;
                        }
                    }
                }
                return false;
            }
            addFocusables(views, direction, focusableMode = view_4.View.FOCUSABLES_TOUCH_MODE) {
                const focusableCount = views.size();
                const descendantFocusability = this.getDescendantFocusability();
                if (descendantFocusability != ViewGroup.FOCUS_BLOCK_DESCENDANTS) {
                    const count = this.mChildrenCount;
                    const children = this.mChildren;
                    for (let i = 0; i < count; i++) {
                        const child = children[i];
                        if ((child.mViewFlags & view_4.View.VISIBILITY_MASK) == view_4.View.VISIBLE) {
                            child.addFocusables(views, direction, focusableMode);
                        }
                    }
                }
                if (descendantFocusability != ViewGroup.FOCUS_AFTER_DESCENDANTS
                    || (focusableCount == views.size())) {
                    super.addFocusables(views, direction, focusableMode);
                }
            }
            requestFocus(direction, previouslyFocusedRect) {
                if (view_4.View.DBG) {
                    System.out.println(this + " ViewGroup.requestFocus direction="
                        + direction);
                }
                let descendantFocusability = this.getDescendantFocusability();
                switch (descendantFocusability) {
                    case ViewGroup.FOCUS_BLOCK_DESCENDANTS:
                        return super.requestFocus(direction, previouslyFocusedRect);
                    case ViewGroup.FOCUS_BEFORE_DESCENDANTS: {
                        const took = super.requestFocus(direction, previouslyFocusedRect);
                        return took ? took : this.onRequestFocusInDescendants(direction, previouslyFocusedRect);
                    }
                    case ViewGroup.FOCUS_AFTER_DESCENDANTS: {
                        const took = this.onRequestFocusInDescendants(direction, previouslyFocusedRect);
                        return took ? took : super.requestFocus(direction, previouslyFocusedRect);
                    }
                    default:
                        throw new Error("descendant focusability must be "
                            + "one of FOCUS_BEFORE_DESCENDANTS, FOCUS_AFTER_DESCENDANTS, FOCUS_BLOCK_DESCENDANTS "
                            + "but is " + descendantFocusability);
                }
            }
            onRequestFocusInDescendants(direction, previouslyFocusedRect) {
                let index;
                let increment;
                let end;
                let count = this.mChildrenCount;
                if ((direction & view_4.View.FOCUS_FORWARD) != 0) {
                    index = 0;
                    increment = 1;
                    end = count;
                }
                else {
                    index = count - 1;
                    increment = -1;
                    end = -1;
                }
                const children = this.mChildren;
                for (let i = index; i != end; i += increment) {
                    let child = children[i];
                    if ((child.mViewFlags & view_4.View.VISIBILITY_MASK) == view_4.View.VISIBLE) {
                        if (child.requestFocus(direction, previouslyFocusedRect)) {
                            return true;
                        }
                    }
                }
                return false;
            }
            addView(...args) {
                let child = args[0];
                let params = child.getLayoutParams();
                let index = -1;
                if (args.length == 2) {
                    if (args[1] instanceof ViewGroup.LayoutParams)
                        params = args[1];
                    else
                        index = args[1];
                }
                else if (args.length == 3) {
                    if (args[2] instanceof ViewGroup.LayoutParams) {
                        index = args[1];
                        params = args[2];
                    }
                    else {
                        params = this.generateDefaultLayoutParams();
                        params.width = args[1];
                        params.height = args[2];
                    }
                }
                if (params == null) {
                    params = this.generateDefaultLayoutParams();
                    if (params == null) {
                        throw new Error("generateDefaultLayoutParams() cannot return null");
                    }
                }
                this.requestLayout();
                this.invalidate(true);
                this.addViewInner(child, index, params, false);
            }
            checkLayoutParams(p) {
                return p != null;
            }
            setOnHierarchyChangeListener(listener) {
                this.mOnHierarchyChangeListener = listener;
            }
            onViewAdded(child) {
                if (this.mOnHierarchyChangeListener != null) {
                    this.mOnHierarchyChangeListener.onChildViewAdded(this, child);
                }
            }
            onViewRemoved(child) {
                if (this.mOnHierarchyChangeListener != null) {
                    this.mOnHierarchyChangeListener.onChildViewRemoved(this, child);
                }
            }
            clearCachedLayoutMode() {
                if (!this.hasBooleanFlag(ViewGroup.FLAG_LAYOUT_MODE_WAS_EXPLICITLY_SET)) {
                    this.mLayoutMode = ViewGroup.LAYOUT_MODE_UNDEFINED;
                }
            }
            addViewInLayout(child, index, params, preventRequestLayout = false) {
                child.mParent = null;
                this.addViewInner(child, index, params, preventRequestLayout);
                child.mPrivateFlags = (child.mPrivateFlags & ~ViewGroup.PFLAG_DIRTY_MASK) | ViewGroup.PFLAG_DRAWN;
                return true;
            }
            cleanupLayoutState(child) {
                child.mPrivateFlags &= ~view_4.View.PFLAG_FORCE_LAYOUT;
            }
            addViewInner(child, index, params, preventRequestLayout) {
                if (child.getParent() != null) {
                    throw new Error("The specified child already has a parent. " +
                        "You must call removeView() on the child's parent first.");
                }
                if (!this.checkLayoutParams(params)) {
                    params = this.generateLayoutParams(params);
                }
                if (preventRequestLayout) {
                    child.mLayoutParams = params;
                }
                else {
                    child.setLayoutParams(params);
                }
                params._attrChangeHandler.view = child;
                if (index < 0) {
                    index = this.mChildrenCount;
                }
                this.addInArray(child, index);
                if (preventRequestLayout) {
                    child.assignParent(this);
                }
                else {
                    child.mParent = this;
                }
                if (child.hasFocus()) {
                    this.requestChildFocus(child, child.findFocus());
                }
                let ai = this.mAttachInfo;
                if (ai != null && (this.mGroupFlags & ViewGroup.FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW) == 0) {
                    child.dispatchAttachedToWindow(this.mAttachInfo, (this.mViewFlags & ViewGroup.VISIBILITY_MASK));
                }
                this.onViewAdded(child);
                if ((child.mViewFlags & ViewGroup.DUPLICATE_PARENT_STATE) == ViewGroup.DUPLICATE_PARENT_STATE) {
                    this.mGroupFlags |= ViewGroup.FLAG_NOTIFY_CHILDREN_ON_DRAWABLE_STATE_CHANGE;
                }
            }
            addInArray(child, index) {
                let count = this.mChildrenCount;
                if (index == count) {
                    this.mChildren.push(child);
                    this.addToBindElement(child.bindElement, null);
                }
                else if (index < count) {
                    let refChild = this.getChildAt(index);
                    this.mChildren.splice(index, 0, child);
                    this.addToBindElement(child.bindElement, refChild.bindElement);
                }
                else {
                    throw new Error("index=" + index + " count=" + count);
                }
            }
            addToBindElement(childElement, insertBeforeElement) {
                if (childElement.parentElement) {
                    if (childElement.parentElement == this.bindElement)
                        return;
                    childElement.parentElement.removeChild(childElement);
                }
                if (insertBeforeElement) {
                    this.bindElement.appendChild(childElement);
                }
                else {
                    this.bindElement.insertBefore(childElement, insertBeforeElement);
                }
            }
            removeChildElement(childElement) {
                try {
                    this.bindElement.removeChild(childElement);
                }
                catch (e) {
                }
            }
            removeFromArray(index, count = 1) {
                let start = Math.max(0, index);
                let end = Math.min(this.mChildrenCount, start + count);
                if (start == end) {
                    return;
                }
                for (let i = start; i < end; i++) {
                    this.mChildren[i].mParent = null;
                    this.removeChildElement(this.mChildren[i].bindElement);
                }
                this.mChildren.splice(index, end - start);
            }
            removeView(view) {
                this.removeViewInternal(view);
                this.requestLayout();
                this.invalidate(true);
            }
            removeViewInLayout(view) {
                this.removeViewInternal(view);
            }
            removeViewsInLayout(start, count) {
                this.removeViewsInternal(start, count);
            }
            removeViewAt(index) {
                this.removeViewsInternal(index, 1);
                this.requestLayout();
                this.invalidate(true);
            }
            removeViews(start, count) {
                this.removeViewsInternal(start, count);
                this.requestLayout();
                this.invalidate(true);
            }
            removeViewInternal(view) {
                let index = this.indexOfChild(view);
                if (index >= 0) {
                    this.removeViewsInternal(index, 1);
                }
            }
            removeViewsInternal(start, count) {
                let focused = this.mFocused;
                let clearChildFocus = false;
                const detach = this.mAttachInfo != null;
                const children = this.mChildren;
                const end = start + count;
                for (let i = start; i < end; i++) {
                    const view = children[i];
                    if (view == focused) {
                        view.unFocus();
                        clearChildFocus = true;
                    }
                    this.cancelTouchTarget(view);
                    if (detach) {
                        view.dispatchDetachedFromWindow();
                    }
                    this.onViewRemoved(view);
                }
                this.removeFromArray(start, count);
                if (clearChildFocus) {
                    this.clearChildFocus(focused);
                    if (!this.rootViewRequestFocus()) {
                        this.notifyGlobalFocusCleared(focused);
                    }
                }
            }
            removeAllViews() {
                this.removeAllViewsInLayout();
                this.requestLayout();
                this.invalidate(true);
            }
            removeAllViewsInLayout() {
                const count = this.mChildrenCount;
                if (count <= 0) {
                    return;
                }
                this.removeViewsInternal(0, count);
            }
            detachViewFromParent(child) {
                if (child instanceof view_4.View)
                    child = this.indexOfChild(child);
                this.removeFromArray(child);
            }
            removeDetachedView(child, animate) {
                if (child == this.mFocused) {
                    child.clearFocus();
                }
                this.cancelTouchTarget(child);
                if ((animate && child.getAnimation() != null)) {
                }
                else if (child.mAttachInfo != null) {
                    child.dispatchDetachedFromWindow();
                }
                if (child.hasTransientState()) {
                    this.childHasTransientStateChanged(child, false);
                }
                this.onViewRemoved(child);
            }
            attachViewToParent(child, index, params) {
                child.mLayoutParams = params;
                if (index < 0) {
                    index = this.mChildrenCount;
                }
                this.addInArray(child, index);
                child.mParent = this;
                child.mPrivateFlags = (child.mPrivateFlags & ~ViewGroup.PFLAG_DIRTY_MASK & ~ViewGroup.PFLAG_DRAWING_CACHE_VALID) | ViewGroup.PFLAG_DRAWN | ViewGroup.PFLAG_INVALIDATED;
                this.mPrivateFlags |= ViewGroup.PFLAG_INVALIDATED;
                if (child.hasFocus()) {
                    this.requestChildFocus(child, child.findFocus());
                }
            }
            detachViewsFromParent(start, count = 1) {
                this.removeFromArray(start, count);
            }
            detachAllViewsFromParent() {
                const count = this.mChildrenCount;
                if (count <= 0) {
                    return;
                }
                const children = this.mChildren;
                this.mChildren = [];
                for (let i = count - 1; i >= 0; i--) {
                    children[i].mParent = null;
                    this.removeChildElement(children[i].bindElement);
                }
            }
            indexOfChild(child) {
                return this.mChildren.indexOf(child);
            }
            getChildCount() {
                return this.mChildrenCount;
            }
            getChildAt(index) {
                if (index < 0 || index >= this.mChildrenCount) {
                    return null;
                }
                return this.mChildren[index];
            }
            bringChildToFront(child) {
                let index = this.indexOfChild(child);
                if (index >= 0) {
                    this.removeFromArray(index);
                    this.addInArray(child, this.mChildrenCount);
                    child.mParent = this;
                    this.requestLayout();
                    this.invalidate();
                }
            }
            hasBooleanFlag(flag) {
                return (this.mGroupFlags & flag) == flag;
            }
            setBooleanFlag(flag, value) {
                if (value) {
                    this.mGroupFlags |= flag;
                }
                else {
                    this.mGroupFlags &= ~flag;
                }
            }
            dispatchGenericPointerEvent(event) {
                const childrenCount = this.mChildrenCount;
                if (childrenCount != 0) {
                    const children = this.mChildren;
                    const x = event.getX();
                    const y = event.getY();
                    const customOrder = this.isChildrenDrawingOrderEnabled();
                    for (let i = childrenCount - 1; i >= 0; i--) {
                        const childIndex = customOrder ? this.getChildDrawingOrder(childrenCount, i) : i;
                        const child = children[childIndex];
                        if (!ViewGroup.canViewReceivePointerEvents(child)
                            || !this.isTransformedTouchPointInView(x, y, child, null)) {
                            continue;
                        }
                        if (this.dispatchTransformedGenericPointerEvent(event, child)) {
                            return true;
                        }
                    }
                }
                return super.dispatchGenericPointerEvent(event);
            }
            dispatchTransformedGenericPointerEvent(event, child) {
                const offsetX = this.mScrollX - child.mLeft;
                const offsetY = this.mScrollY - child.mTop;
                let handled;
                if (!child.hasIdentityMatrix()) {
                }
                else {
                    event.offsetLocation(offsetX, offsetY);
                    handled = child.dispatchGenericMotionEvent(event);
                    event.offsetLocation(-offsetX, -offsetY);
                }
                return handled;
            }
            dispatchKeyEvent(event) {
                if ((this.mPrivateFlags & (view_4.View.PFLAG_FOCUSED | view_4.View.PFLAG_HAS_BOUNDS))
                    == (view_4.View.PFLAG_FOCUSED | view_4.View.PFLAG_HAS_BOUNDS)) {
                    if (super.dispatchKeyEvent(event)) {
                        return true;
                    }
                }
                else if (this.mFocused != null && (this.mFocused.mPrivateFlags & view_4.View.PFLAG_HAS_BOUNDS)
                    == view_4.View.PFLAG_HAS_BOUNDS) {
                    if (this.mFocused.dispatchKeyEvent(event)) {
                        return true;
                    }
                }
                return false;
            }
            dispatchWindowFocusChanged(hasFocus) {
                super.dispatchWindowFocusChanged(hasFocus);
                const count = this.mChildrenCount;
                const children = this.mChildren;
                for (let i = 0; i < count; i++) {
                    children[i].dispatchWindowFocusChanged(hasFocus);
                }
            }
            addTouchables(views) {
                super.addTouchables(views);
                const count = this.mChildrenCount;
                const children = this.mChildren;
                for (let i = 0; i < count; i++) {
                    const child = children[i];
                    if ((child.mViewFlags & view_4.View.VISIBILITY_MASK) == view_4.View.VISIBLE) {
                        child.addTouchables(views);
                    }
                }
            }
            onInterceptTouchEvent(ev) {
                return false;
            }
            dispatchTouchEvent(ev) {
                let handled = false;
                if (this.onFilterTouchEventForSecurity(ev)) {
                    let action = ev.getAction();
                    let actionMasked = action & view_4.MotionEvent.ACTION_MASK;
                    if (actionMasked == view_4.MotionEvent.ACTION_DOWN) {
                        this.cancelAndClearTouchTargets(ev);
                        this.resetTouchState();
                    }
                    let intercepted;
                    if (actionMasked == view_4.MotionEvent.ACTION_DOWN
                        || this.mFirstTouchTarget != null) {
                        let disallowIntercept = (this.mGroupFlags & ViewGroup.FLAG_DISALLOW_INTERCEPT) != 0;
                        if (!disallowIntercept) {
                            intercepted = this.onInterceptTouchEvent(ev);
                            ev.setAction(action);
                        }
                        else {
                            intercepted = false;
                        }
                    }
                    else {
                        intercepted = true;
                    }
                    let canceled = ViewGroup.resetCancelNextUpFlag(this)
                        || actionMasked == view_4.MotionEvent.ACTION_CANCEL;
                    let split = (this.mGroupFlags & ViewGroup.FLAG_SPLIT_MOTION_EVENTS) != 0;
                    let newTouchTarget = null;
                    let alreadyDispatchedToNewTouchTarget = false;
                    if (!canceled && !intercepted) {
                        if (actionMasked == view_4.MotionEvent.ACTION_DOWN
                            || (split && actionMasked == view_4.MotionEvent.ACTION_POINTER_DOWN)
                            || actionMasked == view_4.MotionEvent.ACTION_HOVER_MOVE) {
                            let actionIndex = ev.getActionIndex();
                            let idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex)
                                : TouchTarget.ALL_POINTER_IDS;
                            this.removePointersFromTouchTargets(idBitsToAssign);
                            let childrenCount = this.mChildrenCount;
                            if (newTouchTarget == null && childrenCount != 0) {
                                let x = ev.getX(actionIndex);
                                let y = ev.getY(actionIndex);
                                let children = this.mChildren;
                                let customOrder = this.isChildrenDrawingOrderEnabled();
                                for (let i = childrenCount - 1; i >= 0; i--) {
                                    let childIndex = customOrder ? this.getChildDrawingOrder(childrenCount, i) : i;
                                    let child = children[childIndex];
                                    if (!ViewGroup.canViewReceivePointerEvents(child)
                                        || !this.isTransformedTouchPointInView(x, y, child, null)) {
                                        continue;
                                    }
                                    newTouchTarget = this.getTouchTarget(child);
                                    if (newTouchTarget != null) {
                                        newTouchTarget.pointerIdBits |= idBitsToAssign;
                                        break;
                                    }
                                    ViewGroup.resetCancelNextUpFlag(child);
                                    if (this.dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                                        this.mLastTouchDownTime = ev.getDownTime();
                                        this.mLastTouchDownIndex = childIndex;
                                        this.mLastTouchDownX = ev.getX();
                                        this.mLastTouchDownY = ev.getY();
                                        newTouchTarget = this.addTouchTarget(child, idBitsToAssign);
                                        alreadyDispatchedToNewTouchTarget = true;
                                        break;
                                    }
                                }
                            }
                            if (newTouchTarget == null && this.mFirstTouchTarget != null) {
                                newTouchTarget = this.mFirstTouchTarget;
                                while (newTouchTarget.next != null) {
                                    newTouchTarget = newTouchTarget.next;
                                }
                                newTouchTarget.pointerIdBits |= idBitsToAssign;
                            }
                        }
                    }
                    if (this.mFirstTouchTarget == null) {
                        handled = this.dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);
                    }
                    else {
                        let predecessor = null;
                        let target = this.mFirstTouchTarget;
                        while (target != null) {
                            const next = target.next;
                            if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {
                                handled = true;
                            }
                            else {
                                let cancelChild = ViewGroup.resetCancelNextUpFlag(target.child)
                                    || intercepted;
                                if (this.dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) {
                                    handled = true;
                                }
                                if (cancelChild) {
                                    if (predecessor == null) {
                                        this.mFirstTouchTarget = next;
                                    }
                                    else {
                                        predecessor.next = next;
                                    }
                                    target.recycle();
                                    target = next;
                                    continue;
                                }
                            }
                            predecessor = target;
                            target = next;
                        }
                    }
                    if (canceled
                        || actionMasked == view_4.MotionEvent.ACTION_UP
                        || actionMasked == view_4.MotionEvent.ACTION_HOVER_MOVE) {
                        this.resetTouchState();
                    }
                    else if (split && actionMasked == view_4.MotionEvent.ACTION_POINTER_UP) {
                        let actionIndex = ev.getActionIndex();
                        let idBitsToRemove = 1 << ev.getPointerId(actionIndex);
                        this.removePointersFromTouchTargets(idBitsToRemove);
                    }
                }
                return handled;
            }
            resetTouchState() {
                this.clearTouchTargets();
                ViewGroup.resetCancelNextUpFlag(this);
                this.mGroupFlags &= ~ViewGroup.FLAG_DISALLOW_INTERCEPT;
            }
            static resetCancelNextUpFlag(view) {
                if ((view.mPrivateFlags & view_4.View.PFLAG_CANCEL_NEXT_UP_EVENT) != 0) {
                    view.mPrivateFlags &= ~view_4.View.PFLAG_CANCEL_NEXT_UP_EVENT;
                    return true;
                }
                return false;
            }
            clearTouchTargets() {
                let target = this.mFirstTouchTarget;
                if (target != null) {
                    do {
                        let next = target.next;
                        target.recycle();
                        target = next;
                    } while (target != null);
                    this.mFirstTouchTarget = null;
                }
            }
            cancelAndClearTouchTargets(event) {
                if (this.mFirstTouchTarget != null) {
                    let syntheticEvent = false;
                    if (event == null) {
                        let now = SystemClock.uptimeMillis();
                        event = view_4.MotionEvent.obtainWithAction(now, now, view_4.MotionEvent.ACTION_CANCEL, 0, 0);
                        syntheticEvent = true;
                    }
                    for (let target = this.mFirstTouchTarget; target != null; target = target.next) {
                        ViewGroup.resetCancelNextUpFlag(target.child);
                        this.dispatchTransformedTouchEvent(event, true, target.child, target.pointerIdBits);
                    }
                    this.clearTouchTargets();
                    if (syntheticEvent) {
                        event.recycle();
                    }
                }
            }
            getTouchTarget(child) {
                for (let target = this.mFirstTouchTarget; target != null; target = target.next) {
                    if (target.child == child) {
                        return target;
                    }
                }
                return null;
            }
            addTouchTarget(child, pointerIdBits) {
                let target = TouchTarget.obtain(child, pointerIdBits);
                target.next = this.mFirstTouchTarget;
                this.mFirstTouchTarget = target;
                return target;
            }
            removePointersFromTouchTargets(pointerIdBits) {
                let predecessor = null;
                let target = this.mFirstTouchTarget;
                while (target != null) {
                    let next = target.next;
                    if ((target.pointerIdBits & pointerIdBits) != 0) {
                        target.pointerIdBits &= ~pointerIdBits;
                        if (target.pointerIdBits == 0) {
                            if (predecessor == null) {
                                this.mFirstTouchTarget = next;
                            }
                            else {
                                predecessor.next = next;
                            }
                            target.recycle();
                            target = next;
                            continue;
                        }
                    }
                    predecessor = target;
                    target = next;
                }
            }
            cancelTouchTarget(view) {
                let predecessor = null;
                let target = this.mFirstTouchTarget;
                while (target != null) {
                    let next = target.next;
                    if (target.child == view) {
                        if (predecessor == null) {
                            this.mFirstTouchTarget = next;
                        }
                        else {
                            predecessor.next = next;
                        }
                        target.recycle();
                        let now = SystemClock.uptimeMillis();
                        let event = view_4.MotionEvent.obtainWithAction(now, now, view_4.MotionEvent.ACTION_CANCEL, 0, 0);
                        view.dispatchTouchEvent(event);
                        event.recycle();
                        return;
                    }
                    predecessor = target;
                    target = next;
                }
            }
            static canViewReceivePointerEvents(child) {
                return (child.mViewFlags & view_4.View.VISIBILITY_MASK) == view_4.View.VISIBLE;
            }
            isTransformedTouchPointInView(x, y, child, outLocalPoint) {
                let localX = x + this.mScrollX - child.mLeft;
                let localY = y + this.mScrollY - child.mTop;
                let isInView = child.pointInView(localX, localY);
                if (isInView && outLocalPoint != null) {
                    outLocalPoint.set(localX, localY);
                }
                return isInView;
            }
            dispatchTransformedTouchEvent(event, cancel, child, desiredPointerIdBits) {
                let handled;
                const oldAction = event.getAction();
                if (cancel || oldAction == view_4.MotionEvent.ACTION_CANCEL) {
                    event.setAction(view_4.MotionEvent.ACTION_CANCEL);
                    if (child == null) {
                        handled = super.dispatchTouchEvent(event);
                    }
                    else {
                        handled = child.dispatchTouchEvent(event);
                    }
                    event.setAction(oldAction);
                    return handled;
                }
                const oldPointerIdBits = event.getPointerIdBits();
                const newPointerIdBits = oldPointerIdBits & desiredPointerIdBits;
                if (newPointerIdBits == 0) {
                    return false;
                }
                let transformedEvent;
                if (newPointerIdBits == oldPointerIdBits) {
                    if (child == null || child.hasIdentityMatrix()) {
                        if (child == null) {
                            handled = super.dispatchTouchEvent(event);
                        }
                        else {
                            let offsetX = this.mScrollX - child.mLeft;
                            let offsetY = this.mScrollY - child.mTop;
                            event.offsetLocation(offsetX, offsetY);
                            handled = child.dispatchTouchEvent(event);
                            event.offsetLocation(-offsetX, -offsetY);
                        }
                        return handled;
                    }
                    transformedEvent = view_4.MotionEvent.obtain(event);
                }
                else {
                    transformedEvent = event.split(newPointerIdBits);
                }
                if (child == null) {
                    handled = super.dispatchTouchEvent(transformedEvent);
                }
                else {
                    let offsetX = this.mScrollX - child.mLeft;
                    let offsetY = this.mScrollY - child.mTop;
                    transformedEvent.offsetLocation(offsetX, offsetY);
                    handled = child.dispatchTouchEvent(transformedEvent);
                }
                transformedEvent.recycle();
                return handled;
            }
            isAlwaysDrawnWithCacheEnabled() {
                return (this.mGroupFlags & ViewGroup.FLAG_ALWAYS_DRAWN_WITH_CACHE) == ViewGroup.FLAG_ALWAYS_DRAWN_WITH_CACHE;
            }
            setAlwaysDrawnWithCacheEnabled(always) {
                this.setBooleanFlag(ViewGroup.FLAG_ALWAYS_DRAWN_WITH_CACHE, always);
            }
            isChildrenDrawnWithCacheEnabled() {
                return (this.mGroupFlags & ViewGroup.FLAG_CHILDREN_DRAWN_WITH_CACHE) == ViewGroup.FLAG_CHILDREN_DRAWN_WITH_CACHE;
            }
            setChildrenDrawnWithCacheEnabled(enabled) {
                this.setBooleanFlag(ViewGroup.FLAG_CHILDREN_DRAWN_WITH_CACHE, enabled);
            }
            setChildrenDrawingCacheEnabled(enabled) {
                if (enabled || (this.mPersistentDrawingCache & ViewGroup.PERSISTENT_ALL_CACHES) != ViewGroup.PERSISTENT_ALL_CACHES) {
                    const children = this.mChildren;
                    const count = this.mChildrenCount;
                    for (let i = 0; i < count; i++) {
                        children[i].setDrawingCacheEnabled(enabled);
                    }
                }
            }
            getPersistentDrawingCache() {
                return this.mPersistentDrawingCache;
            }
            setPersistentDrawingCache(drawingCacheToKeep) {
                this.mPersistentDrawingCache = drawingCacheToKeep & ViewGroup.PERSISTENT_ALL_CACHES;
            }
            isChildrenDrawingOrderEnabled() {
                return (this.mGroupFlags & ViewGroup.FLAG_USE_CHILD_DRAWING_ORDER) == ViewGroup.FLAG_USE_CHILD_DRAWING_ORDER;
            }
            setChildrenDrawingOrderEnabled(enabled) {
                this.setBooleanFlag(ViewGroup.FLAG_USE_CHILD_DRAWING_ORDER, enabled);
            }
            getChildDrawingOrder(childCount, i) {
                return i;
            }
            generateLayoutParams(p) {
                return p;
            }
            generateDefaultLayoutParams() {
                return new ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
            }
            measureChildren(widthMeasureSpec, heightMeasureSpec) {
                const size = this.mChildren.length;
                for (let i = 0; i < size; ++i) {
                    const child = this.mChildren[i];
                    if ((child.mViewFlags & view_4.View.VISIBILITY_MASK) != view_4.View.GONE) {
                        this.measureChild(child, widthMeasureSpec, heightMeasureSpec);
                    }
                }
            }
            measureChild(child, parentWidthMeasureSpec, parentHeightMeasureSpec) {
                let lp = child.getLayoutParams();
                lp._measuringParentWidthMeasureSpec = parentWidthMeasureSpec;
                lp._measuringParentHeightMeasureSpec = parentHeightMeasureSpec;
                const childWidthMeasureSpec = ViewGroup.getChildMeasureSpec(parentWidthMeasureSpec, this.mPaddingLeft + this.mPaddingRight, lp.width);
                const childHeightMeasureSpec = ViewGroup.getChildMeasureSpec(parentHeightMeasureSpec, this.mPaddingTop + this.mPaddingBottom, lp.height);
                child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
                lp._measuringParentWidthMeasureSpec = null;
                lp._measuringParentHeightMeasureSpec = null;
            }
            measureChildWithMargins(child, parentWidthMeasureSpec, widthUsed, parentHeightMeasureSpec, heightUsed) {
                let lp = child.getLayoutParams();
                lp._measuringParentWidthMeasureSpec = parentWidthMeasureSpec;
                lp._measuringParentHeightMeasureSpec = parentHeightMeasureSpec;
                if (lp instanceof ViewGroup.MarginLayoutParams) {
                    const childWidthMeasureSpec = ViewGroup.getChildMeasureSpec(parentWidthMeasureSpec, this.mPaddingLeft + this.mPaddingRight + lp.leftMargin + lp.rightMargin
                        + widthUsed, lp.width);
                    const childHeightMeasureSpec = ViewGroup.getChildMeasureSpec(parentHeightMeasureSpec, this.mPaddingTop + this.mPaddingBottom + lp.topMargin + lp.bottomMargin
                        + heightUsed, lp.height);
                    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
                }
                lp._measuringParentWidthMeasureSpec = null;
                lp._measuringParentHeightMeasureSpec = null;
            }
            static getChildMeasureSpec(spec, padding, childDimension) {
                let MeasureSpec = view_4.View.MeasureSpec;
                let specMode = MeasureSpec.getMode(spec);
                let specSize = MeasureSpec.getSize(spec);
                let size = Math.max(0, specSize - padding);
                let resultSize = 0;
                let resultMode = 0;
                switch (specMode) {
                    case MeasureSpec.EXACTLY:
                        if (childDimension >= 0) {
                            resultSize = childDimension;
                            resultMode = MeasureSpec.EXACTLY;
                        }
                        else if (childDimension == ViewGroup.LayoutParams.MATCH_PARENT) {
                            resultSize = size;
                            resultMode = MeasureSpec.EXACTLY;
                        }
                        else if (childDimension == ViewGroup.LayoutParams.WRAP_CONTENT) {
                            resultSize = size;
                            resultMode = MeasureSpec.AT_MOST;
                        }
                        break;
                    case MeasureSpec.AT_MOST:
                        if (childDimension >= 0) {
                            resultSize = childDimension;
                            resultMode = MeasureSpec.EXACTLY;
                        }
                        else if (childDimension == ViewGroup.LayoutParams.MATCH_PARENT) {
                            resultSize = size;
                            resultMode = MeasureSpec.AT_MOST;
                        }
                        else if (childDimension == ViewGroup.LayoutParams.WRAP_CONTENT) {
                            resultSize = size;
                            resultMode = MeasureSpec.AT_MOST;
                        }
                        break;
                    case MeasureSpec.UNSPECIFIED:
                        if (childDimension >= 0) {
                            resultSize = childDimension;
                            resultMode = MeasureSpec.EXACTLY;
                        }
                        else if (childDimension == ViewGroup.LayoutParams.MATCH_PARENT) {
                            resultSize = 0;
                            resultMode = MeasureSpec.UNSPECIFIED;
                        }
                        else if (childDimension == ViewGroup.LayoutParams.WRAP_CONTENT) {
                            resultSize = 0;
                            resultMode = MeasureSpec.UNSPECIFIED;
                        }
                        break;
                }
                return MeasureSpec.makeMeasureSpec(resultSize, resultMode);
            }
            dispatchAttachedToWindow(info, visibility) {
                this.mGroupFlags |= ViewGroup.FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW;
                super.dispatchAttachedToWindow(info, visibility);
                this.mGroupFlags &= ~ViewGroup.FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW;
                const count = this.mChildrenCount;
                const children = this.mChildren;
                for (let i = 0; i < count; i++) {
                    const child = children[i];
                    child.dispatchAttachedToWindow(info, visibility | (child.mViewFlags & view_4.View.VISIBILITY_MASK));
                }
            }
            onAttachedToWindow() {
                super.onAttachedToWindow();
                this.clearCachedLayoutMode();
            }
            onDetachedFromWindow() {
                super.onDetachedFromWindow();
                this.clearCachedLayoutMode();
            }
            dispatchDetachedFromWindow() {
                this.cancelAndClearTouchTargets(null);
                this.mLayoutCalledWhileSuppressed = false;
                this.mChildren.forEach((child) => child.dispatchDetachedFromWindow());
                super.dispatchDetachedFromWindow();
            }
            dispatchDisplayHint(hint) {
                super.dispatchDisplayHint(hint);
                const count = this.mChildrenCount;
                const children = this.mChildren;
                for (let i = 0; i < count; i++) {
                    children[i].dispatchDisplayHint(hint);
                }
            }
            onChildVisibilityChanged(child, oldVisibility, newVisibility) {
            }
            dispatchVisibilityChanged(changedView, visibility) {
                super.dispatchVisibilityChanged(changedView, visibility);
                const count = this.mChildrenCount;
                let children = this.mChildren;
                for (let i = 0; i < count; i++) {
                    children[i].dispatchVisibilityChanged(changedView, visibility);
                }
            }
            dispatchSetSelected(selected) {
                const children = this.mChildren;
                const count = this.mChildrenCount;
                for (let i = 0; i < count; i++) {
                    children[i].setSelected(selected);
                }
            }
            dispatchSetActivated(activated) {
                const children = this.mChildren;
                const count = this.mChildrenCount;
                for (let i = 0; i < count; i++) {
                    children[i].setActivated(activated);
                }
            }
            dispatchSetPressed(pressed) {
                const children = this.mChildren;
                const count = this.mChildrenCount;
                for (let i = 0; i < count; i++) {
                    const child = children[i];
                    if (!pressed || (!child.isClickable() && !child.isLongClickable())) {
                        child.setPressed(pressed);
                    }
                }
            }
            dispatchCancelPendingInputEvents() {
                super.dispatchCancelPendingInputEvents();
                const children = this.mChildren;
                const count = this.mChildrenCount;
                for (let i = 0; i < count; i++) {
                    children[i].dispatchCancelPendingInputEvents();
                }
            }
            offsetDescendantRectToMyCoords(descendant, rect) {
                this.offsetRectBetweenParentAndChild(descendant, rect, true, false);
            }
            offsetRectIntoDescendantCoords(descendant, rect) {
                this.offsetRectBetweenParentAndChild(descendant, rect, false, false);
            }
            offsetRectBetweenParentAndChild(descendant, rect, offsetFromChildToParent, clipToBounds) {
                if (descendant == this) {
                    return;
                }
                let theParent = descendant.mParent;
                while ((theParent != null)
                    && (theParent instanceof view_4.View)
                    && (theParent != this)) {
                    if (offsetFromChildToParent) {
                        rect.offset(descendant.mLeft - descendant.mScrollX, descendant.mTop - descendant.mScrollY);
                        if (clipToBounds) {
                            let p = theParent;
                            rect.intersect(0, 0, p.mRight - p.mLeft, p.mBottom - p.mTop);
                        }
                    }
                    else {
                        if (clipToBounds) {
                            let p = theParent;
                            rect.intersect(0, 0, p.mRight - p.mLeft, p.mBottom - p.mTop);
                        }
                        rect.offset(descendant.mScrollX - descendant.mLeft, descendant.mScrollY - descendant.mTop);
                    }
                    descendant = theParent;
                    theParent = descendant.mParent;
                }
                if (theParent == this) {
                    if (offsetFromChildToParent) {
                        rect.offset(descendant.mLeft - descendant.mScrollX, descendant.mTop - descendant.mScrollY);
                    }
                    else {
                        rect.offset(descendant.mScrollX - descendant.mLeft, descendant.mScrollY - descendant.mTop);
                    }
                }
                else {
                    throw new Error("parameter must be a descendant of this view");
                }
            }
            offsetChildrenTopAndBottom(offset) {
                const count = this.mChildrenCount;
                const children = this.mChildren;
                for (let i = 0; i < count; i++) {
                    const v = children[i];
                    v.mTop += offset;
                    v.mBottom += offset;
                }
                this.invalidateViewProperty(false, false);
            }
            suppressLayout(suppress) {
                this.mSuppressLayout = suppress;
                if (!suppress) {
                    if (this.mLayoutCalledWhileSuppressed) {
                        this.requestLayout();
                        this.mLayoutCalledWhileSuppressed = false;
                    }
                }
            }
            isLayoutSuppressed() {
                return this.mSuppressLayout;
            }
            layout(l, t, r, b) {
                if (!this.mSuppressLayout) {
                    super.layout(l, t, r, b);
                }
                else {
                    this.mLayoutCalledWhileSuppressed = true;
                }
            }
            canAnimate() {
                return false;
            }
            getChildVisibleRect(child, r, offset) {
                const rect = this.mAttachInfo != null ? this.mAttachInfo.mTmpTransformRect : new Rect();
                rect.set(r);
                let dx = child.mLeft - this.mScrollX;
                let dy = child.mTop - this.mScrollY;
                rect.offset(dx, dy);
                if (offset != null) {
                    offset.x += dx;
                    offset.y += dy;
                }
                if (rect.intersect(0, 0, this.mRight - this.mLeft, this.mBottom - this.mTop)) {
                    if (this.mParent == null)
                        return true;
                    r.set(rect);
                    return this.mParent.getChildVisibleRect(this, r, offset);
                }
                return false;
            }
            dispatchDraw(canvas) {
                let count = this.mChildrenCount;
                let children = this.mChildren;
                let flags = this.mGroupFlags;
                let saveCount = 0;
                let clipToPadding = (flags & ViewGroup.CLIP_TO_PADDING_MASK) == ViewGroup.CLIP_TO_PADDING_MASK;
                if (clipToPadding) {
                    saveCount = canvas.save();
                    canvas.clipRect(this.mScrollX + this.mPaddingLeft, this.mScrollY + this.mPaddingTop, this.mScrollX + this.mRight - this.mLeft - this.mPaddingRight, this.mScrollY + this.mBottom - this.mTop - this.mPaddingBottom);
                }
                this.mPrivateFlags &= ~ViewGroup.PFLAG_DRAW_ANIMATION;
                this.mGroupFlags &= ~ViewGroup.FLAG_INVALIDATE_REQUIRED;
                let more = false;
                let drawingTime = this.getDrawingTime();
                let customOrder = this.isChildrenDrawingOrderEnabled();
                for (let i = 0; i < count; i++) {
                    let child = children[customOrder ? this.getChildDrawingOrder(count, i) : i];
                    if ((child.mViewFlags & view_4.View.VISIBILITY_MASK) == view_4.View.VISIBLE) {
                        more = this.drawChild(canvas, child, drawingTime) || more;
                    }
                }
                if (clipToPadding) {
                    canvas.restoreToCount(saveCount);
                }
                flags = this.mGroupFlags;
                if ((flags & ViewGroup.FLAG_INVALIDATE_REQUIRED) == ViewGroup.FLAG_INVALIDATE_REQUIRED) {
                    this.invalidate(true);
                }
            }
            drawChild(canvas, child, drawingTime) {
                return child.drawFromParent(canvas, this, drawingTime);
            }
            drawableStateChanged() {
                super.drawableStateChanged();
                if ((this.mGroupFlags & ViewGroup.FLAG_NOTIFY_CHILDREN_ON_DRAWABLE_STATE_CHANGE) != 0) {
                    if ((this.mGroupFlags & ViewGroup.FLAG_ADD_STATES_FROM_CHILDREN) != 0) {
                        throw new Error("addStateFromChildren cannot be enabled if a"
                            + " child has duplicateParentState set to true");
                    }
                    const children = this.mChildren;
                    const count = this.mChildrenCount;
                    for (let i = 0; i < count; i++) {
                        const child = children[i];
                        if ((child.mViewFlags & view_4.View.DUPLICATE_PARENT_STATE) != 0) {
                            child.refreshDrawableState();
                        }
                    }
                }
            }
            jumpDrawablesToCurrentState() {
                super.jumpDrawablesToCurrentState();
                const children = this.mChildren;
                const count = this.mChildrenCount;
                for (let i = 0; i < count; i++) {
                    children[i].jumpDrawablesToCurrentState();
                }
            }
            onCreateDrawableState(extraSpace) {
                if ((this.mGroupFlags & ViewGroup.FLAG_ADD_STATES_FROM_CHILDREN) == 0) {
                    return super.onCreateDrawableState(extraSpace);
                }
                let need = 0;
                let n = this.getChildCount();
                for (let i = 0; i < n; i++) {
                    let childState = this.getChildAt(i).getDrawableState();
                    if (childState != null) {
                        need += childState.length;
                    }
                }
                let state = super.onCreateDrawableState(extraSpace + need);
                for (let i = 0; i < n; i++) {
                    let childState = this.getChildAt(i).getDrawableState();
                    if (childState != null) {
                        state = view_4.View.mergeDrawableStates(state, childState);
                    }
                }
                return state;
            }
            setAddStatesFromChildren(addsStates) {
                if (addsStates) {
                    this.mGroupFlags |= ViewGroup.FLAG_ADD_STATES_FROM_CHILDREN;
                }
                else {
                    this.mGroupFlags &= ~ViewGroup.FLAG_ADD_STATES_FROM_CHILDREN;
                }
                this.refreshDrawableState();
            }
            addStatesFromChildren() {
                return (this.mGroupFlags & ViewGroup.FLAG_ADD_STATES_FROM_CHILDREN) != 0;
            }
            childDrawableStateChanged(child) {
                if ((this.mGroupFlags & ViewGroup.FLAG_ADD_STATES_FROM_CHILDREN) != 0) {
                    this.refreshDrawableState();
                }
            }
            getClipChildren() {
                return ((this.mGroupFlags & ViewGroup.FLAG_CLIP_CHILDREN) != 0);
            }
            setClipChildren(clipChildren) {
                let previousValue = (this.mGroupFlags & ViewGroup.FLAG_CLIP_CHILDREN) == ViewGroup.FLAG_CLIP_CHILDREN;
                if (clipChildren != previousValue) {
                    this.setBooleanFlag(ViewGroup.FLAG_CLIP_CHILDREN, clipChildren);
                }
            }
            setClipToPadding(clipToPadding) {
                this.setBooleanFlag(ViewGroup.FLAG_CLIP_TO_PADDING, clipToPadding);
            }
            isClipToPadding() {
                return (this.mGroupFlags & ViewGroup.FLAG_CLIP_TO_PADDING) == ViewGroup.FLAG_CLIP_TO_PADDING;
            }
            invalidateChild(child, dirty) {
                let parent = this;
                const attachInfo = this.mAttachInfo;
                if (attachInfo != null) {
                    const drawAnimation = (child.mPrivateFlags & view_4.View.PFLAG_DRAW_ANIMATION)
                        == view_4.View.PFLAG_DRAW_ANIMATION;
                    let childMatrix = child.getMatrix();
                    const isOpaque = child.isOpaque() && !drawAnimation &&
                        child.getAnimation() == null && childMatrix.isIdentity();
                    let opaqueFlag = isOpaque ? view_4.View.PFLAG_DIRTY_OPAQUE : view_4.View.PFLAG_DIRTY;
                    if (child.mLayerType != view_4.View.LAYER_TYPE_NONE) {
                        this.mPrivateFlags |= view_4.View.PFLAG_INVALIDATED;
                        this.mPrivateFlags &= ~view_4.View.PFLAG_DRAWING_CACHE_VALID;
                    }
                    const location = attachInfo.mInvalidateChildLocation;
                    location[0] = child.mLeft;
                    location[1] = child.mTop;
                    do {
                        let view = null;
                        if (parent instanceof view_4.View) {
                            view = parent;
                        }
                        if (view != null) {
                            opaqueFlag = view_4.View.PFLAG_DIRTY;
                            if ((view.mPrivateFlags & view_4.View.PFLAG_DIRTY_MASK) != view_4.View.PFLAG_DIRTY) {
                                view.mPrivateFlags = (view.mPrivateFlags & ~view_4.View.PFLAG_DIRTY_MASK) | opaqueFlag;
                            }
                        }
                        parent = parent.invalidateChildInParent(location, dirty);
                        if (view != null) {
                            let m = view.getMatrix();
                            if (!m.isIdentity()) {
                                let boundingRect = attachInfo.mTmpTransformRect;
                                boundingRect.set(dirty);
                                m.mapRect(boundingRect);
                                dirty.set(boundingRect);
                            }
                        }
                    } while (parent != null);
                }
            }
            invalidateChildInParent(location, dirty) {
                if ((this.mPrivateFlags & view_4.View.PFLAG_DRAWN) == view_4.View.PFLAG_DRAWN ||
                    (this.mPrivateFlags & view_4.View.PFLAG_DRAWING_CACHE_VALID) == view_4.View.PFLAG_DRAWING_CACHE_VALID) {
                    if ((this.mGroupFlags & (ViewGroup.FLAG_OPTIMIZE_INVALIDATE | ViewGroup.FLAG_ANIMATION_DONE)) !=
                        ViewGroup.FLAG_OPTIMIZE_INVALIDATE) {
                        dirty.offset(location[0] - this.mScrollX, location[1] - this.mScrollY);
                        if ((this.mGroupFlags & ViewGroup.FLAG_CLIP_CHILDREN) == 0) {
                            dirty.union(0, 0, this.mRight - this.mLeft, this.mBottom - this.mTop);
                        }
                        const left = this.mLeft;
                        const top = this.mTop;
                        if ((this.mGroupFlags & ViewGroup.FLAG_CLIP_CHILDREN) == ViewGroup.FLAG_CLIP_CHILDREN) {
                            if (!dirty.intersect(0, 0, this.mRight - left, this.mBottom - top)) {
                                dirty.setEmpty();
                            }
                        }
                        this.mPrivateFlags &= ~view_4.View.PFLAG_DRAWING_CACHE_VALID;
                        location[0] = left;
                        location[1] = top;
                        if (this.mLayerType != view_4.View.LAYER_TYPE_NONE) {
                            this.mPrivateFlags |= view_4.View.PFLAG_INVALIDATED;
                        }
                        return this.mParent;
                    }
                    else {
                        this.mPrivateFlags &= ~view_4.View.PFLAG_DRAWN & ~view_4.View.PFLAG_DRAWING_CACHE_VALID;
                        location[0] = this.mLeft;
                        location[1] = this.mTop;
                        if ((this.mGroupFlags & ViewGroup.FLAG_CLIP_CHILDREN) == ViewGroup.FLAG_CLIP_CHILDREN) {
                            dirty.set(0, 0, this.mRight - this.mLeft, this.mBottom - this.mTop);
                        }
                        else {
                            dirty.union(0, 0, this.mRight - this.mLeft, this.mBottom - this.mTop);
                        }
                        if (this.mLayerType != view_4.View.LAYER_TYPE_NONE) {
                            this.mPrivateFlags |= view_4.View.PFLAG_INVALIDATED;
                        }
                        return this.mParent;
                    }
                }
                return null;
            }
            invalidateChildFast(child, dirty) {
                let parent = this;
                const attachInfo = this.mAttachInfo;
                if (attachInfo != null) {
                    let left = child.mLeft;
                    let top = child.mTop;
                    if (!child.getMatrix().isIdentity()) {
                        child.transformRect(dirty);
                    }
                    do {
                        if (parent instanceof ViewGroup) {
                            let parentVG = parent;
                            if (parentVG.mLayerType != view_4.View.LAYER_TYPE_NONE) {
                                parentVG.invalidate();
                                parent = null;
                            }
                            else {
                                parent = parentVG.invalidateChildInParentFast(left, top, dirty);
                                left = parentVG.mLeft;
                                top = parentVG.mTop;
                            }
                        }
                        else {
                            const location = attachInfo.mInvalidateChildLocation;
                            location[0] = left;
                            location[1] = top;
                            parent = parent.invalidateChildInParent(location, dirty);
                        }
                    } while (parent != null);
                }
            }
            invalidateChildInParentFast(left, top, dirty) {
                if ((this.mPrivateFlags & view_4.View.PFLAG_DRAWN) == view_4.View.PFLAG_DRAWN ||
                    (this.mPrivateFlags & view_4.View.PFLAG_DRAWING_CACHE_VALID) == view_4.View.PFLAG_DRAWING_CACHE_VALID) {
                    dirty.offset(left - this.mScrollX, top - this.mScrollY);
                    if ((this.mGroupFlags & ViewGroup.FLAG_CLIP_CHILDREN) == 0) {
                        dirty.union(0, 0, this.mRight - this.mLeft, this.mBottom - this.mTop);
                    }
                    if ((this.mGroupFlags & ViewGroup.FLAG_CLIP_CHILDREN) == 0 ||
                        dirty.intersect(0, 0, this.mRight - this.mLeft, this.mBottom - this.mTop)) {
                        if (this.mLayerType != view_4.View.LAYER_TYPE_NONE) {
                        }
                        if (!this.getMatrix().isIdentity()) {
                            this.transformRect(dirty);
                        }
                        return this.mParent;
                    }
                }
                return null;
            }
            findViewByPredicateTraversal(predicate, childToSkip) {
                if (predicate.apply(this)) {
                    return this;
                }
                const where = this.mChildren;
                const len = this.mChildrenCount;
                for (let i = 0; i < len; i++) {
                    let v = where[i];
                    if (v != childToSkip && (v.mPrivateFlags & view_4.View.PFLAG_IS_ROOT_NAMESPACE) == 0) {
                        v = v.findViewByPredicate(predicate);
                        if (v != null) {
                            return v;
                        }
                    }
                }
                return null;
            }
            requestDisallowInterceptTouchEvent(disallowIntercept) {
                if (disallowIntercept == ((this.mGroupFlags & ViewGroup.FLAG_DISALLOW_INTERCEPT) != 0)) {
                    return;
                }
                if (disallowIntercept) {
                    this.mGroupFlags |= ViewGroup.FLAG_DISALLOW_INTERCEPT;
                }
                else {
                    this.mGroupFlags &= ~ViewGroup.FLAG_DISALLOW_INTERCEPT;
                }
                if (this.mParent != null) {
                    this.mParent.requestDisallowInterceptTouchEvent(disallowIntercept);
                }
            }
            shouldDelayChildPressedState() {
                return true;
            }
            onSetLayoutParams(child, layoutParams) {
            }
        }
        ViewGroup.FLAG_CLIP_CHILDREN = 0x1;
        ViewGroup.FLAG_CLIP_TO_PADDING = 0x2;
        ViewGroup.FLAG_INVALIDATE_REQUIRED = 0x4;
        ViewGroup.FLAG_RUN_ANIMATION = 0x8;
        ViewGroup.FLAG_ANIMATION_DONE = 0x10;
        ViewGroup.FLAG_PADDING_NOT_NULL = 0x20;
        ViewGroup.FLAG_ANIMATION_CACHE = 0x40;
        ViewGroup.FLAG_OPTIMIZE_INVALIDATE = 0x80;
        ViewGroup.FLAG_CLEAR_TRANSFORMATION = 0x100;
        ViewGroup.FLAG_NOTIFY_ANIMATION_LISTENER = 0x200;
        ViewGroup.FLAG_USE_CHILD_DRAWING_ORDER = 0x400;
        ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS = 0x800;
        ViewGroup.FLAG_ALPHA_LOWER_THAN_ONE = 0x1000;
        ViewGroup.FLAG_ADD_STATES_FROM_CHILDREN = 0x2000;
        ViewGroup.FLAG_ALWAYS_DRAWN_WITH_CACHE = 0x4000;
        ViewGroup.FLAG_CHILDREN_DRAWN_WITH_CACHE = 0x8000;
        ViewGroup.FLAG_NOTIFY_CHILDREN_ON_DRAWABLE_STATE_CHANGE = 0x10000;
        ViewGroup.FLAG_MASK_FOCUSABILITY = 0x60000;
        ViewGroup.FOCUS_BEFORE_DESCENDANTS = 0x20000;
        ViewGroup.FOCUS_AFTER_DESCENDANTS = 0x40000;
        ViewGroup.FOCUS_BLOCK_DESCENDANTS = 0x60000;
        ViewGroup.FLAG_DISALLOW_INTERCEPT = 0x80000;
        ViewGroup.FLAG_SPLIT_MOTION_EVENTS = 0x200000;
        ViewGroup.FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW = 0x400000;
        ViewGroup.FLAG_LAYOUT_MODE_WAS_EXPLICITLY_SET = 0x800000;
        ViewGroup.PERSISTENT_NO_CACHE = 0x0;
        ViewGroup.PERSISTENT_ANIMATION_CACHE = 0x1;
        ViewGroup.PERSISTENT_SCROLLING_CACHE = 0x2;
        ViewGroup.PERSISTENT_ALL_CACHES = 0x3;
        ViewGroup.LAYOUT_MODE_UNDEFINED = -1;
        ViewGroup.LAYOUT_MODE_CLIP_BOUNDS = 0;
        ViewGroup.LAYOUT_MODE_DEFAULT = ViewGroup.LAYOUT_MODE_CLIP_BOUNDS;
        ViewGroup.CLIP_TO_PADDING_MASK = ViewGroup.FLAG_CLIP_TO_PADDING | ViewGroup.FLAG_PADDING_NOT_NULL;
        view_4.ViewGroup = ViewGroup;
        (function (ViewGroup) {
            class LayoutParams {
                constructor(...args) {
                    this._width = 0;
                    this._height = 0;
                    this._measuringParentWidthMeasureSpec = 0;
                    this._measuringParentHeightMeasureSpec = 0;
                    if (args.length === 1) {
                        let src = args[0];
                        this.width = src._width;
                        this.height = src._height;
                    }
                    else if (args.length === 2) {
                        let [width = 0, height = 0] = args;
                        this.width = width;
                        this.height = height;
                    }
                    if (!this._attrChangeHandler) {
                        this._attrChangeHandler = new view_4.View.AttrChangeHandler(null);
                        this._createAttrChangeHandler(this._attrChangeHandler);
                        if (!this._attrChangeHandler.isCallSuper) {
                            throw Error('must call super when override createAttrChangeHandler!');
                        }
                    }
                }
                get width() {
                    if (typeof this._width === 'number')
                        return this._width;
                    let up = (this._width + "").toUpperCase();
                    if (up === 'FILL_PARENT' || up === 'MATCH_PARENT')
                        this._width = -1;
                    else if (up === 'WRAP_CONTENT')
                        this._width = -2;
                    else {
                        let parentWidth = view_4.View.MeasureSpec.getSize(this._measuringParentWidthMeasureSpec);
                        try {
                            this._width = TypedValue.complexToDimensionPixelSize(this._width, parentWidth, this._measuringMeasureSpec);
                        }
                        catch (e) {
                            console.error(e);
                            this._width = -2;
                        }
                    }
                    return this._width;
                }
                set width(value) {
                    this._width = this._widthOrig = value;
                }
                get height() {
                    if (typeof this._height === 'number')
                        return this._height;
                    let up = (this._height + "").toUpperCase();
                    if (up === 'FILL_PARENT' || up === 'MATCH_PARENT')
                        this._height = -1;
                    else if (up === 'WRAP_CONTENT')
                        this._height = -2;
                    else {
                        let parentHeight = view_4.View.MeasureSpec.getSize(this._measuringParentHeightMeasureSpec);
                        try {
                            this._height = TypedValue.complexToDimensionPixelSize(this._height, parentHeight, this._measuringMeasureSpec);
                        }
                        catch (e) {
                            console.error(e);
                            this._height = -2;
                        }
                    }
                    return this._height;
                }
                set height(value) {
                    this._height = this._heightOrig = value;
                }
                _createAttrChangeHandler(mergeHandler) {
                    let params = this;
                    mergeHandler.add({
                        set width(value) {
                            if (value == null)
                                value = -2;
                            params.width = value;
                        },
                        get width() {
                            return params._widthOrig;
                        },
                        set height(value) {
                            if (value == null)
                                value = -2;
                            params.height = value;
                        },
                        get height() {
                            return params._heightOrig;
                        }
                    });
                    mergeHandler.isCallSuper = true;
                }
            }
            LayoutParams.FILL_PARENT = -1;
            LayoutParams.MATCH_PARENT = -1;
            LayoutParams.WRAP_CONTENT = -2;
            ViewGroup.LayoutParams = LayoutParams;
            class MarginLayoutParams extends LayoutParams {
                constructor(...args) {
                    super();
                    this._leftMargin = 0;
                    this._topMargin = 0;
                    this._rightMargin = 0;
                    this._bottomMargin = 0;
                    this._leftMarginOrig = 0;
                    this._topMarginOrig = 0;
                    this._rightMarginOrig = 0;
                    this._bottomMarginOrig = 0;
                    if (args.length === 1) {
                        let src = args[0];
                        if (src instanceof MarginLayoutParams) {
                            super(src);
                            this.leftMargin = src._leftMargin;
                            this.topMargin = src._topMargin;
                            this.rightMargin = src._rightMargin;
                            this.bottomMargin = src._bottomMargin;
                        }
                    }
                    else if (args.length == 2) {
                        super(args[0], args[1]);
                    }
                }
                get leftMargin() {
                    if (typeof this._leftMargin === 'number')
                        return this._leftMargin;
                    let parentWidth = view_4.View.MeasureSpec.getSize(this._measuringParentWidthMeasureSpec);
                    try {
                        this._leftMargin = TypedValue.complexToDimensionPixelSize(this._leftMargin, parentWidth, this._measuringMeasureSpec);
                    }
                    catch (e) {
                        console.warn(e);
                        this._leftMargin = 0;
                    }
                    return this._leftMargin;
                }
                get topMargin() {
                    if (typeof this._topMargin === 'number')
                        return this._topMargin;
                    let parentWidth = view_4.View.MeasureSpec.getSize(this._measuringParentWidthMeasureSpec);
                    try {
                        this._topMargin = TypedValue.complexToDimensionPixelSize(this._topMargin, parentWidth, this._measuringMeasureSpec);
                    }
                    catch (e) {
                        console.warn(e);
                        this._topMargin = 0;
                    }
                    return this._topMargin;
                }
                get rightMargin() {
                    if (typeof this._rightMargin === 'number')
                        return this._rightMargin;
                    let parentWidth = view_4.View.MeasureSpec.getSize(this._measuringParentWidthMeasureSpec);
                    try {
                        this._rightMargin = TypedValue.complexToDimensionPixelSize(this._rightMargin, parentWidth, this._measuringMeasureSpec);
                    }
                    catch (e) {
                        console.warn(e);
                        this._rightMargin = 0;
                    }
                    return this._rightMargin;
                }
                get bottomMargin() {
                    if (typeof this._bottomMargin === 'number')
                        return this._bottomMargin;
                    let parentWidth = view_4.View.MeasureSpec.getSize(this._measuringParentWidthMeasureSpec);
                    try {
                        this._bottomMargin = TypedValue.complexToDimensionPixelSize(this._bottomMargin, parentWidth, this._measuringMeasureSpec);
                    }
                    catch (e) {
                        console.warn(e);
                        this._bottomMargin = 0;
                    }
                    return this._bottomMargin;
                }
                set leftMargin(value) {
                    this._leftMargin = this._leftMarginOrig = value;
                }
                set topMargin(value) {
                    this._topMargin = this._topMarginOrig = value;
                }
                set rightMargin(value) {
                    this._rightMargin = this._rightMarginOrig = value;
                }
                set bottomMargin(value) {
                    this._bottomMargin = this._bottomMarginOrig = value;
                }
                setMargins(left, top, right, bottom) {
                    this.leftMargin = left;
                    this.topMargin = top;
                    this.rightMargin = right;
                    this.bottomMargin = bottom;
                }
                _createAttrChangeHandler(mergeHandler) {
                    super._createAttrChangeHandler(mergeHandler);
                    let params = this;
                    mergeHandler.add({
                        set marginLeft(value) {
                            if (value == null)
                                value = 0;
                            params.leftMargin = value;
                        },
                        set marginTop(value) {
                            if (value == null)
                                value = 0;
                            params.topMargin = value;
                        },
                        set marginRight(value) {
                            if (value == null)
                                value = 0;
                            params.rightMargin = value;
                        },
                        set marginBottom(value) {
                            if (value == null)
                                value = 0;
                            params.bottomMargin = value;
                        },
                        set margin(value) {
                            if (value == null)
                                value = 0;
                            let [left, top, right, bottom] = view_4.View.AttrChangeHandler.parsePaddingMarginLTRB(value);
                            params.leftMargin = left;
                            params.topMargin = top;
                            params.rightMargin = right;
                            params.bottomMargin = bottom;
                        },
                    });
                }
            }
            ViewGroup.MarginLayoutParams = MarginLayoutParams;
        })(ViewGroup = view_4.ViewGroup || (view_4.ViewGroup = {}));
        class TouchTarget {
            static obtain(child, pointerIdBits) {
                let target;
                if (TouchTarget.sRecycleBin == null) {
                    target = new TouchTarget();
                }
                else {
                    target = TouchTarget.sRecycleBin;
                    TouchTarget.sRecycleBin = target.next;
                    TouchTarget.sRecycledCount--;
                    target.next = null;
                }
                target.child = child;
                target.pointerIdBits = pointerIdBits;
                return target;
            }
            recycle() {
                if (TouchTarget.sRecycledCount < TouchTarget.MAX_RECYCLED) {
                    this.next = TouchTarget.sRecycleBin;
                    TouchTarget.sRecycleBin = this;
                    TouchTarget.sRecycledCount += 1;
                }
                else {
                    this.next = null;
                }
                this.child = null;
            }
        }
        TouchTarget.MAX_RECYCLED = 32;
        TouchTarget.sRecycledCount = 0;
        TouchTarget.ALL_POINTER_IDS = -1;
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/6.
 */
///<reference path="ViewGroup.ts"/>
///<reference path="ViewRootImpl.ts"/>
///<reference path="View.ts"/>
///<reference path="../graphics/drawable/Drawable.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var Drawable = android.graphics.drawable.Drawable;
        class ViewOverlay {
            constructor(hostView) {
                this.mOverlayViewGroup = new ViewOverlay.OverlayViewGroup(hostView);
            }
            getOverlayView() {
                return this.mOverlayViewGroup;
            }
            add(drawable) {
                this.mOverlayViewGroup.add(drawable);
            }
            remove(drawable) {
            }
            clear() {
                this.mOverlayViewGroup.clear();
            }
            isEmpty() {
                return this.mOverlayViewGroup.isEmpty();
            }
        }
        view.ViewOverlay = ViewOverlay;
        (function (ViewOverlay) {
            class OverlayViewGroup extends view.ViewGroup {
                constructor(hostView) {
                    super();
                    this.mHostView = hostView;
                    this.mAttachInfo = hostView.mAttachInfo;
                    this.mRight = hostView.getWidth();
                    this.mBottom = hostView.getHeight();
                }
                addDrawable(drawable) {
                }
                addView(child) {
                }
                add(arg) {
                    if (arg instanceof Drawable)
                        this.addDrawable(arg);
                    else if (arg instanceof view.View)
                        this.addView(arg);
                }
                clear() {
                }
                isEmpty() {
                    return true;
                }
                onLayout(changed, l, t, r, b) {
                }
            }
            ViewOverlay.OverlayViewGroup = OverlayViewGroup;
        })(ViewOverlay = view.ViewOverlay || (view.ViewOverlay = {}));
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/17.
 */
///<reference path="../util/Log.ts"/>
///<reference path="../util/Pools.ts"/>
///<reference path="MotionEvent.ts"/>
///<reference path="KeyEvent.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var Log = android.util.Log;
        var Pools = android.util.Pools;
        class VelocityTracker {
            constructor() {
                this.mLastTouchIndex = 0;
                this.mGeneration = 0;
                this.clear();
            }
            static obtain() {
                let instance = VelocityTracker.sPool.acquire();
                return (instance != null) ? instance : new VelocityTracker();
            }
            recycle() {
                this.clear();
                VelocityTracker.sPool.release(this);
            }
            setNextPoolable(element) {
                this.mNext = element;
            }
            getNextPoolable() {
                return this.mNext;
            }
            clear() {
                VelocityTracker.releasePointerList(this.mPointerListHead);
                this.mPointerListHead = null;
                this.mLastTouchIndex = 0;
            }
            addMovement(ev) {
                let historySize = ev.getHistorySize();
                const pointerCount = ev.getPointerCount();
                const lastTouchIndex = this.mLastTouchIndex;
                const nextTouchIndex = (lastTouchIndex + 1) % VelocityTracker.NUM_PAST;
                const finalTouchIndex = (nextTouchIndex + historySize) % VelocityTracker.NUM_PAST;
                const generation = this.mGeneration++;
                this.mLastTouchIndex = finalTouchIndex;
                let previousPointer = null;
                for (let i = 0; i < pointerCount; i++) {
                    const pointerId = ev.getPointerId(i);
                    let nextPointer;
                    if (previousPointer == null || pointerId < previousPointer.id) {
                        previousPointer = null;
                        nextPointer = this.mPointerListHead;
                    }
                    else {
                        nextPointer = previousPointer.next;
                    }
                    let pointer;
                    for (;;) {
                        if (nextPointer != null) {
                            const nextPointerId = nextPointer.id;
                            if (nextPointerId == pointerId) {
                                pointer = nextPointer;
                                break;
                            }
                            if (nextPointerId < pointerId) {
                                nextPointer = nextPointer.next;
                                continue;
                            }
                        }
                        pointer = VelocityTracker.obtainPointer();
                        pointer.id = pointerId;
                        pointer.pastTime[lastTouchIndex] = Number.MIN_VALUE;
                        pointer.next = nextPointer;
                        if (previousPointer == null) {
                            this.mPointerListHead = pointer;
                        }
                        else {
                            previousPointer.next = pointer;
                        }
                        break;
                    }
                    pointer.generation = generation;
                    previousPointer = pointer;
                    const pastX = pointer.pastX;
                    const pastY = pointer.pastY;
                    const pastTime = pointer.pastTime;
                    historySize = ev.getHistorySize(pointerId);
                    for (let j = 0; j < historySize; j++) {
                        const touchIndex = (nextTouchIndex + j) % VelocityTracker.NUM_PAST;
                        pastX[touchIndex] = ev.getHistoricalX(i, j);
                        pastY[touchIndex] = ev.getHistoricalY(i, j);
                        pastTime[touchIndex] = ev.getHistoricalEventTime(i, j);
                    }
                    pastX[finalTouchIndex] = ev.getX(i);
                    pastY[finalTouchIndex] = ev.getY(i);
                    pastTime[finalTouchIndex] = ev.getEventTime();
                }
                previousPointer = null;
                for (let pointer = this.mPointerListHead; pointer != null;) {
                    const nextPointer = pointer.next;
                    if (pointer.generation != generation) {
                        if (previousPointer == null) {
                            this.mPointerListHead = nextPointer;
                        }
                        else {
                            previousPointer.next = nextPointer;
                        }
                        VelocityTracker.releasePointer(pointer);
                    }
                    else {
                        previousPointer = pointer;
                    }
                    pointer = nextPointer;
                }
            }
            computeCurrentVelocity(units, maxVelocity = Number.MAX_SAFE_INTEGER) {
                const lastTouchIndex = this.mLastTouchIndex;
                for (let pointer = this.mPointerListHead; pointer != null; pointer = pointer.next) {
                    const pastTime = pointer.pastTime;
                    let oldestTouchIndex = lastTouchIndex;
                    let numTouches = 1;
                    const minTime = pastTime[lastTouchIndex] - VelocityTracker.MAX_AGE_MILLISECONDS;
                    while (numTouches < VelocityTracker.NUM_PAST) {
                        const nextOldestTouchIndex = (oldestTouchIndex + VelocityTracker.NUM_PAST - 1) % VelocityTracker.NUM_PAST;
                        const nextOldestTime = pastTime[nextOldestTouchIndex];
                        if (nextOldestTime < minTime) {
                            break;
                        }
                        oldestTouchIndex = nextOldestTouchIndex;
                        numTouches += 1;
                    }
                    if (numTouches > 3) {
                        numTouches -= 1;
                    }
                    const pastX = pointer.pastX;
                    const pastY = pointer.pastY;
                    const oldestX = pastX[oldestTouchIndex];
                    const oldestY = pastY[oldestTouchIndex];
                    const oldestTime = pastTime[oldestTouchIndex];
                    let accumX = 0;
                    let accumY = 0;
                    for (let i = 1; i < numTouches; i++) {
                        const touchIndex = (oldestTouchIndex + i) % VelocityTracker.NUM_PAST;
                        const duration = (pastTime[touchIndex] - oldestTime);
                        if (duration == 0)
                            continue;
                        let delta = pastX[touchIndex] - oldestX;
                        let velocity = (delta / duration) * units;
                        accumX = (accumX == 0) ? velocity : (accumX + velocity) * .5;
                        delta = pastY[touchIndex] - oldestY;
                        velocity = (delta / duration) * units;
                        accumY = (accumY == 0) ? velocity : (accumY + velocity) * .5;
                    }
                    if (accumX < -maxVelocity) {
                        accumX = -maxVelocity;
                    }
                    else if (accumX > maxVelocity) {
                        accumX = maxVelocity;
                    }
                    if (accumY < -maxVelocity) {
                        accumY = -maxVelocity;
                    }
                    else if (accumY > maxVelocity) {
                        accumY = maxVelocity;
                    }
                    pointer.xVelocity = accumX;
                    pointer.yVelocity = accumY;
                    if (VelocityTracker.localLOGV) {
                        Log.v(VelocityTracker.TAG, "Pointer " + pointer.id
                            + ": Y velocity=" + accumX + " X velocity=" + accumY + " N=" + numTouches);
                    }
                }
            }
            getXVelocity(id = 0) {
                let pointer = this.getPointer(id);
                return pointer != null ? pointer.xVelocity : 0;
            }
            getYVelocity(id = 0) {
                let pointer = this.getPointer(id);
                return pointer != null ? pointer.yVelocity : 0;
            }
            getPointer(id) {
                for (let pointer = this.mPointerListHead; pointer != null; pointer = pointer.next) {
                    if (pointer.id == id) {
                        return pointer;
                    }
                }
                return null;
            }
            static obtainPointer() {
                if (VelocityTracker.sRecycledPointerCount != 0) {
                    let element = VelocityTracker.sRecycledPointerListHead;
                    VelocityTracker.sRecycledPointerCount -= 1;
                    VelocityTracker.sRecycledPointerListHead = element.next;
                    element.next = null;
                    return element;
                }
                return new Pointer();
            }
            static releasePointer(pointer) {
                if (VelocityTracker.sRecycledPointerCount < VelocityTracker.POINTER_POOL_CAPACITY) {
                    pointer.next = VelocityTracker.sRecycledPointerListHead;
                    VelocityTracker.sRecycledPointerCount += 1;
                    VelocityTracker.sRecycledPointerListHead = pointer;
                }
            }
            static releasePointerList(pointer) {
                if (pointer != null) {
                    let count = VelocityTracker.sRecycledPointerCount;
                    if (count >= VelocityTracker.POINTER_POOL_CAPACITY) {
                        return;
                    }
                    let tail = pointer;
                    for (;;) {
                        count += 1;
                        if (count >= VelocityTracker.POINTER_POOL_CAPACITY) {
                            break;
                        }
                        let next = tail.next;
                        if (next == null) {
                            break;
                        }
                        tail = next;
                    }
                    tail.next = VelocityTracker.sRecycledPointerListHead;
                    VelocityTracker.sRecycledPointerCount = count;
                    VelocityTracker.sRecycledPointerListHead = pointer;
                }
            }
        }
        VelocityTracker.TAG = "VelocityTracker";
        VelocityTracker.DEBUG = Log.VelocityTracker_DBG;
        VelocityTracker.localLOGV = VelocityTracker.DEBUG;
        VelocityTracker.NUM_PAST = 10;
        VelocityTracker.MAX_AGE_MILLISECONDS = 200;
        VelocityTracker.POINTER_POOL_CAPACITY = 20;
        VelocityTracker.sPool = new Pools.SynchronizedPool(2);
        VelocityTracker.sRecycledPointerCount = 0;
        view.VelocityTracker = VelocityTracker;
        class Pointer {
            constructor() {
                this.id = 0;
                this.xVelocity = 0;
                this.yVelocity = 0;
                this.pastX = new Array(VelocityTracker.NUM_PAST);
                this.pastY = new Array(VelocityTracker.NUM_PAST);
                this.pastTime = new Array(VelocityTracker.NUM_PAST);
                this.generation = 0;
            }
        }
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/os/Handler.ts"/>
///<reference path="../../android/os/Message.ts"/>
///<reference path="../../android/view/MotionEvent.ts"/>
///<reference path="../../android/view/VelocityTracker.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewConfiguration.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        var Handler = android.os.Handler;
        var MotionEvent = android.view.MotionEvent;
        var VelocityTracker = android.view.VelocityTracker;
        var ViewConfiguration = android.view.ViewConfiguration;
        class GestureDetector {
            constructor(listener, handler) {
                this.mTouchSlopSquare = 0;
                this.mDoubleTapTouchSlopSquare = 0;
                this.mDoubleTapSlopSquare = 0;
                this.mMinimumFlingVelocity = 0;
                this.mMaximumFlingVelocity = 0;
                this.mLastFocusX = 0;
                this.mLastFocusY = 0;
                this.mDownFocusX = 0;
                this.mDownFocusY = 0;
                this.mHandler = new GestureDetector.GestureHandler(this);
                this.mListener = listener;
                if (listener['setOnDoubleTapListener']) {
                    this.setOnDoubleTapListener(listener);
                }
                this.init();
            }
            init() {
                if (this.mListener == null) {
                    throw Error(`new NullPointerException("OnGestureListener must not be null")`);
                }
                this.mIsLongpressEnabled = true;
                let touchSlop, doubleTapSlop, doubleTapTouchSlop;
                const configuration = ViewConfiguration.get();
                touchSlop = configuration.getScaledTouchSlop();
                doubleTapTouchSlop = configuration.getScaledDoubleTapTouchSlop();
                doubleTapSlop = configuration.getScaledDoubleTapSlop();
                this.mMinimumFlingVelocity = configuration.getScaledMinimumFlingVelocity();
                this.mMaximumFlingVelocity = configuration.getScaledMaximumFlingVelocity();
                this.mTouchSlopSquare = touchSlop * touchSlop;
                this.mDoubleTapTouchSlopSquare = doubleTapTouchSlop * doubleTapTouchSlop;
                this.mDoubleTapSlopSquare = doubleTapSlop * doubleTapSlop;
            }
            setOnDoubleTapListener(onDoubleTapListener) {
                this.mDoubleTapListener = onDoubleTapListener;
            }
            setIsLongpressEnabled(isLongpressEnabled) {
                this.mIsLongpressEnabled = isLongpressEnabled;
            }
            isLongpressEnabled() {
                return this.mIsLongpressEnabled;
            }
            onTouchEvent(ev) {
                const action = ev.getAction();
                if (this.mVelocityTracker == null) {
                    this.mVelocityTracker = VelocityTracker.obtain();
                }
                this.mVelocityTracker.addMovement(ev);
                const pointerUp = (action & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP;
                const skipIndex = pointerUp ? ev.getActionIndex() : -1;
                let sumX = 0, sumY = 0;
                const count = ev.getPointerCount();
                for (let i = 0; i < count; i++) {
                    if (skipIndex == i)
                        continue;
                    sumX += ev.getX(i);
                    sumY += ev.getY(i);
                }
                const div = pointerUp ? count - 1 : count;
                const focusX = sumX / div;
                const focusY = sumY / div;
                let handled = false;
                switch (action & MotionEvent.ACTION_MASK) {
                    case MotionEvent.ACTION_POINTER_DOWN:
                        this.mDownFocusX = this.mLastFocusX = focusX;
                        this.mDownFocusY = this.mLastFocusY = focusY;
                        this.cancelTaps();
                        break;
                    case MotionEvent.ACTION_POINTER_UP:
                        this.mDownFocusX = this.mLastFocusX = focusX;
                        this.mDownFocusY = this.mLastFocusY = focusY;
                        this.mVelocityTracker.computeCurrentVelocity(1000, this.mMaximumFlingVelocity);
                        const upIndex = ev.getActionIndex();
                        const id1 = ev.getPointerId(upIndex);
                        const x1 = this.mVelocityTracker.getXVelocity(id1);
                        const y1 = this.mVelocityTracker.getYVelocity(id1);
                        for (let i = 0; i < count; i++) {
                            if (i == upIndex)
                                continue;
                            const id2 = ev.getPointerId(i);
                            const x = x1 * this.mVelocityTracker.getXVelocity(id2);
                            const y = y1 * this.mVelocityTracker.getYVelocity(id2);
                            const dot = x + y;
                            if (dot < 0) {
                                this.mVelocityTracker.clear();
                                break;
                            }
                        }
                        break;
                    case MotionEvent.ACTION_DOWN:
                        if (this.mDoubleTapListener != null) {
                            let hadTapMessage = this.mHandler.hasMessages(GestureDetector.TAP);
                            if (hadTapMessage)
                                this.mHandler.removeMessages(GestureDetector.TAP);
                            if ((this.mCurrentDownEvent != null) && (this.mPreviousUpEvent != null) && hadTapMessage && this.isConsideredDoubleTap(this.mCurrentDownEvent, this.mPreviousUpEvent, ev)) {
                                this.mIsDoubleTapping = true;
                                handled = this.mDoubleTapListener.onDoubleTap(this.mCurrentDownEvent) || handled;
                                handled = this.mDoubleTapListener.onDoubleTapEvent(ev) || handled;
                            }
                            else {
                                this.mHandler.sendEmptyMessageDelayed(GestureDetector.TAP, GestureDetector.DOUBLE_TAP_TIMEOUT);
                            }
                        }
                        this.mDownFocusX = this.mLastFocusX = focusX;
                        this.mDownFocusY = this.mLastFocusY = focusY;
                        if (this.mCurrentDownEvent != null) {
                            this.mCurrentDownEvent.recycle();
                        }
                        this.mCurrentDownEvent = MotionEvent.obtain(ev);
                        this.mAlwaysInTapRegion = true;
                        this.mAlwaysInBiggerTapRegion = true;
                        this.mStillDown = true;
                        this.mInLongPress = false;
                        this.mDeferConfirmSingleTap = false;
                        if (this.mIsLongpressEnabled) {
                            this.mHandler.removeMessages(GestureDetector.LONG_PRESS);
                            this.mHandler.sendEmptyMessageAtTime(GestureDetector.LONG_PRESS, this.mCurrentDownEvent.getDownTime() + GestureDetector.TAP_TIMEOUT + GestureDetector.LONGPRESS_TIMEOUT);
                        }
                        this.mHandler.sendEmptyMessageAtTime(GestureDetector.SHOW_PRESS, this.mCurrentDownEvent.getDownTime() + GestureDetector.TAP_TIMEOUT);
                        handled = this.mListener.onDown(ev) || handled;
                        break;
                    case MotionEvent.ACTION_MOVE:
                        if (this.mInLongPress) {
                            break;
                        }
                        const scrollX = this.mLastFocusX - focusX;
                        const scrollY = this.mLastFocusY - focusY;
                        if (this.mIsDoubleTapping) {
                            handled = this.mDoubleTapListener.onDoubleTapEvent(ev) || handled;
                        }
                        else if (this.mAlwaysInTapRegion) {
                            const deltaX = Math.floor((focusX - this.mDownFocusX));
                            const deltaY = Math.floor((focusY - this.mDownFocusY));
                            let distance = (deltaX * deltaX) + (deltaY * deltaY);
                            if (distance > this.mTouchSlopSquare) {
                                handled = this.mListener.onScroll(this.mCurrentDownEvent, ev, scrollX, scrollY);
                                this.mLastFocusX = focusX;
                                this.mLastFocusY = focusY;
                                this.mAlwaysInTapRegion = false;
                                this.mHandler.removeMessages(GestureDetector.TAP);
                                this.mHandler.removeMessages(GestureDetector.SHOW_PRESS);
                                this.mHandler.removeMessages(GestureDetector.LONG_PRESS);
                            }
                            if (distance > this.mDoubleTapTouchSlopSquare) {
                                this.mAlwaysInBiggerTapRegion = false;
                            }
                        }
                        else if ((Math.abs(scrollX) >= 1) || (Math.abs(scrollY) >= 1)) {
                            handled = this.mListener.onScroll(this.mCurrentDownEvent, ev, scrollX, scrollY);
                            this.mLastFocusX = focusX;
                            this.mLastFocusY = focusY;
                        }
                        break;
                    case MotionEvent.ACTION_UP:
                        this.mStillDown = false;
                        let currentUpEvent = MotionEvent.obtain(ev);
                        if (this.mIsDoubleTapping) {
                            handled = this.mDoubleTapListener.onDoubleTapEvent(ev) || handled;
                        }
                        else if (this.mInLongPress) {
                            this.mHandler.removeMessages(GestureDetector.TAP);
                            this.mInLongPress = false;
                        }
                        else if (this.mAlwaysInTapRegion) {
                            handled = this.mListener.onSingleTapUp(ev);
                            if (this.mDeferConfirmSingleTap && this.mDoubleTapListener != null) {
                                this.mDoubleTapListener.onSingleTapConfirmed(ev);
                            }
                        }
                        else {
                            const velocityTracker = this.mVelocityTracker;
                            const pointerId = ev.getPointerId(0);
                            velocityTracker.computeCurrentVelocity(1000, this.mMaximumFlingVelocity);
                            const velocityY = velocityTracker.getYVelocity(pointerId);
                            const velocityX = velocityTracker.getXVelocity(pointerId);
                            if ((Math.abs(velocityY) > this.mMinimumFlingVelocity) || (Math.abs(velocityX) > this.mMinimumFlingVelocity)) {
                                handled = this.mListener.onFling(this.mCurrentDownEvent, ev, velocityX, velocityY);
                            }
                        }
                        if (this.mPreviousUpEvent != null) {
                            this.mPreviousUpEvent.recycle();
                        }
                        this.mPreviousUpEvent = currentUpEvent;
                        if (this.mVelocityTracker != null) {
                            this.mVelocityTracker.recycle();
                            this.mVelocityTracker = null;
                        }
                        this.mIsDoubleTapping = false;
                        this.mDeferConfirmSingleTap = false;
                        this.mHandler.removeMessages(GestureDetector.SHOW_PRESS);
                        this.mHandler.removeMessages(GestureDetector.LONG_PRESS);
                        break;
                    case MotionEvent.ACTION_CANCEL:
                        this.cancel();
                        break;
                }
                return handled;
            }
            cancel() {
                this.mHandler.removeMessages(GestureDetector.SHOW_PRESS);
                this.mHandler.removeMessages(GestureDetector.LONG_PRESS);
                this.mHandler.removeMessages(GestureDetector.TAP);
                this.mVelocityTracker.recycle();
                this.mVelocityTracker = null;
                this.mIsDoubleTapping = false;
                this.mStillDown = false;
                this.mAlwaysInTapRegion = false;
                this.mAlwaysInBiggerTapRegion = false;
                this.mDeferConfirmSingleTap = false;
                if (this.mInLongPress) {
                    this.mInLongPress = false;
                }
            }
            cancelTaps() {
                this.mHandler.removeMessages(GestureDetector.SHOW_PRESS);
                this.mHandler.removeMessages(GestureDetector.LONG_PRESS);
                this.mHandler.removeMessages(GestureDetector.TAP);
                this.mIsDoubleTapping = false;
                this.mAlwaysInTapRegion = false;
                this.mAlwaysInBiggerTapRegion = false;
                this.mDeferConfirmSingleTap = false;
                if (this.mInLongPress) {
                    this.mInLongPress = false;
                }
            }
            isConsideredDoubleTap(firstDown, firstUp, secondDown) {
                if (!this.mAlwaysInBiggerTapRegion) {
                    return false;
                }
                const deltaTime = secondDown.getEventTime() - firstUp.getEventTime();
                if (deltaTime > GestureDetector.DOUBLE_TAP_TIMEOUT || deltaTime < GestureDetector.DOUBLE_TAP_MIN_TIME) {
                    return false;
                }
                let deltaX = Math.floor(firstDown.getX()) - Math.floor(secondDown.getX());
                let deltaY = Math.floor(firstDown.getY()) - Math.floor(secondDown.getY());
                return (deltaX * deltaX + deltaY * deltaY < this.mDoubleTapSlopSquare);
            }
            dispatchLongPress() {
                this.mHandler.removeMessages(GestureDetector.TAP);
                this.mDeferConfirmSingleTap = false;
                this.mInLongPress = true;
                this.mListener.onLongPress(this.mCurrentDownEvent);
            }
        }
        GestureDetector.LONGPRESS_TIMEOUT = ViewConfiguration.getLongPressTimeout();
        GestureDetector.TAP_TIMEOUT = ViewConfiguration.getTapTimeout();
        GestureDetector.DOUBLE_TAP_TIMEOUT = ViewConfiguration.getDoubleTapTimeout();
        GestureDetector.DOUBLE_TAP_MIN_TIME = ViewConfiguration.getDoubleTapMinTime();
        GestureDetector.SHOW_PRESS = 1;
        GestureDetector.LONG_PRESS = 2;
        GestureDetector.TAP = 3;
        view.GestureDetector = GestureDetector;
        (function (GestureDetector) {
            class SimpleOnGestureListener {
                onSingleTapUp(e) {
                    return false;
                }
                onLongPress(e) {
                }
                onScroll(e1, e2, distanceX, distanceY) {
                    return false;
                }
                onFling(e1, e2, velocityX, velocityY) {
                    return false;
                }
                onShowPress(e) {
                }
                onDown(e) {
                    return false;
                }
                onDoubleTap(e) {
                    return false;
                }
                onDoubleTapEvent(e) {
                    return false;
                }
                onSingleTapConfirmed(e) {
                    return false;
                }
            }
            GestureDetector.SimpleOnGestureListener = SimpleOnGestureListener;
            class GestureHandler extends Handler {
                constructor(arg) {
                    super();
                    this._GestureDetector_this = arg;
                }
                handleMessage(msg) {
                    switch (msg.what) {
                        case GestureDetector.SHOW_PRESS:
                            this._GestureDetector_this.mListener.onShowPress(this._GestureDetector_this.mCurrentDownEvent);
                            break;
                        case GestureDetector.LONG_PRESS:
                            this._GestureDetector_this.dispatchLongPress();
                            break;
                        case GestureDetector.TAP:
                            if (this._GestureDetector_this.mDoubleTapListener != null) {
                                if (!this._GestureDetector_this.mStillDown) {
                                    this._GestureDetector_this.mDoubleTapListener.onSingleTapConfirmed(this._GestureDetector_this.mCurrentDownEvent);
                                }
                                else {
                                    this._GestureDetector_this.mDeferConfirmSingleTap = true;
                                }
                            }
                            break;
                        default:
                            throw Error(`new RuntimeException("Unknown message " + msg)`);
                    }
                }
            }
            GestureDetector.GestureHandler = GestureHandler;
        })(GestureDetector = view.GestureDetector || (view.GestureDetector = {}));
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/9.
 */
///<reference path="../view/Gravity.ts"/>
///<reference path="../view/View.ts"/>
///<reference path="../view/ViewGroup.ts"/>
///<reference path="../graphics/drawable/Drawable.ts"/>
///<reference path="../graphics/Rect.ts"/>
///<reference path="../graphics/Canvas.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var Gravity = android.view.Gravity;
        var View = android.view.View;
        var ViewGroup = android.view.ViewGroup;
        var Rect = android.graphics.Rect;
        class FrameLayout extends ViewGroup {
            constructor(...args) {
                super(...args);
                this.mMeasureAllChildren = false;
                this.mForegroundPaddingLeft = 0;
                this.mForegroundPaddingTop = 0;
                this.mForegroundPaddingRight = 0;
                this.mForegroundPaddingBottom = 0;
                this.mSelfBounds = new Rect();
                this.mOverlayBounds = new Rect();
                this.mForegroundGravity = Gravity.FILL;
                this.mForegroundInPadding = true;
                this.mForegroundBoundsChanged = false;
                this.mMatchParentChildren = new Array(1);
            }
            createAttrChangeHandler(mergeHandler) {
                super.createAttrChangeHandler(mergeHandler);
                let frameLayout = this;
                mergeHandler.add({
                    set foregroundGravity(value) {
                        frameLayout.mForegroundGravity = View.AttrChangeHandler.parseGravity(value, frameLayout.mForegroundGravity);
                    },
                    get foregroundGravity() {
                        return frameLayout.mForegroundGravity;
                    }
                });
            }
            getForegroundGravity() {
                return this.mForegroundGravity;
            }
            setForegroundGravity(foregroundGravity) {
                if (this.mForegroundGravity != foregroundGravity) {
                    if ((foregroundGravity & Gravity.HORIZONTAL_GRAVITY_MASK) == 0) {
                        foregroundGravity |= Gravity.LEFT;
                    }
                    if ((foregroundGravity & Gravity.VERTICAL_GRAVITY_MASK) == 0) {
                        foregroundGravity |= Gravity.TOP;
                    }
                    this.mForegroundGravity = foregroundGravity;
                    if (this.mForegroundGravity == Gravity.FILL && this.mForeground != null) {
                        let padding = new Rect();
                        if (this.mForeground.getPadding(padding)) {
                            this.mForegroundPaddingLeft = padding.left;
                            this.mForegroundPaddingTop = padding.top;
                            this.mForegroundPaddingRight = padding.right;
                            this.mForegroundPaddingBottom = padding.bottom;
                        }
                    }
                    else {
                        this.mForegroundPaddingLeft = 0;
                        this.mForegroundPaddingTop = 0;
                        this.mForegroundPaddingRight = 0;
                        this.mForegroundPaddingBottom = 0;
                    }
                    this.requestLayout();
                }
            }
            verifyDrawable(who) {
                return super.verifyDrawable(who) || (who == this.mForeground);
            }
            jumpDrawablesToCurrentState() {
                super.jumpDrawablesToCurrentState();
                if (this.mForeground != null)
                    this.mForeground.jumpToCurrentState();
            }
            drawableStateChanged() {
                super.drawableStateChanged();
                if (this.mForeground != null && this.mForeground.isStateful()) {
                    this.mForeground.setState(this.getDrawableState());
                }
            }
            generateDefaultLayoutParams() {
                return new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT);
            }
            setForeground(drawable) {
            }
            getForeground() {
                return this.mForeground;
            }
            getPaddingLeftWithForeground() {
                return this.mForegroundInPadding ? Math.max(this.mPaddingLeft, this.mForegroundPaddingLeft) :
                    this.mPaddingLeft + this.mForegroundPaddingLeft;
            }
            getPaddingRightWithForeground() {
                return this.mForegroundInPadding ? Math.max(this.mPaddingRight, this.mForegroundPaddingRight) :
                    this.mPaddingRight + this.mForegroundPaddingRight;
            }
            getPaddingTopWithForeground() {
                return this.mForegroundInPadding ? Math.max(this.mPaddingTop, this.mForegroundPaddingTop) :
                    this.mPaddingTop + this.mForegroundPaddingTop;
            }
            getPaddingBottomWithForeground() {
                return this.mForegroundInPadding ? Math.max(this.mPaddingBottom, this.mForegroundPaddingBottom) :
                    this.mPaddingBottom + this.mForegroundPaddingBottom;
            }
            onMeasure(widthMeasureSpec, heightMeasureSpec) {
                let count = this.getChildCount();
                let measureMatchParentChildren = View.MeasureSpec.getMode(widthMeasureSpec) != View.MeasureSpec.EXACTLY ||
                    View.MeasureSpec.getMode(heightMeasureSpec) != View.MeasureSpec.EXACTLY;
                this.mMatchParentChildren = [];
                let maxHeight = 0;
                let maxWidth = 0;
                let childState = 0;
                for (let i = 0; i < count; i++) {
                    let child = this.getChildAt(i);
                    if (this.mMeasureAllChildren || child.getVisibility() != View.GONE) {
                        this.measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0);
                        let lp = child.getLayoutParams();
                        maxWidth = Math.max(maxWidth, child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
                        maxHeight = Math.max(maxHeight, child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
                        childState = View.combineMeasuredStates(childState, child.getMeasuredState());
                        if (measureMatchParentChildren) {
                            if (lp.width == FrameLayout.LayoutParams.MATCH_PARENT ||
                                lp.height == FrameLayout.LayoutParams.MATCH_PARENT) {
                                this.mMatchParentChildren.push(child);
                            }
                        }
                    }
                }
                maxWidth += this.getPaddingLeftWithForeground() + this.getPaddingRightWithForeground();
                maxHeight += this.getPaddingTopWithForeground() + this.getPaddingBottomWithForeground();
                maxHeight = Math.max(maxHeight, this.getSuggestedMinimumHeight());
                maxWidth = Math.max(maxWidth, this.getSuggestedMinimumWidth());
                let drawable = this.getForeground();
                if (drawable != null) {
                    maxHeight = Math.max(maxHeight, drawable.getMinimumHeight());
                    maxWidth = Math.max(maxWidth, drawable.getMinimumWidth());
                }
                this.setMeasuredDimension(View.resolveSizeAndState(maxWidth, widthMeasureSpec, childState), View.resolveSizeAndState(maxHeight, heightMeasureSpec, childState << View.MEASURED_HEIGHT_STATE_SHIFT));
                count = this.mMatchParentChildren.length;
                if (count > 1) {
                    for (let i = 0; i < count; i++) {
                        let child = this.mMatchParentChildren[i];
                        let lp = child.getLayoutParams();
                        let childWidthMeasureSpec;
                        let childHeightMeasureSpec;
                        if (lp.width == FrameLayout.LayoutParams.MATCH_PARENT) {
                            childWidthMeasureSpec = View.MeasureSpec.makeMeasureSpec(this.getMeasuredWidth() -
                                this.getPaddingLeftWithForeground() - this.getPaddingRightWithForeground() -
                                lp.leftMargin - lp.rightMargin, View.MeasureSpec.EXACTLY);
                        }
                        else {
                            childWidthMeasureSpec = ViewGroup.getChildMeasureSpec(widthMeasureSpec, this.getPaddingLeftWithForeground() + this.getPaddingRightWithForeground() +
                                lp.leftMargin + lp.rightMargin, lp.width);
                        }
                        if (lp.height == FrameLayout.LayoutParams.MATCH_PARENT) {
                            childHeightMeasureSpec = View.MeasureSpec.makeMeasureSpec(this.getMeasuredHeight() -
                                this.getPaddingTopWithForeground() - this.getPaddingBottomWithForeground() -
                                lp.topMargin - lp.bottomMargin, View.MeasureSpec.EXACTLY);
                        }
                        else {
                            childHeightMeasureSpec = ViewGroup.getChildMeasureSpec(heightMeasureSpec, this.getPaddingTopWithForeground() + this.getPaddingBottomWithForeground() +
                                lp.topMargin + lp.bottomMargin, lp.height);
                        }
                        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
                    }
                }
            }
            onLayout(changed, left, top, right, bottom) {
                this.layoutChildren(left, top, right, bottom, false);
            }
            layoutChildren(left, top, right, bottom, forceLeftGravity) {
                const count = this.getChildCount();
                const parentLeft = this.getPaddingLeftWithForeground();
                const parentRight = right - left - this.getPaddingRightWithForeground();
                const parentTop = this.getPaddingTopWithForeground();
                const parentBottom = bottom - top - this.getPaddingBottomWithForeground();
                this.mForegroundBoundsChanged = true;
                for (let i = 0; i < count; i++) {
                    let child = this.getChildAt(i);
                    if (child.getVisibility() != View.GONE) {
                        const lp = child.getLayoutParams();
                        const width = child.getMeasuredWidth();
                        const height = child.getMeasuredHeight();
                        let childLeft;
                        let childTop;
                        let gravity = lp.gravity;
                        if (gravity == -1) {
                            gravity = FrameLayout.DEFAULT_CHILD_GRAVITY;
                        }
                        const absoluteGravity = gravity;
                        const verticalGravity = gravity & Gravity.VERTICAL_GRAVITY_MASK;
                        switch (absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
                            case Gravity.CENTER_HORIZONTAL:
                                childLeft = parentLeft + (parentRight - parentLeft - width) / 2 +
                                    lp.leftMargin - lp.rightMargin;
                                break;
                            case Gravity.RIGHT:
                                if (!forceLeftGravity) {
                                    childLeft = parentRight - width - lp.rightMargin;
                                    break;
                                }
                            case Gravity.LEFT:
                            default:
                                childLeft = parentLeft + lp.leftMargin;
                        }
                        switch (verticalGravity) {
                            case Gravity.TOP:
                                childTop = parentTop + lp.topMargin;
                                break;
                            case Gravity.CENTER_VERTICAL:
                                childTop = parentTop + (parentBottom - parentTop - height) / 2 +
                                    lp.topMargin - lp.bottomMargin;
                                break;
                            case Gravity.BOTTOM:
                                childTop = parentBottom - height - lp.bottomMargin;
                                break;
                            default:
                                childTop = parentTop + lp.topMargin;
                        }
                        child.layout(childLeft, childTop, childLeft + width, childTop + height);
                    }
                }
            }
            onSizeChanged(w, h, oldw, oldh) {
                super.onSizeChanged(w, h, oldw, oldh);
                this.mForegroundBoundsChanged = true;
            }
            draw(canvas) {
                super.draw(canvas);
                if (this.mForeground != null) {
                    const foreground = this.mForeground;
                    if (this.mForegroundBoundsChanged) {
                        this.mForegroundBoundsChanged = false;
                        const selfBounds = this.mSelfBounds;
                        const overlayBounds = this.mOverlayBounds;
                        const w = this.mRight - this.mLeft;
                        const h = this.mBottom - this.mTop;
                        if (this.mForegroundInPadding) {
                            selfBounds.set(0, 0, w, h);
                        }
                        else {
                            selfBounds.set(this.mPaddingLeft, this.mPaddingTop, w - this.mPaddingRight, h - this.mPaddingBottom);
                        }
                        Gravity.apply(this.mForegroundGravity, foreground.getIntrinsicWidth(), foreground.getIntrinsicHeight(), selfBounds, overlayBounds);
                        foreground.setBounds(overlayBounds);
                    }
                    foreground.draw(canvas);
                }
            }
            setMeasureAllChildren(measureAll) {
                this.mMeasureAllChildren = measureAll;
            }
            getMeasureAllChildren() {
                return this.mMeasureAllChildren;
            }
            shouldDelayChildPressedState() {
                return false;
            }
            checkLayoutParams(p) {
                return p instanceof FrameLayout.LayoutParams;
            }
            generateLayoutParams(p) {
                return new FrameLayout.LayoutParams(p);
            }
        }
        FrameLayout.DEFAULT_CHILD_GRAVITY = Gravity.TOP | Gravity.LEFT;
        widget.FrameLayout = FrameLayout;
        (function (FrameLayout) {
            class LayoutParams extends ViewGroup.MarginLayoutParams {
                constructor(...args) {
                    super();
                    this.gravity = -1;
                    if (args.length === 1 && args[0] instanceof LayoutParams) {
                        super(args[0]);
                        this.gravity = args[0].gravity;
                    }
                    else {
                        let [width, height, gravity = -1] = args;
                        super(width, height);
                        this.gravity = gravity;
                    }
                }
                _createAttrChangeHandler(mergeHandler) {
                    super._createAttrChangeHandler(mergeHandler);
                    let params = this;
                    mergeHandler.add({
                        set gravity(value) {
                            params.gravity = View.AttrChangeHandler.parseGravity(value, params.gravity);
                        },
                        get gravity() {
                            return params.gravity;
                        }
                    });
                }
            }
            FrameLayout.LayoutParams = LayoutParams;
        })(FrameLayout = widget.FrameLayout || (widget.FrameLayout = {}));
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/17.
 */
///<reference path="../view/ViewConfiguration.ts"/>
///<reference path="../view/animation/Interpolator.ts"/>
///<reference path="../content/res/Resources.ts"/>
///<reference path="../os/SystemClock.ts"/>
///<reference path="../util/Log.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var ViewConfiguration = android.view.ViewConfiguration;
        var Resources = android.content.res.Resources;
        var SystemClock = android.os.SystemClock;
        var Log = android.util.Log;
        class OverScroller {
            constructor(interpolator, flywheel = true) {
                this.mMode = 0;
                this.mFlywheel = true;
                this.mInterpolator = interpolator;
                this.mFlywheel = flywheel;
                this.mScrollerX = new SplineOverScroller();
                this.mScrollerY = new SplineOverScroller();
            }
            setInterpolator(interpolator) {
                this.mInterpolator = interpolator;
            }
            setFriction(friction) {
                this.mScrollerX.setFriction(friction);
                this.mScrollerY.setFriction(friction);
            }
            isFinished() {
                return this.mScrollerX.mFinished && this.mScrollerY.mFinished;
            }
            forceFinished(finished) {
                this.mScrollerX.mFinished = this.mScrollerY.mFinished = finished;
            }
            getCurrX() {
                return this.mScrollerX.mCurrentPosition;
            }
            getCurrY() {
                return this.mScrollerY.mCurrentPosition;
            }
            getCurrVelocity() {
                let squaredNorm = this.mScrollerX.mCurrVelocity * this.mScrollerX.mCurrVelocity;
                squaredNorm += this.mScrollerY.mCurrVelocity * this.mScrollerY.mCurrVelocity;
                return Math.sqrt(squaredNorm);
            }
            getStartX() {
                return this.mScrollerX.mStart;
            }
            getStartY() {
                return this.mScrollerY.mStart;
            }
            getFinalX() {
                return this.mScrollerX.mFinal;
            }
            getFinalY() {
                return this.mScrollerY.mFinal;
            }
            getDuration() {
                return Math.max(this.mScrollerX.mDuration, this.mScrollerY.mDuration);
            }
            computeScrollOffset() {
                if (this.isFinished()) {
                    return false;
                }
                switch (this.mMode) {
                    case OverScroller.SCROLL_MODE:
                        let time = SystemClock.uptimeMillis();
                        const elapsedTime = time - this.mScrollerX.mStartTime;
                        const duration = this.mScrollerX.mDuration;
                        if (elapsedTime < duration) {
                            let q = (elapsedTime) / duration;
                            if (this.mInterpolator == null) {
                                q = Scroller_viscousFluid(q);
                            }
                            else {
                                q = this.mInterpolator.getInterpolation(q);
                            }
                            this.mScrollerX.updateScroll(q);
                            this.mScrollerY.updateScroll(q);
                        }
                        else {
                            this.abortAnimation();
                        }
                        break;
                    case OverScroller.FLING_MODE:
                        if (!this.mScrollerX.mFinished) {
                            if (!this.mScrollerX.update()) {
                                if (!this.mScrollerX.continueWhenFinished()) {
                                    this.mScrollerX.finish();
                                }
                            }
                        }
                        if (!this.mScrollerY.mFinished) {
                            if (!this.mScrollerY.update()) {
                                if (!this.mScrollerY.continueWhenFinished()) {
                                    this.mScrollerY.finish();
                                }
                            }
                        }
                        break;
                }
                return true;
            }
            startScroll(startX, startY, dx, dy, duration = OverScroller.DEFAULT_DURATION) {
                this.mMode = OverScroller.SCROLL_MODE;
                this.mScrollerX.startScroll(startX, dx, duration);
                this.mScrollerY.startScroll(startY, dy, duration);
            }
            springBack(startX, startY, minX, maxX, minY, maxY) {
                this.mMode = OverScroller.FLING_MODE;
                const spingbackX = this.mScrollerX.springback(startX, minX, maxX);
                const spingbackY = this.mScrollerY.springback(startY, minY, maxY);
                return spingbackX || spingbackY;
            }
            fling(startX, startY, velocityX, velocityY, minX, maxX, minY, maxY, overX = 0, overY = 0) {
                if (this.mFlywheel && !this.isFinished()) {
                    let oldVelocityX = this.mScrollerX.mCurrVelocity;
                    let oldVelocityY = this.mScrollerY.mCurrVelocity;
                    if (Math_signum(velocityX) == Math_signum(oldVelocityX) &&
                        Math_signum(velocityY) == Math_signum(oldVelocityY)) {
                        velocityX += oldVelocityX;
                        velocityY += oldVelocityY;
                    }
                }
                this.mMode = OverScroller.FLING_MODE;
                this.mScrollerX.fling(startX, velocityX, minX, maxX, overX);
                this.mScrollerY.fling(startY, velocityY, minY, maxY, overY);
            }
            notifyHorizontalEdgeReached(startX, finalX, overX) {
                this.mScrollerX.notifyEdgeReached(startX, finalX, overX);
            }
            notifyVerticalEdgeReached(startY, finalY, overY) {
                this.mScrollerY.notifyEdgeReached(startY, finalY, overY);
            }
            isOverScrolled() {
                return ((!this.mScrollerX.mFinished &&
                    this.mScrollerX.mState != SplineOverScroller.SPLINE) ||
                    (!this.mScrollerY.mFinished &&
                        this.mScrollerY.mState != SplineOverScroller.SPLINE));
            }
            abortAnimation() {
                this.mScrollerX.finish();
                this.mScrollerY.finish();
            }
            timePassed() {
                const time = SystemClock.uptimeMillis();
                const startTime = Math.min(this.mScrollerX.mStartTime, this.mScrollerY.mStartTime);
                return (time - startTime);
            }
            isScrollingInDirection(xvel, yvel) {
                const dx = this.mScrollerX.mFinal - this.mScrollerX.mStart;
                const dy = this.mScrollerY.mFinal - this.mScrollerY.mStart;
                return !this.isFinished() && Math_signum(xvel) == Math_signum(dx) &&
                    Math_signum(yvel) == Math_signum(dy);
            }
        }
        OverScroller.DEFAULT_DURATION = 250;
        OverScroller.SCROLL_MODE = 0;
        OverScroller.FLING_MODE = 1;
        widget.OverScroller = OverScroller;
        class SplineOverScroller {
            constructor() {
                this.mStart = 0;
                this.mCurrentPosition = 0;
                this.mFinal = 0;
                this.mVelocity = 0;
                this.mCurrVelocity = 0;
                this.mDeceleration = 0;
                this.mStartTime = 0;
                this.mDuration = 0;
                this.mSplineDuration = 0;
                this.mSplineDistance = 0;
                this.mFinished = false;
                this.mOver = 0;
                this.mFlingFriction = ViewConfiguration.getScrollFriction();
                this.mState = SplineOverScroller.SPLINE;
                this.mPhysicalCoeff = 0;
                this.mFinished = true;
                let ppi = Resources.getDisplayMetrics().density * 160;
                this.mPhysicalCoeff = 9.80665
                    * 39.37
                    * ppi
                    * 0.84;
            }
            setFriction(friction) {
                this.mFlingFriction = friction;
            }
            updateScroll(q) {
                this.mCurrentPosition = this.mStart + Math.round(q * (this.mFinal - this.mStart));
            }
            static getDeceleration(velocity) {
                return velocity > 0 ? -SplineOverScroller.GRAVITY : SplineOverScroller.GRAVITY;
            }
            adjustDuration(start, oldFinal, newFinal) {
                let oldDistance = oldFinal - start;
                let newDistance = newFinal - start;
                let x = Math.abs(newDistance / oldDistance);
                let index = Number.parseInt((SplineOverScroller.NB_SAMPLES * x));
                if (index < SplineOverScroller.NB_SAMPLES) {
                    let x_inf = index / SplineOverScroller.NB_SAMPLES;
                    let x_sup = (index + 1) / SplineOverScroller.NB_SAMPLES;
                    let t_inf = SplineOverScroller.SPLINE_TIME[index];
                    let t_sup = SplineOverScroller.SPLINE_TIME[index + 1];
                    let timeCoef = t_inf + (x - x_inf) / (x_sup - x_inf) * (t_sup - t_inf);
                    this.mDuration *= timeCoef;
                }
            }
            startScroll(start, distance, duration) {
                this.mFinished = false;
                this.mStart = start;
                this.mFinal = start + distance;
                this.mStartTime = SystemClock.uptimeMillis();
                this.mDuration = duration;
                this.mDeceleration = 0;
                this.mVelocity = 0;
            }
            finish() {
                this.mCurrentPosition = this.mFinal;
                this.mFinished = true;
            }
            setFinalPosition(position) {
                this.mFinal = position;
                this.mFinished = false;
            }
            extendDuration(extend) {
                let time = SystemClock.uptimeMillis();
                let elapsedTime = (time - this.mStartTime);
                this.mDuration = elapsedTime + extend;
                this.mFinished = false;
            }
            springback(start, min, max) {
                this.mFinished = true;
                this.mStart = this.mFinal = start;
                this.mVelocity = 0;
                this.mStartTime = SystemClock.uptimeMillis();
                this.mDuration = 0;
                if (start < min) {
                    this.startSpringback(start, min, 0);
                }
                else if (start > max) {
                    this.startSpringback(start, max, 0);
                }
                return !this.mFinished;
            }
            startSpringback(start, end, velocity) {
                this.mFinished = false;
                this.mState = SplineOverScroller.CUBIC;
                this.mStart = start;
                this.mFinal = end;
                const delta = start - end;
                this.mDeceleration = SplineOverScroller.getDeceleration(delta);
                this.mVelocity = -delta;
                this.mOver = Math.abs(delta);
                this.mDuration = (1000.0 * Math.sqrt(-2.0 * delta / this.mDeceleration));
            }
            fling(start, velocity, min, max, over) {
                this.mOver = over;
                this.mFinished = false;
                this.mCurrVelocity = this.mVelocity = velocity;
                this.mDuration = this.mSplineDuration = 0;
                this.mStartTime = SystemClock.uptimeMillis();
                this.mCurrentPosition = this.mStart = start;
                if (start > max || start < min) {
                    this.startAfterEdge(start, min, max, velocity);
                    return;
                }
                this.mState = SplineOverScroller.SPLINE;
                let totalDistance = 0.0;
                if (velocity != 0) {
                    this.mDuration = this.mSplineDuration = this.getSplineFlingDuration(velocity);
                    totalDistance = this.getSplineFlingDistance(velocity);
                }
                this.mSplineDistance = (totalDistance * Math_signum(velocity));
                this.mFinal = start + this.mSplineDistance;
                if (this.mFinal < min) {
                    this.adjustDuration(this.mStart, this.mFinal, min);
                    this.mFinal = min;
                }
                if (this.mFinal > max) {
                    this.adjustDuration(this.mStart, this.mFinal, max);
                    this.mFinal = max;
                }
            }
            getSplineDeceleration(velocity) {
                return Math.log(SplineOverScroller.INFLEXION * Math.abs(velocity) / (this.mFlingFriction * this.mPhysicalCoeff));
            }
            getSplineFlingDistance(velocity) {
                let l = this.getSplineDeceleration(velocity);
                let decelMinusOne = SplineOverScroller.DECELERATION_RATE - 1.0;
                return this.mFlingFriction * this.mPhysicalCoeff * Math.exp(SplineOverScroller.DECELERATION_RATE / decelMinusOne * l);
            }
            getSplineFlingDuration(velocity) {
                let l = this.getSplineDeceleration(velocity);
                let decelMinusOne = SplineOverScroller.DECELERATION_RATE - 1.0;
                return (1000.0 * Math.exp(l / decelMinusOne));
            }
            fitOnBounceCurve(start, end, velocity) {
                let durationToApex = -velocity / this.mDeceleration;
                let distanceToApex = velocity * velocity / 2.0 / Math.abs(this.mDeceleration);
                let distanceToEdge = Math.abs(end - start);
                let totalDuration = Math.sqrt(2.0 * (distanceToApex + distanceToEdge) / Math.abs(this.mDeceleration));
                this.mStartTime -= (1000 * (totalDuration - durationToApex));
                this.mStart = end;
                this.mVelocity = (-this.mDeceleration * totalDuration);
            }
            startBounceAfterEdge(start, end, velocity) {
                this.mDeceleration = SplineOverScroller.getDeceleration(velocity == 0 ? start - end : velocity);
                this.fitOnBounceCurve(start, end, velocity);
                this.onEdgeReached();
            }
            startAfterEdge(start, min, max, velocity) {
                if (start > min && start < max) {
                    Log.e("OverScroller", "startAfterEdge called from a valid position");
                    this.mFinished = true;
                    return;
                }
                const positive = start > max;
                const edge = positive ? max : min;
                const overDistance = start - edge;
                let keepIncreasing = overDistance * velocity >= 0;
                if (keepIncreasing) {
                    this.startBounceAfterEdge(start, edge, velocity);
                }
                else {
                    const totalDistance = this.getSplineFlingDistance(velocity);
                    if (totalDistance > Math.abs(overDistance)) {
                        this.fling(start, velocity, positive ? min : start, positive ? start : max, this.mOver);
                    }
                    else {
                        this.startSpringback(start, edge, velocity);
                    }
                }
            }
            notifyEdgeReached(start, end, over) {
                if (this.mState == SplineOverScroller.SPLINE) {
                    this.mOver = over;
                    this.mStartTime = SystemClock.uptimeMillis();
                    this.startAfterEdge(start, end, end, this.mCurrVelocity);
                }
            }
            onEdgeReached() {
                let distance = this.mVelocity * this.mVelocity / (2 * Math.abs(this.mDeceleration));
                const sign = Math_signum(this.mVelocity);
                if (distance > this.mOver) {
                    this.mDeceleration = -sign * this.mVelocity * this.mVelocity / (2.0 * this.mOver);
                    distance = this.mOver;
                }
                this.mOver = distance;
                this.mState = SplineOverScroller.BALLISTIC;
                this.mFinal = this.mStart + (this.mVelocity > 0 ? distance : -distance);
                this.mDuration = -(1000 * this.mVelocity / this.mDeceleration);
            }
            continueWhenFinished() {
                switch (this.mState) {
                    case SplineOverScroller.SPLINE:
                        if (this.mDuration < this.mSplineDuration) {
                            this.mStart = this.mFinal;
                            this.mVelocity = this.mCurrVelocity;
                            this.mDeceleration = SplineOverScroller.getDeceleration(this.mVelocity);
                            this.mStartTime += this.mDuration;
                            this.onEdgeReached();
                        }
                        else {
                            return false;
                        }
                        break;
                    case SplineOverScroller.BALLISTIC:
                        this.mStartTime += this.mDuration;
                        this.startSpringback(this.mFinal, this.mStart, 0);
                        break;
                    case SplineOverScroller.CUBIC:
                        return false;
                }
                this.update();
                return true;
            }
            update() {
                const time = SystemClock.uptimeMillis();
                const currentTime = time - this.mStartTime;
                if (currentTime > this.mDuration) {
                    return false;
                }
                let distance = 0;
                switch (this.mState) {
                    case SplineOverScroller.SPLINE: {
                        const t = currentTime / this.mSplineDuration;
                        const index = Number.parseInt((SplineOverScroller.NB_SAMPLES * t));
                        let distanceCoef = 1;
                        let velocityCoef = 0;
                        if (index < SplineOverScroller.NB_SAMPLES) {
                            const t_inf = index / SplineOverScroller.NB_SAMPLES;
                            const t_sup = (index + 1) / SplineOverScroller.NB_SAMPLES;
                            const d_inf = SplineOverScroller.SPLINE_POSITION[index];
                            const d_sup = SplineOverScroller.SPLINE_POSITION[index + 1];
                            velocityCoef = (d_sup - d_inf) / (t_sup - t_inf);
                            distanceCoef = d_inf + (t - t_inf) * velocityCoef;
                        }
                        distance = distanceCoef * this.mSplineDistance;
                        this.mCurrVelocity = velocityCoef * this.mSplineDistance / this.mSplineDuration * 1000;
                        break;
                    }
                    case SplineOverScroller.BALLISTIC: {
                        const t = currentTime / 1000;
                        this.mCurrVelocity = this.mVelocity + this.mDeceleration * t;
                        distance = this.mVelocity * t + this.mDeceleration * t * t / 2;
                        break;
                    }
                    case SplineOverScroller.CUBIC: {
                        const t = (currentTime) / this.mDuration;
                        const t2 = t * t;
                        const sign = Math_signum(this.mVelocity);
                        distance = sign * this.mOver * (3 * t2 - 2 * t * t2);
                        this.mCurrVelocity = sign * this.mOver * 6 * (-t + t2);
                        break;
                    }
                }
                this.mCurrentPosition = this.mStart + Math.round(distance);
                return true;
            }
        }
        SplineOverScroller.DECELERATION_RATE = (Math.log(0.78) / Math.log(0.9));
        SplineOverScroller.INFLEXION = 0.35;
        SplineOverScroller.START_TENSION = 0.5;
        SplineOverScroller.END_TENSION = 1.0;
        SplineOverScroller.P1 = SplineOverScroller.START_TENSION * SplineOverScroller.INFLEXION;
        SplineOverScroller.P2 = 1.0 - SplineOverScroller.END_TENSION * (1 - SplineOverScroller.INFLEXION);
        SplineOverScroller.NB_SAMPLES = 100;
        SplineOverScroller.SPLINE_POSITION = new Array(SplineOverScroller.NB_SAMPLES + 1);
        SplineOverScroller.SPLINE_TIME = new Array(SplineOverScroller.NB_SAMPLES + 1);
        SplineOverScroller.SPLINE = 0;
        SplineOverScroller.CUBIC = 1;
        SplineOverScroller.BALLISTIC = 2;
        SplineOverScroller.GRAVITY = 2000;
        SplineOverScroller._staticFunc = function () {
            let x_min = 0.0;
            let y_min = 0.0;
            for (let i = 0; i < SplineOverScroller.NB_SAMPLES; i++) {
                const alpha = i / SplineOverScroller.NB_SAMPLES;
                let x_max = 1.0;
                let x, tx, coef;
                while (true) {
                    x = x_min + (x_max - x_min) / 2.0;
                    coef = 3.0 * x * (1.0 - x);
                    tx = coef * ((1.0 - x) * SplineOverScroller.P1 + x * SplineOverScroller.P2) + x * x * x;
                    if (Math.abs(tx - alpha) < 1E-5)
                        break;
                    if (tx > alpha)
                        x_max = x;
                    else
                        x_min = x;
                }
                SplineOverScroller.SPLINE_POSITION[i] = coef * ((1.0 - x) * SplineOverScroller.START_TENSION + x) + x * x * x;
                let y_max = 1.0;
                let y, dy;
                while (true) {
                    y = y_min + (y_max - y_min) / 2.0;
                    coef = 3.0 * y * (1.0 - y);
                    dy = coef * ((1.0 - y) * SplineOverScroller.START_TENSION + y) + y * y * y;
                    if (Math.abs(dy - alpha) < 1E-5)
                        break;
                    if (dy > alpha)
                        y_max = y;
                    else
                        y_min = y;
                }
                SplineOverScroller.SPLINE_TIME[i] = coef * ((1.0 - y) * SplineOverScroller.P1 + y * SplineOverScroller.P2) + y * y * y;
            }
            SplineOverScroller.SPLINE_POSITION[SplineOverScroller.NB_SAMPLES] = SplineOverScroller.SPLINE_TIME[SplineOverScroller.NB_SAMPLES] = 1.0;
        }();
        function Math_signum(value) {
            if (value === 0 || Number.isNaN(value))
                return value;
            return Math.abs(value) === value ? 1 : -1;
        }
        let sViscousFluidScale = 8;
        let sViscousFluidNormalize = 1;
        function Scroller_viscousFluid(x) {
            x *= sViscousFluidScale;
            if (x < 1) {
                x -= (1 - Math.exp(-x));
            }
            else {
                let start = 0.36787944117;
                x = 1 - Math.exp(1 - x);
                x = start + x * (1 - start);
            }
            x *= sViscousFluidNormalize;
            return x;
        }
        sViscousFluidNormalize = 1 / Scroller_viscousFluid(1);
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/17.
 */
///<reference path="../view/View.ts"/>
///<reference path="../view/ViewGroup.ts"/>
///<reference path="../view/MotionEvent.ts"/>
///<reference path="FrameLayout.ts"/>
///<reference path="OverScroller.ts"/>
///<reference path="../view/VelocityTracker.ts"/>
///<reference path="../view/ViewConfiguration.ts"/>
///<reference path="../util/Log.ts"/>
///<reference path="../os/SystemClock.ts"/>
///<reference path="../graphics/Rect.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var View = android.view.View;
        var ViewGroup = android.view.ViewGroup;
        var MeasureSpec = View.MeasureSpec;
        var MotionEvent = android.view.MotionEvent;
        var VelocityTracker = android.view.VelocityTracker;
        var ViewConfiguration = android.view.ViewConfiguration;
        var Rect = android.graphics.Rect;
        var OverScroller = android.widget.OverScroller;
        var Log = android.util.Log;
        var SystemClock = android.os.SystemClock;
        var KeyEvent = android.view.KeyEvent;
        class ScrollView extends widget.FrameLayout {
            constructor() {
                super();
                this.mLastScroll = 0;
                this.mTempRect = new Rect();
                this.mLastMotionY = 0;
                this.mIsLayoutDirty = true;
                this.mIsBeingDragged = false;
                this.mFillViewport = false;
                this.mSmoothScrollingEnabled = true;
                this.mMinimumVelocity = 0;
                this.mMaximumVelocity = 0;
                this.mOverscrollDistance = 0;
                this.mOverflingDistance = 0;
                this.mActivePointerId = ScrollView.INVALID_POINTER;
                this.initScrollView();
            }
            createAttrChangeHandler(mergeHandler) {
                super.createAttrChangeHandler(mergeHandler);
                let scrollView = this;
                mergeHandler.add({
                    set fillViewport(value) {
                        scrollView.setFillViewport(View.AttrChangeHandler.parseBoolean(value));
                    },
                    get fillViewport() {
                        return scrollView.mFillViewport;
                    }
                });
            }
            shouldDelayChildPressedState() {
                return true;
            }
            getMaxScrollAmount() {
                return (ScrollView.MAX_SCROLL_FACTOR * (this.mBottom - this.mTop));
            }
            initScrollView() {
                this.mScroller = new OverScroller();
                this.setFocusable(true);
                this.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);
                this.setWillNotDraw(false);
                const configuration = ViewConfiguration.get();
                this.mTouchSlop = configuration.getScaledTouchSlop();
                this.mMinimumVelocity = configuration.getScaledMinimumFlingVelocity();
                this.mMaximumVelocity = configuration.getScaledMaximumFlingVelocity();
                this.mOverscrollDistance = configuration.getScaledOverscrollDistance();
                this.mOverflingDistance = configuration.getScaledOverflingDistance();
                this.initScrollCache();
                this.setVerticalScrollBarEnabled(true);
            }
            addView(...args) {
                if (this.getChildCount() > 0) {
                    throw new Error("ScrollView can host only one direct child");
                }
                return super.addView(...args);
            }
            canScroll() {
                let child = this.getChildAt(0);
                if (child != null) {
                    let childHeight = child.getHeight();
                    return this.getHeight() < childHeight + this.mPaddingTop + this.mPaddingBottom;
                }
                return false;
            }
            isFillViewport() {
                return this.mFillViewport;
            }
            setFillViewport(fillViewport) {
                if (fillViewport != this.mFillViewport) {
                    this.mFillViewport = fillViewport;
                    this.requestLayout();
                }
            }
            isSmoothScrollingEnabled() {
                return this.mSmoothScrollingEnabled;
            }
            setSmoothScrollingEnabled(smoothScrollingEnabled) {
                this.mSmoothScrollingEnabled = smoothScrollingEnabled;
            }
            onMeasure(widthMeasureSpec, heightMeasureSpec) {
                super.onMeasure(widthMeasureSpec, heightMeasureSpec);
                if (!this.mFillViewport) {
                    return;
                }
                const heightMode = MeasureSpec.getMode(heightMeasureSpec);
                if (heightMode == MeasureSpec.UNSPECIFIED) {
                    return;
                }
                if (this.getChildCount() > 0) {
                    const child = this.getChildAt(0);
                    let height = this.getMeasuredHeight();
                    if (child.getMeasuredHeight() < height) {
                        const lp = child.getLayoutParams();
                        let childWidthMeasureSpec = widget.FrameLayout.getChildMeasureSpec(widthMeasureSpec, this.mPaddingLeft + this.mPaddingRight, lp.width);
                        height -= this.mPaddingTop;
                        height -= this.mPaddingBottom;
                        let childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height, MeasureSpec.EXACTLY);
                        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
                    }
                }
            }
            dispatchKeyEvent(event) {
                return super.dispatchKeyEvent(event) || this.executeKeyEvent(event);
            }
            executeKeyEvent(event) {
                this.mTempRect.setEmpty();
                if (!this.canScroll()) {
                    return false;
                }
                let handled = false;
                if (event.getAction() == KeyEvent.ACTION_DOWN) {
                    switch (event.getKeyCode()) {
                        case KeyEvent.KEYCODE_DPAD_UP:
                            if (!event.isAltPressed()) {
                                handled = this.arrowScroll(View.FOCUS_UP);
                            }
                            else {
                                handled = this.fullScroll(View.FOCUS_UP);
                            }
                            break;
                        case KeyEvent.KEYCODE_DPAD_DOWN:
                            if (!event.isAltPressed()) {
                                handled = this.arrowScroll(View.FOCUS_DOWN);
                            }
                            else {
                                handled = this.fullScroll(View.FOCUS_DOWN);
                            }
                            break;
                        case KeyEvent.KEYCODE_SPACE:
                            this.pageScroll(event.isShiftPressed() ? View.FOCUS_UP : View.FOCUS_DOWN);
                            break;
                    }
                }
                return handled;
            }
            inChild(x, y) {
                if (this.getChildCount() > 0) {
                    const scrollY = this.mScrollY;
                    const child = this.getChildAt(0);
                    return !(y < child.getTop() - scrollY
                        || y >= child.getBottom() - scrollY
                        || x < child.getLeft()
                        || x >= child.getRight());
                }
                return false;
            }
            initOrResetVelocityTracker() {
                if (this.mVelocityTracker == null) {
                    this.mVelocityTracker = VelocityTracker.obtain();
                }
                else {
                    this.mVelocityTracker.clear();
                }
            }
            initVelocityTrackerIfNotExists() {
                if (this.mVelocityTracker == null) {
                    this.mVelocityTracker = VelocityTracker.obtain();
                }
            }
            recycleVelocityTracker() {
                if (this.mVelocityTracker != null) {
                    this.mVelocityTracker.recycle();
                    this.mVelocityTracker = null;
                }
            }
            requestDisallowInterceptTouchEvent(disallowIntercept) {
                if (disallowIntercept) {
                    this.recycleVelocityTracker();
                }
                super.requestDisallowInterceptTouchEvent(disallowIntercept);
            }
            onInterceptTouchEvent(ev) {
                /*
                 * This method JUST determines whether we want to intercept the motion.
                 * If we return true, onMotionEvent will be called and we do the actual
                 * scrolling there.
                 */
                const action = ev.getAction();
                if ((action == MotionEvent.ACTION_MOVE) && (this.mIsBeingDragged)) {
                    return true;
                }
                if (this.getScrollY() == 0 && !this.canScrollVertically(1)) {
                    return false;
                }
                switch (action & MotionEvent.ACTION_MASK) {
                    case MotionEvent.ACTION_MOVE:
                        {
                            const activePointerId = this.mActivePointerId;
                            if (activePointerId == ScrollView.INVALID_POINTER) {
                                break;
                            }
                            const pointerIndex = ev.findPointerIndex(activePointerId);
                            if (pointerIndex == -1) {
                                Log.e(ScrollView.TAG, "Invalid pointerId=" + activePointerId
                                    + " in onInterceptTouchEvent");
                                break;
                            }
                            const y = ev.getY(pointerIndex);
                            const yDiff = Math.abs(y - this.mLastMotionY);
                            if (yDiff > this.mTouchSlop) {
                                this.mIsBeingDragged = true;
                                this.mLastMotionY = y;
                                this.initVelocityTrackerIfNotExists();
                                this.mVelocityTracker.addMovement(ev);
                                const parent = this.getParent();
                                if (parent != null) {
                                    parent.requestDisallowInterceptTouchEvent(true);
                                }
                            }
                            break;
                        }
                    case MotionEvent.ACTION_DOWN:
                        {
                            const y = ev.getY();
                            if (!this.inChild(ev.getX(), y)) {
                                this.mIsBeingDragged = false;
                                this.recycleVelocityTracker();
                                break;
                            }
                            this.mLastMotionY = y;
                            this.mActivePointerId = ev.getPointerId(0);
                            this.initOrResetVelocityTracker();
                            this.mVelocityTracker.addMovement(ev);
                            this.mIsBeingDragged = !this.mScroller.isFinished();
                            break;
                        }
                    case MotionEvent.ACTION_CANCEL:
                    case MotionEvent.ACTION_UP:
                        this.mIsBeingDragged = false;
                        this.mActivePointerId = ScrollView.INVALID_POINTER;
                        this.recycleVelocityTracker();
                        if (this.mScroller.springBack(this.mScrollX, this.mScrollY, 0, 0, 0, this.getScrollRange())) {
                            this.postInvalidateOnAnimation();
                        }
                        break;
                    case MotionEvent.ACTION_POINTER_UP:
                        this.onSecondaryPointerUp(ev);
                        break;
                }
                return this.mIsBeingDragged;
            }
            onTouchEvent(ev) {
                this.initVelocityTrackerIfNotExists();
                this.mVelocityTracker.addMovement(ev);
                const action = ev.getAction();
                switch (action & MotionEvent.ACTION_MASK) {
                    case MotionEvent.ACTION_DOWN:
                        {
                            if (this.getChildCount() == 0) {
                                return false;
                            }
                            if ((this.mIsBeingDragged = !this.mScroller.isFinished())) {
                                const parent = this.getParent();
                                if (parent != null) {
                                    parent.requestDisallowInterceptTouchEvent(true);
                                }
                            }
                            if (!this.mScroller.isFinished()) {
                                this.mScroller.abortAnimation();
                            }
                            this.mLastMotionY = ev.getY();
                            this.mActivePointerId = ev.getPointerId(0);
                            break;
                        }
                    case MotionEvent.ACTION_MOVE:
                        const activePointerIndex = ev.findPointerIndex(this.mActivePointerId);
                        if (activePointerIndex == -1) {
                            Log.e(ScrollView.TAG, "Invalid pointerId=" + this.mActivePointerId + " in onTouchEvent");
                            break;
                        }
                        const y = ev.getY(activePointerIndex);
                        let deltaY = this.mLastMotionY - y;
                        if (!this.mIsBeingDragged && Math.abs(deltaY) > this.mTouchSlop) {
                            const parent = this.getParent();
                            if (parent != null) {
                                parent.requestDisallowInterceptTouchEvent(true);
                            }
                            this.mIsBeingDragged = true;
                            if (deltaY > 0) {
                                deltaY -= this.mTouchSlop;
                            }
                            else {
                                deltaY += this.mTouchSlop;
                            }
                        }
                        if (this.mIsBeingDragged) {
                            this.mLastMotionY = y;
                            const oldX = this.mScrollX;
                            const oldY = this.mScrollY;
                            const range = this.getScrollRange();
                            const overscrollMode = this.getOverScrollMode();
                            const canOverscroll = overscrollMode == ScrollView.OVER_SCROLL_ALWAYS ||
                                (overscrollMode == ScrollView.OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
                            if (this.overScrollBy(0, deltaY, 0, this.mScrollY, 0, range, 0, this.mOverscrollDistance, true)) {
                                this.mVelocityTracker.clear();
                            }
                            if (canOverscroll) {
                                const pulledToY = oldY + deltaY;
                                if (pulledToY < 0) {
                                }
                                else if (pulledToY > range) {
                                }
                            }
                        }
                        break;
                    case MotionEvent.ACTION_UP:
                        if (this.mIsBeingDragged) {
                            let velocityTracker = this.mVelocityTracker;
                            velocityTracker.computeCurrentVelocity(1000, this.mMaximumVelocity);
                            let initialVelocity = velocityTracker.getYVelocity(this.mActivePointerId);
                            if (this.getChildCount() > 0) {
                                let isOverDrag = this.mScrollY < 0 || this.mScrollY > this.getScrollRange();
                                if (!isOverDrag && (Math.abs(initialVelocity) > this.mMinimumVelocity)) {
                                    this.fling(-initialVelocity);
                                }
                                else {
                                    if (this.mScroller.springBack(this.mScrollX, this.mScrollY, 0, 0, 0, this.getScrollRange())) {
                                        this.postInvalidateOnAnimation();
                                    }
                                }
                            }
                            this.mActivePointerId = ScrollView.INVALID_POINTER;
                            this.endDrag();
                        }
                        break;
                    case MotionEvent.ACTION_CANCEL:
                        if (this.mIsBeingDragged && this.getChildCount() > 0) {
                            if (this.mScroller.springBack(this.mScrollX, this.mScrollY, 0, 0, 0, this.getScrollRange())) {
                                this.postInvalidateOnAnimation();
                            }
                            this.mActivePointerId = ScrollView.INVALID_POINTER;
                            this.endDrag();
                        }
                        break;
                    case MotionEvent.ACTION_POINTER_DOWN:
                        {
                            const index = ev.getActionIndex();
                            this.mLastMotionY = ev.getY(index);
                            this.mActivePointerId = ev.getPointerId(index);
                            break;
                        }
                    case MotionEvent.ACTION_POINTER_UP:
                        this.onSecondaryPointerUp(ev);
                        this.mLastMotionY = ev.getY(ev.findPointerIndex(this.mActivePointerId));
                        break;
                }
                return true;
            }
            onSecondaryPointerUp(ev) {
                const pointerIndex = (ev.getAction() & MotionEvent.ACTION_POINTER_INDEX_MASK) >>
                    MotionEvent.ACTION_POINTER_INDEX_SHIFT;
                const pointerId = ev.getPointerId(pointerIndex);
                if (pointerId == this.mActivePointerId) {
                    const newPointerIndex = pointerIndex == 0 ? 1 : 0;
                    this.mLastMotionY = ev.getY(newPointerIndex);
                    this.mActivePointerId = ev.getPointerId(newPointerIndex);
                    if (this.mVelocityTracker != null) {
                        this.mVelocityTracker.clear();
                    }
                }
            }
            onGenericMotionEvent(event) {
                switch (event.getAction()) {
                    case MotionEvent.ACTION_SCROLL: {
                        if (!this.mIsBeingDragged) {
                            const vscroll = event.getAxisValue(MotionEvent.AXIS_VSCROLL);
                            if (vscroll != 0) {
                                const delta = Math.floor(vscroll * this.getVerticalScrollFactor());
                                const range = this.getScrollRange();
                                let oldScrollY = this.mScrollY;
                                let newScrollY = oldScrollY - delta;
                                if (newScrollY < 0) {
                                    newScrollY = 0;
                                }
                                else if (newScrollY > range) {
                                    newScrollY = range;
                                }
                                if (newScrollY != oldScrollY) {
                                    super.scrollTo(this.mScrollX, newScrollY);
                                    return true;
                                }
                            }
                        }
                    }
                }
                return super.onGenericMotionEvent(event);
            }
            onOverScrolled(scrollX, scrollY, clampedX, clampedY) {
                if (!this.mScroller.isFinished()) {
                    const oldX = this.mScrollX;
                    const oldY = this.mScrollY;
                    this.mScrollX = scrollX;
                    this.mScrollY = scrollY;
                    this.invalidateParentIfNeeded();
                    this.onScrollChanged(this.mScrollX, this.mScrollY, oldX, oldY);
                }
                else {
                    super.scrollTo(scrollX, scrollY);
                }
                if (!this.awakenScrollBars()) {
                    this.postInvalidateOnAnimation();
                }
            }
            getScrollRange() {
                let scrollRange = 0;
                if (this.getChildCount() > 0) {
                    let child = this.getChildAt(0);
                    scrollRange = Math.max(0, child.getHeight() - (this.getHeight() - this.mPaddingBottom - this.mPaddingTop));
                }
                return scrollRange;
            }
            findFocusableViewInBounds(topFocus, top, bottom) {
                return null;
            }
            pageScroll(direction) {
                let down = direction == View.FOCUS_DOWN;
                let height = this.getHeight();
                if (down) {
                    this.mTempRect.top = this.getScrollY() + height;
                    let count = this.getChildCount();
                    if (count > 0) {
                        let view = this.getChildAt(count - 1);
                        if (this.mTempRect.top + height > view.getBottom()) {
                            this.mTempRect.top = view.getBottom() - height;
                        }
                    }
                }
                else {
                    this.mTempRect.top = this.getScrollY() - height;
                    if (this.mTempRect.top < 0) {
                        this.mTempRect.top = 0;
                    }
                }
                this.mTempRect.bottom = this.mTempRect.top + height;
                return this.scrollAndFocus(direction, this.mTempRect.top, this.mTempRect.bottom);
            }
            fullScroll(direction) {
                let down = direction == View.FOCUS_DOWN;
                let height = this.getHeight();
                this.mTempRect.top = 0;
                this.mTempRect.bottom = height;
                if (down) {
                    let count = this.getChildCount();
                    if (count > 0) {
                        let view = this.getChildAt(count - 1);
                        this.mTempRect.bottom = view.getBottom() + this.mPaddingBottom;
                        this.mTempRect.top = this.mTempRect.bottom - height;
                    }
                }
                return this.scrollAndFocus(direction, this.mTempRect.top, this.mTempRect.bottom);
            }
            scrollAndFocus(direction, top, bottom) {
                let handled = true;
                let height = this.getHeight();
                let containerTop = this.getScrollY();
                let containerBottom = containerTop + height;
                let up = direction == View.FOCUS_UP;
                let newFocused = this.findFocusableViewInBounds(up, top, bottom);
                if (newFocused == null) {
                    newFocused = this;
                }
                if (top >= containerTop && bottom <= containerBottom) {
                    handled = false;
                }
                else {
                    let delta = up ? (top - containerTop) : (bottom - containerBottom);
                    this.doScrollY(delta);
                }
                if (newFocused != this.findFocus())
                    newFocused.requestFocus(direction);
                return handled;
            }
            arrowScroll(direction) {
                let currentFocused = this.findFocus();
                if (currentFocused == this)
                    currentFocused = null;
                let nextFocused = null;
                const maxJump = this.getMaxScrollAmount();
                if (nextFocused != null && this.isWithinDeltaOfScreen(nextFocused, maxJump, this.getHeight())) {
                }
                else {
                    let scrollDelta = maxJump;
                    if (direction == View.FOCUS_UP && this.getScrollY() < scrollDelta) {
                        scrollDelta = this.getScrollY();
                    }
                    else if (direction == View.FOCUS_DOWN) {
                        if (this.getChildCount() > 0) {
                            let daBottom = this.getChildAt(0).getBottom();
                            let screenBottom = this.getScrollY() + this.getHeight() - this.mPaddingBottom;
                            if (daBottom - screenBottom < maxJump) {
                                scrollDelta = daBottom - screenBottom;
                            }
                        }
                    }
                    if (scrollDelta == 0) {
                        return false;
                    }
                    this.doScrollY(direction == View.FOCUS_DOWN ? scrollDelta : -scrollDelta);
                }
                if (currentFocused != null && currentFocused.isFocused() && this.isOffScreen(currentFocused)) {
                }
                return true;
            }
            isOffScreen(descendant) {
                return !this.isWithinDeltaOfScreen(descendant, 0, this.getHeight());
            }
            isWithinDeltaOfScreen(descendant, delta, height) {
                descendant.getDrawingRect(this.mTempRect);
                this.offsetDescendantRectToMyCoords(descendant, this.mTempRect);
                return (this.mTempRect.bottom + delta) >= this.getScrollY()
                    && (this.mTempRect.top - delta) <= (this.getScrollY() + height);
            }
            doScrollY(delta) {
                if (delta != 0) {
                    if (this.mSmoothScrollingEnabled) {
                        this.smoothScrollBy(0, delta);
                    }
                    else {
                        this.scrollBy(0, delta);
                    }
                }
            }
            smoothScrollBy(dx, dy) {
                if (this.getChildCount() == 0) {
                    return;
                }
                let duration = SystemClock.uptimeMillis() - this.mLastScroll;
                if (duration > ScrollView.ANIMATED_SCROLL_GAP) {
                    const height = this.getHeight() - this.mPaddingBottom - this.mPaddingTop;
                    const bottom = this.getChildAt(0).getHeight();
                    const maxY = Math.max(0, bottom - height);
                    const scrollY = this.mScrollY;
                    dy = Math.max(0, Math.min(scrollY + dy, maxY)) - scrollY;
                    this.mScroller.startScroll(this.mScrollX, scrollY, 0, dy);
                    this.postInvalidateOnAnimation();
                }
                else {
                    if (!this.mScroller.isFinished()) {
                        this.mScroller.abortAnimation();
                    }
                    this.scrollBy(dx, dy);
                }
                this.mLastScroll = SystemClock.uptimeMillis();
            }
            smoothScrollTo(x, y) {
                this.smoothScrollBy(x - this.mScrollX, y - this.mScrollY);
            }
            computeVerticalScrollRange() {
                const count = this.getChildCount();
                const contentHeight = this.getHeight() - this.mPaddingBottom - this.mPaddingTop;
                if (count == 0) {
                    return contentHeight;
                }
                let scrollRange = this.getChildAt(0).getBottom();
                const scrollY = this.mScrollY;
                const overscrollBottom = Math.max(0, scrollRange - contentHeight);
                if (scrollY < 0) {
                    scrollRange -= scrollY;
                }
                else if (scrollY > overscrollBottom) {
                    scrollRange += scrollY - overscrollBottom;
                }
                return scrollRange;
            }
            computeVerticalScrollOffset() {
                return Math.max(0, super.computeVerticalScrollOffset());
            }
            measureChild(child, parentWidthMeasureSpec, parentHeightMeasureSpec) {
                let lp = child.getLayoutParams();
                lp._measuringParentWidthMeasureSpec = parentWidthMeasureSpec;
                lp._measuringParentHeightMeasureSpec = parentHeightMeasureSpec;
                let childWidthMeasureSpec;
                let childHeightMeasureSpec;
                childWidthMeasureSpec = ViewGroup.getChildMeasureSpec(parentWidthMeasureSpec, this.mPaddingLeft
                    + this.mPaddingRight, lp.width);
                childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
                child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
                lp._measuringParentWidthMeasureSpec = null;
                lp._measuringParentHeightMeasureSpec = null;
            }
            measureChildWithMargins(child, parentWidthMeasureSpec, widthUsed, parentHeightMeasureSpec, heightUsed) {
                const lp = child.getLayoutParams();
                lp._measuringParentWidthMeasureSpec = parentWidthMeasureSpec;
                lp._measuringParentHeightMeasureSpec = parentHeightMeasureSpec;
                const childWidthMeasureSpec = ScrollView.getChildMeasureSpec(parentWidthMeasureSpec, this.mPaddingLeft + this.mPaddingRight + lp.leftMargin + lp.rightMargin
                    + widthUsed, lp.width);
                const childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(lp.topMargin + lp.bottomMargin, MeasureSpec.UNSPECIFIED);
                child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
                lp._measuringParentWidthMeasureSpec = null;
                lp._measuringParentHeightMeasureSpec = null;
            }
            computeScroll() {
                if (this.mScroller.computeScrollOffset()) {
                    let oldX = this.mScrollX;
                    let oldY = this.mScrollY;
                    let x = this.mScroller.getCurrX();
                    let y = this.mScroller.getCurrY();
                    if (oldX != x || oldY != y) {
                        const range = this.getScrollRange();
                        const overscrollMode = this.getOverScrollMode();
                        const canOverscroll = overscrollMode == ScrollView.OVER_SCROLL_ALWAYS ||
                            (overscrollMode == ScrollView.OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
                        this.overScrollBy(x - oldX, y - oldY, oldX, oldY, 0, range, 0, this.getOverflingDistance(), false);
                        this.onScrollChanged(this.mScrollX, this.mScrollY, oldX, oldY);
                        if (canOverscroll) {
                            if (y < 0 && oldY >= 0) {
                            }
                            else if (y > range && oldY <= range) {
                            }
                        }
                    }
                    if (!this.awakenScrollBars()) {
                        this.postInvalidateOnAnimation();
                    }
                }
                else {
                }
            }
            scrollToChild(child) {
                child.getDrawingRect(this.mTempRect);
                this.offsetDescendantRectToMyCoords(child, this.mTempRect);
                let scrollDelta = this.computeScrollDeltaToGetChildRectOnScreen(this.mTempRect);
                if (scrollDelta != 0) {
                    this.scrollBy(0, scrollDelta);
                }
            }
            scrollToChildRect(rect, immediate) {
                const delta = this.computeScrollDeltaToGetChildRectOnScreen(rect);
                const scroll = delta != 0;
                if (scroll) {
                    if (immediate) {
                        this.scrollBy(0, delta);
                    }
                    else {
                        this.smoothScrollBy(0, delta);
                    }
                }
                return scroll;
            }
            computeScrollDeltaToGetChildRectOnScreen(rect) {
                if (this.getChildCount() == 0)
                    return 0;
                let height = this.getHeight();
                let screenTop = this.getScrollY();
                let screenBottom = screenTop + height;
                let fadingEdge = this.getVerticalFadingEdgeLength();
                if (rect.top > 0) {
                    screenTop += fadingEdge;
                }
                if (rect.bottom < this.getChildAt(0).getHeight()) {
                    screenBottom -= fadingEdge;
                }
                let scrollYDelta = 0;
                if (rect.bottom > screenBottom && rect.top > screenTop) {
                    if (rect.height() > height) {
                        scrollYDelta += (rect.top - screenTop);
                    }
                    else {
                        scrollYDelta += (rect.bottom - screenBottom);
                    }
                    let bottom = this.getChildAt(0).getBottom();
                    let distanceToBottom = bottom - screenBottom;
                    scrollYDelta = Math.min(scrollYDelta, distanceToBottom);
                }
                else if (rect.top < screenTop && rect.bottom < screenBottom) {
                    if (rect.height() > height) {
                        scrollYDelta -= (screenBottom - rect.bottom);
                    }
                    else {
                        scrollYDelta -= (screenTop - rect.top);
                    }
                    scrollYDelta = Math.max(scrollYDelta, -this.getScrollY());
                }
                return scrollYDelta;
            }
            requestChildFocus(child, focused) {
                if (!this.mIsLayoutDirty) {
                    this.scrollToChild(focused);
                }
                else {
                    this.mChildToScrollTo = focused;
                }
                super.requestChildFocus(child, focused);
            }
            onRequestFocusInDescendants(direction, previouslyFocusedRect) {
                return false;
            }
            requestChildRectangleOnScreen(child, rectangle, immediate) {
                rectangle.offset(child.getLeft() - child.getScrollX(), child.getTop() - child.getScrollY());
                return this.scrollToChildRect(rectangle, immediate);
            }
            requestLayout() {
                this.mIsLayoutDirty = true;
                super.requestLayout();
            }
            onLayout(changed, l, t, r, b) {
                super.onLayout(changed, l, t, r, b);
                this.mIsLayoutDirty = false;
                if (this.mChildToScrollTo != null && ScrollView.isViewDescendantOf(this.mChildToScrollTo, this)) {
                    this.scrollToChild(this.mChildToScrollTo);
                }
                this.mChildToScrollTo = null;
                if (!this.isLaidOut()) {
                    const childHeight = (this.getChildCount() > 0) ? this.getChildAt(0).getMeasuredHeight() : 0;
                    const scrollRange = Math.max(0, childHeight - (b - t - this.mPaddingBottom - this.mPaddingTop));
                    if (this.mScrollY > scrollRange) {
                        this.mScrollY = scrollRange;
                    }
                    else if (this.mScrollY < 0) {
                        this.mScrollY = 0;
                    }
                }
                this.scrollTo(this.mScrollX, this.mScrollY);
            }
            onSizeChanged(w, h, oldw, oldh) {
                super.onSizeChanged(w, h, oldw, oldh);
                let currentFocused = this.findFocus();
                if (null == currentFocused || this == currentFocused)
                    return;
                if (this.isWithinDeltaOfScreen(currentFocused, 0, oldh)) {
                    currentFocused.getDrawingRect(this.mTempRect);
                    this.offsetDescendantRectToMyCoords(currentFocused, this.mTempRect);
                    let scrollDelta = this.computeScrollDeltaToGetChildRectOnScreen(this.mTempRect);
                    this.doScrollY(scrollDelta);
                }
            }
            static isViewDescendantOf(child, parent) {
                if (child == parent) {
                    return true;
                }
                const theParent = child.getParent();
                return (theParent instanceof ViewGroup) && ScrollView.isViewDescendantOf(theParent, parent);
            }
            getOverflingDistance() {
                let height = this.getHeight() - this.mPaddingBottom - this.mPaddingTop;
                let bottom = this.getChildAt(0).getHeight();
                let minOverY = this.mScrollY < 0 ? -this.mScrollY : this.mScrollY - (bottom - height);
                return Math.max(this.mOverflingDistance, minOverY + this.mOverflingDistance);
            }
            fling(velocityY) {
                if (this.getChildCount() > 0) {
                    let height = this.getHeight() - this.mPaddingBottom - this.mPaddingTop;
                    let bottom = this.getChildAt(0).getHeight();
                    this.mScroller.fling(this.mScrollX, this.mScrollY, 0, velocityY, 0, 0, 0, Math.max(0, bottom - height), 0, this.getOverflingDistance());
                    this.postInvalidateOnAnimation();
                }
            }
            endDrag() {
                this.mIsBeingDragged = false;
                this.recycleVelocityTracker();
            }
            scrollTo(x, y) {
                if (this.getChildCount() > 0) {
                    let child = this.getChildAt(0);
                    x = ScrollView.clamp(x, this.getWidth() - this.mPaddingRight - this.mPaddingLeft, child.getWidth());
                    y = ScrollView.clamp(y, this.getHeight() - this.mPaddingBottom - this.mPaddingTop, child.getHeight());
                    if (x != this.mScrollX || y != this.mScrollY) {
                        super.scrollTo(x, y);
                    }
                }
            }
            static clamp(n, my, child) {
                if (my >= child || n < 0) {
                    return 0;
                }
                if ((my + n) > child) {
                    return child - my;
                }
                return n;
            }
            canScrollVertically(direction) {
                if (this.getOverScrollMode() === View.OVER_SCROLL_ALWAYS)
                    return true;
                return super.canScrollVertically(direction);
            }
        }
        ScrollView.ANIMATED_SCROLL_GAP = 250;
        ScrollView.MAX_SCROLL_FACTOR = 0.5;
        ScrollView.TAG = "ScrollView";
        ScrollView.INVALID_POINTER = -1;
        widget.ScrollView = ScrollView;
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
///<reference path="../view/Gravity.ts"/>
///<reference path="../view/View.ts"/>
///<reference path="../view/ViewGroup.ts"/>
///<reference path="../graphics/drawable/Drawable.ts"/>
///<reference path="../graphics/Rect.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var Gravity = android.view.Gravity;
        var View = android.view.View;
        var MeasureSpec = View.MeasureSpec;
        var ViewGroup = android.view.ViewGroup;
        class LinearLayout extends ViewGroup {
            constructor(...args) {
                super(...args);
                this.mBaselineAligned = true;
                this.mBaselineAlignedChildIndex = -1;
                this.mBaselineChildTop = 0;
                this.mOrientation = 0;
                this.mGravity = Gravity.LEFT | Gravity.TOP;
                this.mTotalLength = 0;
                this.mWeightSum = -1;
                this.mUseLargestChild = false;
                this.mDividerWidth = 0;
                this.mDividerHeight = 0;
                this.mShowDividers = LinearLayout.SHOW_DIVIDER_NONE;
                this.mDividerPadding = 0;
            }
            createAttrChangeHandler(mergeHandler) {
                super.createAttrChangeHandler(mergeHandler);
                let linearLayout = this;
                mergeHandler.add({
                    set orientation(value) {
                        let isVertical = (value + "").toUpperCase() === 'VERTICAL';
                        if (isVertical) {
                            linearLayout.setOrientation(LinearLayout.VERTICAL);
                            return;
                        }
                        let isHorizontal = (value + "").toUpperCase() === 'HORIZONTAL';
                        if (isHorizontal) {
                            linearLayout.setOrientation(LinearLayout.HORIZONTAL);
                        }
                    },
                    get orientation() {
                        if (linearLayout.mOrientation === LinearLayout.VERTICAL) {
                            return 'VERTICAL';
                        }
                        else {
                            return 'HORIZONTAL';
                        }
                    },
                    set gravity(value) {
                        linearLayout.setGravity(View.AttrChangeHandler.parseGravity(value, linearLayout.mGravity));
                    },
                    get gravity() {
                        return linearLayout.mGravity;
                    },
                    set baselineAligned(value) {
                        if (!View.AttrChangeHandler.parseBoolean(value))
                            linearLayout.setBaselineAligned(false);
                    },
                    set weightSum(value) {
                        let weightSum = Number.parseInt(value);
                        if (Number.isSafeInteger(weightSum)) {
                            linearLayout.mWeightSum = weightSum;
                        }
                    },
                    get weightSum() {
                        return linearLayout.mWeightSum;
                    },
                    set baselineAlignedChildIndex(value) {
                        value = Number.parseInt(value);
                        if (Number.isSafeInteger(value)) {
                            linearLayout.mBaselineAlignedChildIndex = value;
                        }
                    },
                    set measureWithLargestChild(value) {
                        linearLayout.mUseLargestChild = View.AttrChangeHandler.parseBoolean(value, linearLayout.mUseLargestChild);
                    },
                    set divider(value) {
                    },
                    set showDividers(value) {
                        let fieldName = ('SHOW_DIVIDER_' + value).toUpperCase();
                        if (Number.isInteger(LinearLayout[fieldName])) {
                            linearLayout.mShowDividers = LinearLayout[fieldName];
                        }
                    },
                    set dividerPadding(value) {
                        value = Number.parseInt(value);
                        if (Number.isInteger(value)) {
                            linearLayout.mDividerPadding = value;
                        }
                    },
                    get dividerPadding() {
                        return linearLayout.mDividerPadding;
                    }
                });
            }
            setShowDividers(showDividers) {
                if (showDividers != this.mShowDividers) {
                    this.requestLayout();
                }
                this.mShowDividers = showDividers;
            }
            shouldDelayChildPressedState() {
                return false;
            }
            getShowDividers() {
                return this.mShowDividers;
            }
            getDividerDrawable() {
                return this.mDivider;
            }
            setDividerDrawable(divider) {
                if (divider == this.mDivider) {
                    return;
                }
                this.mDivider = divider;
                if (divider != null) {
                    this.mDividerWidth = divider.getIntrinsicWidth();
                    this.mDividerHeight = divider.getIntrinsicHeight();
                }
                else {
                    this.mDividerWidth = 0;
                    this.mDividerHeight = 0;
                }
                this.setWillNotDraw(divider == null);
                this.requestLayout();
            }
            setDividerPadding(padding) {
                this.mDividerPadding = padding;
            }
            getDividerPadding() {
                return this.mDividerPadding;
            }
            getDividerWidth() {
                return this.mDividerWidth;
            }
            onDraw(canvas) {
                if (this.mDivider == null) {
                    return;
                }
                if (this.mOrientation == LinearLayout.VERTICAL) {
                    this.drawDividersVertical(canvas);
                }
                else {
                    this.drawDividersHorizontal(canvas);
                }
            }
            drawDividersVertical(canvas) {
                const count = this.getVirtualChildCount();
                for (let i = 0; i < count; i++) {
                    const child = this.getVirtualChildAt(i);
                    if (child != null && child.getVisibility() != View.GONE) {
                        if (this.hasDividerBeforeChildAt(i)) {
                            const lp = child.getLayoutParams();
                            const top = child.getTop() - lp.topMargin - this.mDividerHeight;
                            this.drawHorizontalDivider(canvas, top);
                        }
                    }
                }
                if (this.hasDividerBeforeChildAt(count)) {
                    const child = this.getVirtualChildAt(count - 1);
                    let bottom = 0;
                    if (child == null) {
                        bottom = this.getHeight() - this.getPaddingBottom() - this.mDividerHeight;
                    }
                    else {
                        const lp = child.getLayoutParams();
                        bottom = child.getBottom() + lp.bottomMargin;
                    }
                    this.drawHorizontalDivider(canvas, bottom);
                }
            }
            drawDividersHorizontal(canvas) {
                const count = this.getVirtualChildCount();
                const isLayoutRtl = this.isLayoutRtl();
                for (let i = 0; i < count; i++) {
                    const child = this.getVirtualChildAt(i);
                    if (child != null && child.getVisibility() != View.GONE) {
                        if (this.hasDividerBeforeChildAt(i)) {
                            const lp = child.getLayoutParams();
                            let position;
                            if (isLayoutRtl) {
                                position = child.getRight() + lp.rightMargin;
                            }
                            else {
                                position = child.getLeft() - lp.leftMargin - this.mDividerWidth;
                            }
                            this.drawVerticalDivider(canvas, position);
                        }
                    }
                }
                if (this.hasDividerBeforeChildAt(count)) {
                    const child = this.getVirtualChildAt(count - 1);
                    let position;
                    if (child == null) {
                        if (isLayoutRtl) {
                            position = this.getPaddingLeft();
                        }
                        else {
                            position = this.getWidth() - this.getPaddingRight() - this.mDividerWidth;
                        }
                    }
                    else {
                        const lp = child.getLayoutParams();
                        if (isLayoutRtl) {
                            position = child.getLeft() - lp.leftMargin - this.mDividerWidth;
                        }
                        else {
                            position = child.getRight() + lp.rightMargin;
                        }
                    }
                    this.drawVerticalDivider(canvas, position);
                }
            }
            drawHorizontalDivider(canvas, top) {
                this.mDivider.setBounds(this.getPaddingLeft() + this.mDividerPadding, top, this.getWidth() - this.getPaddingRight() - this.mDividerPadding, top + this.mDividerHeight);
                this.mDivider.draw(canvas);
            }
            drawVerticalDivider(canvas, left) {
                this.mDivider.setBounds(left, this.getPaddingTop() + this.mDividerPadding, left + this.mDividerWidth, this.getHeight() - this.getPaddingBottom() - this.mDividerPadding);
                this.mDivider.draw(canvas);
            }
            isBaselineAligned() {
                return this.mBaselineAligned;
            }
            setBaselineAligned(baselineAligned) {
                this.mBaselineAligned = baselineAligned;
            }
            isMeasureWithLargestChildEnabled() {
                return this.mUseLargestChild;
            }
            setMeasureWithLargestChildEnabled(enabled) {
                this.mUseLargestChild = enabled;
            }
            getBaseline() {
                if (this.mBaselineAlignedChildIndex < 0) {
                    return super.getBaseline();
                }
                if (this.getChildCount() <= this.mBaselineAlignedChildIndex) {
                    throw new Error("mBaselineAlignedChildIndex of LinearLayout "
                        + "set to an index that is out of bounds.");
                }
                const child = this.getChildAt(this.mBaselineAlignedChildIndex);
                const childBaseline = child.getBaseline();
                if (childBaseline == -1) {
                    if (this.mBaselineAlignedChildIndex == 0) {
                        return -1;
                    }
                    throw new Error("mBaselineAlignedChildIndex of LinearLayout "
                        + "points to a View that doesn't know how to get its baseline.");
                }
                let childTop = this.mBaselineChildTop;
                if (this.mOrientation == LinearLayout.VERTICAL) {
                    const majorGravity = this.mGravity & Gravity.VERTICAL_GRAVITY_MASK;
                    if (majorGravity != Gravity.TOP) {
                        switch (majorGravity) {
                            case Gravity.BOTTOM:
                                childTop = this.mBottom - this.mTop - this.mPaddingBottom - this.mTotalLength;
                                break;
                            case Gravity.CENTER_VERTICAL:
                                childTop += ((this.mBottom - this.mTop - this.mPaddingTop - this.mPaddingBottom) -
                                    this.mTotalLength) / 2;
                                break;
                        }
                    }
                }
                let lp = child.getLayoutParams();
                return childTop + lp.topMargin + childBaseline;
            }
            getBaselineAlignedChildIndex() {
                return this.mBaselineAlignedChildIndex;
            }
            setBaselineAlignedChildIndex(i) {
                if ((i < 0) || (i >= this.getChildCount())) {
                    throw new Error("base aligned child index out "
                        + "of range (0, " + this.getChildCount() + ")");
                }
                this.mBaselineAlignedChildIndex = i;
            }
            getVirtualChildAt(index) {
                return this.getChildAt(index);
            }
            getVirtualChildCount() {
                return this.getChildCount();
            }
            getWeightSum() {
                return this.mWeightSum;
            }
            setWeightSum(weightSum) {
                this.mWeightSum = Math.max(0, weightSum);
            }
            onMeasure(widthMeasureSpec, heightMeasureSpec) {
                if (this.mOrientation == LinearLayout.VERTICAL) {
                    this.measureVertical(widthMeasureSpec, heightMeasureSpec);
                }
                else {
                    this.measureHorizontal(widthMeasureSpec, heightMeasureSpec);
                }
            }
            hasDividerBeforeChildAt(childIndex) {
                if (childIndex == 0) {
                    return (this.mShowDividers & LinearLayout.SHOW_DIVIDER_BEGINNING) != 0;
                }
                else if (childIndex == this.getChildCount()) {
                    return (this.mShowDividers & LinearLayout.SHOW_DIVIDER_END) != 0;
                }
                else if ((this.mShowDividers & LinearLayout.SHOW_DIVIDER_MIDDLE) != 0) {
                    let hasVisibleViewBefore = false;
                    for (let i = childIndex - 1; i >= 0; i--) {
                        if (this.getChildAt(i).getVisibility() != LinearLayout.GONE) {
                            hasVisibleViewBefore = true;
                            break;
                        }
                    }
                    return hasVisibleViewBefore;
                }
                return false;
            }
            measureVertical(widthMeasureSpec, heightMeasureSpec) {
                this.mTotalLength = 0;
                let maxWidth = 0;
                let childState = 0;
                let alternativeMaxWidth = 0;
                let weightedMaxWidth = 0;
                let allFillParent = true;
                let totalWeight = 0;
                const count = this.getVirtualChildCount();
                const widthMode = MeasureSpec.getMode(widthMeasureSpec);
                const heightMode = MeasureSpec.getMode(heightMeasureSpec);
                let matchWidth = false;
                const baselineChildIndex = this.mBaselineAlignedChildIndex;
                const useLargestChild = this.mUseLargestChild;
                let largestChildHeight = Number.MIN_SAFE_INTEGER;
                for (let i = 0; i < count; ++i) {
                    const child = this.getVirtualChildAt(i);
                    if (child == null) {
                        this.mTotalLength += this.measureNullChild(i);
                        continue;
                    }
                    if (child.getVisibility() == View.GONE) {
                        i += this.getChildrenSkipCount(child, i);
                        continue;
                    }
                    if (this.hasDividerBeforeChildAt(i)) {
                        this.mTotalLength += this.mDividerHeight;
                    }
                    let lp = child.getLayoutParams();
                    totalWeight += lp.weight;
                    if (heightMode == MeasureSpec.EXACTLY && lp.height == 0 && lp.weight > 0) {
                        const totalLength = this.mTotalLength;
                        this.mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);
                    }
                    else {
                        let oldHeight = Number.MIN_SAFE_INTEGER;
                        if (lp.height == 0 && lp.weight > 0) {
                            oldHeight = 0;
                            lp.height = LinearLayout.LayoutParams.WRAP_CONTENT;
                        }
                        this.measureChildBeforeLayout(child, i, widthMeasureSpec, 0, heightMeasureSpec, totalWeight == 0 ? this.mTotalLength : 0);
                        if (oldHeight != Number.MIN_SAFE_INTEGER) {
                            lp.height = oldHeight;
                        }
                        const childHeight = child.getMeasuredHeight();
                        const totalLength = this.mTotalLength;
                        this.mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +
                            lp.bottomMargin + this.getNextLocationOffset(child));
                        if (useLargestChild) {
                            largestChildHeight = Math.max(childHeight, largestChildHeight);
                        }
                    }
                    if ((baselineChildIndex >= 0) && (baselineChildIndex == i + 1)) {
                        this.mBaselineChildTop = this.mTotalLength;
                    }
                    if (i < baselineChildIndex && lp.weight > 0) {
                        throw new Error("A child of LinearLayout with index "
                            + "less than mBaselineAlignedChildIndex has weight > 0, which "
                            + "won't work.  Either remove the weight, or don't set "
                            + "mBaselineAlignedChildIndex.");
                    }
                    let matchWidthLocally = false;
                    if (widthMode != MeasureSpec.EXACTLY && lp.width == LinearLayout.LayoutParams.MATCH_PARENT) {
                        matchWidth = true;
                        matchWidthLocally = true;
                    }
                    const margin = lp.leftMargin + lp.rightMargin;
                    const measuredWidth = child.getMeasuredWidth() + margin;
                    maxWidth = Math.max(maxWidth, measuredWidth);
                    childState = LinearLayout.combineMeasuredStates(childState, child.getMeasuredState());
                    allFillParent = allFillParent && lp.width == LinearLayout.LayoutParams.MATCH_PARENT;
                    if (lp.weight > 0) {
                        weightedMaxWidth = Math.max(weightedMaxWidth, matchWidthLocally ? margin : measuredWidth);
                    }
                    else {
                        alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
                    }
                    i += this.getChildrenSkipCount(child, i);
                }
                if (this.mTotalLength > 0 && this.hasDividerBeforeChildAt(count)) {
                    this.mTotalLength += this.mDividerHeight;
                }
                if (useLargestChild &&
                    (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) {
                    this.mTotalLength = 0;
                    for (let i = 0; i < count; ++i) {
                        const child = this.getVirtualChildAt(i);
                        if (child == null) {
                            this.mTotalLength += this.measureNullChild(i);
                            continue;
                        }
                        if (child.getVisibility() == View.GONE) {
                            i += this.getChildrenSkipCount(child, i);
                            continue;
                        }
                        const lp = child.getLayoutParams();
                        const totalLength = this.mTotalLength;
                        this.mTotalLength = Math.max(totalLength, totalLength + largestChildHeight +
                            lp.topMargin + lp.bottomMargin + this.getNextLocationOffset(child));
                    }
                }
                this.mTotalLength += this.mPaddingTop + this.mPaddingBottom;
                let heightSize = this.mTotalLength;
                heightSize = Math.max(heightSize, this.getSuggestedMinimumHeight());
                let heightSizeAndState = LinearLayout.resolveSizeAndState(heightSize, heightMeasureSpec, 0);
                heightSize = heightSizeAndState & View.MEASURED_SIZE_MASK;
                let delta = heightSize - this.mTotalLength;
                if (delta != 0 && totalWeight > 0) {
                    let weightSum = this.mWeightSum > 0 ? this.mWeightSum : totalWeight;
                    this.mTotalLength = 0;
                    for (let i = 0; i < count; ++i) {
                        const child = this.getVirtualChildAt(i);
                        if (child.getVisibility() == View.GONE) {
                            continue;
                        }
                        let lp = child.getLayoutParams();
                        let childExtra = lp.weight;
                        if (childExtra > 0) {
                            let share = (childExtra * delta / weightSum);
                            weightSum -= childExtra;
                            delta -= share;
                            const childWidthMeasureSpec = LinearLayout.getChildMeasureSpec(widthMeasureSpec, this.mPaddingLeft + this.mPaddingRight +
                                lp.leftMargin + lp.rightMargin, lp.width);
                            if ((lp.height != 0) || (heightMode != MeasureSpec.EXACTLY)) {
                                let childHeight = child.getMeasuredHeight() + share;
                                if (childHeight < 0) {
                                    childHeight = 0;
                                }
                                child.measure(childWidthMeasureSpec, MeasureSpec.makeMeasureSpec(childHeight, MeasureSpec.EXACTLY));
                            }
                            else {
                                child.measure(childWidthMeasureSpec, MeasureSpec.makeMeasureSpec(share > 0 ? share : 0, MeasureSpec.EXACTLY));
                            }
                            childState = LinearLayout.combineMeasuredStates(childState, child.getMeasuredState()
                                & (View.MEASURED_STATE_MASK >> View.MEASURED_HEIGHT_STATE_SHIFT));
                        }
                        const margin = lp.leftMargin + lp.rightMargin;
                        const measuredWidth = child.getMeasuredWidth() + margin;
                        maxWidth = Math.max(maxWidth, measuredWidth);
                        let matchWidthLocally = widthMode != MeasureSpec.EXACTLY &&
                            lp.width == LinearLayout.LayoutParams.MATCH_PARENT;
                        alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
                        allFillParent = allFillParent && lp.width == LinearLayout.LayoutParams.MATCH_PARENT;
                        const totalLength = this.mTotalLength;
                        this.mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() +
                            lp.topMargin + lp.bottomMargin + this.getNextLocationOffset(child));
                    }
                    this.mTotalLength += this.mPaddingTop + this.mPaddingBottom;
                }
                else {
                    alternativeMaxWidth = Math.max(alternativeMaxWidth, weightedMaxWidth);
                    if (useLargestChild && heightMode != MeasureSpec.EXACTLY) {
                        for (let i = 0; i < count; i++) {
                            const child = this.getVirtualChildAt(i);
                            if (child == null || child.getVisibility() == View.GONE) {
                                continue;
                            }
                            const lp = child.getLayoutParams();
                            let childExtra = lp.weight;
                            if (childExtra > 0) {
                                child.measure(MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(largestChildHeight, MeasureSpec.EXACTLY));
                            }
                        }
                    }
                }
                if (!allFillParent && widthMode != MeasureSpec.EXACTLY) {
                    maxWidth = alternativeMaxWidth;
                }
                maxWidth += this.mPaddingLeft + this.mPaddingRight;
                maxWidth = Math.max(maxWidth, this.getSuggestedMinimumWidth());
                this.setMeasuredDimension(LinearLayout.resolveSizeAndState(maxWidth, widthMeasureSpec, childState), heightSizeAndState);
                if (matchWidth) {
                    this.forceUniformWidth(count, heightMeasureSpec);
                }
            }
            forceUniformWidth(count, heightMeasureSpec) {
                let uniformMeasureSpec = MeasureSpec.makeMeasureSpec(this.getMeasuredWidth(), MeasureSpec.EXACTLY);
                for (let i = 0; i < count; ++i) {
                    const child = this.getVirtualChildAt(i);
                    if (child.getVisibility() != View.GONE) {
                        let lp = child.getLayoutParams();
                        if (lp.width == LinearLayout.LayoutParams.MATCH_PARENT) {
                            let oldHeight = lp.height;
                            lp.height = child.getMeasuredHeight();
                            this.measureChildWithMargins(child, uniformMeasureSpec, 0, heightMeasureSpec, 0);
                            lp.height = oldHeight;
                        }
                    }
                }
            }
            measureHorizontal(widthMeasureSpec, heightMeasureSpec) {
                this.mTotalLength = 0;
                let maxHeight = 0;
                let childState = 0;
                let alternativeMaxHeight = 0;
                let weightedMaxHeight = 0;
                let allFillParent = true;
                let totalWeight = 0;
                const count = this.getVirtualChildCount();
                const widthMode = MeasureSpec.getMode(widthMeasureSpec);
                const heightMode = MeasureSpec.getMode(heightMeasureSpec);
                let matchHeight = false;
                if (this.mMaxAscent == null || this.mMaxDescent == null) {
                    this.mMaxAscent = new Array(LinearLayout.VERTICAL_GRAVITY_COUNT);
                    this.mMaxDescent = new Array(LinearLayout.VERTICAL_GRAVITY_COUNT);
                }
                let maxAscent = this.mMaxAscent;
                let maxDescent = this.mMaxDescent;
                maxAscent[0] = maxAscent[1] = maxAscent[2] = maxAscent[3] = -1;
                maxDescent[0] = maxDescent[1] = maxDescent[2] = maxDescent[3] = -1;
                const baselineAligned = this.mBaselineAligned;
                const useLargestChild = this.mUseLargestChild;
                const isExactly = widthMode == MeasureSpec.EXACTLY;
                let largestChildWidth = Number.MAX_SAFE_INTEGER;
                for (let i = 0; i < count; ++i) {
                    const child = this.getVirtualChildAt(i);
                    if (child == null) {
                        this.mTotalLength += this.measureNullChild(i);
                        continue;
                    }
                    if (child.getVisibility() == View.GONE) {
                        i += this.getChildrenSkipCount(child, i);
                        continue;
                    }
                    if (this.hasDividerBeforeChildAt(i)) {
                        this.mTotalLength += this.mDividerWidth;
                    }
                    const lp = child.getLayoutParams();
                    totalWeight += lp.weight;
                    if (widthMode == MeasureSpec.EXACTLY && lp.width == 0 && lp.weight > 0) {
                        if (isExactly) {
                            this.mTotalLength += lp.leftMargin + lp.rightMargin;
                        }
                        else {
                            const totalLength = this.mTotalLength;
                            this.mTotalLength = Math.max(totalLength, totalLength +
                                lp.leftMargin + lp.rightMargin);
                        }
                        if (baselineAligned) {
                            const freeSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
                            child.measure(freeSpec, freeSpec);
                        }
                    }
                    else {
                        let oldWidth = Number.MIN_SAFE_INTEGER;
                        if (lp.width == 0 && lp.weight > 0) {
                            oldWidth = 0;
                            lp.width = LinearLayout.LayoutParams.WRAP_CONTENT;
                        }
                        this.measureChildBeforeLayout(child, i, widthMeasureSpec, totalWeight == 0 ? this.mTotalLength : 0, heightMeasureSpec, 0);
                        if (oldWidth != Number.MIN_SAFE_INTEGER) {
                            lp.width = oldWidth;
                        }
                        const childWidth = child.getMeasuredWidth();
                        if (isExactly) {
                            this.mTotalLength += childWidth + lp.leftMargin + lp.rightMargin +
                                this.getNextLocationOffset(child);
                        }
                        else {
                            const totalLength = this.mTotalLength;
                            this.mTotalLength = Math.max(totalLength, totalLength + childWidth + lp.leftMargin +
                                lp.rightMargin + this.getNextLocationOffset(child));
                        }
                        if (useLargestChild) {
                            largestChildWidth = Math.max(childWidth, largestChildWidth);
                        }
                    }
                    let matchHeightLocally = false;
                    if (heightMode != MeasureSpec.EXACTLY && lp.height == LinearLayout.LayoutParams.MATCH_PARENT) {
                        matchHeight = true;
                        matchHeightLocally = true;
                    }
                    const margin = lp.topMargin + lp.bottomMargin;
                    const childHeight = child.getMeasuredHeight() + margin;
                    childState = LinearLayout.combineMeasuredStates(childState, child.getMeasuredState());
                    if (baselineAligned) {
                        const childBaseline = child.getBaseline();
                        if (childBaseline != -1) {
                            const gravity = (lp.gravity < 0 ? this.mGravity : lp.gravity)
                                & Gravity.VERTICAL_GRAVITY_MASK;
                            const index = ((gravity >> Gravity.AXIS_Y_SHIFT)
                                & ~Gravity.AXIS_SPECIFIED) >> 1;
                            maxAscent[index] = Math.max(maxAscent[index], childBaseline);
                            maxDescent[index] = Math.max(maxDescent[index], childHeight - childBaseline);
                        }
                    }
                    maxHeight = Math.max(maxHeight, childHeight);
                    allFillParent = allFillParent && lp.height == LinearLayout.LayoutParams.MATCH_PARENT;
                    if (lp.weight > 0) {
                        weightedMaxHeight = Math.max(weightedMaxHeight, matchHeightLocally ? margin : childHeight);
                    }
                    else {
                        alternativeMaxHeight = Math.max(alternativeMaxHeight, matchHeightLocally ? margin : childHeight);
                    }
                    i += this.getChildrenSkipCount(child, i);
                }
                if (this.mTotalLength > 0 && this.hasDividerBeforeChildAt(count)) {
                    this.mTotalLength += this.mDividerWidth;
                }
                if (maxAscent[LinearLayout.INDEX_TOP] != -1 ||
                    maxAscent[LinearLayout.INDEX_CENTER_VERTICAL] != -1 ||
                    maxAscent[LinearLayout.INDEX_BOTTOM] != -1 ||
                    maxAscent[LinearLayout.INDEX_FILL] != -1) {
                    const ascent = Math.max(maxAscent[LinearLayout.INDEX_FILL], Math.max(maxAscent[LinearLayout.INDEX_CENTER_VERTICAL], Math.max(maxAscent[LinearLayout.INDEX_TOP], maxAscent[LinearLayout.INDEX_BOTTOM])));
                    const descent = Math.max(maxDescent[LinearLayout.INDEX_FILL], Math.max(maxDescent[LinearLayout.INDEX_CENTER_VERTICAL], Math.max(maxDescent[LinearLayout.INDEX_TOP], maxDescent[LinearLayout.INDEX_BOTTOM])));
                    maxHeight = Math.max(maxHeight, ascent + descent);
                }
                if (useLargestChild &&
                    (widthMode == MeasureSpec.AT_MOST || widthMode == MeasureSpec.UNSPECIFIED)) {
                    this.mTotalLength = 0;
                    for (let i = 0; i < count; ++i) {
                        const child = this.getVirtualChildAt(i);
                        if (child == null) {
                            this.mTotalLength += this.measureNullChild(i);
                            continue;
                        }
                        if (child.getVisibility() == View.GONE) {
                            i += this.getChildrenSkipCount(child, i);
                            continue;
                        }
                        const lp = child.getLayoutParams();
                        if (isExactly) {
                            this.mTotalLength += largestChildWidth + lp.leftMargin + lp.rightMargin +
                                this.getNextLocationOffset(child);
                        }
                        else {
                            const totalLength = this.mTotalLength;
                            this.mTotalLength = Math.max(totalLength, totalLength + largestChildWidth +
                                lp.leftMargin + lp.rightMargin + this.getNextLocationOffset(child));
                        }
                    }
                }
                this.mTotalLength += this.mPaddingLeft + this.mPaddingRight;
                let widthSize = this.mTotalLength;
                widthSize = Math.max(widthSize, this.getSuggestedMinimumWidth());
                let widthSizeAndState = LinearLayout.resolveSizeAndState(widthSize, widthMeasureSpec, 0);
                widthSize = widthSizeAndState & View.MEASURED_SIZE_MASK;
                let delta = widthSize - this.mTotalLength;
                if (delta != 0 && totalWeight > 0) {
                    let weightSum = this.mWeightSum > 0 ? this.mWeightSum : totalWeight;
                    maxAscent[0] = maxAscent[1] = maxAscent[2] = maxAscent[3] = -1;
                    maxDescent[0] = maxDescent[1] = maxDescent[2] = maxDescent[3] = -1;
                    maxHeight = -1;
                    this.mTotalLength = 0;
                    for (let i = 0; i < count; ++i) {
                        const child = this.getVirtualChildAt(i);
                        if (child == null || child.getVisibility() == View.GONE) {
                            continue;
                        }
                        const lp = child.getLayoutParams();
                        let childExtra = lp.weight;
                        if (childExtra > 0) {
                            let share = (childExtra * delta / weightSum);
                            weightSum -= childExtra;
                            delta -= share;
                            const childHeightMeasureSpec = LinearLayout.getChildMeasureSpec(heightMeasureSpec, this.mPaddingTop + this.mPaddingBottom + lp.topMargin + lp.bottomMargin, lp.height);
                            if ((lp.width != 0) || (widthMode != MeasureSpec.EXACTLY)) {
                                let childWidth = child.getMeasuredWidth() + share;
                                if (childWidth < 0) {
                                    childWidth = 0;
                                }
                                child.measure(MeasureSpec.makeMeasureSpec(childWidth, MeasureSpec.EXACTLY), childHeightMeasureSpec);
                            }
                            else {
                                child.measure(MeasureSpec.makeMeasureSpec(share > 0 ? share : 0, MeasureSpec.EXACTLY), childHeightMeasureSpec);
                            }
                            childState = LinearLayout.combineMeasuredStates(childState, child.getMeasuredState() & View.MEASURED_STATE_MASK);
                        }
                        if (isExactly) {
                            this.mTotalLength += child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin +
                                this.getNextLocationOffset(child);
                        }
                        else {
                            const totalLength = this.mTotalLength;
                            this.mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredWidth() +
                                lp.leftMargin + lp.rightMargin + this.getNextLocationOffset(child));
                        }
                        let matchHeightLocally = heightMode != MeasureSpec.EXACTLY &&
                            lp.height == LinearLayout.LayoutParams.MATCH_PARENT;
                        const margin = lp.topMargin + lp.bottomMargin;
                        let childHeight = child.getMeasuredHeight() + margin;
                        maxHeight = Math.max(maxHeight, childHeight);
                        alternativeMaxHeight = Math.max(alternativeMaxHeight, matchHeightLocally ? margin : childHeight);
                        allFillParent = allFillParent && lp.height == LinearLayout.LayoutParams.MATCH_PARENT;
                        if (baselineAligned) {
                            const childBaseline = child.getBaseline();
                            if (childBaseline != -1) {
                                const gravity = (lp.gravity < 0 ? this.mGravity : lp.gravity)
                                    & Gravity.VERTICAL_GRAVITY_MASK;
                                const index = ((gravity >> Gravity.AXIS_Y_SHIFT)
                                    & ~Gravity.AXIS_SPECIFIED) >> 1;
                                maxAscent[index] = Math.max(maxAscent[index], childBaseline);
                                maxDescent[index] = Math.max(maxDescent[index], childHeight - childBaseline);
                            }
                        }
                    }
                    this.mTotalLength += this.mPaddingLeft + this.mPaddingRight;
                    if (maxAscent[LinearLayout.INDEX_TOP] != -1 ||
                        maxAscent[LinearLayout.INDEX_CENTER_VERTICAL] != -1 ||
                        maxAscent[LinearLayout.INDEX_BOTTOM] != -1 ||
                        maxAscent[LinearLayout.INDEX_FILL] != -1) {
                        const ascent = Math.max(maxAscent[LinearLayout.INDEX_FILL], Math.max(maxAscent[LinearLayout.INDEX_CENTER_VERTICAL], Math.max(maxAscent[LinearLayout.INDEX_TOP], maxAscent[LinearLayout.INDEX_BOTTOM])));
                        const descent = Math.max(maxDescent[LinearLayout.INDEX_FILL], Math.max(maxDescent[LinearLayout.INDEX_CENTER_VERTICAL], Math.max(maxDescent[LinearLayout.INDEX_TOP], maxDescent[LinearLayout.INDEX_BOTTOM])));
                        maxHeight = Math.max(maxHeight, ascent + descent);
                    }
                }
                else {
                    alternativeMaxHeight = Math.max(alternativeMaxHeight, weightedMaxHeight);
                    if (useLargestChild && widthMode != MeasureSpec.EXACTLY) {
                        for (let i = 0; i < count; i++) {
                            const child = this.getVirtualChildAt(i);
                            if (child == null || child.getVisibility() == View.GONE) {
                                continue;
                            }
                            const lp = child.getLayoutParams();
                            let childExtra = lp.weight;
                            if (childExtra > 0) {
                                child.measure(MeasureSpec.makeMeasureSpec(largestChildWidth, MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(child.getMeasuredHeight(), MeasureSpec.EXACTLY));
                            }
                        }
                    }
                }
                if (!allFillParent && heightMode != MeasureSpec.EXACTLY) {
                    maxHeight = alternativeMaxHeight;
                }
                maxHeight += this.mPaddingTop + this.mPaddingBottom;
                maxHeight = Math.max(maxHeight, this.getSuggestedMinimumHeight());
                this.setMeasuredDimension(widthSizeAndState | (childState & View.MEASURED_STATE_MASK), LinearLayout.resolveSizeAndState(maxHeight, heightMeasureSpec, (childState << View.MEASURED_HEIGHT_STATE_SHIFT)));
                if (matchHeight) {
                    this.forceUniformHeight(count, widthMeasureSpec);
                }
            }
            forceUniformHeight(count, widthMeasureSpec) {
                let uniformMeasureSpec = MeasureSpec.makeMeasureSpec(this.getMeasuredHeight(), MeasureSpec.EXACTLY);
                for (let i = 0; i < count; ++i) {
                    const child = this.getVirtualChildAt(i);
                    if (child.getVisibility() != View.GONE) {
                        let lp = child.getLayoutParams();
                        if (lp.height == LinearLayout.LayoutParams.MATCH_PARENT) {
                            let oldWidth = lp.width;
                            lp.width = child.getMeasuredWidth();
                            this.measureChildWithMargins(child, widthMeasureSpec, 0, uniformMeasureSpec, 0);
                            lp.width = oldWidth;
                        }
                    }
                }
            }
            getChildrenSkipCount(child, index) {
                return 0;
            }
            measureNullChild(childIndex) {
                return 0;
            }
            measureChildBeforeLayout(child, childIndex, widthMeasureSpec, totalWidth, heightMeasureSpec, totalHeight) {
                this.measureChildWithMargins(child, widthMeasureSpec, totalWidth, heightMeasureSpec, totalHeight);
            }
            getLocationOffset(child) {
                return 0;
            }
            getNextLocationOffset(child) {
                return 0;
            }
            onLayout(changed, l, t, r, b) {
                if (this.mOrientation == LinearLayout.VERTICAL) {
                    this.layoutVertical(l, t, r, b);
                }
                else {
                    this.layoutHorizontal(l, t, r, b);
                }
            }
            layoutVertical(left, top, right, bottom) {
                const paddingLeft = this.mPaddingLeft;
                let childTop;
                let childLeft;
                const width = right - left;
                let childRight = width - this.mPaddingRight;
                let childSpace = width - paddingLeft - this.mPaddingRight;
                const count = this.getVirtualChildCount();
                const majorGravity = this.mGravity & Gravity.VERTICAL_GRAVITY_MASK;
                const minorGravity = this.mGravity & Gravity.HORIZONTAL_GRAVITY_MASK;
                switch (majorGravity) {
                    case Gravity.BOTTOM:
                        childTop = this.mPaddingTop + bottom - top - this.mTotalLength;
                        break;
                    case Gravity.CENTER_VERTICAL:
                        childTop = this.mPaddingTop + (bottom - top - this.mTotalLength) / 2;
                        break;
                    case Gravity.TOP:
                    default:
                        childTop = this.mPaddingTop;
                        break;
                }
                for (let i = 0; i < count; i++) {
                    const child = this.getVirtualChildAt(i);
                    if (child == null) {
                        childTop += this.measureNullChild(i);
                    }
                    else if (child.getVisibility() != View.GONE) {
                        const childWidth = child.getMeasuredWidth();
                        const childHeight = child.getMeasuredHeight();
                        const lp = child.getLayoutParams();
                        let gravity = lp.gravity;
                        if (gravity < 0) {
                            gravity = minorGravity;
                        }
                        const absoluteGravity = gravity;
                        switch (absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
                            case Gravity.CENTER_HORIZONTAL:
                                childLeft = paddingLeft + ((childSpace - childWidth) / 2)
                                    + lp.leftMargin - lp.rightMargin;
                                break;
                            case Gravity.RIGHT:
                                childLeft = childRight - childWidth - lp.rightMargin;
                                break;
                            case Gravity.LEFT:
                            default:
                                childLeft = paddingLeft + lp.leftMargin;
                                break;
                        }
                        if (this.hasDividerBeforeChildAt(i)) {
                            childTop += this.mDividerHeight;
                        }
                        childTop += lp.topMargin;
                        this.setChildFrame(child, childLeft, childTop + this.getLocationOffset(child), childWidth, childHeight);
                        childTop += childHeight + lp.bottomMargin + this.getNextLocationOffset(child);
                        i += this.getChildrenSkipCount(child, i);
                    }
                }
            }
            layoutHorizontal(left, top, right, bottom) {
                const isLayoutRtl = this.isLayoutRtl();
                const paddingTop = this.mPaddingTop;
                let childTop;
                let childLeft;
                const height = bottom - top;
                let childBottom = height - this.mPaddingBottom;
                let childSpace = height - paddingTop - this.mPaddingBottom;
                const count = this.getVirtualChildCount();
                const majorGravity = this.mGravity & Gravity.HORIZONTAL_GRAVITY_MASK;
                const minorGravity = this.mGravity & Gravity.VERTICAL_GRAVITY_MASK;
                const baselineAligned = this.mBaselineAligned;
                const maxAscent = this.mMaxAscent;
                const maxDescent = this.mMaxDescent;
                let absoluteGravity = majorGravity;
                switch (absoluteGravity) {
                    case Gravity.RIGHT:
                        childLeft = this.mPaddingLeft + right - left - this.mTotalLength;
                        break;
                    case Gravity.CENTER_HORIZONTAL:
                        childLeft = this.mPaddingLeft + (right - left - this.mTotalLength) / 2;
                        break;
                    case Gravity.LEFT:
                    default:
                        childLeft = this.mPaddingLeft;
                        break;
                }
                let start = 0;
                let dir = 1;
                if (isLayoutRtl) {
                    start = count - 1;
                    dir = -1;
                }
                for (let i = 0; i < count; i++) {
                    let childIndex = start + dir * i;
                    const child = this.getVirtualChildAt(childIndex);
                    if (child == null) {
                        childLeft += this.measureNullChild(childIndex);
                    }
                    else if (child.getVisibility() != View.GONE) {
                        const childWidth = child.getMeasuredWidth();
                        const childHeight = child.getMeasuredHeight();
                        let childBaseline = -1;
                        const lp = child.getLayoutParams();
                        if (baselineAligned && lp.height != LinearLayout.LayoutParams.MATCH_PARENT) {
                            childBaseline = child.getBaseline();
                        }
                        let gravity = lp.gravity;
                        if (gravity < 0) {
                            gravity = minorGravity;
                        }
                        switch (gravity & Gravity.VERTICAL_GRAVITY_MASK) {
                            case Gravity.TOP:
                                childTop = paddingTop + lp.topMargin;
                                if (childBaseline != -1) {
                                    childTop += maxAscent[LinearLayout.INDEX_TOP] - childBaseline;
                                }
                                break;
                            case Gravity.CENTER_VERTICAL:
                                childTop = paddingTop + ((childSpace - childHeight) / 2)
                                    + lp.topMargin - lp.bottomMargin;
                                break;
                            case Gravity.BOTTOM:
                                childTop = childBottom - childHeight - lp.bottomMargin;
                                if (childBaseline != -1) {
                                    let descent = child.getMeasuredHeight() - childBaseline;
                                    childTop -= (maxDescent[LinearLayout.INDEX_BOTTOM] - descent);
                                }
                                break;
                            default:
                                childTop = paddingTop;
                                break;
                        }
                        if (this.hasDividerBeforeChildAt(childIndex)) {
                            childLeft += this.mDividerWidth;
                        }
                        childLeft += lp.leftMargin;
                        this.setChildFrame(child, childLeft + this.getLocationOffset(child), childTop, childWidth, childHeight);
                        childLeft += childWidth + lp.rightMargin +
                            this.getNextLocationOffset(child);
                        i += this.getChildrenSkipCount(child, childIndex);
                    }
                }
            }
            setChildFrame(child, left, top, width, height) {
                child.layout(left, top, left + width, top + height);
            }
            setOrientation(orientation) {
                if (typeof orientation === 'string') {
                    if ('VERTICAL' === (orientation + '').toUpperCase())
                        orientation = LinearLayout.VERTICAL;
                    else if ('HORIZONTAL' === (orientation + '').toUpperCase())
                        orientation = LinearLayout.HORIZONTAL;
                }
                if (this.mOrientation != orientation) {
                    this.mOrientation = orientation;
                    this.requestLayout();
                }
            }
            getOrientation() {
                return this.mOrientation;
            }
            setGravity(gravity) {
                if (this.mGravity != gravity) {
                    if ((gravity & Gravity.HORIZONTAL_GRAVITY_MASK) == 0) {
                        gravity |= Gravity.LEFT;
                    }
                    if ((gravity & Gravity.VERTICAL_GRAVITY_MASK) == 0) {
                        gravity |= Gravity.TOP;
                    }
                    this.mGravity = gravity;
                    this.requestLayout();
                }
            }
            setHorizontalGravity(horizontalGravity) {
                const gravity = horizontalGravity & Gravity.HORIZONTAL_GRAVITY_MASK;
                if ((this.mGravity & Gravity.HORIZONTAL_GRAVITY_MASK) != gravity) {
                    this.mGravity = (this.mGravity & ~Gravity.HORIZONTAL_GRAVITY_MASK) | gravity;
                    this.requestLayout();
                }
            }
            setVerticalGravity(verticalGravity) {
                const gravity = verticalGravity & Gravity.VERTICAL_GRAVITY_MASK;
                if ((this.mGravity & Gravity.VERTICAL_GRAVITY_MASK) != gravity) {
                    this.mGravity = (this.mGravity & ~Gravity.VERTICAL_GRAVITY_MASK) | gravity;
                    this.requestLayout();
                }
            }
            generateDefaultLayoutParams() {
                let LayoutParams = LinearLayout.LayoutParams;
                if (this.mOrientation == LinearLayout.HORIZONTAL) {
                    return new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
                }
                else if (this.mOrientation == LinearLayout.VERTICAL) {
                    return new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
                }
                return super.generateDefaultLayoutParams();
            }
            generateLayoutParams(p) {
                return new LinearLayout.LayoutParams(p);
            }
            checkLayoutParams(p) {
                return p instanceof LinearLayout.LayoutParams;
            }
        }
        LinearLayout.HORIZONTAL = 0;
        LinearLayout.VERTICAL = 1;
        LinearLayout.SHOW_DIVIDER_NONE = 0;
        LinearLayout.SHOW_DIVIDER_BEGINNING = 1;
        LinearLayout.SHOW_DIVIDER_MIDDLE = 2;
        LinearLayout.SHOW_DIVIDER_END = 4;
        LinearLayout.VERTICAL_GRAVITY_COUNT = 4;
        LinearLayout.INDEX_CENTER_VERTICAL = 0;
        LinearLayout.INDEX_TOP = 1;
        LinearLayout.INDEX_BOTTOM = 2;
        LinearLayout.INDEX_FILL = 3;
        widget.LinearLayout = LinearLayout;
        (function (LinearLayout) {
            class LayoutParams extends android.view.ViewGroup.MarginLayoutParams {
                constructor(...args) {
                    super();
                    this.weight = 0;
                    this.gravity = -1;
                    if (args.length === 1 && args[0] instanceof LayoutParams) {
                        this.gravity = args[0].gravity;
                    }
                    else {
                        let [width, height, weight = 0] = args;
                        super(width, height);
                        this.weight = weight;
                    }
                }
                _createAttrChangeHandler(mergeHandler) {
                    super._createAttrChangeHandler(mergeHandler);
                    let params = this;
                    mergeHandler.add({
                        set gravity(value) {
                            params.gravity = View.AttrChangeHandler.parseGravity(value, params.gravity);
                        },
                        get gravity() {
                            return params.gravity;
                        },
                        set weight(value) {
                            value = Number.parseInt(value);
                            if (Number.isInteger(value))
                                params.weight = value;
                        },
                        get weight() {
                            return params.weight;
                        }
                    });
                }
            }
            LinearLayout.LayoutParams = LayoutParams;
        })(LinearLayout = widget.LinearLayout || (widget.LinearLayout = {}));
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/2.
 */
///<reference path="Drawable.ts"/>
///<reference path="../Canvas.ts"/>
///<reference path="../Rect.ts"/>
///<reference path="../PixelFormat.ts"/>
///<reference path="../../../java/lang/ref/WeakReference.ts"/>
///<reference path="../../../java/lang/Runnable.ts"/>
///<reference path="../../util/StateSet.ts"/>
///<reference path="../../util/Log.ts"/>
///<reference path="../../util/SparseArray.ts"/>
///<reference path="../../os/SystemClock.ts"/>
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        var drawable;
        (function (drawable) {
            var Rect = android.graphics.Rect;
            var PixelFormat = android.graphics.PixelFormat;
            var Log = android.util.Log;
            var SparseArray = android.util.SparseArray;
            var SystemClock = android.os.SystemClock;
            class DrawableContainer extends drawable.Drawable {
                constructor(...args) {
                    super(...args);
                    this.mAlpha = 0xFF;
                    this.mCurIndex = -1;
                    this.mMutated = false;
                    this.mEnterAnimationEnd = 0;
                    this.mExitAnimationEnd = 0;
                }
                draw(canvas) {
                    if (this.mCurrDrawable != null) {
                        this.mCurrDrawable.draw(canvas);
                    }
                    if (this.mLastDrawable != null) {
                        this.mLastDrawable.draw(canvas);
                    }
                }
                needsMirroring() {
                    return false && this.isAutoMirrored();
                }
                getPadding(padding) {
                    const r = this.mDrawableContainerState.getConstantPadding();
                    let result;
                    if (r != null) {
                        padding.set(r);
                        result = (r.left | r.top | r.bottom | r.right) != 0;
                    }
                    else {
                        if (this.mCurrDrawable != null) {
                            result = this.mCurrDrawable.getPadding(padding);
                        }
                        else {
                            result = super.getPadding(padding);
                        }
                    }
                    if (this.needsMirroring()) {
                        const left = padding.left;
                        const right = padding.right;
                        padding.left = right;
                        padding.right = left;
                    }
                    return result;
                }
                setAlpha(alpha) {
                    if (this.mAlpha != alpha) {
                        this.mAlpha = alpha;
                        if (this.mCurrDrawable != null) {
                            if (this.mEnterAnimationEnd == 0) {
                                this.mCurrDrawable.mutate().setAlpha(alpha);
                            }
                            else {
                                this.animate(false);
                            }
                        }
                    }
                }
                getAlpha() {
                    return this.mAlpha;
                }
                setDither(dither) {
                    if (this.mDrawableContainerState.mDither != dither) {
                        this.mDrawableContainerState.mDither = dither;
                        if (this.mCurrDrawable != null) {
                            this.mCurrDrawable.mutate().setDither(this.mDrawableContainerState.mDither);
                        }
                    }
                }
                setEnterFadeDuration(ms) {
                    this.mDrawableContainerState.mEnterFadeDuration = ms;
                }
                setExitFadeDuration(ms) {
                    this.mDrawableContainerState.mExitFadeDuration = ms;
                }
                onBoundsChange(bounds) {
                    if (this.mLastDrawable != null) {
                        this.mLastDrawable.setBounds(bounds);
                    }
                    if (this.mCurrDrawable != null) {
                        this.mCurrDrawable.setBounds(bounds);
                    }
                }
                isStateful() {
                    return this.mDrawableContainerState.isStateful();
                }
                setAutoMirrored(mirrored) {
                    this.mDrawableContainerState.mAutoMirrored = mirrored;
                    if (this.mCurrDrawable != null) {
                        this.mCurrDrawable.mutate().setAutoMirrored(this.mDrawableContainerState.mAutoMirrored);
                    }
                }
                isAutoMirrored() {
                    return this.mDrawableContainerState.mAutoMirrored;
                }
                jumpToCurrentState() {
                    let changed = false;
                    if (this.mLastDrawable != null) {
                        this.mLastDrawable.jumpToCurrentState();
                        this.mLastDrawable = null;
                        changed = true;
                    }
                    if (this.mCurrDrawable != null) {
                        this.mCurrDrawable.jumpToCurrentState();
                        this.mCurrDrawable.mutate().setAlpha(this.mAlpha);
                    }
                    if (this.mExitAnimationEnd != 0) {
                        this.mExitAnimationEnd = 0;
                        changed = true;
                    }
                    if (this.mEnterAnimationEnd != 0) {
                        this.mEnterAnimationEnd = 0;
                        changed = true;
                    }
                    if (changed) {
                        this.invalidateSelf();
                    }
                }
                onStateChange(state) {
                    if (this.mLastDrawable != null) {
                        return this.mLastDrawable.setState(state);
                    }
                    if (this.mCurrDrawable != null) {
                        return this.mCurrDrawable.setState(state);
                    }
                    return false;
                }
                onLevelChange(level) {
                    if (this.mLastDrawable != null) {
                        return this.mLastDrawable.setLevel(level);
                    }
                    if (this.mCurrDrawable != null) {
                        return this.mCurrDrawable.setLevel(level);
                    }
                    return false;
                }
                getIntrinsicWidth() {
                    if (this.mDrawableContainerState.isConstantSize()) {
                        return this.mDrawableContainerState.getConstantWidth();
                    }
                    return this.mCurrDrawable != null ? this.mCurrDrawable.getIntrinsicWidth() : -1;
                }
                getIntrinsicHeight() {
                    if (this.mDrawableContainerState.isConstantSize()) {
                        return this.mDrawableContainerState.getConstantHeight();
                    }
                    return this.mCurrDrawable != null ? this.mCurrDrawable.getIntrinsicHeight() : -1;
                }
                getMinimumWidth() {
                    if (this.mDrawableContainerState.isConstantSize()) {
                        return this.mDrawableContainerState.getConstantMinimumWidth();
                    }
                    return this.mCurrDrawable != null ? this.mCurrDrawable.getMinimumWidth() : 0;
                }
                getMinimumHeight() {
                    if (this.mDrawableContainerState.isConstantSize()) {
                        return this.mDrawableContainerState.getConstantMinimumHeight();
                    }
                    return this.mCurrDrawable != null ? this.mCurrDrawable.getMinimumHeight() : 0;
                }
                invalidateDrawable(who) {
                    if (who == this.mCurrDrawable && this.getCallback() != null) {
                        this.getCallback().invalidateDrawable(this);
                    }
                }
                scheduleDrawable(who, what, when) {
                    if (who == this.mCurrDrawable && this.getCallback() != null) {
                        this.getCallback().scheduleDrawable(this, what, when);
                    }
                }
                unscheduleDrawable(who, what) {
                    if (who == this.mCurrDrawable && this.getCallback() != null) {
                        this.getCallback().unscheduleDrawable(this, what);
                    }
                }
                setVisible(visible, restart) {
                    let changed = super.setVisible(visible, restart);
                    if (this.mLastDrawable != null) {
                        this.mLastDrawable.setVisible(visible, restart);
                    }
                    if (this.mCurrDrawable != null) {
                        this.mCurrDrawable.setVisible(visible, restart);
                    }
                    return changed;
                }
                getOpacity() {
                    return this.mCurrDrawable == null || !this.mCurrDrawable.isVisible() ? PixelFormat.TRANSPARENT :
                        this.mDrawableContainerState.getOpacity();
                }
                selectDrawable(idx) {
                    if (idx == this.mCurIndex) {
                        return false;
                    }
                    const now = SystemClock.uptimeMillis();
                    if (DrawableContainer.DEBUG)
                        android.util.Log.i(DrawableContainer.TAG, toString() + " from " + this.mCurIndex + " to " + idx
                            + ": exit=" + this.mDrawableContainerState.mExitFadeDuration
                            + " enter=" + this.mDrawableContainerState.mEnterFadeDuration);
                    if (this.mDrawableContainerState.mExitFadeDuration > 0) {
                        if (this.mLastDrawable != null) {
                            this.mLastDrawable.setVisible(false, false);
                        }
                        if (this.mCurrDrawable != null) {
                            this.mLastDrawable = this.mCurrDrawable;
                            this.mExitAnimationEnd = now + this.mDrawableContainerState.mExitFadeDuration;
                        }
                        else {
                            this.mLastDrawable = null;
                            this.mExitAnimationEnd = 0;
                        }
                    }
                    else if (this.mCurrDrawable != null) {
                        this.mCurrDrawable.setVisible(false, false);
                    }
                    if (idx >= 0 && idx < this.mDrawableContainerState.mNumChildren) {
                        const d = this.mDrawableContainerState.getChild(idx);
                        this.mCurrDrawable = d;
                        this.mCurIndex = idx;
                        if (d != null) {
                            d.mutate();
                            if (this.mDrawableContainerState.mEnterFadeDuration > 0) {
                                this.mEnterAnimationEnd = now + this.mDrawableContainerState.mEnterFadeDuration;
                            }
                            else {
                                d.setAlpha(this.mAlpha);
                            }
                            d.setVisible(this.isVisible(), true);
                            d.setDither(this.mDrawableContainerState.mDither);
                            d.setState(this.getState());
                            d.setLevel(this.getLevel());
                            d.setBounds(this.getBounds());
                            d.setAutoMirrored(this.mDrawableContainerState.mAutoMirrored);
                        }
                        else {
                        }
                    }
                    else {
                        this.mCurrDrawable = null;
                        this.mCurIndex = -1;
                    }
                    if (this.mEnterAnimationEnd != 0 || this.mExitAnimationEnd != 0) {
                        if (this.mAnimationRunnable == null) {
                            let t = this;
                            this.mAnimationRunnable = {
                                run() {
                                    t.animate(true);
                                    t.invalidateSelf();
                                }
                            };
                        }
                        else {
                            this.unscheduleSelf(this.mAnimationRunnable);
                        }
                        this.animate(true);
                    }
                    this.invalidateSelf();
                    return true;
                }
                animate(schedule) {
                    const now = SystemClock.uptimeMillis();
                    let animating = false;
                    if (this.mCurrDrawable != null) {
                        if (this.mEnterAnimationEnd != 0) {
                            if (this.mEnterAnimationEnd <= now) {
                                this.mCurrDrawable.mutate().setAlpha(this.mAlpha);
                                this.mEnterAnimationEnd = 0;
                            }
                            else {
                                let animAlpha = ((this.mEnterAnimationEnd - now) * 255)
                                    / this.mDrawableContainerState.mEnterFadeDuration;
                                if (DrawableContainer.DEBUG)
                                    android.util.Log.i(DrawableContainer.TAG, toString() + " cur alpha " + animAlpha);
                                this.mCurrDrawable.mutate().setAlpha(((255 - animAlpha) * this.mAlpha) / 255);
                                animating = true;
                            }
                        }
                    }
                    else {
                        this.mEnterAnimationEnd = 0;
                    }
                    if (this.mLastDrawable != null) {
                        if (this.mExitAnimationEnd != 0) {
                            if (this.mExitAnimationEnd <= now) {
                                this.mLastDrawable.setVisible(false, false);
                                this.mLastDrawable = null;
                                this.mExitAnimationEnd = 0;
                            }
                            else {
                                let animAlpha = ((this.mExitAnimationEnd - now) * 255)
                                    / this.mDrawableContainerState.mExitFadeDuration;
                                if (DrawableContainer.DEBUG)
                                    android.util.Log.i(DrawableContainer.TAG, toString() + " last alpha " + animAlpha);
                                this.mLastDrawable.mutate().setAlpha((animAlpha * this.mAlpha) / 255);
                                animating = true;
                            }
                        }
                    }
                    else {
                        this.mExitAnimationEnd = 0;
                    }
                    if (schedule && animating) {
                        this.scheduleSelf(this.mAnimationRunnable, now + 1000 / 60);
                    }
                }
                getCurrent() {
                    return this.mCurrDrawable;
                }
                getConstantState() {
                    if (this.mDrawableContainerState.canConstantState()) {
                        return this.mDrawableContainerState;
                    }
                    return null;
                }
                mutate() {
                    if (!this.mMutated && super.mutate() == this) {
                        this.mDrawableContainerState.mutate();
                        this.mMutated = true;
                    }
                    return this;
                }
                setConstantState(state) {
                    this.mDrawableContainerState = state;
                }
            }
            DrawableContainer.DEBUG = Log.DBG_DrawableContainer;
            DrawableContainer.TAG = "DrawableContainer";
            DrawableContainer.DEFAULT_DITHER = true;
            drawable.DrawableContainer = DrawableContainer;
            (function (DrawableContainer) {
                class DrawableContainerState {
                    constructor(orig, owner) {
                        this.mVariablePadding = false;
                        this.mPaddingChecked = false;
                        this.mConstantSize = false;
                        this.mComputedConstantSize = false;
                        this.mConstantWidth = 0;
                        this.mConstantHeight = 0;
                        this.mConstantMinimumWidth = 0;
                        this.mConstantMinimumHeight = 0;
                        this.mCheckedOpacity = false;
                        this.mOpacity = 0;
                        this.mCheckedStateful = false;
                        this.mStateful = false;
                        this.mCheckedConstantState = false;
                        this.mCanConstantState = false;
                        this.mDither = DrawableContainer.DEFAULT_DITHER;
                        this.mMutated = false;
                        this.mEnterFadeDuration = 0;
                        this.mExitFadeDuration = 0;
                        this.mAutoMirrored = false;
                        this.mOwner = owner;
                        if (orig != null) {
                            this.mCheckedConstantState = true;
                            this.mCanConstantState = true;
                            this.mVariablePadding = orig.mVariablePadding;
                            this.mConstantSize = orig.mConstantSize;
                            this.mDither = orig.mDither;
                            this.mMutated = orig.mMutated;
                            this.mEnterFadeDuration = orig.mEnterFadeDuration;
                            this.mExitFadeDuration = orig.mExitFadeDuration;
                            this.mAutoMirrored = orig.mAutoMirrored;
                            this.mConstantPadding = orig.getConstantPadding();
                            this.mPaddingChecked = true;
                            this.mConstantWidth = orig.getConstantWidth();
                            this.mConstantHeight = orig.getConstantHeight();
                            this.mConstantMinimumWidth = orig.getConstantMinimumWidth();
                            this.mConstantMinimumHeight = orig.getConstantMinimumHeight();
                            this.mComputedConstantSize = true;
                            this.mOpacity = orig.getOpacity();
                            this.mCheckedOpacity = true;
                            this.mStateful = orig.isStateful();
                            this.mCheckedStateful = true;
                            const origDr = orig.mDrawables;
                            this.mDrawables = new Array(0);
                            const origDf = orig.mDrawableFutures;
                            if (origDf != null) {
                                this.mDrawableFutures = origDf.clone();
                            }
                            else {
                                this.mDrawableFutures = new SparseArray(this.mNumChildren);
                            }
                            const N = this.mNumChildren;
                            for (let i = 0; i < N; i++) {
                                if (origDr[i] != null) {
                                    this.mDrawableFutures.put(i, new ConstantStateFuture(origDr[i]));
                                }
                            }
                        }
                        else {
                            this.mDrawables = new Array(0);
                        }
                    }
                    get mNumChildren() {
                        return this.mDrawables.length;
                    }
                    addChild(dr) {
                        const pos = this.mNumChildren;
                        dr.setVisible(false, true);
                        dr.setCallback(this.mOwner);
                        this.mDrawables.push(dr);
                        this.mCheckedStateful = false;
                        this.mCheckedOpacity = false;
                        this.mConstantPadding = null;
                        this.mPaddingChecked = false;
                        this.mComputedConstantSize = false;
                        return pos;
                    }
                    getCapacity() {
                        return this.mDrawables.length;
                    }
                    createAllFutures() {
                        if (this.mDrawableFutures != null) {
                            const futureCount = this.mDrawableFutures.size();
                            for (let keyIndex = 0; keyIndex < futureCount; keyIndex++) {
                                const index = this.mDrawableFutures.keyAt(keyIndex);
                                this.mDrawables[index] = this.mDrawableFutures.valueAt(keyIndex).get(this);
                            }
                            this.mDrawableFutures = null;
                        }
                    }
                    getChildCount() {
                        return this.mNumChildren;
                    }
                    getChildren() {
                        this.createAllFutures();
                        return this.mDrawables;
                    }
                    getChild(index) {
                        const result = this.mDrawables[index];
                        if (result != null) {
                            return result;
                        }
                        if (this.mDrawableFutures != null) {
                            const keyIndex = this.mDrawableFutures.indexOfKey(index);
                            if (keyIndex >= 0) {
                                const prepared = this.mDrawableFutures.valueAt(keyIndex).get(this);
                                this.mDrawables[index] = prepared;
                                this.mDrawableFutures.removeAt(keyIndex);
                                return prepared;
                            }
                        }
                        return null;
                    }
                    mutate() {
                        const N = this.mNumChildren;
                        const drawables = this.mDrawables;
                        for (let i = 0; i < N; i++) {
                            if (drawables[i] != null) {
                                drawables[i].mutate();
                            }
                        }
                        this.mMutated = true;
                    }
                    setVariablePadding(variable) {
                        this.mVariablePadding = variable;
                    }
                    getConstantPadding() {
                        if (this.mVariablePadding) {
                            return null;
                        }
                        if ((this.mConstantPadding != null) || this.mPaddingChecked) {
                            return this.mConstantPadding;
                        }
                        this.createAllFutures();
                        let r = null;
                        const t = new Rect();
                        const N = this.mNumChildren;
                        const drawables = this.mDrawables;
                        for (let i = 0; i < N; i++) {
                            if (drawables[i].getPadding(t)) {
                                if (r == null)
                                    r = new Rect(0, 0, 0, 0);
                                if (t.left > r.left)
                                    r.left = t.left;
                                if (t.top > r.top)
                                    r.top = t.top;
                                if (t.right > r.right)
                                    r.right = t.right;
                                if (t.bottom > r.bottom)
                                    r.bottom = t.bottom;
                            }
                        }
                        this.mPaddingChecked = true;
                        return (this.mConstantPadding = r);
                    }
                    setConstantSize(constant) {
                        this.mConstantSize = constant;
                    }
                    isConstantSize() {
                        return this.mConstantSize;
                    }
                    getConstantWidth() {
                        if (!this.mComputedConstantSize) {
                            this.computeConstantSize();
                        }
                        return this.mConstantWidth;
                    }
                    getConstantHeight() {
                        if (!this.mComputedConstantSize) {
                            this.computeConstantSize();
                        }
                        return this.mConstantHeight;
                    }
                    getConstantMinimumWidth() {
                        if (!this.mComputedConstantSize) {
                            this.computeConstantSize();
                        }
                        return this.mConstantMinimumWidth;
                    }
                    getConstantMinimumHeight() {
                        if (!this.mComputedConstantSize) {
                            this.computeConstantSize();
                        }
                        return this.mConstantMinimumHeight;
                    }
                    computeConstantSize() {
                        this.mComputedConstantSize = true;
                        this.createAllFutures();
                        const N = this.mNumChildren;
                        const drawables = this.mDrawables;
                        this.mConstantWidth = this.mConstantHeight = -1;
                        this.mConstantMinimumWidth = this.mConstantMinimumHeight = 0;
                        for (let i = 0; i < N; i++) {
                            const dr = drawables[i];
                            let s = dr.getIntrinsicWidth();
                            if (s > this.mConstantWidth)
                                this.mConstantWidth = s;
                            s = dr.getIntrinsicHeight();
                            if (s > this.mConstantHeight)
                                this.mConstantHeight = s;
                            s = dr.getMinimumWidth();
                            if (s > this.mConstantMinimumWidth)
                                this.mConstantMinimumWidth = s;
                            s = dr.getMinimumHeight();
                            if (s > this.mConstantMinimumHeight)
                                this.mConstantMinimumHeight = s;
                        }
                    }
                    setEnterFadeDuration(duration) {
                        this.mEnterFadeDuration = duration;
                    }
                    getEnterFadeDuration() {
                        return this.mEnterFadeDuration;
                    }
                    setExitFadeDuration(duration) {
                        this.mExitFadeDuration = duration;
                    }
                    getExitFadeDuration() {
                        return this.mExitFadeDuration;
                    }
                    getOpacity() {
                        if (this.mCheckedOpacity) {
                            return this.mOpacity;
                        }
                        this.createAllFutures();
                        this.mCheckedOpacity = true;
                        const N = this.mNumChildren;
                        const drawables = this.mDrawables;
                        let op = (N > 0) ? drawables[0].getOpacity() : PixelFormat.TRANSPARENT;
                        for (let i = 1; i < N; i++) {
                            op = drawable.Drawable.resolveOpacity(op, drawables[i].getOpacity());
                        }
                        this.mOpacity = op;
                        return op;
                    }
                    isStateful() {
                        if (this.mCheckedStateful) {
                            return this.mStateful;
                        }
                        this.createAllFutures();
                        this.mCheckedStateful = true;
                        const N = this.mNumChildren;
                        const drawables = this.mDrawables;
                        for (let i = 0; i < N; i++) {
                            if (drawables[i].isStateful()) {
                                this.mStateful = true;
                                return true;
                            }
                        }
                        this.mStateful = false;
                        return false;
                    }
                    canConstantState() {
                        if (this.mCheckedConstantState) {
                            return this.mCanConstantState;
                        }
                        this.createAllFutures();
                        this.mCheckedConstantState = true;
                        const N = this.mNumChildren;
                        const drawables = this.mDrawables;
                        for (let i = 0; i < N; i++) {
                            if (drawables[i].getConstantState() == null) {
                                this.mCanConstantState = false;
                                return false;
                            }
                        }
                        this.mCanConstantState = true;
                        return true;
                    }
                    newDrawable() {
                        return undefined;
                    }
                }
                DrawableContainer.DrawableContainerState = DrawableContainerState;
                class ConstantStateFuture {
                    constructor(source) {
                        this.mConstantState = source.getConstantState();
                    }
                    get(state) {
                        const result = this.mConstantState.newDrawable();
                        result.setCallback(state.mOwner);
                        if (state.mMutated) {
                            result.mutate();
                        }
                        return result;
                    }
                }
            })(DrawableContainer = drawable.DrawableContainer || (drawable.DrawableContainer = {}));
        })(drawable = graphics.drawable || (graphics.drawable = {}));
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/2.
 */
///<reference path="DrawableContainer.ts"/>
var android;
(function (android) {
    var graphics;
    (function (graphics) {
        var drawable;
        (function (drawable_2) {
            const DEBUG = android.util.Log.DBG_StateListDrawable;
            const TAG = "StateListDrawable";
            const DEFAULT_DITHER = true;
            class StateListDrawable extends drawable_2.DrawableContainer {
                constructor() {
                    super();
                    this.initWithState(null);
                }
                initWithState(state) {
                    let _as = new StateListState(state, this);
                    this.mStateListState = _as;
                    this.setConstantState(_as);
                    this.onStateChange(this.getState());
                }
                addState(stateSet, drawable) {
                    if (drawable != null) {
                        this.mStateListState.addStateSet(stateSet, drawable);
                        this.onStateChange(this.getState());
                    }
                }
                isStateful() {
                    return true;
                }
                onStateChange(stateSet) {
                    let idx = this.mStateListState.indexOfStateSet(stateSet);
                    if (DEBUG)
                        android.util.Log.i(TAG, "onStateChange " + this + " states "
                            + stateSet + " found " + idx);
                    if (idx < 0) {
                        idx = this.mStateListState.indexOfStateSet(android.util.StateSet.WILD_CARD);
                    }
                    if (this.selectDrawable(idx)) {
                        return true;
                    }
                    return super.onStateChange(stateSet);
                }
                getStateCount() {
                    return this.mStateListState.getChildCount();
                }
                getStateSet(index) {
                    return this.mStateListState.mStateSets[index];
                }
                getStateDrawable(index) {
                    return this.mStateListState.getChild(index);
                }
                getStateDrawableIndex(stateSet) {
                    return this.mStateListState.indexOfStateSet(stateSet);
                }
                mutate() {
                    if (!this.mMutated && super.mutate() == this) {
                        const sets = this.mStateListState.mStateSets;
                        const count = sets.length;
                        this.mStateListState.mStateSets = new Array(count);
                        for (let i = 0; i < count; i++) {
                            const _set = sets[i];
                            if (_set != null) {
                                this.mStateListState.mStateSets[i] = _set.concat();
                            }
                        }
                        this.mMutated = true;
                    }
                    return this;
                }
            }
            drawable_2.StateListDrawable = StateListDrawable;
            class StateListState extends drawable_2.DrawableContainer.DrawableContainerState {
                constructor(orig, owner) {
                    super(orig, owner);
                    if (orig != null) {
                        this.mStateSets = orig.mStateSets.concat();
                    }
                    else {
                        this.mStateSets = new Array(this.getCapacity());
                    }
                }
                addStateSet(stateSet, drawable) {
                    let pos = this.addChild(drawable);
                    this.mStateSets[pos] = stateSet;
                    return pos;
                }
                indexOfStateSet(stateSet) {
                    const stateSets = this.mStateSets;
                    const N = this.getChildCount();
                    for (let i = 0; i < N; i++) {
                        if (android.util.StateSet.stateSetMatches(stateSets[i], stateSet)) {
                            return i;
                        }
                    }
                    return -1;
                }
                newDrawable() {
                    let drawable = new StateListDrawable();
                    drawable.initWithState(this);
                    return drawable;
                }
            }
        })(drawable = graphics.drawable || (graphics.drawable = {}));
    })(graphics = android.graphics || (android.graphics = {}));
})(android || (android = {}));
///<reference path="../view/View.ts"/>
///<reference path="../content/res/Resources.ts"/>
///<reference path="../content/res/ColorStateList.ts"/>
///<reference path="../graphics/Color.ts"/>
///<reference path="../graphics/drawable/Drawable.ts"/>
///<reference path="../graphics/drawable/InsetDrawable.ts"/>
///<reference path="../graphics/drawable/ColorDrawable.ts"/>
///<reference path="../graphics/drawable/StateListDrawable.ts"/>
var android;
(function (android) {
    var R;
    (function (R) {
        var View = android.view.View;
        var ColorStateList = android.content.res.ColorStateList;
        class color {
            static get textView_textColor() {
                let _defaultStates = [[-View.VIEW_STATE_ENABLED], []];
                let _defaultColors = [0xffc0c0c0, 0xff333333];
                class DefaultStyleTextColor extends ColorStateList {
                    constructor() {
                        super(_defaultStates, _defaultColors);
                    }
                }
                return new DefaultStyleTextColor();
            }
        }
        R.color = color;
    })(R = android.R || (android.R = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/26.
 */
///<reference path="../view/View.ts"/>
///<reference path="../view/Gravity.ts"/>
///<reference path="../content/res/Resources.ts"/>
///<reference path="../graphics/Color.ts"/>
///<reference path="../content/res/ColorStateList.ts"/>
///<reference path="../util/TypedValue.ts"/>
///<reference path="../R/color.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var View = android.view.View;
        var Gravity = android.view.Gravity;
        var Resources = android.content.res.Resources;
        var Color = android.graphics.Color;
        var ColorStateList = android.content.res.ColorStateList;
        var MeasureSpec = View.MeasureSpec;
        var TypedValue = android.util.TypedValue;
        class TextView extends View {
            constructor() {
                super();
                this.mSingleLine = false;
                this.mTextColor = ColorStateList.valueOf(Color.BLACK);
                this.mCurTextColor = Color.BLACK;
                this.mHintColor = Color.LTGRAY;
                this.mSpacingMult = 1.2;
                this.mSpacingAdd = 0;
                this.mMaxWidth = Number.MAX_SAFE_INTEGER;
                this.mMaxHeight = Number.MAX_SAFE_INTEGER;
                this.mMaxLineCount = Number.MAX_SAFE_INTEGER;
                this.mMinLineCount = 0;
                this.initTextElement();
                this.setTextSize(TextView.Default_TextSize);
                this.setGravity(Gravity.TOP | Gravity.LEFT);
                this.setTextColor(android.R.color.textView_textColor);
            }
            createAttrChangeHandler(mergeHandler) {
                super.createAttrChangeHandler(mergeHandler);
                let textView = this;
                mergeHandler.add({
                    set enabled(value) {
                        textView.setEnabled(mergeHandler.parseBoolean(value, true));
                    },
                    get enabled() {
                        return textView.isEnabled();
                    },
                    set textColorHighlight(value) {
                    },
                    set textColor(value) {
                        let colorList = mergeHandler.parseColorList(value);
                        if (colorList instanceof ColorStateList) {
                            textView.setTextColor(colorList);
                            return;
                        }
                        let color = mergeHandler.parseColor(value);
                        if (Number.isInteger(color))
                            textView.setTextColor(color);
                    },
                    get textColor() {
                        if (textView.mTextColor.isStateful())
                            return textView.mTextColor;
                        return textView.mTextColor.getDefaultColor();
                    },
                    set textColorHint(value) {
                    },
                    set textSize(value) {
                        if (value !== undefined && value !== null) {
                            value = TypedValue.complexToDimensionPixelSize(value, 0, Resources.getDisplayMetrics());
                            textView.setTextSize(value);
                        }
                    },
                    get textSize() {
                        return textView.mTextSize;
                    },
                    set textStyle(value) {
                    },
                    set textAllCaps(value) {
                    },
                    set drawableLeft(value) {
                    },
                    set drawableTop(value) {
                    },
                    set drawableRight(value) {
                    },
                    set drawableBottom(value) {
                    },
                    set drawablePadding(value) {
                    },
                    set maxLines(value) {
                        value = Number.parseInt(value);
                        if (Number.isInteger(value))
                            textView.setMaxLines(value);
                    },
                    get maxLines() {
                        return textView.mMaxLineCount;
                    },
                    set maxHeight(value) {
                        value = Number.parseInt(value);
                        if (Number.isInteger(value))
                            textView.setMaxHeight(value);
                    },
                    get maxHeight() {
                        return textView.mMaxHeight;
                    },
                    set lines(value) {
                        value = Number.parseInt(value);
                        if (Number.isInteger(value))
                            textView.setLines(value);
                    },
                    get lines() {
                        if (textView.mMaxLineCount === textView.mMinLineCount)
                            return textView.mMaxLineCount;
                        return null;
                    },
                    set height(value) {
                        value = Number.parseInt(value);
                        if (Number.isInteger(value))
                            textView.setHeight(value);
                    },
                    get height() {
                        if (textView.mMaxHeight === textView.getMinimumHeight())
                            return textView.mMaxHeight;
                        return null;
                    },
                    set minLines(value) {
                        value = Number.parseInt(value);
                        if (Number.isInteger(value))
                            textView.setMinLines(value);
                    },
                    get minLines() {
                        return textView.mMinLineCount;
                    },
                    set minHeight(value) {
                        value = Number.parseInt(value);
                        if (Number.isInteger(value))
                            textView.setMinimumHeight(value);
                    },
                    set maxWidth(value) {
                        value = Number.parseInt(value);
                        if (Number.isInteger(value))
                            textView.setMaxWidth(value);
                    },
                    get maxWidth() {
                        return textView.mMaxWidth;
                    },
                    set width(value) {
                        value = Number.parseInt(value);
                        if (Number.isInteger(value))
                            textView.setWidth(value);
                    },
                    get width() {
                        if (textView.mMinWidth === textView.mMaxWidth)
                            return textView.mMinWidth;
                        return null;
                    },
                    set gravity(value) {
                        textView.setGravity(View.AttrChangeHandler.parseGravity(value, textView.mGravity));
                    },
                    get gravity() {
                        return textView.mGravity;
                    },
                    set text(value) {
                        textView.setText(value);
                    },
                    get text() {
                        return textView.getText();
                    },
                    set singleLine(value) {
                        if (View.AttrChangeHandler.parseBoolean(value, false))
                            textView.setSingleLine();
                    },
                    get singleLine() {
                        if (textView.mMinLineCount === 1 && textView.mMaxLineCount === 1)
                            return true;
                        return false;
                    },
                    set textScaleX(value) {
                    },
                    set lineSpacingExtra(value) {
                        value = Number.parseInt(value);
                        if (Number.isInteger(value))
                            textView.setLineSpacing(value, textView.mSpacingMult);
                    },
                    get lineSpacingExtra() {
                        return textView.mSpacingAdd;
                    },
                    set lineSpacingMultiplier(value) {
                        value = Number.parseInt(value);
                        if (Number.isInteger(value))
                            textView.setLineSpacing(textView.mSpacingAdd, value);
                    },
                    get lineSpacingMultiplier() {
                        return textView.mSpacingMult;
                    },
                });
            }
            initTextElement() {
                this.mTextElement = document.createElement('div');
                this.mTextElement.style.position = "absolute";
                this.mTextElement.style.boxSizing = "border-box";
                this.mTextElement.style.overflow = "hidden";
                this.mTextElement.style.opacity = "0";
            }
            initBindElement(bindElement, rootElement) {
                super.initBindElement(bindElement, rootElement);
                this.bindElement.appendChild(this.mTextElement);
            }
            onLayout(changed, left, top, right, bottom) {
                super.onLayout(changed, left, top, right, bottom);
                this.mTextElement.style.opacity = "";
            }
            onFinishInflate() {
                super.onFinishInflate();
                Array.from(this.bindElement.childNodes).forEach((item) => {
                    if (item === this.mTextElement)
                        return;
                    this.bindElement.removeChild(item);
                    this.mTextElement.appendChild(item);
                });
            }
            onMeasure(widthMeasureSpec, heightMeasureSpec) {
                let widthMode = MeasureSpec.getMode(widthMeasureSpec);
                let heightMode = MeasureSpec.getMode(heightMeasureSpec);
                let widthSize = MeasureSpec.getSize(widthMeasureSpec);
                let heightSize = MeasureSpec.getSize(heightMeasureSpec);
                let width, height;
                let padLeft = this.getCompoundPaddingLeft();
                let padTop = this.getCompoundPaddingTop();
                let padRight = this.getCompoundPaddingRight();
                let padBottom = this.getCompoundPaddingBottom();
                this.mTextElement.style.height = "";
                this.mTextElement.style.width = "";
                this.mTextElement.style.left = -Resources.getDisplayMetrics().widthPixels + 'px';
                this.mTextElement.style.top = "";
                if (widthMode == MeasureSpec.EXACTLY) {
                    width = widthSize;
                }
                else {
                    width = this.mTextElement.offsetWidth + 2;
                    width += padLeft + padRight;
                    width = Math.min(width, this.mMaxWidth);
                    width = Math.max(width, this.getSuggestedMinimumWidth());
                    if (widthMode == MeasureSpec.AT_MOST) {
                        width = Math.min(widthSize, width);
                    }
                }
                let unpaddedWidth = width - padLeft - padRight;
                this.mTextElement.style.width = unpaddedWidth + "px";
                this.mTextElement.style.left = padLeft + "px";
                if (heightMode == MeasureSpec.EXACTLY) {
                    height = heightSize;
                    let pad = this.getCompoundPaddingTop() + this.getCompoundPaddingBottom();
                    if (this.mMaxLineCount < Number.MAX_SAFE_INTEGER) {
                        let maxHeightWithLineCount = pad + this.mMaxLineCount * this.getLineHeight();
                        height = Math.min(maxHeightWithLineCount, height);
                    }
                }
                else {
                    let desired = this.getDesiredHeight();
                    height = desired;
                    if (heightMode == MeasureSpec.AT_MOST) {
                        height = Math.min(desired, heightSize);
                    }
                }
                let contextHeight = height - padTop - padBottom;
                let textHeight = this.mTextElement.offsetHeight;
                let finalTop = padTop;
                if (textHeight < contextHeight) {
                    const verticalGravity = this.mGravity & Gravity.VERTICAL_GRAVITY_MASK;
                    switch (verticalGravity) {
                        case Gravity.CENTER_VERTICAL:
                            finalTop += (contextHeight - textHeight) / 2;
                            break;
                        case Gravity.BOTTOM:
                            finalTop += (contextHeight - textHeight);
                            break;
                        case Gravity.TOP:
                            break;
                    }
                    contextHeight = textHeight;
                }
                this.mTextElement.style.height = contextHeight + "px";
                this.mTextElement.style.top = finalTop + "px";
                this.setMeasuredDimension(width, height);
            }
            getDesiredHeight() {
                let desired = this.mTextElement.offsetHeight;
                let pad = this.getCompoundPaddingTop() + this.getCompoundPaddingBottom();
                desired += pad;
                desired = Math.min(this.mMaxHeight, desired);
                if (this.mMaxLineCount < Number.MAX_SAFE_INTEGER) {
                    let maxHeightWithLineCount = pad + this.mMaxLineCount * this.getLineHeight();
                    desired = Math.min(maxHeightWithLineCount, desired);
                }
                if (this.mMinLineCount > 0) {
                    let minHeightWithLineCount = pad + this.mMinLineCount * this.getLineHeight();
                    desired = Math.max(minHeightWithLineCount, desired);
                }
                desired = Math.max(desired, this.getSuggestedMinimumHeight());
                return desired;
            }
            onDraw(canvas) {
                let r = Color.red(this.mCurTextColor);
                let g = Color.green(this.mCurTextColor);
                let b = Color.blue(this.mCurTextColor);
                let a = Color.alpha(this.mCurTextColor);
                this.mTextElement.style.color = `rgba(${r}, ${g}, ${b}, ${a / 255})`;
                return super.onDraw(canvas);
            }
            setTextColor(color) {
                if (Number.isInteger(color)) {
                    this.mTextColor = ColorStateList.valueOf(color);
                }
                else {
                    if (color === null || color === undefined) {
                        throw new Error('colors is null');
                    }
                    this.mTextColor = color;
                }
                this.updateTextColors();
            }
            getTextColors() {
                return this.mTextColor;
            }
            getCurrentTextColor() {
                return this.mCurTextColor;
            }
            updateTextColors() {
                let inval = false;
                let color = this.mTextColor.getColorForState(this.getDrawableState(), 0);
                if (color != this.mCurTextColor) {
                    this.mCurTextColor = color;
                    inval = true;
                }
                if (inval) {
                    this.invalidate();
                }
            }
            drawableStateChanged() {
                super.drawableStateChanged();
                if (this.mTextColor != null && this.mTextColor.isStateful()) {
                    this.updateTextColors();
                }
            }
            getCompoundPaddingTop() {
                return this.mPaddingTop;
            }
            getCompoundPaddingBottom() {
                return this.mPaddingBottom;
            }
            getCompoundPaddingLeft() {
                return this.mPaddingLeft;
            }
            getCompoundPaddingRight() {
                return this.mPaddingRight;
            }
            setGravity(gravity) {
                switch (gravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
                    case Gravity.CENTER_HORIZONTAL:
                        this.mTextElement.style.textAlign = "center";
                        break;
                    case Gravity.RIGHT:
                        this.mTextElement.style.textAlign = "right";
                        break;
                    case Gravity.LEFT:
                        this.mTextElement.style.textAlign = "left";
                        break;
                }
                if ((gravity & Gravity.VERTICAL_GRAVITY_MASK) !=
                    (this.mGravity & Gravity.VERTICAL_GRAVITY_MASK)) {
                    this.requestLayout();
                }
                this.mGravity = gravity;
            }
            setLineSpacing(add, mult) {
                if (this.mSpacingAdd != add || this.mSpacingMult != mult) {
                    this.mSpacingAdd = add;
                    this.mSpacingMult = mult;
                    this.setTextSize(this.mTextSize);
                }
            }
            setTextSizeInPx(sizeInPx) {
                if (this.mTextSize !== sizeInPx) {
                    this.mTextSize = sizeInPx;
                    this.mTextElement.style.fontSize = sizeInPx + "px";
                    this.mTextElement.style.lineHeight = this.getLineHeight() + "px";
                    this.requestLayout();
                }
            }
            setTextSize(size) {
                let sizeInPx = size * Resources.getDisplayMetrics().density;
                this.setTextSizeInPx(sizeInPx);
            }
            getLineHeight() {
                return Math.ceil(this.mTextSize * this.mSpacingMult + this.mSpacingAdd);
            }
            setHeight(pixels) {
                this.mMaxHeight = pixels;
                this.setMinimumHeight(pixels);
                this.requestLayout();
                this.invalidate();
            }
            setMaxLines(max) {
                this.mMaxLineCount = max;
                this.requestLayout();
                this.invalidate();
            }
            getMaxLines() {
                return this.mMaxLineCount;
            }
            setMaxHeight(maxHeight) {
                this.mMaxHeight = maxHeight;
                this.requestLayout();
                this.invalidate();
            }
            getMaxHeight() {
                return this.mMaxHeight;
            }
            setMaxWidth(maxpixels) {
                this.mMaxWidth = maxpixels;
                this.requestLayout();
                this.invalidate();
            }
            getMaxWidth() {
                return this.mMaxWidth;
            }
            setWidth(pixels) {
                this.mMaxWidth = pixels;
                this.setMinimumWidth(pixels);
                this.requestLayout();
                this.invalidate();
            }
            setMinLines(min) {
                this.mMinLineCount = min;
                this.requestLayout();
                this.invalidate();
            }
            getMinLines() {
                return this.mMinLineCount;
            }
            setSingleLine(singleLine = true) {
                if (singleLine)
                    this.setLines(1);
                else {
                    this.mMaxLineCount = Number.MAX_SAFE_INTEGER;
                    this.mMinLineCount = 0;
                    this.requestLayout();
                    this.invalidate();
                }
            }
            setLines(lines) {
                this.mMaxLineCount = this.mMinLineCount = lines;
                this.requestLayout();
                this.invalidate();
            }
            setText(text = '') {
                this.mTextElement.innerText = text;
                this.requestLayout();
            }
            getText() {
                return this.mTextElement.innerText;
            }
            setHtml(html) {
                this.mTextElement.innerHTML = html;
                this.requestLayout();
            }
            getHtml() {
                return this.mTextElement.innerHTML;
            }
            getTextElement() {
                return this.mTextElement;
            }
        }
        TextView.Default_TextSize = 14;
        widget.TextView = TextView;
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/15.
 */
///<reference path="../view/View.ts"/>
///<reference path="../content/res/Resources.ts"/>
///<reference path="../graphics/Color.ts"/>
///<reference path="../graphics/drawable/Drawable.ts"/>
///<reference path="../graphics/drawable/InsetDrawable.ts"/>
///<reference path="../graphics/drawable/ColorDrawable.ts"/>
///<reference path="../graphics/drawable/StateListDrawable.ts"/>
var android;
(function (android) {
    var R;
    (function (R) {
        var View = android.view.View;
        var Resources = android.content.res.Resources;
        var Color = android.graphics.Color;
        var InsetDrawable = android.graphics.drawable.InsetDrawable;
        var ColorDrawable = android.graphics.drawable.ColorDrawable;
        var StateListDrawable = android.graphics.drawable.StateListDrawable;
        const density = Resources.getDisplayMetrics().density;
        class drawable {
            static get button_background() {
                class DefaultButtonBackgroundDrawable extends InsetDrawable {
                    constructor() {
                        super(DefaultButtonBackgroundDrawable.createStateList(), 6 * density);
                    }
                    static createStateList() {
                        let stateList = new StateListDrawable();
                        stateList.addState([View.VIEW_STATE_PRESSED], new ColorDrawable(Color.GRAY));
                        stateList.addState([View.VIEW_STATE_ACTIVATED], new ColorDrawable(Color.GRAY));
                        stateList.addState([View.VIEW_STATE_FOCUSED], new ColorDrawable(0xffaaaaaa));
                        stateList.addState([-View.VIEW_STATE_ENABLED], new ColorDrawable(0xffebebeb));
                        stateList.addState([], new ColorDrawable(Color.LTGRAY));
                        return stateList;
                    }
                    getPadding(padding) {
                        let result = super.getPadding(padding);
                        padding.left += 12 * density;
                        padding.right += 12 * density;
                        padding.top += 6 * density;
                        padding.bottom += 6 * density;
                        return result;
                    }
                }
                return new DefaultButtonBackgroundDrawable();
            }
            static get list_selector_background() {
                let stateList = new StateListDrawable();
                stateList.addState([View.VIEW_STATE_FOCUSED, -View.VIEW_STATE_ENABLED], new ColorDrawable(0xffebebeb));
                stateList.addState([View.VIEW_STATE_FOCUSED, View.VIEW_STATE_PRESSED], new ColorDrawable(Color.LTGRAY));
                stateList.addState([-View.VIEW_STATE_FOCUSED, View.VIEW_STATE_PRESSED], new ColorDrawable(Color.LTGRAY));
                stateList.addState([View.VIEW_STATE_FOCUSED], new ColorDrawable(0xffaaaaaa));
                stateList.addState([], new ColorDrawable(Color.TRANSPARENT));
                return stateList;
            }
            static get list_divider() {
                let divider = new ColorDrawable(0xffcccccc);
                return divider;
            }
        }
        R.drawable = drawable;
    })(R = android.R || (android.R = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/2.
 */
///<reference path="TextView.ts"/>
///<reference path="../view/View.ts"/>
///<reference path="../content/res/Resources.ts"/>
///<reference path="../graphics/Color.ts"/>
///<reference path="../graphics/drawable/Drawable.ts"/>
///<reference path="../graphics/drawable/InsetDrawable.ts"/>
///<reference path="../graphics/drawable/ColorDrawable.ts"/>
///<reference path="../graphics/drawable/StateListDrawable.ts"/>
///<reference path="../R/drawable.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var Resources = android.content.res.Resources;
        var Gravity = android.view.Gravity;
        class Button extends widget.TextView {
            constructor() {
                super();
                this._initDefaultStyle();
            }
            _initDefaultStyle() {
                let density = Resources.getDisplayMetrics().density;
                this.setFocusable(true);
                this.setClickable(true);
                this.setTextSize(18);
                this.setMinimumHeight(48 * density);
                this.setMinimumWidth(64 * density);
                this.setBackground(android.R.drawable.button_background);
                this.setGravity(Gravity.CENTER);
            }
        }
        widget.Button = Button;
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/7.
 */
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/widget/ImageView.ts"/>
var androidui;
(function (androidui) {
    var widget;
    (function (widget) {
        var View = android.view.View;
        var MeasureSpec = View.MeasureSpec;
        var ImageView = android.widget.ImageView;
        requestAnimationFrame(() => {
            eval('ImageView = android.widget.ImageView;');
        });
        class HtmlImageView extends View {
            constructor() {
                super();
                this.mHaveFrame = false;
                this.mAdjustViewBounds = false;
                this.mMaxWidth = Number.MAX_SAFE_INTEGER;
                this.mMaxHeight = Number.MAX_SAFE_INTEGER;
                this.mAlpha = 255;
                this.mDrawableWidth = 0;
                this.mDrawableHeight = 0;
                this.mAdjustViewBoundsCompat = false;
                this.initImageView();
            }
            initImageView() {
                this.mScaleType = ImageView.ScaleType.FIT_CENTER;
                this.mImgElement = document.createElement('img');
                this.mImgElement.style.position = "absolute";
                this.mImgElement.onload = (() => {
                    this.mImgElement.style.left = 0 + 'px';
                    this.mImgElement.style.top = 0 + 'px';
                    this.mImgElement.style.width = '';
                    this.mImgElement.style.height = '';
                    this.mDrawableWidth = this.mImgElement.width;
                    this.mDrawableHeight = this.mImgElement.height;
                    this.mImgElement.style.display = 'none';
                    this.mImgElement.style.opacity = '';
                    this.requestLayout();
                });
            }
            initBindElement(bindElement, rootElement) {
                super.initBindElement(bindElement, rootElement);
                this.bindElement.appendChild(this.mImgElement);
            }
            createAttrChangeHandler(mergeHandler) {
                super.createAttrChangeHandler(mergeHandler);
                let imageView = this;
                mergeHandler.add({
                    set src(value) {
                        imageView.setImageURI(value);
                    },
                    get src() {
                        return imageView.mImgElement.src;
                    },
                    set adjustViewBounds(value) {
                        imageView.setAdjustViewBounds(mergeHandler.parseBoolean(value, false));
                    },
                    get adjustViewBounds() {
                        return imageView.mAdjustViewBounds;
                    },
                    set maxWidth(value) {
                        imageView.setMaxWidth(mergeHandler.parseNumber(value, imageView.mMaxWidth));
                    },
                    get maxWidth() {
                        return imageView.mMaxWidth;
                    },
                    set maxHeight(value) {
                        imageView.setMaxHeight(mergeHandler.parseNumber(value, imageView.mMaxHeight));
                    },
                    get maxHeight() {
                        return imageView.mMaxHeight;
                    },
                    set scaleType(value) {
                        imageView.setScaleType(ImageView.ScaleType.parseScaleType(value, imageView.mScaleType));
                    },
                    get scaleType() {
                        return imageView.mScaleType.toString();
                    }
                });
            }
            getAdjustViewBounds() {
                return this.mAdjustViewBounds;
            }
            setAdjustViewBounds(adjustViewBounds) {
                this.mAdjustViewBounds = adjustViewBounds;
                if (adjustViewBounds) {
                    this.setScaleType(ImageView.ScaleType.FIT_CENTER);
                }
            }
            getMaxWidth() {
                return this.mMaxWidth;
            }
            setMaxWidth(maxWidth) {
                this.mMaxWidth = maxWidth;
            }
            getMaxHeight() {
                return this.mMaxHeight;
            }
            setMaxHeight(maxHeight) {
                this.mMaxHeight = maxHeight;
            }
            setImageURI(uri) {
                this.mDrawableWidth = -1;
                this.mDrawableHeight = -1;
                this.mImgElement.style.opacity = '0';
                this.mImgElement.src = uri;
            }
            setScaleType(scaleType) {
                if (scaleType == null) {
                    throw new Error('NullPointerException');
                }
                if (this.mScaleType != scaleType) {
                    this.mScaleType = scaleType;
                    this.setWillNotCacheDrawing(scaleType == ImageView.ScaleType.CENTER);
                    this.requestLayout();
                    this.invalidate();
                }
            }
            getScaleType() {
                return this.mScaleType;
            }
            onMeasure(widthMeasureSpec, heightMeasureSpec) {
                let w;
                let h;
                let desiredAspect = 0.0;
                let resizeWidth = false;
                let resizeHeight = false;
                const widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);
                const heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);
                if (!this.mImgElement.src || !this.mImgElement.complete) {
                    this.mDrawableWidth = -1;
                    this.mDrawableHeight = -1;
                    w = h = 0;
                }
                else {
                    w = this.mDrawableWidth;
                    h = this.mDrawableHeight;
                    if (w <= 0)
                        w = 1;
                    if (h <= 0)
                        h = 1;
                    if (this.mAdjustViewBounds) {
                        resizeWidth = widthSpecMode != MeasureSpec.EXACTLY;
                        resizeHeight = heightSpecMode != MeasureSpec.EXACTLY;
                        desiredAspect = w / h;
                    }
                }
                let pleft = this.mPaddingLeft;
                let pright = this.mPaddingRight;
                let ptop = this.mPaddingTop;
                let pbottom = this.mPaddingBottom;
                let widthSize;
                let heightSize;
                if (resizeWidth || resizeHeight) {
                    widthSize = this.resolveAdjustedSize(w + pleft + pright, this.mMaxWidth, widthMeasureSpec);
                    heightSize = this.resolveAdjustedSize(h + ptop + pbottom, this.mMaxHeight, heightMeasureSpec);
                    if (desiredAspect != 0) {
                        let actualAspect = (widthSize - pleft - pright) / (heightSize - ptop - pbottom);
                        if (Math.abs(actualAspect - desiredAspect) > 0.0000001) {
                            let done = false;
                            if (resizeWidth) {
                                let newWidth = Math.floor(desiredAspect * (heightSize - ptop - pbottom)) +
                                    pleft + pright;
                                if (!resizeHeight && !this.mAdjustViewBoundsCompat) {
                                    widthSize = this.resolveAdjustedSize(newWidth, this.mMaxWidth, widthMeasureSpec);
                                }
                                if (newWidth <= widthSize) {
                                    widthSize = newWidth;
                                    done = true;
                                }
                            }
                            if (!done && resizeHeight) {
                                let newHeight = Math.floor((widthSize - pleft - pright) / desiredAspect) +
                                    ptop + pbottom;
                                if (!resizeWidth && !this.mAdjustViewBoundsCompat) {
                                    heightSize = this.resolveAdjustedSize(newHeight, this.mMaxHeight, heightMeasureSpec);
                                }
                                if (newHeight <= heightSize) {
                                    heightSize = newHeight;
                                }
                            }
                        }
                    }
                }
                else {
                    w += pleft + pright;
                    h += ptop + pbottom;
                    w = Math.max(w, this.getSuggestedMinimumWidth());
                    h = Math.max(h, this.getSuggestedMinimumHeight());
                    widthSize = HtmlImageView.resolveSizeAndState(w, widthMeasureSpec, 0);
                    heightSize = HtmlImageView.resolveSizeAndState(h, heightMeasureSpec, 0);
                }
                this.setMeasuredDimension(widthSize, heightSize);
            }
            resolveAdjustedSize(desiredSize, maxSize, measureSpec) {
                let result = desiredSize;
                let specMode = MeasureSpec.getMode(measureSpec);
                let specSize = MeasureSpec.getSize(measureSpec);
                switch (specMode) {
                    case MeasureSpec.UNSPECIFIED:
                        result = Math.min(desiredSize, maxSize);
                        break;
                    case MeasureSpec.AT_MOST:
                        result = Math.min(Math.min(desiredSize, specSize), maxSize);
                        break;
                    case MeasureSpec.EXACTLY:
                        result = specSize;
                        break;
                }
                return result;
            }
            setFrame(left, top, right, bottom) {
                let changed = super.setFrame(left, top, right, bottom);
                this.mHaveFrame = true;
                this.configureBounds();
                this.mImgElement.style.display = '';
                return changed;
            }
            configureBounds() {
                let dwidth = this.mDrawableWidth;
                let dheight = this.mDrawableHeight;
                let vwidth = this.getWidth() - this.mPaddingLeft - this.mPaddingRight;
                let vheight = this.getHeight() - this.mPaddingTop - this.mPaddingBottom;
                let fits = (dwidth < 0 || vwidth == dwidth) && (dheight < 0 || vheight == dheight);
                this.mImgElement.style.left = 0 + 'px';
                this.mImgElement.style.top = 0 + 'px';
                this.mImgElement.style.width = '';
                this.mImgElement.style.height = '';
                if (dwidth <= 0 || dheight <= 0) {
                    return;
                }
                if (this.mScaleType === ImageView.ScaleType.FIT_XY) {
                    this.mImgElement.style.width = vwidth + 'px';
                    this.mImgElement.style.height = vheight + 'px';
                    return;
                }
                this.mImgElement.style.width = dwidth + 'px';
                this.mImgElement.style.height = dheight + 'px';
                if (ImageView.ScaleType.MATRIX === this.mScaleType) {
                }
                else if (fits) {
                }
                else if (ImageView.ScaleType.CENTER === this.mScaleType) {
                    let left = Math.round((vwidth - dwidth) * 0.5);
                    let top = Math.round((vheight - dheight) * 0.5);
                    this.mImgElement.style.left = left + 'px';
                    this.mImgElement.style.top = top + 'px';
                }
                else if (ImageView.ScaleType.CENTER_CROP === this.mScaleType) {
                    let scale;
                    let dx = 0, dy = 0;
                    if (dwidth * vheight > vwidth * dheight) {
                        scale = vheight / dheight;
                        dx = (vwidth - dwidth * scale) * 0.5;
                        this.mImgElement.style.width = 'auto';
                        this.mImgElement.style.height = vheight + 'px';
                        this.mImgElement.style.left = Math.round(dx) + 'px';
                        this.mImgElement.style.top = '0px';
                    }
                    else {
                        scale = vwidth / dwidth;
                        dy = (vheight - dheight * scale) * 0.5;
                        this.mImgElement.style.width = vwidth + 'px';
                        this.mImgElement.style.height = 'auto';
                        this.mImgElement.style.left = '0px';
                        this.mImgElement.style.top = Math.round(dy) + 'px';
                    }
                }
                else if (ImageView.ScaleType.CENTER_INSIDE === this.mScaleType) {
                    let scale = 1;
                    if (dwidth <= vwidth && dheight <= vheight) {
                    }
                    else {
                        let wScale = vwidth / dwidth;
                        let hScale = vheight / dheight;
                        if (wScale < hScale) {
                            this.mImgElement.style.width = vwidth + 'px';
                            this.mImgElement.style.height = 'auto';
                        }
                        else {
                            this.mImgElement.style.width = 'auto';
                            this.mImgElement.style.height = vheight + 'px';
                        }
                        scale = Math.min(wScale, hScale);
                    }
                    let dx = Math.round((vwidth - dwidth * scale) * 0.5);
                    let dy = Math.round((vheight - dheight * scale) * 0.5);
                    this.mImgElement.style.left = dx + 'px';
                    this.mImgElement.style.top = dy + 'px';
                }
                else {
                    let wScale = vwidth / dwidth;
                    let hScale = vheight / dheight;
                    if (wScale < hScale) {
                        this.mImgElement.style.width = vwidth + 'px';
                        this.mImgElement.style.height = 'auto';
                    }
                    else {
                        this.mImgElement.style.width = 'auto';
                        this.mImgElement.style.height = vheight + 'px';
                    }
                    let scale = Math.min(wScale, hScale);
                    if (ImageView.ScaleType.FIT_CENTER === this.mScaleType) {
                        let dx = Math.round((vwidth - dwidth * scale) * 0.5);
                        let dy = Math.round((vheight - dheight * scale) * 0.5);
                        this.mImgElement.style.left = dx + 'px';
                        this.mImgElement.style.top = dy + 'px';
                    }
                    else if (ImageView.ScaleType.FIT_END === this.mScaleType) {
                        let dx = Math.round((vwidth - dwidth * scale));
                        let dy = Math.round((vheight - dheight * scale));
                        this.mImgElement.style.left = dx + 'px';
                        this.mImgElement.style.top = dy + 'px';
                    }
                    else if (ImageView.ScaleType.FIT_START === this.mScaleType) {
                    }
                }
            }
            getImageAlpha() {
                return this.mAlpha;
            }
            setImageAlpha(alpha) {
                this.setAlpha(alpha);
            }
        }
        widget.HtmlImageView = HtmlImageView;
    })(widget = androidui.widget || (androidui.widget = {}));
})(androidui || (androidui = {}));
///<reference path="../view/View.ts"/>
///<reference path="../../androidui/widget/HtmlImageView.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        class ImageView extends androidui.widget.HtmlImageView {
        }
        widget.ImageView = ImageView;
        (function (ImageView) {
            class ScaleType {
                constructor(type) {
                    this.mType = type;
                }
                toString() {
                    return this.mType;
                }
                static parseScaleType(s, defaultType) {
                    if (s == null)
                        return defaultType;
                    if (s.toLowerCase() === ScaleType.MATRIX.mType.toLowerCase())
                        return ScaleType.MATRIX;
                    if (s.toLowerCase() === ScaleType.FIT_XY.mType.toLowerCase())
                        return ScaleType.FIT_XY;
                    if (s.toLowerCase() === ScaleType.FIT_START.mType.toLowerCase())
                        return ScaleType.FIT_START;
                    if (s.toLowerCase() === ScaleType.FIT_CENTER.mType.toLowerCase())
                        return ScaleType.FIT_CENTER;
                    if (s.toLowerCase() === ScaleType.FIT_END.mType.toLowerCase())
                        return ScaleType.FIT_END;
                    if (s.toLowerCase() === ScaleType.CENTER.mType.toLowerCase())
                        return ScaleType.CENTER;
                    if (s.toLowerCase() === ScaleType.CENTER_CROP.mType.toLowerCase())
                        return ScaleType.CENTER_CROP;
                    if (s.toLowerCase() === ScaleType.CENTER_INSIDE.mType.toLowerCase())
                        return ScaleType.CENTER_INSIDE;
                    return defaultType;
                }
            }
            ScaleType.MATRIX = new ScaleType("matrix");
            ScaleType.FIT_XY = new ScaleType("fitXY");
            ScaleType.FIT_START = new ScaleType("fitStart");
            ScaleType.FIT_CENTER = new ScaleType("fitCenter");
            ScaleType.FIT_END = new ScaleType("fitEnd");
            ScaleType.CENTER = new ScaleType("center");
            ScaleType.CENTER_CROP = new ScaleType("centerCrop");
            ScaleType.CENTER_INSIDE = new ScaleType("centerInside");
            ImageView.ScaleType = ScaleType;
        })(ImageView = widget.ImageView || (widget.ImageView = {}));
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var android;
(function (android) {
    var util;
    (function (util) {
        class MathUtils {
            constructor() {
            }
            static abs(v) {
                return v > 0 ? v : -v;
            }
            static constrain(amount, low, high) {
                return amount < low ? low : (amount > high ? high : amount);
            }
            static log(a) {
                return Math.log(a);
            }
            static exp(a) {
                return Math.exp(a);
            }
            static pow(a, b) {
                return Math.pow(a, b);
            }
            static max(a, b, c) {
                if (c == null)
                    return a > b ? a : b;
                return a > b ? (a > c ? a : c) : (b > c ? b : c);
            }
            static min(a, b, c) {
                if (c == null)
                    return a < b ? a : b;
                return a < b ? (a < c ? a : c) : (b < c ? b : c);
            }
            static dist(x1, y1, x2, y2) {
                const x = (x2 - x1);
                const y = (y2 - y1);
                return Math.sqrt(x * x + y * y);
            }
            static dist3(x1, y1, z1, x2, y2, z2) {
                const x = (x2 - x1);
                const y = (y2 - y1);
                const z = (z2 - z1);
                return Math.sqrt(x * x + y * y + z * z);
            }
            static mag(a, b, c) {
                if (c == null)
                    return Math.sqrt(a * a + b * b);
                return Math.sqrt(a * a + b * b + c * c);
            }
            static sq(v) {
                return v * v;
            }
            static radians(degrees) {
                return degrees * MathUtils.DEG_TO_RAD;
            }
            static degrees(radians) {
                return radians * MathUtils.RAD_TO_DEG;
            }
            static acos(value) {
                return Math.acos(value);
            }
            static asin(value) {
                return Math.asin(value);
            }
            static atan(value) {
                return Math.atan(value);
            }
            static atan2(a, b) {
                return Math.atan2(a, b);
            }
            static tan(angle) {
                return Math.tan(angle);
            }
            static lerp(start, stop, amount) {
                return start + (stop - start) * amount;
            }
            static norm(start, stop, value) {
                return (value - start) / (stop - start);
            }
            static map(minStart, minStop, maxStart, maxStop, value) {
                return maxStart + (maxStart - maxStop) * ((value - minStart) / (minStop - minStart));
            }
            static random(...args) {
                if (args.length == 1)
                    return Math.random() * args[0];
                let [howsmall, howbig] = args;
                if (howsmall >= howbig)
                    return howsmall;
                return Math.random() * (howbig - howsmall) + howsmall;
            }
        }
        MathUtils.DEG_TO_RAD = 3.1415926 / 180.0;
        MathUtils.RAD_TO_DEG = 180.0 / 3.1415926;
        util.MathUtils = MathUtils;
    })(util = android.util || (android.util = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/3.
 */
///<reference path="SparseArray.ts"/>
var android;
(function (android) {
    var util;
    (function (util) {
        class SparseBooleanArray extends util.SparseArray {
        }
        util.SparseBooleanArray = SparseBooleanArray;
    })(util = android.util || (android.util = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="View.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        class SoundEffectConstants {
            static getContantForFocusDirection(direction) {
                switch (direction) {
                    case view.View.FOCUS_RIGHT:
                        return SoundEffectConstants.NAVIGATION_RIGHT;
                    case view.View.FOCUS_FORWARD:
                    case view.View.FOCUS_DOWN:
                        return SoundEffectConstants.NAVIGATION_DOWN;
                    case view.View.FOCUS_LEFT:
                        return SoundEffectConstants.NAVIGATION_LEFT;
                    case view.View.FOCUS_BACKWARD:
                    case view.View.FOCUS_UP:
                        return SoundEffectConstants.NAVIGATION_UP;
                }
                throw Error(`new IllegalArgumentException("direction must be one of " + "{FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT, FOCUS_FORWARD, FOCUS_BACKWARD}.")`);
            }
        }
        SoundEffectConstants.CLICK = 0;
        SoundEffectConstants.NAVIGATION_LEFT = 1;
        SoundEffectConstants.NAVIGATION_UP = 2;
        SoundEffectConstants.NAVIGATION_RIGHT = 3;
        SoundEffectConstants.NAVIGATION_DOWN = 4;
        view.SoundEffectConstants = SoundEffectConstants;
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2012 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/util/Log.ts"/>
var android;
(function (android) {
    var os;
    (function (os) {
        class Trace {
            static nativeGetEnabledTags() {
                return Trace.TRACE_TAG_ALWAYS;
            }
            static nativeTraceCounter(tag, name, value) {
            }
            static nativeTraceBegin(tag, name) { }
            static nativeTraceEnd(tag) { }
            static nativeAsyncTraceBegin(tag, name, cookie) { }
            static nativeAsyncTraceEnd(tag, name, cookie) { }
            static nativeSetAppTracingAllowed(allowed) { }
            static nativeSetTracingEnabled(allowed) { }
            static cacheEnabledTags() {
                let tags = Trace.nativeGetEnabledTags();
                Trace.sEnabledTags = tags;
                return tags;
            }
            static isTagEnabled(traceTag) {
                let tags = Trace.sEnabledTags;
                if (tags == Trace.TRACE_TAG_NOT_READY) {
                    tags = Trace.cacheEnabledTags();
                }
                return (tags & traceTag) != 0;
            }
            static traceCounter(traceTag, counterName, counterValue) {
                if (Trace.isTagEnabled(traceTag)) {
                    Trace.nativeTraceCounter(traceTag, counterName, counterValue);
                }
            }
            static setAppTracingAllowed(allowed) {
                Trace.nativeSetAppTracingAllowed(allowed);
                Trace.cacheEnabledTags();
            }
            static setTracingEnabled(enabled) {
                Trace.nativeSetTracingEnabled(enabled);
                Trace.cacheEnabledTags();
            }
            static traceBegin(traceTag, methodName) {
                if (Trace.isTagEnabled(traceTag)) {
                    Trace.nativeTraceBegin(traceTag, methodName);
                }
            }
            static traceEnd(traceTag) {
                if (Trace.isTagEnabled(traceTag)) {
                    Trace.nativeTraceEnd(traceTag);
                }
            }
            static asyncTraceBegin(traceTag, methodName, cookie) {
                if (Trace.isTagEnabled(traceTag)) {
                    Trace.nativeAsyncTraceBegin(traceTag, methodName, cookie);
                }
            }
            static asyncTraceEnd(traceTag, methodName, cookie) {
                if (Trace.isTagEnabled(traceTag)) {
                    Trace.nativeAsyncTraceEnd(traceTag, methodName, cookie);
                }
            }
            static beginSection(sectionName) {
                if (Trace.isTagEnabled(Trace.TRACE_TAG_APP)) {
                    if (sectionName.length > Trace.MAX_SECTION_NAME_LEN) {
                        throw Error(`new IllegalArgumentException("sectionName is too long")`);
                    }
                    Trace.nativeTraceBegin(Trace.TRACE_TAG_APP, sectionName);
                }
            }
            static endSection() {
                if (Trace.isTagEnabled(Trace.TRACE_TAG_APP)) {
                    Trace.nativeTraceEnd(Trace.TRACE_TAG_APP);
                }
            }
        }
        Trace.TAG = "Trace";
        Trace.TRACE_TAG_NEVER = 0;
        Trace.TRACE_TAG_ALWAYS = 1 << 0;
        Trace.TRACE_TAG_GRAPHICS = 1 << 1;
        Trace.TRACE_TAG_INPUT = 1 << 2;
        Trace.TRACE_TAG_VIEW = 1 << 3;
        Trace.TRACE_TAG_WEBVIEW = 1 << 4;
        Trace.TRACE_TAG_WINDOW_MANAGER = 1 << 5;
        Trace.TRACE_TAG_ACTIVITY_MANAGER = 1 << 6;
        Trace.TRACE_TAG_SYNC_MANAGER = 1 << 7;
        Trace.TRACE_TAG_AUDIO = 1 << 8;
        Trace.TRACE_TAG_VIDEO = 1 << 9;
        Trace.TRACE_TAG_CAMERA = 1 << 10;
        Trace.TRACE_TAG_HAL = 1 << 11;
        Trace.TRACE_TAG_APP = 1 << 12;
        Trace.TRACE_TAG_RESOURCES = 1 << 13;
        Trace.TRACE_TAG_DALVIK = 1 << 14;
        Trace.TRACE_TAG_RS = 1 << 15;
        Trace.TRACE_TAG_NOT_READY = 1 << 63;
        Trace.MAX_SECTION_NAME_LEN = 127;
        Trace.sEnabledTags = Trace.TRACE_TAG_NOT_READY;
        os.Trace = Trace;
    })(os = android.os || (android.os = {}));
})(android || (android = {}));
var java;
(function (java) {
    var lang;
    (function (lang) {
        class Integer {
        }
        Integer.MIN_VALUE = Number.MIN_SAFE_INTEGER;
        Integer.MAX_VALUE = Number.MAX_SAFE_INTEGER;
        lang.Integer = Integer;
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var android;
(function (android) {
    var text;
    (function (text) {
        class InputType {
        }
        InputType.TYPE_MASK_CLASS = 0x0000000f;
        InputType.TYPE_MASK_VARIATION = 0x00000ff0;
        InputType.TYPE_MASK_FLAGS = 0x00fff000;
        InputType.TYPE_NULL = 0x00000000;
        InputType.TYPE_CLASS_TEXT = 0x00000001;
        InputType.TYPE_TEXT_FLAG_CAP_CHARACTERS = 0x00001000;
        InputType.TYPE_TEXT_FLAG_CAP_WORDS = 0x00002000;
        InputType.TYPE_TEXT_FLAG_CAP_SENTENCES = 0x00004000;
        InputType.TYPE_TEXT_FLAG_AUTO_CORRECT = 0x00008000;
        InputType.TYPE_TEXT_FLAG_AUTO_COMPLETE = 0x00010000;
        InputType.TYPE_TEXT_FLAG_MULTI_LINE = 0x00020000;
        InputType.TYPE_TEXT_FLAG_IME_MULTI_LINE = 0x00040000;
        InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS = 0x00080000;
        InputType.TYPE_TEXT_VARIATION_NORMAL = 0x00000000;
        InputType.TYPE_TEXT_VARIATION_URI = 0x00000010;
        InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS = 0x00000020;
        InputType.TYPE_TEXT_VARIATION_EMAIL_SUBJECT = 0x00000030;
        InputType.TYPE_TEXT_VARIATION_SHORT_MESSAGE = 0x00000040;
        InputType.TYPE_TEXT_VARIATION_LONG_MESSAGE = 0x00000050;
        InputType.TYPE_TEXT_VARIATION_PERSON_NAME = 0x00000060;
        InputType.TYPE_TEXT_VARIATION_POSTAL_ADDRESS = 0x00000070;
        InputType.TYPE_TEXT_VARIATION_PASSWORD = 0x00000080;
        InputType.TYPE_TEXT_VARIATION_VISIBLE_PASSWORD = 0x00000090;
        InputType.TYPE_TEXT_VARIATION_WEB_EDIT_TEXT = 0x000000a0;
        InputType.TYPE_TEXT_VARIATION_FILTER = 0x000000b0;
        InputType.TYPE_TEXT_VARIATION_PHONETIC = 0x000000c0;
        InputType.TYPE_TEXT_VARIATION_WEB_EMAIL_ADDRESS = 0x000000d0;
        InputType.TYPE_TEXT_VARIATION_WEB_PASSWORD = 0x000000e0;
        InputType.TYPE_CLASS_NUMBER = 0x00000002;
        InputType.TYPE_NUMBER_FLAG_SIGNED = 0x00001000;
        InputType.TYPE_NUMBER_FLAG_DECIMAL = 0x00002000;
        InputType.TYPE_NUMBER_VARIATION_NORMAL = 0x00000000;
        InputType.TYPE_NUMBER_VARIATION_PASSWORD = 0x00000010;
        InputType.TYPE_CLASS_PHONE = 0x00000003;
        InputType.TYPE_CLASS_DATETIME = 0x00000004;
        InputType.TYPE_DATETIME_VARIATION_NORMAL = 0x00000000;
        InputType.TYPE_DATETIME_VARIATION_DATE = 0x00000010;
        InputType.TYPE_DATETIME_VARIATION_TIME = 0x00000020;
        text.InputType = InputType;
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
var android;
(function (android) {
    var text;
    (function (text) {
        class TextUtils {
            static isEmpty(str) {
                if (str == null || str.length == 0)
                    return true;
                else
                    return false;
            }
        }
        text.TextUtils = TextUtils;
    })(text = android.text || (android.text = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/10/3.
 */
///<reference path="SparseArray.ts"/>
var android;
(function (android) {
    var util;
    (function (util) {
        class LongSparseArray extends util.SparseArray {
        }
        util.LongSparseArray = LongSparseArray;
    })(util = android.util || (android.util = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/view/View.ts"/>
var android;
(function (android) {
    var view;
    (function (view) {
        class HapticFeedbackConstants {
        }
        HapticFeedbackConstants.LONG_PRESS = 0;
        HapticFeedbackConstants.VIRTUAL_KEY = 1;
        HapticFeedbackConstants.KEYBOARD_TAP = 3;
        HapticFeedbackConstants.SAFE_MODE_DISABLED = 10000;
        HapticFeedbackConstants.SAFE_MODE_ENABLED = 10001;
        HapticFeedbackConstants.FLAG_IGNORE_VIEW_SETTING = 0x0001;
        HapticFeedbackConstants.FLAG_IGNORE_GLOBAL_SETTING = 0x0002;
        view.HapticFeedbackConstants = HapticFeedbackConstants;
    })(view = android.view || (android.view = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/5.
 */
var android;
(function (android) {
    var database;
    (function (database) {
        class DataSetObserver {
            onChanged() { }
            onInvalidated() { }
        }
        database.DataSetObserver = DataSetObserver;
    })(database = android.database || (android.database = {}));
})(android || (android = {}));
var java;
(function (java) {
    var lang;
    (function (lang) {
        class Long {
        }
        Long.MIN_VALUE = Number.MIN_SAFE_INTEGER;
        Long.MAX_VALUE = Number.MAX_SAFE_INTEGER;
        lang.Long = Long;
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/database/DataSetObserver.ts"/>
///<reference path="../../android/os/SystemClock.ts"/>
///<reference path="../../android/util/SparseArray.ts"/>
///<reference path="../../android/view/SoundEffectConstants.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../java/lang/Long.ts"/>
///<reference path="Adapter.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var DataSetObserver = android.database.DataSetObserver;
        var SystemClock = android.os.SystemClock;
        var SoundEffectConstants = android.view.SoundEffectConstants;
        var View = android.view.View;
        var ViewGroup = android.view.ViewGroup;
        var Long = java.lang.Long;
        class AdapterView extends ViewGroup {
            constructor(...args) {
                super(...args);
                this.mFirstPosition = 0;
                this.mSpecificTop = 0;
                this.mSyncPosition = 0;
                this.mSyncRowId = AdapterView.INVALID_ROW_ID;
                this.mSyncHeight = 0;
                this.mNeedSync = false;
                this.mSyncMode = 0;
                this.mLayoutHeight = 0;
                this.mInLayout = false;
                this.mNextSelectedPosition = AdapterView.INVALID_POSITION;
                this.mNextSelectedRowId = AdapterView.INVALID_ROW_ID;
                this.mSelectedPosition = AdapterView.INVALID_POSITION;
                this.mSelectedRowId = AdapterView.INVALID_ROW_ID;
                this.mItemCount = 0;
                this.mOldItemCount = 0;
                this.mOldSelectedPosition = AdapterView.INVALID_POSITION;
                this.mOldSelectedRowId = AdapterView.INVALID_ROW_ID;
                this.mBlockLayoutRequests = false;
            }
            setOnItemClickListener(listener) {
                this.mOnItemClickListener = listener;
            }
            getOnItemClickListener() {
                return this.mOnItemClickListener;
            }
            performItemClick(view, position, id) {
                if (this.mOnItemClickListener != null) {
                    this.playSoundEffect(SoundEffectConstants.CLICK);
                    this.mOnItemClickListener.onItemClick(this, view, position, id);
                    return true;
                }
                return false;
            }
            setOnItemLongClickListener(listener) {
                if (!this.isLongClickable()) {
                    this.setLongClickable(true);
                }
                this.mOnItemLongClickListener = listener;
            }
            getOnItemLongClickListener() {
                return this.mOnItemLongClickListener;
            }
            setOnItemSelectedListener(listener) {
                this.mOnItemSelectedListener = listener;
            }
            getOnItemSelectedListener() {
                return this.mOnItemSelectedListener;
            }
            addView(...args) {
                throw Error(`new UnsupportedOperationException("addView() is not supported in AdapterView")`);
            }
            removeView(child) {
                throw Error(`new UnsupportedOperationException("removeView(View) is not supported in AdapterView")`);
            }
            removeViewAt(index) {
                throw Error(`new UnsupportedOperationException("removeViewAt(int) is not supported in AdapterView")`);
            }
            removeAllViews() {
                throw Error(`new UnsupportedOperationException("removeAllViews() is not supported in AdapterView")`);
            }
            onLayout(changed, left, top, right, bottom) {
                this.mLayoutHeight = this.getHeight();
            }
            getSelectedItemPosition() {
                return this.mNextSelectedPosition;
            }
            getSelectedItemId() {
                return this.mNextSelectedRowId;
            }
            getSelectedItem() {
                let adapter = this.getAdapter();
                let selection = this.getSelectedItemPosition();
                if (adapter != null && adapter.getCount() > 0 && selection >= 0) {
                    return adapter.getItem(selection);
                }
                else {
                    return null;
                }
            }
            getCount() {
                return this.mItemCount;
            }
            getPositionForView(view) {
                let listItem = view;
                try {
                    let v;
                    while (!((v = listItem.getParent()) == (this))) {
                        listItem = v;
                    }
                }
                catch (e) {
                    return AdapterView.INVALID_POSITION;
                }
                const childCount = this.getChildCount();
                for (let i = 0; i < childCount; i++) {
                    if (this.getChildAt(i) == (listItem)) {
                        return this.mFirstPosition + i;
                    }
                }
                return AdapterView.INVALID_POSITION;
            }
            getFirstVisiblePosition() {
                return this.mFirstPosition;
            }
            getLastVisiblePosition() {
                return this.mFirstPosition + this.getChildCount() - 1;
            }
            setEmptyView(emptyView) {
                this.mEmptyView = emptyView;
                const adapter = this.getAdapter();
                const empty = ((adapter == null) || adapter.isEmpty());
                this.updateEmptyStatus(empty);
            }
            getEmptyView() {
                return this.mEmptyView;
            }
            isInFilterMode() {
                return false;
            }
            setFocusable(focusable) {
                const adapter = this.getAdapter();
                const empty = adapter == null || adapter.getCount() == 0;
                this.mDesiredFocusableState = focusable;
                if (!focusable) {
                    this.mDesiredFocusableInTouchModeState = false;
                }
                super.setFocusable(focusable && (!empty || this.isInFilterMode()));
            }
            setFocusableInTouchMode(focusable) {
                const adapter = this.getAdapter();
                const empty = adapter == null || adapter.getCount() == 0;
                this.mDesiredFocusableInTouchModeState = focusable;
                if (focusable) {
                    this.mDesiredFocusableState = true;
                }
                super.setFocusableInTouchMode(focusable && (!empty || this.isInFilterMode()));
            }
            checkFocus() {
                const adapter = this.getAdapter();
                const empty = adapter == null || adapter.getCount() == 0;
                const focusable = !empty || this.isInFilterMode();
                super.setFocusableInTouchMode(focusable && this.mDesiredFocusableInTouchModeState);
                super.setFocusable(focusable && this.mDesiredFocusableState);
                if (this.mEmptyView != null) {
                    this.updateEmptyStatus((adapter == null) || adapter.isEmpty());
                }
            }
            updateEmptyStatus(empty) {
                if (this.isInFilterMode()) {
                    empty = false;
                }
                if (empty) {
                    if (this.mEmptyView != null) {
                        this.mEmptyView.setVisibility(View.VISIBLE);
                        this.setVisibility(View.GONE);
                    }
                    else {
                        this.setVisibility(View.VISIBLE);
                    }
                    if (this.mDataChanged) {
                        this.onLayout(false, this.mLeft, this.mTop, this.mRight, this.mBottom);
                    }
                }
                else {
                    if (this.mEmptyView != null)
                        this.mEmptyView.setVisibility(View.GONE);
                    this.setVisibility(View.VISIBLE);
                }
            }
            getItemAtPosition(position) {
                let adapter = this.getAdapter();
                return (adapter == null || position < 0) ? null : adapter.getItem(position);
            }
            getItemIdAtPosition(position) {
                let adapter = this.getAdapter();
                return (adapter == null || position < 0) ? AdapterView.INVALID_ROW_ID : adapter.getItemId(position);
            }
            setOnClickListener(l) {
                throw Error(`new RuntimeException("Don't call setOnClickListener for an AdapterView. " + "You probably want setOnItemClickListener instead")`);
            }
            onDetachedFromWindow() {
                super.onDetachedFromWindow();
                this.removeCallbacks(this.mSelectionNotifier);
            }
            selectionChanged() {
                if (this.mOnItemSelectedListener != null) {
                    if (this.mInLayout || this.mBlockLayoutRequests) {
                        if (this.mSelectionNotifier == null) {
                            this.mSelectionNotifier = new SelectionNotifier(this);
                        }
                        this.post(this.mSelectionNotifier);
                    }
                    else {
                        this.fireOnSelected();
                        this.performAccessibilityActionsOnSelected();
                    }
                }
            }
            fireOnSelected() {
                if (this.mOnItemSelectedListener == null) {
                    return;
                }
                const selection = this.getSelectedItemPosition();
                if (selection >= 0) {
                    let v = this.getSelectedView();
                    this.mOnItemSelectedListener.onItemSelected(this, v, selection, this.getAdapter().getItemId(selection));
                }
                else {
                    this.mOnItemSelectedListener.onNothingSelected(this);
                }
            }
            performAccessibilityActionsOnSelected() {
            }
            isScrollableForAccessibility() {
                let adapter = this.getAdapter();
                if (adapter != null) {
                    const itemCount = adapter.getCount();
                    return itemCount > 0 && (this.getFirstVisiblePosition() > 0 || this.getLastVisiblePosition() < itemCount - 1);
                }
                return false;
            }
            canAnimate() {
                return super.canAnimate() && this.mItemCount > 0;
            }
            handleDataChanged() {
                const count = this.mItemCount;
                let found = false;
                if (count > 0) {
                    let newPos;
                    if (this.mNeedSync) {
                        this.mNeedSync = false;
                        newPos = this.findSyncPosition();
                        if (newPos >= 0) {
                            let selectablePos = this.lookForSelectablePosition(newPos, true);
                            if (selectablePos == newPos) {
                                this.setNextSelectedPositionInt(newPos);
                                found = true;
                            }
                        }
                    }
                    if (!found) {
                        newPos = this.getSelectedItemPosition();
                        if (newPos >= count) {
                            newPos = count - 1;
                        }
                        if (newPos < 0) {
                            newPos = 0;
                        }
                        let selectablePos = this.lookForSelectablePosition(newPos, true);
                        if (selectablePos < 0) {
                            selectablePos = this.lookForSelectablePosition(newPos, false);
                        }
                        if (selectablePos >= 0) {
                            this.setNextSelectedPositionInt(selectablePos);
                            this.checkSelectionChanged();
                            found = true;
                        }
                    }
                }
                if (!found) {
                    this.mSelectedPosition = AdapterView.INVALID_POSITION;
                    this.mSelectedRowId = AdapterView.INVALID_ROW_ID;
                    this.mNextSelectedPosition = AdapterView.INVALID_POSITION;
                    this.mNextSelectedRowId = AdapterView.INVALID_ROW_ID;
                    this.mNeedSync = false;
                    this.checkSelectionChanged();
                }
            }
            checkSelectionChanged() {
                if ((this.mSelectedPosition != this.mOldSelectedPosition) || (this.mSelectedRowId != this.mOldSelectedRowId)) {
                    this.selectionChanged();
                    this.mOldSelectedPosition = this.mSelectedPosition;
                    this.mOldSelectedRowId = this.mSelectedRowId;
                }
            }
            findSyncPosition() {
                let count = this.mItemCount;
                if (count == 0) {
                    return AdapterView.INVALID_POSITION;
                }
                let idToMatch = this.mSyncRowId;
                let seed = this.mSyncPosition;
                if (idToMatch == AdapterView.INVALID_ROW_ID) {
                    return AdapterView.INVALID_POSITION;
                }
                seed = Math.max(0, seed);
                seed = Math.min(count - 1, seed);
                let endTime = SystemClock.uptimeMillis() + AdapterView.SYNC_MAX_DURATION_MILLIS;
                let rowId;
                let first = seed;
                let last = seed;
                let next = false;
                let hitFirst;
                let hitLast;
                let adapter = this.getAdapter();
                if (adapter == null) {
                    return AdapterView.INVALID_POSITION;
                }
                while (SystemClock.uptimeMillis() <= endTime) {
                    rowId = adapter.getItemId(seed);
                    if (rowId == idToMatch) {
                        return seed;
                    }
                    hitLast = last == count - 1;
                    hitFirst = first == 0;
                    if (hitLast && hitFirst) {
                        break;
                    }
                    if (hitFirst || (next && !hitLast)) {
                        last++;
                        seed = last;
                        next = false;
                    }
                    else if (hitLast || (!next && !hitFirst)) {
                        first--;
                        seed = first;
                        next = true;
                    }
                }
                return AdapterView.INVALID_POSITION;
            }
            lookForSelectablePosition(position, lookDown) {
                return position;
            }
            setSelectedPositionInt(position) {
                this.mSelectedPosition = position;
                this.mSelectedRowId = this.getItemIdAtPosition(position);
            }
            setNextSelectedPositionInt(position) {
                this.mNextSelectedPosition = position;
                this.mNextSelectedRowId = this.getItemIdAtPosition(position);
                if (this.mNeedSync && this.mSyncMode == AdapterView.SYNC_SELECTED_POSITION && position >= 0) {
                    this.mSyncPosition = position;
                    this.mSyncRowId = this.mNextSelectedRowId;
                }
            }
            rememberSyncState() {
                if (this.getChildCount() > 0) {
                    this.mNeedSync = true;
                    this.mSyncHeight = this.mLayoutHeight;
                    if (this.mSelectedPosition >= 0) {
                        let v = this.getChildAt(this.mSelectedPosition - this.mFirstPosition);
                        this.mSyncRowId = this.mNextSelectedRowId;
                        this.mSyncPosition = this.mNextSelectedPosition;
                        if (v != null) {
                            this.mSpecificTop = v.getTop();
                        }
                        this.mSyncMode = AdapterView.SYNC_SELECTED_POSITION;
                    }
                    else {
                        let v = this.getChildAt(0);
                        let adapter = this.getAdapter();
                        if (this.mFirstPosition >= 0 && this.mFirstPosition < adapter.getCount()) {
                            this.mSyncRowId = adapter.getItemId(this.mFirstPosition);
                        }
                        else {
                            this.mSyncRowId = AdapterView.NO_ID;
                        }
                        this.mSyncPosition = this.mFirstPosition;
                        if (v != null) {
                            this.mSpecificTop = v.getTop();
                        }
                        this.mSyncMode = AdapterView.SYNC_FIRST_POSITION;
                    }
                }
            }
        }
        AdapterView.ITEM_VIEW_TYPE_IGNORE = -1;
        AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER = -2;
        AdapterView.SYNC_SELECTED_POSITION = 0;
        AdapterView.SYNC_FIRST_POSITION = 1;
        AdapterView.SYNC_MAX_DURATION_MILLIS = 100;
        AdapterView.INVALID_POSITION = -1;
        AdapterView.INVALID_ROW_ID = Long.MIN_VALUE;
        widget.AdapterView = AdapterView;
        (function (AdapterView) {
            class AdapterDataSetObserver extends DataSetObserver {
                constructor(AdapterView_this) {
                    super();
                    this.AdapterView_this = AdapterView_this;
                }
                onChanged() {
                    this.AdapterView_this.mDataChanged = true;
                    this.AdapterView_this.mOldItemCount = this.AdapterView_this.mItemCount;
                    this.AdapterView_this.mItemCount = this.AdapterView_this.getAdapter().getCount();
                    this.AdapterView_this.rememberSyncState();
                    this.AdapterView_this.checkFocus();
                    this.AdapterView_this.requestLayout();
                }
                onInvalidated() {
                    this.AdapterView_this.mDataChanged = true;
                    this.AdapterView_this.mOldItemCount = this.AdapterView_this.mItemCount;
                    this.AdapterView_this.mItemCount = 0;
                    this.AdapterView_this.mSelectedPosition = AdapterView.INVALID_POSITION;
                    this.AdapterView_this.mSelectedRowId = AdapterView.INVALID_ROW_ID;
                    this.AdapterView_this.mNextSelectedPosition = AdapterView.INVALID_POSITION;
                    this.AdapterView_this.mNextSelectedRowId = AdapterView.INVALID_ROW_ID;
                    this.AdapterView_this.mNeedSync = false;
                    this.AdapterView_this.checkFocus();
                    this.AdapterView_this.requestLayout();
                }
                clearSavedState() {
                }
            }
            AdapterView.AdapterDataSetObserver = AdapterDataSetObserver;
        })(AdapterView = widget.AdapterView || (widget.AdapterView = {}));
        class SelectionNotifier {
            constructor(AdapterView_this) {
                this.AdapterView_this = AdapterView_this;
            }
            run() {
                if (this.AdapterView_this.mDataChanged) {
                    if (this.AdapterView_this.getAdapter() != null) {
                        this.AdapterView_this.post(this);
                    }
                }
                else {
                    this.AdapterView_this.fireOnSelected();
                    this.AdapterView_this.performAccessibilityActionsOnSelected();
                }
            }
        }
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/database/DataSetObserver.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../java/lang/Integer.ts"/>
///<reference path="AdapterView.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var Integer = java.lang.Integer;
        var Adapter;
        (function (Adapter) {
            Adapter.IGNORE_ITEM_VIEW_TYPE = widget.AdapterView.ITEM_VIEW_TYPE_IGNORE;
            Adapter.NO_SELECTION = Integer.MIN_VALUE;
        })(Adapter = widget.Adapter || (widget.Adapter = {}));
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/widget/Adapter.ts"/>
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/graphics/Canvas.ts"/>
///<reference path="../../android/graphics/Rect.ts"/>
///<reference path="../../android/graphics/drawable/Drawable.ts"/>
///<reference path="../../android/text/InputType.ts"/>
///<reference path="../../android/text/TextUtils.ts"/>
///<reference path="../../android/util/Log.ts"/>
///<reference path="../../android/util/LongSparseArray.ts"/>
///<reference path="../../android/util/SparseArray.ts"/>
///<reference path="../../android/util/SparseBooleanArray.ts"/>
///<reference path="../../android/util/StateSet.ts"/>
///<reference path="../../android/view/Gravity.ts"/>
///<reference path="../../android/view/HapticFeedbackConstants.ts"/>
///<reference path="../../android/view/KeyEvent.ts"/>
///<reference path="../../android/view/MotionEvent.ts"/>
///<reference path="../../android/view/VelocityTracker.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewConfiguration.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../android/view/ViewParent.ts"/>
///<reference path="../../android/view/ViewTreeObserver.ts"/>
///<reference path="../../android/view/animation/Interpolator.ts"/>
///<reference path="../../android/view/animation/LinearInterpolator.ts"/>
///<reference path="../../java/util/ArrayList.ts"/>
///<reference path="../../java/util/List.ts"/>
///<reference path="../../java/lang/Integer.ts"/>
///<reference path="../../java/lang/Runnable.ts"/>
///<reference path="../../java/lang/System.ts"/>
///<reference path="../../android/widget/Adapter.ts"/>
///<reference path="../../android/widget/AdapterView.ts"/>
///<reference path="../../android/widget/Button.ts"/>
///<reference path="../../android/widget/Checkable.ts"/>
///<reference path="../../android/widget/ListAdapter.ts"/>
///<reference path="../../android/widget/OverScroller.ts"/>
///<reference path="../../android/R/drawable.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var Rect = android.graphics.Rect;
        var Log = android.util.Log;
        var LongSparseArray = android.util.LongSparseArray;
        var SparseArray = android.util.SparseArray;
        var SparseBooleanArray = android.util.SparseBooleanArray;
        var StateSet = android.util.StateSet;
        var HapticFeedbackConstants = android.view.HapticFeedbackConstants;
        var KeyEvent = android.view.KeyEvent;
        var MotionEvent = android.view.MotionEvent;
        var VelocityTracker = android.view.VelocityTracker;
        var View = android.view.View;
        var ViewConfiguration = android.view.ViewConfiguration;
        var ViewGroup = android.view.ViewGroup;
        var LinearInterpolator = android.view.animation.LinearInterpolator;
        var ArrayList = java.util.ArrayList;
        var Integer = java.lang.Integer;
        var System = java.lang.System;
        var AdapterView = android.widget.AdapterView;
        var OverScroller = android.widget.OverScroller;
        class AbsListView extends AdapterView {
            constructor() {
                super();
                this.mChoiceMode = AbsListView.CHOICE_MODE_NONE;
                this.mCheckedItemCount = 0;
                this.mDeferNotifyDataSetChanged = false;
                this.mDrawSelectorOnTop = false;
                this.mSelectorPosition = AbsListView.INVALID_POSITION;
                this.mSelectorRect = new Rect();
                this.mRecycler = new AbsListView.RecycleBin(this);
                this.mSelectionLeftPadding = 0;
                this.mSelectionTopPadding = 0;
                this.mSelectionRightPadding = 0;
                this.mSelectionBottomPadding = 0;
                this.mListPadding = new Rect();
                this.mWidthMeasureSpec = 0;
                this.mMotionPosition = 0;
                this.mMotionViewOriginalTop = 0;
                this.mMotionViewNewTop = 0;
                this.mMotionX = 0;
                this.mMotionY = 0;
                this.mTouchMode = AbsListView.TOUCH_MODE_REST;
                this.mLastY = 0;
                this.mMotionCorrection = 0;
                this.mSelectedTop = 0;
                this.mSmoothScrollbarEnabled = true;
                this.mResurrectToPosition = AbsListView.INVALID_POSITION;
                this.mOverscrollMax = 0;
                this.mLastTouchMode = AbsListView.TOUCH_MODE_UNKNOWN;
                this.mScrollProfilingStarted = false;
                this.mFlingProfilingStarted = false;
                this.mTranscriptMode = 0;
                this.mCacheColorHint = 0;
                this.mLastScrollState = AbsListView.OnScrollListener.SCROLL_STATE_IDLE;
                this.mDensityScale = 0;
                this.mMinimumVelocity = 0;
                this.mMaximumVelocity = 0;
                this.mVelocityScale = 1.0;
                this.mIsScrap = new Array(1);
                this.mActivePointerId = AbsListView.INVALID_POINTER;
                this.mOverscrollDistance = 0;
                this._mOverflingDistance = 0;
                this.mFirstPositionDistanceGuess = 0;
                this.mLastPositionDistanceGuess = 0;
                this.mDirection = 0;
                this.mGlowPaddingLeft = 0;
                this.mGlowPaddingRight = 0;
                this.mLastHandledItemCount = 0;
                this.initAbsListView();
                this.setVerticalScrollBarEnabled(true);
                this.initializeScrollbars();
            }
            get mOverflingDistance() {
                if (this.mScrollY <= 0) {
                    if (this.mScrollY < -this._mOverflingDistance)
                        return -this.mScrollY;
                    return this._mOverflingDistance;
                }
                let overDistance = this.mScrollY;
                if (overDistance > this._mOverflingDistance)
                    return overDistance;
                return this._mOverflingDistance;
            }
            set mOverflingDistance(value) {
                this._mOverflingDistance = value;
            }
            createAttrChangeHandler(mergeHandler) {
                super.createAttrChangeHandler(mergeHandler);
                let absListView = this;
                mergeHandler.add({
                    set listSelector(value) {
                        let d = mergeHandler.parseDrawable(value);
                        if (d)
                            absListView.setSelector(d);
                    },
                    set drawSelectorOnTop(value) {
                        absListView.mDrawSelectorOnTop = mergeHandler.parseBoolean(value, false);
                    },
                    set stackFromBottom(value) {
                        absListView.setStackFromBottom(mergeHandler.parseBoolean(value, false));
                    },
                    set scrollingCache(value) {
                        this.setScrollingCacheEnabled(mergeHandler.parseBoolean(value, true));
                    },
                    set transcriptMode(value) {
                        let transcriptMode = mergeHandler.parseNumber(value, AbsListView.TRANSCRIPT_MODE_DISABLED);
                        absListView.setTranscriptMode(transcriptMode);
                    },
                    set cacheColorHint(value) {
                        let color = mergeHandler.parseNumber(value, 0);
                        absListView.setCacheColorHint(color);
                    },
                    set fastScrollEnabled(value) {
                        let enableFastScroll = mergeHandler.parseBoolean(value, false);
                    },
                    set fastScrollAlwaysVisible(value) {
                        let fastScrollAlwaysVisible = mergeHandler.parseBoolean(value, false);
                    },
                    set smoothScrollbar(value) {
                        let smoothScrollbar = mergeHandler.parseBoolean(value, true);
                        absListView.setSmoothScrollbarEnabled(smoothScrollbar);
                    },
                    set choiceMode(value) {
                        absListView.setChoiceMode(mergeHandler.parseNumber(value, AbsListView.CHOICE_MODE_NONE));
                    }
                });
            }
            initAbsListView() {
                this.setClickable(true);
                this.setFocusableInTouchMode(true);
                this.setWillNotDraw(false);
                this.setAlwaysDrawnWithCacheEnabled(false);
                this.setScrollingCacheEnabled(true);
                const configuration = ViewConfiguration.get();
                this.mTouchSlop = configuration.getScaledTouchSlop();
                this.mMinimumVelocity = configuration.getScaledMinimumFlingVelocity();
                this.mMaximumVelocity = configuration.getScaledMaximumFlingVelocity();
                this.mOverscrollDistance = configuration.getScaledOverscrollDistance();
                this.mOverflingDistance = configuration.getScaledOverflingDistance();
                this.mDensityScale = android.content.res.Resources.getDisplayMetrics().density;
                this.mLayoutMode = AbsListView.LAYOUT_NORMAL;
            }
            setOverScrollMode(mode) {
                if (mode != AbsListView.OVER_SCROLL_NEVER) {
                }
                else {
                }
                super.setOverScrollMode(mode);
            }
            setAdapter(adapter) {
                if (adapter != null) {
                    this.mAdapterHasStableIds = this.mAdapter.hasStableIds();
                    if (this.mChoiceMode != AbsListView.CHOICE_MODE_NONE && this.mAdapterHasStableIds && this.mCheckedIdStates == null) {
                        this.mCheckedIdStates = new LongSparseArray();
                    }
                }
                if (this.mCheckStates != null) {
                    this.mCheckStates.clear();
                }
                if (this.mCheckedIdStates != null) {
                    this.mCheckedIdStates.clear();
                }
            }
            getCheckedItemCount() {
                return this.mCheckedItemCount;
            }
            isItemChecked(position) {
                if (this.mChoiceMode != AbsListView.CHOICE_MODE_NONE && this.mCheckStates != null) {
                    return this.mCheckStates.get(position);
                }
                return false;
            }
            getCheckedItemPosition() {
                if (this.mChoiceMode == AbsListView.CHOICE_MODE_SINGLE && this.mCheckStates != null && this.mCheckStates.size() == 1) {
                    return this.mCheckStates.keyAt(0);
                }
                return AbsListView.INVALID_POSITION;
            }
            getCheckedItemPositions() {
                if (this.mChoiceMode != AbsListView.CHOICE_MODE_NONE) {
                    return this.mCheckStates;
                }
                return null;
            }
            getCheckedItemIds() {
                if (this.mChoiceMode == AbsListView.CHOICE_MODE_NONE || this.mCheckedIdStates == null || this.mAdapter == null) {
                    return [0];
                }
                const idStates = this.mCheckedIdStates;
                const count = idStates.size();
                const ids = [count];
                for (let i = 0; i < count; i++) {
                    ids[i] = idStates.keyAt(i);
                }
                return ids;
            }
            clearChoices() {
                if (this.mCheckStates != null) {
                    this.mCheckStates.clear();
                }
                if (this.mCheckedIdStates != null) {
                    this.mCheckedIdStates.clear();
                }
                this.mCheckedItemCount = 0;
            }
            setItemChecked(position, value) {
                if (this.mChoiceMode == AbsListView.CHOICE_MODE_NONE) {
                    return;
                }
                if (this.mChoiceMode == AbsListView.CHOICE_MODE_MULTIPLE || this.mChoiceMode == AbsListView.CHOICE_MODE_MULTIPLE_MODAL) {
                    let oldValue = this.mCheckStates.get(position);
                    this.mCheckStates.put(position, value);
                    if (this.mCheckedIdStates != null && this.mAdapter.hasStableIds()) {
                        if (value) {
                            this.mCheckedIdStates.put(this.mAdapter.getItemId(position), position);
                        }
                        else {
                            this.mCheckedIdStates.delete(this.mAdapter.getItemId(position));
                        }
                    }
                    if (oldValue != value) {
                        if (value) {
                            this.mCheckedItemCount++;
                        }
                        else {
                            this.mCheckedItemCount--;
                        }
                    }
                }
                else {
                    let updateIds = this.mCheckedIdStates != null && this.mAdapter.hasStableIds();
                    if (value || this.isItemChecked(position)) {
                        this.mCheckStates.clear();
                        if (updateIds) {
                            this.mCheckedIdStates.clear();
                        }
                    }
                    if (value) {
                        this.mCheckStates.put(position, true);
                        if (updateIds) {
                            this.mCheckedIdStates.put(this.mAdapter.getItemId(position), position);
                        }
                        this.mCheckedItemCount = 1;
                    }
                    else if (this.mCheckStates.size() == 0 || !this.mCheckStates.valueAt(0)) {
                        this.mCheckedItemCount = 0;
                    }
                }
                if (!this.mInLayout && !this.mBlockLayoutRequests) {
                    this.mDataChanged = true;
                    this.rememberSyncState();
                    this.requestLayout();
                }
            }
            performItemClick(view, position, id) {
                let handled = false;
                let dispatchItemClick = true;
                if (this.mChoiceMode != AbsListView.CHOICE_MODE_NONE) {
                    handled = true;
                    let checkedStateChanged = false;
                    if (this.mChoiceMode == AbsListView.CHOICE_MODE_MULTIPLE || (this.mChoiceMode == AbsListView.CHOICE_MODE_MULTIPLE_MODAL && this.mChoiceActionMode != null)) {
                        let checked = !this.mCheckStates.get(position, false);
                        this.mCheckStates.put(position, checked);
                        if (this.mCheckedIdStates != null && this.mAdapter.hasStableIds()) {
                            if (checked) {
                                this.mCheckedIdStates.put(this.mAdapter.getItemId(position), position);
                            }
                            else {
                                this.mCheckedIdStates.delete(this.mAdapter.getItemId(position));
                            }
                        }
                        if (checked) {
                            this.mCheckedItemCount++;
                        }
                        else {
                            this.mCheckedItemCount--;
                        }
                        checkedStateChanged = true;
                    }
                    else if (this.mChoiceMode == AbsListView.CHOICE_MODE_SINGLE) {
                        let checked = !this.mCheckStates.get(position, false);
                        if (checked) {
                            this.mCheckStates.clear();
                            this.mCheckStates.put(position, true);
                            if (this.mCheckedIdStates != null && this.mAdapter.hasStableIds()) {
                                this.mCheckedIdStates.clear();
                                this.mCheckedIdStates.put(this.mAdapter.getItemId(position), position);
                            }
                            this.mCheckedItemCount = 1;
                        }
                        else if (this.mCheckStates.size() == 0 || !this.mCheckStates.valueAt(0)) {
                            this.mCheckedItemCount = 0;
                        }
                        checkedStateChanged = true;
                    }
                    if (checkedStateChanged) {
                        this.updateOnScreenCheckedViews();
                    }
                }
                if (dispatchItemClick) {
                    handled = super.performItemClick(view, position, id) || handled;
                }
                return handled;
            }
            updateOnScreenCheckedViews() {
                const firstPos = this.mFirstPosition;
                const count = this.getChildCount();
                const useActivated = true;
                for (let i = 0; i < count; i++) {
                    const child = this.getChildAt(i);
                    const position = firstPos + i;
                    if (child['setChecked']) {
                        child.setChecked(this.mCheckStates.get(position));
                    }
                    else if (useActivated) {
                        child.setActivated(this.mCheckStates.get(position));
                    }
                }
            }
            getChoiceMode() {
                return this.mChoiceMode;
            }
            setChoiceMode(choiceMode) {
                this.mChoiceMode = choiceMode;
                if (this.mChoiceActionMode != null) {
                    this.mChoiceActionMode.finish();
                    this.mChoiceActionMode = null;
                }
                if (this.mChoiceMode != AbsListView.CHOICE_MODE_NONE) {
                    if (this.mCheckStates == null) {
                        this.mCheckStates = new SparseBooleanArray(0);
                    }
                    if (this.mCheckedIdStates == null && this.mAdapter != null && this.mAdapter.hasStableIds()) {
                        this.mCheckedIdStates = new LongSparseArray(0);
                    }
                    if (this.mChoiceMode == AbsListView.CHOICE_MODE_MULTIPLE_MODAL) {
                        this.clearChoices();
                        this.setLongClickable(true);
                    }
                }
            }
            contentFits() {
                const childCount = this.getChildCount();
                if (childCount == 0)
                    return true;
                if (childCount != this.mItemCount)
                    return false;
                return this.getChildAt(0).getTop() >= this.mListPadding.top && this.getChildAt(childCount - 1).getBottom() <= this.getHeight() - this.mListPadding.bottom;
            }
            setFastScrollEnabled(enabled) {
                if (this.mFastScrollEnabled != enabled) {
                    this.mFastScrollEnabled = enabled;
                    this.setFastScrollerEnabledUiThread(enabled);
                }
            }
            setFastScrollerEnabledUiThread(enabled) {
            }
            setFastScrollAlwaysVisible(alwaysShow) {
                if (this.mFastScrollAlwaysVisible != alwaysShow) {
                    if (alwaysShow && !this.mFastScrollEnabled) {
                        this.setFastScrollEnabled(true);
                    }
                    this.mFastScrollAlwaysVisible = alwaysShow;
                    this.setFastScrollerAlwaysVisibleUiThread(alwaysShow);
                }
            }
            setFastScrollerAlwaysVisibleUiThread(alwaysShow) {
            }
            isOwnerThread() {
                return true;
            }
            isFastScrollAlwaysVisible() {
                return false;
            }
            getVerticalScrollbarWidth() {
                return super.getVerticalScrollbarWidth();
            }
            isFastScrollEnabled() {
                return false;
            }
            setVerticalScrollbarPosition(position) {
                super.setVerticalScrollbarPosition(position);
            }
            setScrollBarStyle(style) {
                super.setScrollBarStyle(style);
            }
            isVerticalScrollBarHidden() {
                return this.isFastScrollEnabled();
            }
            setSmoothScrollbarEnabled(enabled) {
                this.mSmoothScrollbarEnabled = enabled;
            }
            isSmoothScrollbarEnabled() {
                return this.mSmoothScrollbarEnabled;
            }
            setOnScrollListener(l) {
                this.mOnScrollListener = l;
                this.invokeOnItemScrollListener();
            }
            invokeOnItemScrollListener() {
                if (this.mOnScrollListener != null) {
                    this.mOnScrollListener.onScroll(this, this.mFirstPosition, this.getChildCount(), this.mItemCount);
                }
                this.onScrollChanged(0, 0, 0, 0);
            }
            isScrollingCacheEnabled() {
                return this.mScrollingCacheEnabled;
            }
            setScrollingCacheEnabled(enabled) {
                if (this.mScrollingCacheEnabled && !enabled) {
                    this.clearScrollingCache();
                }
                this.mScrollingCacheEnabled = enabled;
            }
            setTextFilterEnabled(textFilterEnabled) {
                this.mTextFilterEnabled = textFilterEnabled;
            }
            isTextFilterEnabled() {
                return this.mTextFilterEnabled;
            }
            getFocusedRect(r) {
                let view = this.getSelectedView();
                if (view != null && view.getParent() == this) {
                    view.getFocusedRect(r);
                    this.offsetDescendantRectToMyCoords(view, r);
                }
                else {
                    super.getFocusedRect(r);
                }
            }
            useDefaultSelector() {
                this.setSelector(android.R.drawable.list_selector_background);
            }
            isStackFromBottom() {
                return this.mStackFromBottom;
            }
            setStackFromBottom(stackFromBottom) {
                if (this.mStackFromBottom != stackFromBottom) {
                    this.mStackFromBottom = stackFromBottom;
                    this.requestLayoutIfNecessary();
                }
            }
            requestLayoutIfNecessary() {
                if (this.getChildCount() > 0) {
                    this.resetList();
                    this.requestLayout();
                    this.invalidate();
                }
            }
            onFocusChanged(gainFocus, direction, previouslyFocusedRect) {
                super.onFocusChanged(gainFocus, direction, previouslyFocusedRect);
                if (gainFocus && this.mSelectedPosition < 0 && !this.isInTouchMode()) {
                    if (!this.isAttachedToWindow() && this.mAdapter != null) {
                        this.mDataChanged = true;
                        this.mOldItemCount = this.mItemCount;
                        this.mItemCount = this.mAdapter.getCount();
                    }
                    this.resurrectSelection();
                }
            }
            requestLayout() {
                if (!this.mBlockLayoutRequests && !this.mInLayout) {
                    super.requestLayout();
                }
            }
            resetList() {
                this.removeAllViewsInLayout();
                this.mFirstPosition = 0;
                this.mDataChanged = false;
                this.mPositionScrollAfterLayout = null;
                this.mNeedSync = false;
                this.mPendingSync = null;
                this.mOldSelectedPosition = AbsListView.INVALID_POSITION;
                this.mOldSelectedRowId = AbsListView.INVALID_ROW_ID;
                this.setSelectedPositionInt(AbsListView.INVALID_POSITION);
                this.setNextSelectedPositionInt(AbsListView.INVALID_POSITION);
                this.mSelectedTop = 0;
                this.mSelectorPosition = AbsListView.INVALID_POSITION;
                this.mSelectorRect.setEmpty();
                this.invalidate();
            }
            computeVerticalScrollExtent() {
                const count = this.getChildCount();
                if (count > 0) {
                    if (this.mSmoothScrollbarEnabled) {
                        let extent = count * 100;
                        let view = this.getChildAt(0);
                        const top = view.getTop();
                        let height = view.getHeight();
                        if (height > 0) {
                            extent += (top * 100) / height;
                        }
                        view = this.getChildAt(count - 1);
                        const bottom = view.getBottom();
                        height = view.getHeight();
                        if (height > 0) {
                            extent -= ((bottom - this.getHeight()) * 100) / height;
                        }
                        return extent;
                    }
                    else {
                        return 1;
                    }
                }
                return 0;
            }
            computeVerticalScrollOffset() {
                const firstPosition = this.mFirstPosition;
                const childCount = this.getChildCount();
                if (firstPosition >= 0 && childCount > 0) {
                    if (this.mSmoothScrollbarEnabled) {
                        const view = this.getChildAt(0);
                        const top = view.getTop();
                        let height = view.getHeight();
                        if (height > 0) {
                            return Math.max(firstPosition * 100 - (top * 100) / height + Math.floor((this.mScrollY / this.getHeight() * this.mItemCount * 100)), 0);
                        }
                    }
                    else {
                        let index;
                        const count = this.mItemCount;
                        if (firstPosition == 0) {
                            index = 0;
                        }
                        else if (firstPosition + childCount == count) {
                            index = count;
                        }
                        else {
                            index = firstPosition + childCount / 2;
                        }
                        return Math.floor((firstPosition + childCount * (index / count)));
                    }
                }
                return 0;
            }
            computeVerticalScrollRange() {
                let result;
                if (this.mSmoothScrollbarEnabled) {
                    result = Math.max(this.mItemCount * 100, 0);
                    if (this.mScrollY != 0) {
                        result += Math.abs(Math.floor((this.mScrollY / this.getHeight() * this.mItemCount * 100)));
                    }
                }
                else {
                    result = this.mItemCount;
                }
                return result;
            }
            getTopFadingEdgeStrength() {
                const count = this.getChildCount();
                const fadeEdge = super.getTopFadingEdgeStrength();
                if (count == 0) {
                    return fadeEdge;
                }
                else {
                    if (this.mFirstPosition > 0) {
                        return 1.0;
                    }
                    const top = this.getChildAt(0).getTop();
                    const fadeLength = this.getVerticalFadingEdgeLength();
                    return top < this.mPaddingTop ? -(top - this.mPaddingTop) / fadeLength : fadeEdge;
                }
            }
            getBottomFadingEdgeStrength() {
                const count = this.getChildCount();
                const fadeEdge = super.getBottomFadingEdgeStrength();
                if (count == 0) {
                    return fadeEdge;
                }
                else {
                    if (this.mFirstPosition + count - 1 < this.mItemCount - 1) {
                        return 1.0;
                    }
                    const bottom = this.getChildAt(count - 1).getBottom();
                    const height = this.getHeight();
                    const fadeLength = this.getVerticalFadingEdgeLength();
                    return bottom > height - this.mPaddingBottom ? (bottom - height + this.mPaddingBottom) / fadeLength : fadeEdge;
                }
            }
            onMeasure(widthMeasureSpec, heightMeasureSpec) {
                if (this.mSelector == null) {
                    this.useDefaultSelector();
                }
                const listPadding = this.mListPadding;
                listPadding.left = this.mSelectionLeftPadding + this.mPaddingLeft;
                listPadding.top = this.mSelectionTopPadding + this.mPaddingTop;
                listPadding.right = this.mSelectionRightPadding + this.mPaddingRight;
                listPadding.bottom = this.mSelectionBottomPadding + this.mPaddingBottom;
                if (this.mTranscriptMode == AbsListView.TRANSCRIPT_MODE_NORMAL) {
                    const childCount = this.getChildCount();
                    const listBottom = this.getHeight() - this.getPaddingBottom();
                    const lastChild = this.getChildAt(childCount - 1);
                    const lastBottom = lastChild != null ? lastChild.getBottom() : listBottom;
                    this.mForceTranscriptScroll = this.mFirstPosition + childCount >= this.mLastHandledItemCount && lastBottom <= listBottom;
                }
            }
            onLayout(changed, l, t, r, b) {
                super.onLayout(changed, l, t, r, b);
                this.mInLayout = true;
                if (changed) {
                    let childCount = this.getChildCount();
                    for (let i = 0; i < childCount; i++) {
                        this.getChildAt(i).forceLayout();
                    }
                    this.mRecycler.markChildrenDirty();
                }
                this.layoutChildren();
                this.mInLayout = false;
                this.mOverscrollMax = (b - t) / AbsListView.OVERSCROLL_LIMIT_DIVISOR;
            }
            setFrame(left, top, right, bottom) {
                const changed = super.setFrame(left, top, right, bottom);
                if (changed) {
                    const visible = this.getWindowVisibility() == View.VISIBLE;
                }
                return changed;
            }
            layoutChildren() {
            }
            updateScrollIndicators() {
                if (this.mScrollUp != null) {
                    let canScrollUp;
                    canScrollUp = this.mFirstPosition > 0;
                    if (!canScrollUp) {
                        if (this.getChildCount() > 0) {
                            let child = this.getChildAt(0);
                            canScrollUp = child.getTop() < this.mListPadding.top;
                        }
                    }
                    this.mScrollUp.setVisibility(canScrollUp ? View.VISIBLE : View.INVISIBLE);
                }
                if (this.mScrollDown != null) {
                    let canScrollDown;
                    let count = this.getChildCount();
                    canScrollDown = (this.mFirstPosition + count) < this.mItemCount;
                    if (!canScrollDown && count > 0) {
                        let child = this.getChildAt(count - 1);
                        canScrollDown = child.getBottom() > this.mBottom - this.mListPadding.bottom;
                    }
                    this.mScrollDown.setVisibility(canScrollDown ? View.VISIBLE : View.INVISIBLE);
                }
            }
            getSelectedView() {
                if (this.mItemCount > 0 && this.mSelectedPosition >= 0) {
                    return this.getChildAt(this.mSelectedPosition - this.mFirstPosition);
                }
                else {
                    return null;
                }
            }
            getListPaddingTop() {
                return this.mListPadding.top;
            }
            getListPaddingBottom() {
                return this.mListPadding.bottom;
            }
            getListPaddingLeft() {
                return this.mListPadding.left;
            }
            getListPaddingRight() {
                return this.mListPadding.right;
            }
            obtainView(position, isScrap) {
                isScrap[0] = false;
                let scrapView;
                scrapView = this.mRecycler.getTransientStateView(position);
                if (scrapView == null) {
                    scrapView = this.mRecycler.getScrapView(position);
                }
                let child;
                if (scrapView != null) {
                    child = this.mAdapter.getView(position, scrapView, this);
                    if (child != scrapView) {
                        this.mRecycler.addScrapView(scrapView, position);
                        if (this.mCacheColorHint != 0) {
                            child.setDrawingCacheBackgroundColor(this.mCacheColorHint);
                        }
                    }
                    else {
                        isScrap[0] = true;
                        child.dispatchFinishTemporaryDetach();
                    }
                }
                else {
                    child = this.mAdapter.getView(position, null, this);
                    if (this.mCacheColorHint != 0) {
                        child.setDrawingCacheBackgroundColor(this.mCacheColorHint);
                    }
                }
                if (this.mAdapterHasStableIds) {
                    const vlp = child.getLayoutParams();
                    let lp;
                    if (vlp == null) {
                        lp = this.generateDefaultLayoutParams();
                    }
                    else if (!this.checkLayoutParams(vlp)) {
                        lp = this.generateLayoutParams(vlp);
                    }
                    else {
                        lp = vlp;
                    }
                    lp.itemId = this.mAdapter.getItemId(position);
                    child.setLayoutParams(lp);
                }
                return child;
            }
            positionSelector(...args) {
                if (args.length === 4) {
                    let [l, t, r, b] = args;
                    this.mSelectorRect.set(l - this.mSelectionLeftPadding, t - this.mSelectionTopPadding, r + this.mSelectionRightPadding, b + this.mSelectionBottomPadding);
                }
                else {
                    let position = args[0];
                    let sel = args[1];
                    if (position != AbsListView.INVALID_POSITION) {
                        this.mSelectorPosition = position;
                    }
                    const selectorRect = this.mSelectorRect;
                    selectorRect.set(sel.getLeft(), sel.getTop(), sel.getRight(), sel.getBottom());
                    if (sel['adjustListItemSelectionBounds']) {
                        sel.adjustListItemSelectionBounds(selectorRect);
                    }
                    this.positionSelector(selectorRect.left, selectorRect.top, selectorRect.right, selectorRect.bottom);
                    const isChildViewEnabled = this.mIsChildViewEnabled;
                    if (sel.isEnabled() != isChildViewEnabled) {
                        this.mIsChildViewEnabled = !isChildViewEnabled;
                        if (this.getSelectedItemPosition() != AbsListView.INVALID_POSITION) {
                            this.refreshDrawableState();
                        }
                    }
                }
            }
            dispatchDraw(canvas) {
                let saveCount = 0;
                const clipToPadding = (this.mGroupFlags & AbsListView.CLIP_TO_PADDING_MASK) == AbsListView.CLIP_TO_PADDING_MASK;
                if (clipToPadding) {
                    saveCount = canvas.save();
                    const scrollX = this.mScrollX;
                    const scrollY = this.mScrollY;
                    canvas.clipRect(scrollX + this.mPaddingLeft, scrollY + this.mPaddingTop, scrollX + this.mRight - this.mLeft - this.mPaddingRight, scrollY + this.mBottom - this.mTop - this.mPaddingBottom);
                    this.mGroupFlags &= ~AbsListView.CLIP_TO_PADDING_MASK;
                }
                const drawSelectorOnTop = this.mDrawSelectorOnTop;
                if (!drawSelectorOnTop) {
                    this.drawSelector(canvas);
                }
                super.dispatchDraw(canvas);
                if (drawSelectorOnTop) {
                    this.drawSelector(canvas);
                }
                if (clipToPadding) {
                    canvas.restoreToCount(saveCount);
                    this.mGroupFlags |= AbsListView.CLIP_TO_PADDING_MASK;
                }
            }
            isPaddingOffsetRequired() {
                return (this.mGroupFlags & AbsListView.CLIP_TO_PADDING_MASK) != AbsListView.CLIP_TO_PADDING_MASK;
            }
            getLeftPaddingOffset() {
                return (this.mGroupFlags & AbsListView.CLIP_TO_PADDING_MASK) == AbsListView.CLIP_TO_PADDING_MASK ? 0 : -this.mPaddingLeft;
            }
            getTopPaddingOffset() {
                return (this.mGroupFlags & AbsListView.CLIP_TO_PADDING_MASK) == AbsListView.CLIP_TO_PADDING_MASK ? 0 : -this.mPaddingTop;
            }
            getRightPaddingOffset() {
                return (this.mGroupFlags & AbsListView.CLIP_TO_PADDING_MASK) == AbsListView.CLIP_TO_PADDING_MASK ? 0 : this.mPaddingRight;
            }
            getBottomPaddingOffset() {
                return (this.mGroupFlags & AbsListView.CLIP_TO_PADDING_MASK) == AbsListView.CLIP_TO_PADDING_MASK ? 0 : this.mPaddingBottom;
            }
            onSizeChanged(w, h, oldw, oldh) {
                if (this.getChildCount() > 0) {
                    this.mDataChanged = true;
                    this.rememberSyncState();
                }
            }
            touchModeDrawsInPressedState() {
                switch (this.mTouchMode) {
                    case AbsListView.TOUCH_MODE_TAP:
                    case AbsListView.TOUCH_MODE_DONE_WAITING:
                        return true;
                    default:
                        return false;
                }
            }
            shouldShowSelector() {
                return (!this.isInTouchMode()) || (this.touchModeDrawsInPressedState() && this.isPressed());
            }
            drawSelector(canvas) {
                if (!this.mSelectorRect.isEmpty()) {
                    const selector = this.mSelector;
                    selector.setBounds(this.mSelectorRect);
                    selector.draw(canvas);
                }
            }
            setDrawSelectorOnTop(onTop) {
                this.mDrawSelectorOnTop = onTop;
            }
            setSelector(sel) {
                if (this.mSelector != null) {
                    this.mSelector.setCallback(null);
                    this.unscheduleDrawable(this.mSelector);
                }
                this.mSelector = sel;
                let padding = new Rect();
                sel.getPadding(padding);
                this.mSelectionLeftPadding = padding.left;
                this.mSelectionTopPadding = padding.top;
                this.mSelectionRightPadding = padding.right;
                this.mSelectionBottomPadding = padding.bottom;
                sel.setCallback(this);
                this.updateSelectorState();
            }
            getSelector() {
                return this.mSelector;
            }
            keyPressed() {
                if (!this.isEnabled() || !this.isClickable()) {
                    return;
                }
                let selector = this.mSelector;
                let selectorRect = this.mSelectorRect;
                if (selector != null && (this.isFocused() || this.touchModeDrawsInPressedState()) && !selectorRect.isEmpty()) {
                    const v = this.getChildAt(this.mSelectedPosition - this.mFirstPosition);
                    if (v != null) {
                        if (v.hasFocusable())
                            return;
                        v.setPressed(true);
                    }
                    this.setPressed(true);
                    const longClickable = this.isLongClickable();
                    let d = selector.getCurrent();
                    if (longClickable && !this.mDataChanged) {
                        if (this.mPendingCheckForKeyLongPress == null) {
                            this.mPendingCheckForKeyLongPress = new AbsListView.CheckForKeyLongPress(this);
                        }
                        this.mPendingCheckForKeyLongPress.rememberWindowAttachCount();
                        this.postDelayed(this.mPendingCheckForKeyLongPress, ViewConfiguration.getLongPressTimeout());
                    }
                }
            }
            setScrollIndicators(up, down) {
                this.mScrollUp = up;
                this.mScrollDown = down;
            }
            updateSelectorState() {
                if (this.mSelector != null) {
                    if (this.shouldShowSelector()) {
                        this.mSelector.setState(this.getDrawableState());
                    }
                    else {
                        this.mSelector.setState(StateSet.NOTHING);
                    }
                }
            }
            drawableStateChanged() {
                super.drawableStateChanged();
                this.updateSelectorState();
            }
            onCreateDrawableState(extraSpace) {
                if (this.mIsChildViewEnabled) {
                    return super.onCreateDrawableState(extraSpace);
                }
                const enabledState = AbsListView.ENABLED_STATE_SET[0];
                let state = super.onCreateDrawableState(extraSpace + 1);
                let enabledPos = -1;
                for (let i = state.length - 1; i >= 0; i--) {
                    if (state[i] == enabledState) {
                        enabledPos = i;
                        break;
                    }
                }
                if (enabledPos >= 0) {
                    System.arraycopy(state, enabledPos + 1, state, enabledPos, state.length - enabledPos - 1);
                }
                return state;
            }
            verifyDrawable(dr) {
                return this.mSelector == dr || super.verifyDrawable(dr);
            }
            jumpDrawablesToCurrentState() {
                super.jumpDrawablesToCurrentState();
                if (this.mSelector != null)
                    this.mSelector.jumpToCurrentState();
            }
            onAttachedToWindow() {
                super.onAttachedToWindow();
                const treeObserver = this.getViewTreeObserver();
                treeObserver.addOnTouchModeChangeListener(this);
                if (this.mAdapter != null && this.mDataSetObserver == null) {
                    this.mDataSetObserver = new AbsListView.AdapterDataSetObserver(this);
                    this.mAdapter.registerDataSetObserver(this.mDataSetObserver);
                    this.mDataChanged = true;
                    this.mOldItemCount = this.mItemCount;
                    this.mItemCount = this.mAdapter.getCount();
                }
            }
            onDetachedFromWindow() {
                super.onDetachedFromWindow();
                this.dismissPopup();
                this.mRecycler.clear();
                const treeObserver = this.getViewTreeObserver();
                treeObserver.removeOnTouchModeChangeListener(this);
                if (this.mAdapter != null && this.mDataSetObserver != null) {
                    this.mAdapter.unregisterDataSetObserver(this.mDataSetObserver);
                    this.mDataSetObserver = null;
                }
                if (this.mFlingRunnable != null) {
                    this.removeCallbacks(this.mFlingRunnable);
                }
                if (this.mPositionScroller != null) {
                    this.mPositionScroller.stop();
                }
                if (this.mClearScrollingCache != null) {
                    this.removeCallbacks(this.mClearScrollingCache);
                }
                if (this.mPerformClick_ != null) {
                    this.removeCallbacks(this.mPerformClick_);
                }
                if (this.mTouchModeReset != null) {
                    this.removeCallbacks(this.mTouchModeReset);
                    this.mTouchModeReset.run();
                }
            }
            onWindowFocusChanged(hasWindowFocus) {
                super.onWindowFocusChanged(hasWindowFocus);
                const touchMode = this.isInTouchMode() ? AbsListView.TOUCH_MODE_ON : AbsListView.TOUCH_MODE_OFF;
                if (!hasWindowFocus) {
                    this.setChildrenDrawingCacheEnabled(false);
                    if (this.mFlingRunnable != null) {
                        this.removeCallbacks(this.mFlingRunnable);
                        this.mFlingRunnable.endFling();
                        if (this.mPositionScroller != null) {
                            this.mPositionScroller.stop();
                        }
                        if (this.mScrollY != 0) {
                            this.mScrollY = 0;
                            this.invalidateParentCaches();
                            this.finishGlows();
                            this.invalidate();
                        }
                    }
                    this.dismissPopup();
                    if (touchMode == AbsListView.TOUCH_MODE_OFF) {
                        this.mResurrectToPosition = this.mSelectedPosition;
                    }
                }
                else {
                    if (this.mFiltered && !this.mPopupHidden) {
                        this.showPopup();
                    }
                    if (touchMode != this.mLastTouchMode && this.mLastTouchMode != AbsListView.TOUCH_MODE_UNKNOWN) {
                        if (touchMode == AbsListView.TOUCH_MODE_OFF) {
                            this.resurrectSelection();
                        }
                        else {
                            this.hideSelector();
                            this.mLayoutMode = AbsListView.LAYOUT_NORMAL;
                            this.layoutChildren();
                        }
                    }
                }
                this.mLastTouchMode = touchMode;
            }
            onCancelPendingInputEvents() {
                super.onCancelPendingInputEvents();
                if (this.mPerformClick_ != null) {
                    this.removeCallbacks(this.mPerformClick_);
                }
                if (this.mPendingCheckForTap_ != null) {
                    this.removeCallbacks(this.mPendingCheckForTap_);
                }
                if (this.mPendingCheckForLongPress_List != null) {
                    this.removeCallbacks(this.mPendingCheckForLongPress_List);
                }
                if (this.mPendingCheckForKeyLongPress != null) {
                    this.removeCallbacks(this.mPendingCheckForKeyLongPress);
                }
            }
            performLongPress(child, longPressPosition, longPressId) {
                let handled = false;
                if (this.mOnItemLongClickListener != null) {
                    handled = this.mOnItemLongClickListener.onItemLongClick(this, child, longPressPosition, longPressId);
                }
                if (handled) {
                    this.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
                }
                return handled;
            }
            onKeyDown(keyCode, event) {
                return false;
            }
            onKeyUp(keyCode, event) {
                if (KeyEvent.isConfirmKey(keyCode)) {
                    if (!this.isEnabled()) {
                        return true;
                    }
                    if (this.isClickable() && this.isPressed() && this.mSelectedPosition >= 0
                        && this.mAdapter != null && this.mSelectedPosition < this.mAdapter.getCount()) {
                        const view = this.getChildAt(this.mSelectedPosition - this.mFirstPosition);
                        if (view != null) {
                            this.performItemClick(view, this.mSelectedPosition, this.mSelectedRowId);
                            view.setPressed(false);
                        }
                        this.setPressed(false);
                        return true;
                    }
                }
                return super.onKeyUp(keyCode, event);
            }
            dispatchSetPressed(pressed) {
            }
            pointToPosition(x, y) {
                let frame = this.mTouchFrame;
                if (frame == null) {
                    this.mTouchFrame = new Rect();
                    frame = this.mTouchFrame;
                }
                const count = this.getChildCount();
                for (let i = count - 1; i >= 0; i--) {
                    const child = this.getChildAt(i);
                    if (child.getVisibility() == View.VISIBLE) {
                        child.getHitRect(frame);
                        if (frame.contains(x, y)) {
                            return this.mFirstPosition + i;
                        }
                    }
                }
                return AbsListView.INVALID_POSITION;
            }
            pointToRowId(x, y) {
                let position = this.pointToPosition(x, y);
                if (position >= 0) {
                    return this.mAdapter.getItemId(position);
                }
                return AbsListView.INVALID_ROW_ID;
            }
            startScrollIfNeeded(y) {
                const deltaY = y - this.mMotionY;
                const distance = Math.abs(deltaY);
                const overscroll = this.mScrollY != 0;
                if (overscroll || distance > this.mTouchSlop) {
                    this.createScrollingCache();
                    if (overscroll) {
                        this.mTouchMode = AbsListView.TOUCH_MODE_OVERSCROLL;
                        this.mMotionCorrection = 0;
                    }
                    else {
                        this.mTouchMode = AbsListView.TOUCH_MODE_SCROLL;
                        this.mMotionCorrection = deltaY > 0 ? this.mTouchSlop : -this.mTouchSlop;
                    }
                    this.removeCallbacks(this.mPendingCheckForLongPress_List);
                    this.setPressed(false);
                    const motionView = this.getChildAt(this.mMotionPosition - this.mFirstPosition);
                    if (motionView != null) {
                        motionView.setPressed(false);
                    }
                    this.reportScrollStateChange(AbsListView.OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
                    const parent = this.getParent();
                    if (parent != null) {
                        parent.requestDisallowInterceptTouchEvent(true);
                    }
                    this.scrollIfNeeded(y);
                    return true;
                }
                return false;
            }
            scrollIfNeeded(y) {
                const rawDeltaY = y - this.mMotionY;
                const deltaY = rawDeltaY - this.mMotionCorrection;
                let incrementalDeltaY = this.mLastY != Integer.MIN_VALUE ? y - this.mLastY : deltaY;
                if (this.mTouchMode == AbsListView.TOUCH_MODE_SCROLL) {
                    if (AbsListView.PROFILE_SCROLLING) {
                        if (!this.mScrollProfilingStarted) {
                            this.mScrollProfilingStarted = true;
                        }
                    }
                    if (y != this.mLastY) {
                        if ((this.mGroupFlags & AbsListView.FLAG_DISALLOW_INTERCEPT) == 0 && Math.abs(rawDeltaY) > this.mTouchSlop) {
                            const parent = this.getParent();
                            if (parent != null) {
                                parent.requestDisallowInterceptTouchEvent(true);
                            }
                        }
                        let motionIndex;
                        if (this.mMotionPosition >= 0) {
                            motionIndex = this.mMotionPosition - this.mFirstPosition;
                        }
                        else {
                            motionIndex = this.getChildCount() / 2;
                        }
                        let motionViewPrevTop = 0;
                        let motionView = this.getChildAt(motionIndex);
                        if (motionView != null) {
                            motionViewPrevTop = motionView.getTop();
                        }
                        let atEdge = false;
                        if (incrementalDeltaY != 0) {
                            atEdge = this.trackMotionScroll(deltaY, incrementalDeltaY);
                        }
                        motionView = this.getChildAt(motionIndex);
                        if (motionView != null) {
                            const motionViewRealTop = motionView.getTop();
                            if (atEdge) {
                                let overscroll = -incrementalDeltaY - (motionViewRealTop - motionViewPrevTop);
                                this.overScrollBy(0, overscroll, 0, this.mScrollY, 0, 0, 0, this.mOverscrollDistance, true);
                                if (Math.abs(this.mOverscrollDistance) == Math.abs(this.mScrollY)) {
                                    if (this.mVelocityTracker != null) {
                                        this.mVelocityTracker.clear();
                                    }
                                }
                                const overscrollMode = this.getOverScrollMode();
                                if (overscrollMode == AbsListView.OVER_SCROLL_ALWAYS || (overscrollMode == AbsListView.OVER_SCROLL_IF_CONTENT_SCROLLS && !this.contentFits())) {
                                    this.mDirection = 0;
                                    this.mTouchMode = AbsListView.TOUCH_MODE_OVERSCROLL;
                                    if (rawDeltaY > 0) {
                                    }
                                    else if (rawDeltaY < 0) {
                                    }
                                }
                            }
                            this.mMotionY = y;
                        }
                        this.mLastY = y;
                    }
                }
                else if (this.mTouchMode == AbsListView.TOUCH_MODE_OVERSCROLL) {
                    if (y != this.mLastY) {
                        const oldScroll = this.mScrollY;
                        const newScroll = oldScroll - incrementalDeltaY;
                        let newDirection = y > this.mLastY ? 1 : -1;
                        if (this.mDirection == 0) {
                            this.mDirection = newDirection;
                        }
                        let overScrollDistance = -incrementalDeltaY;
                        if ((newScroll < 0 && oldScroll >= 0) || (newScroll > 0 && oldScroll <= 0)) {
                            overScrollDistance = -oldScroll;
                            incrementalDeltaY += overScrollDistance;
                        }
                        else {
                            incrementalDeltaY = 0;
                        }
                        if (overScrollDistance != 0) {
                            this.overScrollBy(0, overScrollDistance, 0, this.mScrollY, 0, 0, 0, this.mOverscrollDistance, true);
                            const overscrollMode = this.getOverScrollMode();
                            if (overscrollMode == AbsListView.OVER_SCROLL_ALWAYS || (overscrollMode == AbsListView.OVER_SCROLL_IF_CONTENT_SCROLLS && !this.contentFits())) {
                                if (rawDeltaY > 0) {
                                }
                                else if (rawDeltaY < 0) {
                                }
                            }
                        }
                        if (incrementalDeltaY != 0) {
                            if (this.mScrollY != 0) {
                                this.mScrollY = 0;
                                this.invalidateParentIfNeeded();
                            }
                            this.trackMotionScroll(incrementalDeltaY, incrementalDeltaY);
                            this.mTouchMode = AbsListView.TOUCH_MODE_SCROLL;
                            const motionPosition = this.findClosestMotionRow(y);
                            this.mMotionCorrection = 0;
                            let motionView = this.getChildAt(motionPosition - this.mFirstPosition);
                            this.mMotionViewOriginalTop = motionView != null ? motionView.getTop() : 0;
                            this.mMotionY = y;
                            this.mMotionPosition = motionPosition;
                        }
                        this.mLastY = y;
                        this.mDirection = newDirection;
                    }
                }
            }
            onTouchModeChanged(isInTouchMode) {
                if (isInTouchMode) {
                    this.hideSelector();
                    if (this.getHeight() > 0 && this.getChildCount() > 0) {
                        this.layoutChildren();
                    }
                    this.updateSelectorState();
                }
                else {
                    let touchMode = this.mTouchMode;
                    if (touchMode == AbsListView.TOUCH_MODE_OVERSCROLL || touchMode == AbsListView.TOUCH_MODE_OVERFLING) {
                        if (this.mFlingRunnable != null) {
                            this.mFlingRunnable.endFling();
                        }
                        if (this.mPositionScroller != null) {
                            this.mPositionScroller.stop();
                        }
                        if (this.mScrollY != 0) {
                            this.mScrollY = 0;
                            this.invalidateParentCaches();
                            this.finishGlows();
                            this.invalidate();
                        }
                    }
                }
            }
            onTouchEvent(ev) {
                if (!this.isEnabled()) {
                    return this.isClickable() || this.isLongClickable();
                }
                if (this.mPositionScroller != null) {
                    this.mPositionScroller.stop();
                }
                if (!this.isAttachedToWindow()) {
                    return false;
                }
                this.initVelocityTrackerIfNotExists();
                this.mVelocityTracker.addMovement(ev);
                const actionMasked = ev.getActionMasked();
                switch (actionMasked) {
                    case MotionEvent.ACTION_DOWN:
                        {
                            this.onTouchDown(ev);
                            break;
                        }
                    case MotionEvent.ACTION_MOVE:
                        {
                            this.onTouchMove(ev);
                            break;
                        }
                    case MotionEvent.ACTION_UP:
                        {
                            this.onTouchUp(ev);
                            break;
                        }
                    case MotionEvent.ACTION_CANCEL:
                        {
                            this.onTouchCancel();
                            break;
                        }
                    case MotionEvent.ACTION_POINTER_UP:
                        {
                            this.onSecondaryPointerUp(ev);
                            const x = this.mMotionX;
                            const y = this.mMotionY;
                            const motionPosition = this.pointToPosition(x, y);
                            if (motionPosition >= 0) {
                                const child = this.getChildAt(motionPosition - this.mFirstPosition);
                                this.mMotionViewOriginalTop = child.getTop();
                                this.mMotionPosition = motionPosition;
                            }
                            this.mLastY = y;
                            break;
                        }
                    case MotionEvent.ACTION_POINTER_DOWN:
                        {
                            const index = ev.getActionIndex();
                            const id = ev.getPointerId(index);
                            const x = Math.floor(ev.getX(index));
                            const y = Math.floor(ev.getY(index));
                            this.mMotionCorrection = 0;
                            this.mActivePointerId = id;
                            this.mMotionX = x;
                            this.mMotionY = y;
                            const motionPosition = this.pointToPosition(x, y);
                            if (motionPosition >= 0) {
                                const child = this.getChildAt(motionPosition - this.mFirstPosition);
                                this.mMotionViewOriginalTop = child.getTop();
                                this.mMotionPosition = motionPosition;
                            }
                            this.mLastY = y;
                            break;
                        }
                }
                return true;
            }
            onTouchDown(ev) {
                this.mActivePointerId = ev.getPointerId(0);
                if (this.mTouchMode == AbsListView.TOUCH_MODE_OVERFLING) {
                    this.mFlingRunnable.endFling();
                    if (this.mPositionScroller != null) {
                        this.mPositionScroller.stop();
                    }
                    this.mTouchMode = AbsListView.TOUCH_MODE_OVERSCROLL;
                    this.mMotionX = Math.floor(ev.getX());
                    this.mMotionY = Math.floor(ev.getY());
                    this.mLastY = this.mMotionY;
                    this.mMotionCorrection = 0;
                    this.mDirection = 0;
                }
                else {
                    const x = Math.floor(ev.getX());
                    const y = Math.floor(ev.getY());
                    let motionPosition = this.pointToPosition(x, y);
                    if (!this.mDataChanged) {
                        if (this.mTouchMode == AbsListView.TOUCH_MODE_FLING) {
                            this.createScrollingCache();
                            this.mTouchMode = AbsListView.TOUCH_MODE_SCROLL;
                            this.mMotionCorrection = 0;
                            motionPosition = this.findMotionRow(y);
                            this.mFlingRunnable.flywheelTouch();
                        }
                        else if ((motionPosition >= 0) && this.getAdapter().isEnabled(motionPosition)) {
                            this.mTouchMode = AbsListView.TOUCH_MODE_DOWN;
                            if (this.mPendingCheckForTap_ == null) {
                                this.mPendingCheckForTap_ = new AbsListView.CheckForTap(this);
                            }
                            this.postDelayed(this.mPendingCheckForTap_, ViewConfiguration.getTapTimeout());
                        }
                    }
                    if (motionPosition >= 0) {
                        const v = this.getChildAt(motionPosition - this.mFirstPosition);
                        this.mMotionViewOriginalTop = v.getTop();
                    }
                    this.mMotionX = x;
                    this.mMotionY = y;
                    this.mMotionPosition = motionPosition;
                    this.mLastY = Integer.MIN_VALUE;
                }
                if (this.mTouchMode == AbsListView.TOUCH_MODE_DOWN && this.mMotionPosition != AbsListView.INVALID_POSITION
                    && this.performButtonActionOnTouchDown(ev)) {
                    this.removeCallbacks(this.mPendingCheckForTap_);
                }
            }
            onTouchMove(ev) {
                let pointerIndex = ev.findPointerIndex(this.mActivePointerId);
                if (pointerIndex == -1) {
                    pointerIndex = 0;
                    this.mActivePointerId = ev.getPointerId(pointerIndex);
                }
                if (this.mDataChanged) {
                    this.layoutChildren();
                }
                const y = Math.floor(ev.getY(pointerIndex));
                switch (this.mTouchMode) {
                    case AbsListView.TOUCH_MODE_DOWN:
                    case AbsListView.TOUCH_MODE_TAP:
                    case AbsListView.TOUCH_MODE_DONE_WAITING:
                        if (this.startScrollIfNeeded(y)) {
                            break;
                        }
                        const x = ev.getX(pointerIndex);
                        if (!this.pointInView(x, y, this.mTouchSlop)) {
                            this.setPressed(false);
                            const motionView = this.getChildAt(this.mMotionPosition - this.mFirstPosition);
                            if (motionView != null) {
                                motionView.setPressed(false);
                            }
                            this.removeCallbacks(this.mTouchMode == AbsListView.TOUCH_MODE_DOWN ? this.mPendingCheckForTap_ : this.mPendingCheckForLongPress_List);
                            this.mTouchMode = AbsListView.TOUCH_MODE_DONE_WAITING;
                            this.updateSelectorState();
                        }
                        break;
                    case AbsListView.TOUCH_MODE_SCROLL:
                    case AbsListView.TOUCH_MODE_OVERSCROLL:
                        this.scrollIfNeeded(y);
                        break;
                }
            }
            onTouchUp(ev) {
                switch (this.mTouchMode) {
                    case AbsListView.TOUCH_MODE_DOWN:
                    case AbsListView.TOUCH_MODE_TAP:
                    case AbsListView.TOUCH_MODE_DONE_WAITING:
                        const motionPosition = this.mMotionPosition;
                        const child = this.getChildAt(motionPosition - this.mFirstPosition);
                        if (child != null) {
                            if (this.mTouchMode != AbsListView.TOUCH_MODE_DOWN) {
                                child.setPressed(false);
                            }
                            const x = ev.getX();
                            const inList = x > this.mListPadding.left && x < this.getWidth() - this.mListPadding.right;
                            if (inList && !child.hasFocusable()) {
                                if (this.mPerformClick_ == null) {
                                    this.mPerformClick_ = new AbsListView.PerformClick(this);
                                }
                                const performClick = this.mPerformClick_;
                                performClick.mClickMotionPosition = motionPosition;
                                performClick.rememberWindowAttachCount();
                                this.mResurrectToPosition = motionPosition;
                                if (this.mTouchMode == AbsListView.TOUCH_MODE_DOWN || this.mTouchMode == AbsListView.TOUCH_MODE_TAP) {
                                    this.removeCallbacks(this.mTouchMode == AbsListView.TOUCH_MODE_DOWN ? this.mPendingCheckForTap_ : this.mPendingCheckForLongPress_List);
                                    this.mLayoutMode = AbsListView.LAYOUT_NORMAL;
                                    if (!this.mDataChanged && this.mAdapter.isEnabled(motionPosition)) {
                                        this.mTouchMode = AbsListView.TOUCH_MODE_TAP;
                                        this.setSelectedPositionInt(this.mMotionPosition);
                                        this.layoutChildren();
                                        child.setPressed(true);
                                        this.positionSelector(this.mMotionPosition, child);
                                        this.setPressed(true);
                                        if (this.mSelector != null) {
                                            let d = this.mSelector.getCurrent();
                                        }
                                        if (this.mTouchModeReset != null) {
                                            this.removeCallbacks(this.mTouchModeReset);
                                        }
                                        this.mTouchModeReset = (() => {
                                            const _this = this;
                                            class _Inner {
                                                run() {
                                                    _this.mTouchModeReset = null;
                                                    _this.mTouchMode = AbsListView.TOUCH_MODE_REST;
                                                    child.setPressed(false);
                                                    _this.setPressed(false);
                                                    if (!_this.mDataChanged && _this.isAttachedToWindow()) {
                                                        performClick.run();
                                                    }
                                                }
                                            }
                                            return new _Inner();
                                        })();
                                        this.postDelayed(this.mTouchModeReset, ViewConfiguration.getPressedStateDuration());
                                    }
                                    else {
                                        this.mTouchMode = AbsListView.TOUCH_MODE_REST;
                                        this.updateSelectorState();
                                    }
                                    return;
                                }
                                else if (!this.mDataChanged && this.mAdapter.isEnabled(motionPosition)) {
                                    performClick.run();
                                }
                            }
                        }
                        this.mTouchMode = AbsListView.TOUCH_MODE_REST;
                        this.updateSelectorState();
                        break;
                    case AbsListView.TOUCH_MODE_SCROLL:
                        const childCount = this.getChildCount();
                        if (childCount > 0) {
                            const firstChildTop = this.getChildAt(0).getTop();
                            const lastChildBottom = this.getChildAt(childCount - 1).getBottom();
                            const contentTop = this.mListPadding.top;
                            const contentBottom = this.getHeight() - this.mListPadding.bottom;
                            if (this.mFirstPosition == 0 && firstChildTop >= contentTop && this.mFirstPosition + childCount < this.mItemCount
                                && lastChildBottom <= this.getHeight() - contentBottom) {
                                this.mTouchMode = AbsListView.TOUCH_MODE_REST;
                                this.reportScrollStateChange(AbsListView.OnScrollListener.SCROLL_STATE_IDLE);
                            }
                            else {
                                const velocityTracker = this.mVelocityTracker;
                                velocityTracker.computeCurrentVelocity(1000, this.mMaximumVelocity);
                                const initialVelocity = Math.floor((velocityTracker.getYVelocity(this.mActivePointerId) * this.mVelocityScale));
                                if (Math.abs(initialVelocity) > this.mMinimumVelocity
                                    && !((this.mFirstPosition == 0 && firstChildTop == contentTop - this.mOverscrollDistance)
                                        || (this.mFirstPosition + childCount == this.mItemCount
                                            && lastChildBottom == contentBottom + this.mOverscrollDistance))) {
                                    if (this.mFlingRunnable == null) {
                                        this.mFlingRunnable = new AbsListView.FlingRunnable(this);
                                    }
                                    this.reportScrollStateChange(AbsListView.OnScrollListener.SCROLL_STATE_FLING);
                                    this.mFlingRunnable.start(-initialVelocity);
                                }
                                else {
                                    this.mTouchMode = AbsListView.TOUCH_MODE_REST;
                                    this.reportScrollStateChange(AbsListView.OnScrollListener.SCROLL_STATE_IDLE);
                                    if (this.mFlingRunnable != null) {
                                        this.mFlingRunnable.endFling();
                                    }
                                    if (this.mPositionScroller != null) {
                                        this.mPositionScroller.stop();
                                    }
                                }
                            }
                        }
                        else {
                            this.mTouchMode = AbsListView.TOUCH_MODE_REST;
                            this.reportScrollStateChange(AbsListView.OnScrollListener.SCROLL_STATE_IDLE);
                        }
                        break;
                    case AbsListView.TOUCH_MODE_OVERSCROLL:
                        if (this.mFlingRunnable == null) {
                            this.mFlingRunnable = new AbsListView.FlingRunnable(this);
                        }
                        const velocityTracker = this.mVelocityTracker;
                        velocityTracker.computeCurrentVelocity(1000, this.mMaximumVelocity);
                        const initialVelocity = Math.floor(velocityTracker.getYVelocity(this.mActivePointerId));
                        this.reportScrollStateChange(AbsListView.OnScrollListener.SCROLL_STATE_FLING);
                        let isOverDrag = this.mScrollY < 0 || this.mScrollY > this.computeVerticalScrollRange();
                        if (!isOverDrag && Math.abs(initialVelocity) > this.mMinimumVelocity) {
                            this.mFlingRunnable.startOverfling(-initialVelocity);
                        }
                        else {
                            this.mFlingRunnable.startSpringback();
                        }
                        break;
                }
                this.setPressed(false);
                this.invalidate();
                this.removeCallbacks(this.mPendingCheckForLongPress_List);
                this.recycleVelocityTracker();
                this.mActivePointerId = AbsListView.INVALID_POINTER;
                if (AbsListView.PROFILE_SCROLLING) {
                    if (this.mScrollProfilingStarted) {
                        this.mScrollProfilingStarted = false;
                    }
                }
            }
            onTouchCancel() {
                switch (this.mTouchMode) {
                    case AbsListView.TOUCH_MODE_OVERSCROLL:
                        if (this.mFlingRunnable == null) {
                            this.mFlingRunnable = new AbsListView.FlingRunnable(this);
                        }
                        this.mFlingRunnable.startSpringback();
                        break;
                    case AbsListView.TOUCH_MODE_OVERFLING:
                        break;
                    default:
                        this.mTouchMode = AbsListView.TOUCH_MODE_REST;
                        this.setPressed(false);
                        const motionView = this.getChildAt(this.mMotionPosition - this.mFirstPosition);
                        if (motionView != null) {
                            motionView.setPressed(false);
                        }
                        this.clearScrollingCache();
                        this.removeCallbacks(this.mPendingCheckForLongPress_List);
                        this.recycleVelocityTracker();
                }
                this.mActivePointerId = AbsListView.INVALID_POINTER;
            }
            onOverScrolled(scrollX, scrollY, clampedX, clampedY) {
                if (this.mScrollY != scrollY) {
                    this.onScrollChanged(this.mScrollX, scrollY, this.mScrollX, this.mScrollY);
                    this.mScrollY = scrollY;
                    this.invalidateParentIfNeeded();
                    this.awakenScrollBars();
                }
            }
            onGenericMotionEvent(event) {
                if (event.isPointerEvent()) {
                    switch (event.getAction()) {
                        case MotionEvent.ACTION_SCROLL:
                            {
                                if (this.mTouchMode == AbsListView.TOUCH_MODE_REST) {
                                    const vscroll = event.getAxisValue(MotionEvent.AXIS_VSCROLL);
                                    if (vscroll != 0) {
                                        const delta = Math.floor((vscroll * this.getVerticalScrollFactor()));
                                        if (!this.trackMotionScroll(delta, delta)) {
                                            return true;
                                        }
                                    }
                                }
                            }
                    }
                }
                return super.onGenericMotionEvent(event);
            }
            draw(canvas) {
                super.draw(canvas);
            }
            setOverScrollEffectPadding(leftPadding, rightPadding) {
                this.mGlowPaddingLeft = leftPadding;
                this.mGlowPaddingRight = rightPadding;
            }
            initOrResetVelocityTracker() {
                if (this.mVelocityTracker == null) {
                    this.mVelocityTracker = VelocityTracker.obtain();
                }
                else {
                    this.mVelocityTracker.clear();
                }
            }
            initVelocityTrackerIfNotExists() {
                if (this.mVelocityTracker == null) {
                    this.mVelocityTracker = VelocityTracker.obtain();
                }
            }
            recycleVelocityTracker() {
                if (this.mVelocityTracker != null) {
                    this.mVelocityTracker.recycle();
                    this.mVelocityTracker = null;
                }
            }
            requestDisallowInterceptTouchEvent(disallowIntercept) {
                if (disallowIntercept) {
                    this.recycleVelocityTracker();
                }
                super.requestDisallowInterceptTouchEvent(disallowIntercept);
            }
            onInterceptTouchEvent(ev) {
                let action = ev.getAction();
                let v;
                if (this.mPositionScroller != null) {
                    this.mPositionScroller.stop();
                }
                if (!this.isAttachedToWindow()) {
                    return false;
                }
                switch (action & MotionEvent.ACTION_MASK) {
                    case MotionEvent.ACTION_DOWN:
                        {
                            let touchMode = this.mTouchMode;
                            if (touchMode == AbsListView.TOUCH_MODE_OVERFLING || touchMode == AbsListView.TOUCH_MODE_OVERSCROLL) {
                                this.mMotionCorrection = 0;
                                return true;
                            }
                            const x = Math.floor(ev.getX());
                            const y = Math.floor(ev.getY());
                            this.mActivePointerId = ev.getPointerId(0);
                            let motionPosition = this.findMotionRow(y);
                            if (touchMode != AbsListView.TOUCH_MODE_FLING && motionPosition >= 0) {
                                v = this.getChildAt(motionPosition - this.mFirstPosition);
                                this.mMotionViewOriginalTop = v.getTop();
                                this.mMotionX = x;
                                this.mMotionY = y;
                                this.mMotionPosition = motionPosition;
                                this.mTouchMode = AbsListView.TOUCH_MODE_DOWN;
                                this.clearScrollingCache();
                            }
                            this.mLastY = Integer.MIN_VALUE;
                            this.initOrResetVelocityTracker();
                            this.mVelocityTracker.addMovement(ev);
                            if (touchMode == AbsListView.TOUCH_MODE_FLING) {
                                return true;
                            }
                            break;
                        }
                    case MotionEvent.ACTION_MOVE:
                        {
                            switch (this.mTouchMode) {
                                case AbsListView.TOUCH_MODE_DOWN:
                                    let pointerIndex = ev.findPointerIndex(this.mActivePointerId);
                                    if (pointerIndex == -1) {
                                        pointerIndex = 0;
                                        this.mActivePointerId = ev.getPointerId(pointerIndex);
                                    }
                                    const y = Math.floor(ev.getY(pointerIndex));
                                    this.initVelocityTrackerIfNotExists();
                                    this.mVelocityTracker.addMovement(ev);
                                    if (this.startScrollIfNeeded(y)) {
                                        return true;
                                    }
                                    break;
                            }
                            break;
                        }
                    case MotionEvent.ACTION_CANCEL:
                    case MotionEvent.ACTION_UP:
                        {
                            this.mTouchMode = AbsListView.TOUCH_MODE_REST;
                            this.mActivePointerId = AbsListView.INVALID_POINTER;
                            this.recycleVelocityTracker();
                            this.reportScrollStateChange(AbsListView.OnScrollListener.SCROLL_STATE_IDLE);
                            break;
                        }
                    case MotionEvent.ACTION_POINTER_UP:
                        {
                            this.onSecondaryPointerUp(ev);
                            break;
                        }
                }
                return false;
            }
            onSecondaryPointerUp(ev) {
                const pointerIndex = (ev.getAction() & MotionEvent.ACTION_POINTER_INDEX_MASK) >> MotionEvent.ACTION_POINTER_INDEX_SHIFT;
                const pointerId = ev.getPointerId(pointerIndex);
                if (pointerId == this.mActivePointerId) {
                    const newPointerIndex = pointerIndex == 0 ? 1 : 0;
                    this.mMotionX = Math.floor(ev.getX(newPointerIndex));
                    this.mMotionY = Math.floor(ev.getY(newPointerIndex));
                    this.mMotionCorrection = 0;
                    this.mActivePointerId = ev.getPointerId(newPointerIndex);
                }
            }
            addTouchables(views) {
                const count = this.getChildCount();
                const firstPosition = this.mFirstPosition;
                const adapter = this.mAdapter;
                if (adapter == null) {
                    return;
                }
                for (let i = 0; i < count; i++) {
                    const child = this.getChildAt(i);
                    if (adapter.isEnabled(firstPosition + i)) {
                        views.add(child);
                    }
                    child.addTouchables(views);
                }
            }
            reportScrollStateChange(newState) {
                if (newState != this.mLastScrollState) {
                    if (this.mOnScrollListener != null) {
                        this.mLastScrollState = newState;
                        this.mOnScrollListener.onScrollStateChanged(this, newState);
                    }
                }
            }
            setFriction(friction) {
                if (this.mFlingRunnable == null) {
                    this.mFlingRunnable = new AbsListView.FlingRunnable(this);
                }
                this.mFlingRunnable.mScroller.setFriction(friction);
            }
            setVelocityScale(scale) {
                this.mVelocityScale = scale;
            }
            smoothScrollToPositionFromTop(position, offset, duration) {
                if (this.mPositionScroller == null) {
                    this.mPositionScroller = new AbsListView.PositionScroller(this);
                }
                this.mPositionScroller.startWithOffset(position, offset, duration);
            }
            smoothScrollToPosition(position, boundPosition) {
                if (this.mPositionScroller == null) {
                    this.mPositionScroller = new AbsListView.PositionScroller(this);
                }
                this.mPositionScroller.start(position, boundPosition);
            }
            smoothScrollBy(distance, duration, linear = false) {
                if (this.mFlingRunnable == null) {
                    this.mFlingRunnable = new AbsListView.FlingRunnable(this);
                }
                const firstPos = this.mFirstPosition;
                const childCount = this.getChildCount();
                const lastPos = firstPos + childCount;
                const topLimit = this.getPaddingTop();
                const bottomLimit = this.getHeight() - this.getPaddingBottom();
                if (distance == 0 || this.mItemCount == 0 || childCount == 0
                    || (firstPos == 0 && this.getChildAt(0).getTop() == topLimit && distance < 0)
                    || (lastPos == this.mItemCount && this.getChildAt(childCount - 1).getBottom() == bottomLimit && distance > 0)) {
                    this.mFlingRunnable.endFling();
                    if (this.mPositionScroller != null) {
                        this.mPositionScroller.stop();
                    }
                }
                else {
                    this.reportScrollStateChange(AbsListView.OnScrollListener.SCROLL_STATE_FLING);
                    this.mFlingRunnable.startScroll(distance, duration, linear);
                }
            }
            smoothScrollByOffset(position) {
                let index = -1;
                if (position < 0) {
                    index = this.getFirstVisiblePosition();
                }
                else if (position > 0) {
                    index = this.getLastVisiblePosition();
                }
                if (index > -1) {
                    let child = this.getChildAt(index - this.getFirstVisiblePosition());
                    if (child != null) {
                        let visibleRect = new Rect();
                        if (child.getGlobalVisibleRect(visibleRect)) {
                            let childRectArea = child.getWidth() * child.getHeight();
                            let visibleRectArea = visibleRect.width() * visibleRect.height();
                            let visibleArea = (visibleRectArea / childRectArea);
                            const visibleThreshold = 0.75;
                            if ((position < 0) && (visibleArea < visibleThreshold)) {
                                ++index;
                            }
                            else if ((position > 0) && (visibleArea < visibleThreshold)) {
                                --index;
                            }
                        }
                        this.smoothScrollToPosition(Math.max(0, Math.min(this.getCount(), index + position)));
                    }
                }
            }
            createScrollingCache() {
                if (this.mScrollingCacheEnabled && !this.mCachingStarted && !this.isHardwareAccelerated()) {
                    this.setChildrenDrawnWithCacheEnabled(true);
                    this.setChildrenDrawingCacheEnabled(true);
                    this.mCachingStarted = this.mCachingActive = true;
                }
            }
            clearScrollingCache() {
                if (!this.isHardwareAccelerated()) {
                    if (this.mClearScrollingCache == null) {
                        this.mClearScrollingCache = (() => {
                            const _this = this;
                            class _Inner {
                                run() {
                                    if (_this.mCachingStarted) {
                                        _this.mCachingStarted = _this.mCachingActive = false;
                                        _this.setChildrenDrawnWithCacheEnabled(false);
                                        if ((_this.mPersistentDrawingCache & AbsListView.PERSISTENT_SCROLLING_CACHE) == 0) {
                                            _this.setChildrenDrawingCacheEnabled(false);
                                        }
                                        if (!_this.isAlwaysDrawnWithCacheEnabled()) {
                                            _this.invalidate();
                                        }
                                    }
                                }
                            }
                            return new _Inner();
                        })();
                    }
                    this.post(this.mClearScrollingCache);
                }
            }
            scrollListBy(y) {
                this.trackMotionScroll(-y, -y);
            }
            canScrollList(direction) {
                const childCount = this.getChildCount();
                if (childCount == 0) {
                    return false;
                }
                const firstPosition = this.mFirstPosition;
                const listPadding = this.mListPadding;
                if (direction > 0) {
                    const lastBottom = this.getChildAt(childCount - 1).getBottom();
                    const lastPosition = firstPosition + childCount;
                    return lastPosition < this.mItemCount || lastBottom > this.getHeight() - listPadding.bottom;
                }
                else {
                    const firstTop = this.getChildAt(0).getTop();
                    return firstPosition > 0 || firstTop < listPadding.top;
                }
            }
            trackMotionScroll(deltaY, incrementalDeltaY) {
                const childCount = this.getChildCount();
                if (childCount == 0) {
                    return true;
                }
                const firstTop = this.getChildAt(0).getTop();
                const lastBottom = this.getChildAt(childCount - 1).getBottom();
                const listPadding = this.mListPadding;
                let effectivePaddingTop = 0;
                let effectivePaddingBottom = 0;
                if ((this.mGroupFlags & AbsListView.CLIP_TO_PADDING_MASK) == AbsListView.CLIP_TO_PADDING_MASK) {
                    effectivePaddingTop = listPadding.top;
                    effectivePaddingBottom = listPadding.bottom;
                }
                const spaceAbove = effectivePaddingTop - firstTop;
                const end = this.getHeight() - effectivePaddingBottom;
                const spaceBelow = lastBottom - end;
                const height = this.getHeight() - this.mPaddingBottom - this.mPaddingTop;
                if (deltaY < 0) {
                    deltaY = Math.max(-(height - 1), deltaY);
                }
                else {
                    deltaY = Math.min(height - 1, deltaY);
                }
                if (incrementalDeltaY < 0) {
                    incrementalDeltaY = Math.max(-(height - 1), incrementalDeltaY);
                }
                else {
                    incrementalDeltaY = Math.min(height - 1, incrementalDeltaY);
                }
                const firstPosition = this.mFirstPosition;
                if (firstPosition == 0) {
                    this.mFirstPositionDistanceGuess = firstTop - listPadding.top;
                }
                else {
                    this.mFirstPositionDistanceGuess += incrementalDeltaY;
                }
                if (firstPosition + childCount == this.mItemCount) {
                    this.mLastPositionDistanceGuess = lastBottom + listPadding.bottom;
                }
                else {
                    this.mLastPositionDistanceGuess += incrementalDeltaY;
                }
                const cannotScrollDown = (firstPosition == 0 && firstTop >= listPadding.top && incrementalDeltaY >= 0);
                const cannotScrollUp = (firstPosition + childCount == this.mItemCount && lastBottom <= this.getHeight() - listPadding.bottom && incrementalDeltaY <= 0);
                if (cannotScrollDown || cannotScrollUp) {
                    return incrementalDeltaY != 0;
                }
                const down = incrementalDeltaY < 0;
                const inTouchMode = this.isInTouchMode();
                if (inTouchMode) {
                    this.hideSelector();
                }
                const headerViewsCount = this.getHeaderViewsCount();
                const footerViewsStart = this.mItemCount - this.getFooterViewsCount();
                let start = 0;
                let count = 0;
                if (down) {
                    let top = -incrementalDeltaY;
                    if ((this.mGroupFlags & AbsListView.CLIP_TO_PADDING_MASK) == AbsListView.CLIP_TO_PADDING_MASK) {
                        top += listPadding.top;
                    }
                    for (let i = 0; i < childCount; i++) {
                        const child = this.getChildAt(i);
                        if (child.getBottom() >= top) {
                            break;
                        }
                        else {
                            count++;
                            let position = firstPosition + i;
                            if (position >= headerViewsCount && position < footerViewsStart) {
                                this.mRecycler.addScrapView(child, position);
                            }
                        }
                    }
                }
                else {
                    let bottom = this.getHeight() - incrementalDeltaY;
                    if ((this.mGroupFlags & AbsListView.CLIP_TO_PADDING_MASK) == AbsListView.CLIP_TO_PADDING_MASK) {
                        bottom -= listPadding.bottom;
                    }
                    for (let i = childCount - 1; i >= 0; i--) {
                        const child = this.getChildAt(i);
                        if (child.getTop() <= bottom) {
                            break;
                        }
                        else {
                            start = i;
                            count++;
                            let position = firstPosition + i;
                            if (position >= headerViewsCount && position < footerViewsStart) {
                                this.mRecycler.addScrapView(child, position);
                            }
                        }
                    }
                }
                this.mMotionViewNewTop = this.mMotionViewOriginalTop + deltaY;
                this.mBlockLayoutRequests = true;
                if (count > 0) {
                    this.detachViewsFromParent(start, count);
                    this.mRecycler.removeSkippedScrap();
                }
                if (!this.awakenScrollBars()) {
                    this.invalidate();
                }
                this.offsetChildrenTopAndBottom(incrementalDeltaY);
                if (down) {
                    this.mFirstPosition += count;
                }
                const absIncrementalDeltaY = Math.abs(incrementalDeltaY);
                if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
                    this.fillGap(down);
                }
                if (!inTouchMode && this.mSelectedPosition != AbsListView.INVALID_POSITION) {
                    const childIndex = this.mSelectedPosition - this.mFirstPosition;
                    if (childIndex >= 0 && childIndex < this.getChildCount()) {
                        this.positionSelector(this.mSelectedPosition, this.getChildAt(childIndex));
                    }
                }
                else if (this.mSelectorPosition != AbsListView.INVALID_POSITION) {
                    const childIndex = this.mSelectorPosition - this.mFirstPosition;
                    if (childIndex >= 0 && childIndex < this.getChildCount()) {
                        this.positionSelector(AbsListView.INVALID_POSITION, this.getChildAt(childIndex));
                    }
                }
                else {
                    this.mSelectorRect.setEmpty();
                }
                this.mBlockLayoutRequests = false;
                this.invokeOnItemScrollListener();
                return false;
            }
            getHeaderViewsCount() {
                return 0;
            }
            getFooterViewsCount() {
                return 0;
            }
            hideSelector() {
                if (this.mSelectedPosition != AbsListView.INVALID_POSITION) {
                    if (this.mLayoutMode != AbsListView.LAYOUT_SPECIFIC) {
                        this.mResurrectToPosition = this.mSelectedPosition;
                    }
                    if (this.mNextSelectedPosition >= 0 && this.mNextSelectedPosition != this.mSelectedPosition) {
                        this.mResurrectToPosition = this.mNextSelectedPosition;
                    }
                    this.setSelectedPositionInt(AbsListView.INVALID_POSITION);
                    this.setNextSelectedPositionInt(AbsListView.INVALID_POSITION);
                    this.mSelectedTop = 0;
                }
            }
            reconcileSelectedPosition() {
                let position = this.mSelectedPosition;
                if (position < 0) {
                    position = this.mResurrectToPosition;
                }
                position = Math.max(0, position);
                position = Math.min(position, this.mItemCount - 1);
                return position;
            }
            findClosestMotionRow(y) {
                const childCount = this.getChildCount();
                if (childCount == 0) {
                    return AbsListView.INVALID_POSITION;
                }
                const motionRow = this.findMotionRow(y);
                return motionRow != AbsListView.INVALID_POSITION ? motionRow : this.mFirstPosition + childCount - 1;
            }
            invalidateViews() {
                this.mDataChanged = true;
                this.rememberSyncState();
                this.requestLayout();
                this.invalidate();
            }
            resurrectSelectionIfNeeded() {
                if (this.mSelectedPosition < 0 && this.resurrectSelection()) {
                    this.updateSelectorState();
                    return true;
                }
                return false;
            }
            resurrectSelection() {
                const childCount = this.getChildCount();
                if (childCount <= 0) {
                    return false;
                }
                let selectedTop = 0;
                let selectedPos;
                let childrenTop = this.mListPadding.top;
                let childrenBottom = this.mBottom - this.mTop - this.mListPadding.bottom;
                const firstPosition = this.mFirstPosition;
                const toPosition = this.mResurrectToPosition;
                let down = true;
                if (toPosition >= firstPosition && toPosition < firstPosition + childCount) {
                    selectedPos = toPosition;
                    const selected = this.getChildAt(selectedPos - this.mFirstPosition);
                    selectedTop = selected.getTop();
                    let selectedBottom = selected.getBottom();
                    if (selectedTop < childrenTop) {
                        selectedTop = childrenTop + this.getVerticalFadingEdgeLength();
                    }
                    else if (selectedBottom > childrenBottom) {
                        selectedTop = childrenBottom - selected.getMeasuredHeight() - this.getVerticalFadingEdgeLength();
                    }
                }
                else {
                    if (toPosition < firstPosition) {
                        selectedPos = firstPosition;
                        for (let i = 0; i < childCount; i++) {
                            const v = this.getChildAt(i);
                            const top = v.getTop();
                            if (i == 0) {
                                selectedTop = top;
                                if (firstPosition > 0 || top < childrenTop) {
                                    childrenTop += this.getVerticalFadingEdgeLength();
                                }
                            }
                            if (top >= childrenTop) {
                                selectedPos = firstPosition + i;
                                selectedTop = top;
                                break;
                            }
                        }
                    }
                    else {
                        const itemCount = this.mItemCount;
                        down = false;
                        selectedPos = firstPosition + childCount - 1;
                        for (let i = childCount - 1; i >= 0; i--) {
                            const v = this.getChildAt(i);
                            const top = v.getTop();
                            const bottom = v.getBottom();
                            if (i == childCount - 1) {
                                selectedTop = top;
                                if (firstPosition + childCount < itemCount || bottom > childrenBottom) {
                                    childrenBottom -= this.getVerticalFadingEdgeLength();
                                }
                            }
                            if (bottom <= childrenBottom) {
                                selectedPos = firstPosition + i;
                                selectedTop = top;
                                break;
                            }
                        }
                    }
                }
                this.mResurrectToPosition = AbsListView.INVALID_POSITION;
                this.removeCallbacks(this.mFlingRunnable);
                if (this.mPositionScroller != null) {
                    this.mPositionScroller.stop();
                }
                this.mTouchMode = AbsListView.TOUCH_MODE_REST;
                this.clearScrollingCache();
                this.mSpecificTop = selectedTop;
                selectedPos = this.lookForSelectablePosition(selectedPos, down);
                if (selectedPos >= firstPosition && selectedPos <= this.getLastVisiblePosition()) {
                    this.mLayoutMode = AbsListView.LAYOUT_SPECIFIC;
                    this.updateSelectorState();
                    this.setSelectionInt(selectedPos);
                    this.invokeOnItemScrollListener();
                }
                else {
                    selectedPos = AbsListView.INVALID_POSITION;
                }
                this.reportScrollStateChange(AbsListView.OnScrollListener.SCROLL_STATE_IDLE);
                return selectedPos >= 0;
            }
            confirmCheckedPositionsById() {
                this.mCheckStates.clear();
                let checkedCountChanged = false;
                for (let checkedIndex = 0; checkedIndex < this.mCheckedIdStates.size(); checkedIndex++) {
                    const id = this.mCheckedIdStates.keyAt(checkedIndex);
                    const lastPos = this.mCheckedIdStates.valueAt(checkedIndex);
                    const lastPosId = this.mAdapter.getItemId(lastPos);
                    if (id != lastPosId) {
                        const start = Math.max(0, lastPos - AbsListView.CHECK_POSITION_SEARCH_DISTANCE);
                        const end = Math.min(lastPos + AbsListView.CHECK_POSITION_SEARCH_DISTANCE, this.mItemCount);
                        let found = false;
                        for (let searchPos = start; searchPos < end; searchPos++) {
                            const searchId = this.mAdapter.getItemId(searchPos);
                            if (id == searchId) {
                                found = true;
                                this.mCheckStates.put(searchPos, true);
                                this.mCheckedIdStates.setValueAt(checkedIndex, searchPos);
                                break;
                            }
                        }
                        if (!found) {
                            this.mCheckedIdStates.delete(id);
                            checkedIndex--;
                            this.mCheckedItemCount--;
                            checkedCountChanged = true;
                        }
                    }
                    else {
                        this.mCheckStates.put(lastPos, true);
                    }
                }
                if (checkedCountChanged && this.mChoiceActionMode != null) {
                    this.mChoiceActionMode.invalidate();
                }
            }
            handleDataChanged() {
                let count = this.mItemCount;
                let lastHandledItemCount = this.mLastHandledItemCount;
                this.mLastHandledItemCount = this.mItemCount;
                if (this.mChoiceMode != AbsListView.CHOICE_MODE_NONE && this.mAdapter != null && this.mAdapter.hasStableIds()) {
                    this.confirmCheckedPositionsById();
                }
                this.mRecycler.clearTransientStateViews();
                if (count > 0) {
                    let newPos;
                    let selectablePos;
                    if (this.mNeedSync) {
                        this.mNeedSync = false;
                        this.mPendingSync = null;
                        if (this.mTranscriptMode == AbsListView.TRANSCRIPT_MODE_ALWAYS_SCROLL) {
                            this.mLayoutMode = AbsListView.LAYOUT_FORCE_BOTTOM;
                            return;
                        }
                        else if (this.mTranscriptMode == AbsListView.TRANSCRIPT_MODE_NORMAL) {
                            if (this.mForceTranscriptScroll) {
                                this.mForceTranscriptScroll = false;
                                this.mLayoutMode = AbsListView.LAYOUT_FORCE_BOTTOM;
                                return;
                            }
                            const childCount = this.getChildCount();
                            const listBottom = this.getHeight() - this.getPaddingBottom();
                            const lastChild = this.getChildAt(childCount - 1);
                            const lastBottom = lastChild != null ? lastChild.getBottom() : listBottom;
                            if (this.mFirstPosition + childCount >= lastHandledItemCount && lastBottom <= listBottom) {
                                this.mLayoutMode = AbsListView.LAYOUT_FORCE_BOTTOM;
                                return;
                            }
                            this.awakenScrollBars();
                        }
                        switch (this.mSyncMode) {
                            case AbsListView.SYNC_SELECTED_POSITION:
                                if (this.isInTouchMode()) {
                                    this.mLayoutMode = AbsListView.LAYOUT_SYNC;
                                    this.mSyncPosition = Math.min(Math.max(0, this.mSyncPosition), count - 1);
                                    return;
                                }
                                else {
                                    newPos = this.findSyncPosition();
                                    if (newPos >= 0) {
                                        selectablePos = this.lookForSelectablePosition(newPos, true);
                                        if (selectablePos == newPos) {
                                            this.mSyncPosition = newPos;
                                            if (this.mSyncHeight == this.getHeight()) {
                                                this.mLayoutMode = AbsListView.LAYOUT_SYNC;
                                            }
                                            else {
                                                this.mLayoutMode = AbsListView.LAYOUT_SET_SELECTION;
                                            }
                                            this.setNextSelectedPositionInt(newPos);
                                            return;
                                        }
                                    }
                                }
                                break;
                            case AbsListView.SYNC_FIRST_POSITION:
                                this.mLayoutMode = AbsListView.LAYOUT_SYNC;
                                this.mSyncPosition = Math.min(Math.max(0, this.mSyncPosition), count - 1);
                                return;
                        }
                    }
                    if (!this.isInTouchMode()) {
                        newPos = this.getSelectedItemPosition();
                        if (newPos >= count) {
                            newPos = count - 1;
                        }
                        if (newPos < 0) {
                            newPos = 0;
                        }
                        selectablePos = this.lookForSelectablePosition(newPos, true);
                        if (selectablePos >= 0) {
                            this.setNextSelectedPositionInt(selectablePos);
                            return;
                        }
                        else {
                            selectablePos = this.lookForSelectablePosition(newPos, false);
                            if (selectablePos >= 0) {
                                this.setNextSelectedPositionInt(selectablePos);
                                return;
                            }
                        }
                    }
                    else {
                        if (this.mResurrectToPosition >= 0) {
                            return;
                        }
                    }
                }
                this.mLayoutMode = this.mStackFromBottom ? AbsListView.LAYOUT_FORCE_BOTTOM : AbsListView.LAYOUT_FORCE_TOP;
                this.mSelectedPosition = AbsListView.INVALID_POSITION;
                this.mSelectedRowId = AbsListView.INVALID_ROW_ID;
                this.mNextSelectedPosition = AbsListView.INVALID_POSITION;
                this.mNextSelectedRowId = AbsListView.INVALID_ROW_ID;
                this.mNeedSync = false;
                this.mPendingSync = null;
                this.mSelectorPosition = AbsListView.INVALID_POSITION;
                this.checkSelectionChanged();
            }
            onDisplayHint(hint) {
                super.onDisplayHint(hint);
                this.mPopupHidden = hint == AbsListView.INVISIBLE;
            }
            dismissPopup() {
            }
            showPopup() {
            }
            positionPopup() {
            }
            static getDistance(source, dest, direction) {
                let sX, sY;
                let dX, dY;
                switch (direction) {
                    case View.FOCUS_RIGHT:
                        sX = source.right;
                        sY = source.top + source.height() / 2;
                        dX = dest.left;
                        dY = dest.top + dest.height() / 2;
                        break;
                    case View.FOCUS_DOWN:
                        sX = source.left + source.width() / 2;
                        sY = source.bottom;
                        dX = dest.left + dest.width() / 2;
                        dY = dest.top;
                        break;
                    case View.FOCUS_LEFT:
                        sX = source.left;
                        sY = source.top + source.height() / 2;
                        dX = dest.right;
                        dY = dest.top + dest.height() / 2;
                        break;
                    case View.FOCUS_UP:
                        sX = source.left + source.width() / 2;
                        sY = source.top;
                        dX = dest.left + dest.width() / 2;
                        dY = dest.bottom;
                        break;
                    case View.FOCUS_FORWARD:
                    case View.FOCUS_BACKWARD:
                        sX = source.right + source.width() / 2;
                        sY = source.top + source.height() / 2;
                        dX = dest.left + dest.width() / 2;
                        dY = dest.top + dest.height() / 2;
                        break;
                    default:
                        throw Error(`new IllegalArgumentException("direction must be one of " + "{FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT, " + "FOCUS_FORWARD, FOCUS_BACKWARD}.")`);
                }
                let deltaX = dX - sX;
                let deltaY = dY - sY;
                return deltaY * deltaY + deltaX * deltaX;
            }
            isInFilterMode() {
                return this.mFiltered;
            }
            hasTextFilter() {
                return this.mFiltered;
            }
            onGlobalLayout() {
                if (this.isShown()) {
                }
                else {
                }
            }
            generateDefaultLayoutParams() {
                return new AbsListView.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT, 0);
            }
            generateLayoutParams(p) {
                return new AbsListView.LayoutParams(p);
            }
            checkLayoutParams(p) {
                return p instanceof AbsListView.LayoutParams;
            }
            setTranscriptMode(mode) {
                this.mTranscriptMode = mode;
            }
            getTranscriptMode() {
                return this.mTranscriptMode;
            }
            getSolidColor() {
                return this.mCacheColorHint;
            }
            setCacheColorHint(color) {
                if (color != this.mCacheColorHint) {
                    this.mCacheColorHint = color;
                    let count = this.getChildCount();
                    for (let i = 0; i < count; i++) {
                        this.getChildAt(i).setDrawingCacheBackgroundColor(color);
                    }
                    this.mRecycler.setCacheColorHint(color);
                }
            }
            getCacheColorHint() {
                return this.mCacheColorHint;
            }
            reclaimViews(views) {
                let childCount = this.getChildCount();
                let listener = this.mRecycler.mRecyclerListener;
                for (let i = 0; i < childCount; i++) {
                    let child = this.getChildAt(i);
                    let lp = child.getLayoutParams();
                    if (lp != null && this.mRecycler.shouldRecycleViewType(lp.viewType)) {
                        views.add(child);
                        if (listener != null) {
                            listener.onMovedToScrapHeap(child);
                        }
                    }
                }
                this.mRecycler.reclaimScrapViews(views);
                this.removeAllViewsInLayout();
            }
            finishGlows() {
            }
            setVisibleRangeHint(start, end) {
            }
            setRecyclerListener(listener) {
                this.mRecycler.mRecyclerListener = listener;
            }
            static retrieveFromScrap(scrapViews, position) {
                let size = scrapViews.size();
                if (size > 0) {
                    for (let i = 0; i < size; i++) {
                        let view = scrapViews.get(i);
                        if (view.getLayoutParams().scrappedFromPosition == position) {
                            scrapViews.remove(i);
                            return view;
                        }
                    }
                    return scrapViews.remove(size - 1);
                }
                else {
                    return null;
                }
            }
        }
        AbsListView.TAG_AbsListView = "AbsListView";
        AbsListView.TRANSCRIPT_MODE_DISABLED = 0;
        AbsListView.TRANSCRIPT_MODE_NORMAL = 1;
        AbsListView.TRANSCRIPT_MODE_ALWAYS_SCROLL = 2;
        AbsListView.TOUCH_MODE_REST = -1;
        AbsListView.TOUCH_MODE_DOWN = 0;
        AbsListView.TOUCH_MODE_TAP = 1;
        AbsListView.TOUCH_MODE_DONE_WAITING = 2;
        AbsListView.TOUCH_MODE_SCROLL = 3;
        AbsListView.TOUCH_MODE_FLING = 4;
        AbsListView.TOUCH_MODE_OVERSCROLL = 5;
        AbsListView.TOUCH_MODE_OVERFLING = 6;
        AbsListView.LAYOUT_NORMAL = 0;
        AbsListView.LAYOUT_FORCE_TOP = 1;
        AbsListView.LAYOUT_SET_SELECTION = 2;
        AbsListView.LAYOUT_FORCE_BOTTOM = 3;
        AbsListView.LAYOUT_SPECIFIC = 4;
        AbsListView.LAYOUT_SYNC = 5;
        AbsListView.LAYOUT_MOVE_SELECTION = 6;
        AbsListView.CHOICE_MODE_NONE = 0;
        AbsListView.CHOICE_MODE_SINGLE = 1;
        AbsListView.CHOICE_MODE_MULTIPLE = 2;
        AbsListView.CHOICE_MODE_MULTIPLE_MODAL = 3;
        AbsListView.OVERSCROLL_LIMIT_DIVISOR = 3;
        AbsListView.CHECK_POSITION_SEARCH_DISTANCE = 20;
        AbsListView.TOUCH_MODE_UNKNOWN = -1;
        AbsListView.TOUCH_MODE_ON = 0;
        AbsListView.TOUCH_MODE_OFF = 1;
        AbsListView.PROFILE_SCROLLING = false;
        AbsListView.PROFILE_FLINGING = false;
        AbsListView.INVALID_POINTER = -1;
        AbsListView.sLinearInterpolator = new LinearInterpolator();
        widget.AbsListView = AbsListView;
        (function (AbsListView) {
            var OnScrollListener;
            (function (OnScrollListener) {
                OnScrollListener.SCROLL_STATE_IDLE = 0;
                OnScrollListener.SCROLL_STATE_TOUCH_SCROLL = 1;
                OnScrollListener.SCROLL_STATE_FLING = 2;
            })(OnScrollListener = AbsListView.OnScrollListener || (AbsListView.OnScrollListener = {}));
            class WindowRunnnable {
                constructor(arg) {
                    this._AbsListView_this = arg;
                }
                rememberWindowAttachCount() {
                    this.mOriginalAttachCount = this._AbsListView_this.getWindowAttachCount();
                }
                sameWindow() {
                    return this._AbsListView_this.getWindowAttachCount() == this.mOriginalAttachCount;
                }
            }
            AbsListView.WindowRunnnable = WindowRunnnable;
            class PerformClick extends AbsListView.WindowRunnnable {
                constructor(arg) {
                    super(arg);
                    this.mClickMotionPosition = 0;
                    this._AbsListView_this = arg;
                }
                run() {
                    if (this._AbsListView_this.mDataChanged)
                        return;
                    const adapter = this._AbsListView_this.mAdapter;
                    const motionPosition = this.mClickMotionPosition;
                    if (adapter != null && this._AbsListView_this.mItemCount > 0 && motionPosition != AbsListView.INVALID_POSITION
                        && motionPosition < adapter.getCount() && this.sameWindow()) {
                        const view = this._AbsListView_this.getChildAt(motionPosition - this._AbsListView_this.mFirstPosition);
                        if (view != null) {
                            this._AbsListView_this.performItemClick(view, motionPosition, adapter.getItemId(motionPosition));
                        }
                    }
                }
            }
            AbsListView.PerformClick = PerformClick;
            class CheckForLongPress extends AbsListView.WindowRunnnable {
                constructor(arg) {
                    super(arg);
                    this._AbsListView_this = arg;
                }
                run() {
                    const motionPosition = this._AbsListView_this.mMotionPosition;
                    const child = this._AbsListView_this.getChildAt(motionPosition - this._AbsListView_this.mFirstPosition);
                    if (child != null) {
                        const longPressPosition = this._AbsListView_this.mMotionPosition;
                        const longPressId = this._AbsListView_this.mAdapter.getItemId(this._AbsListView_this.mMotionPosition);
                        let handled = false;
                        if (this.sameWindow() && !this._AbsListView_this.mDataChanged) {
                            handled = this._AbsListView_this.performLongPress(child, longPressPosition, longPressId);
                        }
                        if (handled) {
                            this._AbsListView_this.mTouchMode = AbsListView.TOUCH_MODE_REST;
                            this._AbsListView_this.setPressed(false);
                            child.setPressed(false);
                        }
                        else {
                            this._AbsListView_this.mTouchMode = AbsListView.TOUCH_MODE_DONE_WAITING;
                        }
                    }
                }
            }
            AbsListView.CheckForLongPress = CheckForLongPress;
            class CheckForKeyLongPress extends AbsListView.WindowRunnnable {
                constructor(arg) {
                    super(arg);
                    this._AbsListView_this = arg;
                }
                run() {
                    if (this._AbsListView_this.isPressed() && this._AbsListView_this.mSelectedPosition >= 0) {
                        let index = this._AbsListView_this.mSelectedPosition - this._AbsListView_this.mFirstPosition;
                        let v = this._AbsListView_this.getChildAt(index);
                        if (!this._AbsListView_this.mDataChanged) {
                            let handled = false;
                            if (this.sameWindow()) {
                                handled = this._AbsListView_this.performLongPress(v, this._AbsListView_this.mSelectedPosition, this._AbsListView_this.mSelectedRowId);
                            }
                            if (handled) {
                                this._AbsListView_this.setPressed(false);
                                v.setPressed(false);
                            }
                        }
                        else {
                            this._AbsListView_this.setPressed(false);
                            if (v != null)
                                v.setPressed(false);
                        }
                    }
                }
            }
            AbsListView.CheckForKeyLongPress = CheckForKeyLongPress;
            class CheckForTap {
                constructor(arg) {
                    this._AbsListView_this = arg;
                }
                run() {
                    if (this._AbsListView_this.mTouchMode == AbsListView.TOUCH_MODE_DOWN) {
                        this._AbsListView_this.mTouchMode = AbsListView.TOUCH_MODE_TAP;
                        const child = this._AbsListView_this.getChildAt(this._AbsListView_this.mMotionPosition - this._AbsListView_this.mFirstPosition);
                        if (child != null && !child.hasFocusable()) {
                            this._AbsListView_this.mLayoutMode = AbsListView.LAYOUT_NORMAL;
                            if (!this._AbsListView_this.mDataChanged) {
                                child.setPressed(true);
                                this._AbsListView_this.setPressed(true);
                                this._AbsListView_this.layoutChildren();
                                this._AbsListView_this.positionSelector(this._AbsListView_this.mMotionPosition, child);
                                this._AbsListView_this.refreshDrawableState();
                                const longPressTimeout = ViewConfiguration.getLongPressTimeout();
                                const longClickable = this._AbsListView_this.isLongClickable();
                                if (this._AbsListView_this.mSelector != null) {
                                    let d = this._AbsListView_this.mSelector.getCurrent();
                                }
                                if (longClickable) {
                                    if (this._AbsListView_this.mPendingCheckForLongPress_List == null) {
                                        this._AbsListView_this.mPendingCheckForLongPress_List = new AbsListView.CheckForLongPress(this._AbsListView_this);
                                    }
                                    this._AbsListView_this.mPendingCheckForLongPress_List.rememberWindowAttachCount();
                                    this._AbsListView_this.postDelayed(this._AbsListView_this.mPendingCheckForLongPress_List, longPressTimeout);
                                }
                                else {
                                    this._AbsListView_this.mTouchMode = AbsListView.TOUCH_MODE_DONE_WAITING;
                                }
                            }
                            else {
                                this._AbsListView_this.mTouchMode = AbsListView.TOUCH_MODE_DONE_WAITING;
                            }
                        }
                    }
                }
            }
            AbsListView.CheckForTap = CheckForTap;
            class FlingRunnable {
                constructor(arg) {
                    this.mLastFlingY = 0;
                    this.mCheckFlywheel = (() => {
                        const _this = this;
                        class _Inner {
                            run() {
                                const activeId = _this._AbsListView_this.mActivePointerId;
                                const vt = _this._AbsListView_this.mVelocityTracker;
                                const scroller = _this.mScroller;
                                if (vt == null || activeId == AbsListView.INVALID_POINTER) {
                                    return;
                                }
                                vt.computeCurrentVelocity(1000, _this._AbsListView_this.mMaximumVelocity);
                                const yvel = -vt.getYVelocity(activeId);
                                if (Math.abs(yvel) >= _this._AbsListView_this.mMinimumVelocity && scroller.isScrollingInDirection(0, yvel)) {
                                    _this._AbsListView_this.postDelayed(_this, FlingRunnable.FLYWHEEL_TIMEOUT);
                                }
                                else {
                                    _this.endFling();
                                    _this._AbsListView_this.mTouchMode = AbsListView.TOUCH_MODE_SCROLL;
                                    _this._AbsListView_this.reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
                                }
                            }
                        }
                        return new _Inner();
                    })();
                    this._AbsListView_this = arg;
                    this.mScroller = new OverScroller();
                }
                start(initialVelocity) {
                    let initialY = initialVelocity < 0 ? Integer.MAX_VALUE : 0;
                    this.mLastFlingY = initialY;
                    this.mScroller.setInterpolator(null);
                    this.mScroller.fling(0, initialY, 0, initialVelocity, 0, Integer.MAX_VALUE, 0, Integer.MAX_VALUE);
                    this._AbsListView_this.mTouchMode = AbsListView.TOUCH_MODE_FLING;
                    this._AbsListView_this.postOnAnimation(this);
                    if (AbsListView.PROFILE_FLINGING) {
                        if (!this._AbsListView_this.mFlingProfilingStarted) {
                            this._AbsListView_this.mFlingProfilingStarted = true;
                        }
                    }
                }
                startSpringback() {
                    if (this.mScroller.springBack(0, this._AbsListView_this.mScrollY, 0, 0, 0, 0)) {
                        this._AbsListView_this.mTouchMode = AbsListView.TOUCH_MODE_OVERFLING;
                        this._AbsListView_this.invalidate();
                        this._AbsListView_this.postOnAnimation(this);
                    }
                    else {
                        this._AbsListView_this.mTouchMode = AbsListView.TOUCH_MODE_REST;
                        this._AbsListView_this.reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                    }
                }
                startOverfling(initialVelocity) {
                    this.mScroller.setInterpolator(null);
                    this.mScroller.fling(0, this._AbsListView_this.mScrollY, 0, initialVelocity, 0, 0, Integer.MIN_VALUE, Integer.MAX_VALUE, 0, this._AbsListView_this.getHeight());
                    this._AbsListView_this.mTouchMode = AbsListView.TOUCH_MODE_OVERFLING;
                    this._AbsListView_this.invalidate();
                    this._AbsListView_this.postOnAnimation(this);
                }
                edgeReached(delta) {
                    this.mScroller.notifyVerticalEdgeReached(this._AbsListView_this.mScrollY, 0, this._AbsListView_this.mOverflingDistance);
                    const overscrollMode = this._AbsListView_this.getOverScrollMode();
                    if (overscrollMode == AbsListView.OVER_SCROLL_ALWAYS || (overscrollMode == AbsListView.OVER_SCROLL_IF_CONTENT_SCROLLS && !this._AbsListView_this.contentFits())) {
                        this._AbsListView_this.mTouchMode = AbsListView.TOUCH_MODE_OVERFLING;
                        const vel = Math.floor(this.mScroller.getCurrVelocity());
                    }
                    else {
                        this._AbsListView_this.mTouchMode = AbsListView.TOUCH_MODE_REST;
                        if (this._AbsListView_this.mPositionScroller != null) {
                            this._AbsListView_this.mPositionScroller.stop();
                        }
                    }
                    this._AbsListView_this.invalidate();
                    this._AbsListView_this.postOnAnimation(this);
                }
                startScroll(distance, duration, linear) {
                    let initialY = distance < 0 ? Integer.MAX_VALUE : 0;
                    this.mLastFlingY = initialY;
                    this.mScroller.setInterpolator(linear ? AbsListView.sLinearInterpolator : null);
                    this.mScroller.startScroll(0, initialY, 0, distance, duration);
                    this._AbsListView_this.mTouchMode = AbsListView.TOUCH_MODE_FLING;
                    this._AbsListView_this.postOnAnimation(this);
                }
                endFling() {
                    this._AbsListView_this.mTouchMode = AbsListView.TOUCH_MODE_REST;
                    this._AbsListView_this.removeCallbacks(this);
                    this._AbsListView_this.removeCallbacks(this.mCheckFlywheel);
                    this._AbsListView_this.reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
                    this._AbsListView_this.clearScrollingCache();
                    this.mScroller.abortAnimation();
                }
                flywheelTouch() {
                    this._AbsListView_this.postDelayed(this.mCheckFlywheel, FlingRunnable.FLYWHEEL_TIMEOUT);
                }
                run() {
                    switch (this._AbsListView_this.mTouchMode) {
                        default:
                            this.endFling();
                            return;
                        case AbsListView.TOUCH_MODE_SCROLL:
                            if (this.mScroller.isFinished()) {
                                return;
                            }
                        case AbsListView.TOUCH_MODE_FLING:
                            {
                                if (this._AbsListView_this.mDataChanged) {
                                    this._AbsListView_this.layoutChildren();
                                }
                                if (this._AbsListView_this.mItemCount == 0 || this._AbsListView_this.getChildCount() == 0) {
                                    this.endFling();
                                    return;
                                }
                                const scroller = this.mScroller;
                                let more = scroller.computeScrollOffset();
                                const y = scroller.getCurrY();
                                let delta = this.mLastFlingY - y;
                                if (delta > 0) {
                                    this._AbsListView_this.mMotionPosition = this._AbsListView_this.mFirstPosition;
                                    const firstView = this._AbsListView_this.getChildAt(0);
                                    this._AbsListView_this.mMotionViewOriginalTop = firstView.getTop();
                                    delta = Math.min(this._AbsListView_this.getHeight() - this._AbsListView_this.mPaddingBottom - this._AbsListView_this.mPaddingTop - 1, delta);
                                }
                                else {
                                    let offsetToLast = this._AbsListView_this.getChildCount() - 1;
                                    this._AbsListView_this.mMotionPosition = this._AbsListView_this.mFirstPosition + offsetToLast;
                                    const lastView = this._AbsListView_this.getChildAt(offsetToLast);
                                    this._AbsListView_this.mMotionViewOriginalTop = lastView.getTop();
                                    delta = Math.max(-(this._AbsListView_this.getHeight() - this._AbsListView_this.mPaddingBottom - this._AbsListView_this.mPaddingTop - 1), delta);
                                }
                                let motionView = this._AbsListView_this.getChildAt(this._AbsListView_this.mMotionPosition - this._AbsListView_this.mFirstPosition);
                                let oldTop = 0;
                                if (motionView != null) {
                                    oldTop = motionView.getTop();
                                }
                                const atEdge = this._AbsListView_this.trackMotionScroll(delta, delta);
                                const atEnd = atEdge && (delta != 0);
                                if (atEnd) {
                                    if (motionView != null) {
                                        let overshoot = -(delta - (motionView.getTop() - oldTop));
                                        this._AbsListView_this.overScrollBy(0, overshoot, 0, this._AbsListView_this.mScrollY, 0, 0, 0, this._AbsListView_this.mOverflingDistance, false);
                                    }
                                    if (more) {
                                        this.edgeReached(delta);
                                    }
                                    break;
                                }
                                if (more && !atEnd) {
                                    if (atEdge)
                                        this._AbsListView_this.invalidate();
                                    this.mLastFlingY = y;
                                    this._AbsListView_this.postOnAnimation(this);
                                }
                                else {
                                    this.endFling();
                                    if (AbsListView.PROFILE_FLINGING) {
                                        if (this._AbsListView_this.mFlingProfilingStarted) {
                                            this._AbsListView_this.mFlingProfilingStarted = false;
                                        }
                                    }
                                }
                                break;
                            }
                        case AbsListView.TOUCH_MODE_OVERFLING:
                            {
                                const scroller = this.mScroller;
                                if (scroller.computeScrollOffset()) {
                                    const scrollY = this._AbsListView_this.mScrollY;
                                    const currY = scroller.getCurrY();
                                    const deltaY = currY - scrollY;
                                    if (this._AbsListView_this.overScrollBy(0, deltaY, 0, scrollY, 0, 0, 0, this._AbsListView_this.mOverflingDistance, false)) {
                                        const crossDown = scrollY <= 0 && currY > 0;
                                        const crossUp = scrollY >= 0 && currY < 0;
                                        if (crossDown || crossUp) {
                                            let velocity = Math.floor(scroller.getCurrVelocity());
                                            if (crossUp)
                                                velocity = -velocity;
                                            scroller.abortAnimation();
                                            this.start(velocity);
                                        }
                                        else {
                                            this.startSpringback();
                                        }
                                    }
                                    else {
                                        this._AbsListView_this.invalidate();
                                        this._AbsListView_this.postOnAnimation(this);
                                    }
                                }
                                else {
                                    this.endFling();
                                }
                                break;
                            }
                    }
                }
            }
            FlingRunnable.FLYWHEEL_TIMEOUT = 40;
            AbsListView.FlingRunnable = FlingRunnable;
            class PositionScroller {
                constructor(arg) {
                    this.mMode = 0;
                    this.mTargetPos = 0;
                    this.mBoundPos = 0;
                    this.mLastSeenPos = 0;
                    this.mScrollDuration = 0;
                    this.mExtraScroll = 0;
                    this.mOffsetFromTop = 0;
                    this._AbsListView_this = arg;
                    this.mExtraScroll = ViewConfiguration.get().getScaledFadingEdgeLength();
                }
                start(...args) {
                    if (args.length === 1)
                        this._start_1(args[0]);
                    else if (args.length === 2)
                        this._start_2(args[0], args[1]);
                }
                _start_1(position) {
                    this.stop();
                    if (this._AbsListView_this.mDataChanged) {
                        this._AbsListView_this.mPositionScrollAfterLayout = (() => {
                            const _this = this;
                            class _Inner {
                                run() {
                                    _this.start(position);
                                }
                            }
                            return new _Inner();
                        })();
                        return;
                    }
                    const childCount = this._AbsListView_this.getChildCount();
                    if (childCount == 0) {
                        return;
                    }
                    const firstPos = this._AbsListView_this.mFirstPosition;
                    const lastPos = firstPos + childCount - 1;
                    let viewTravelCount;
                    let clampedPosition = Math.max(0, Math.min(this._AbsListView_this.getCount() - 1, position));
                    if (clampedPosition < firstPos) {
                        viewTravelCount = firstPos - clampedPosition + 1;
                        this.mMode = PositionScroller.MOVE_UP_POS;
                    }
                    else if (clampedPosition > lastPos) {
                        viewTravelCount = clampedPosition - lastPos + 1;
                        this.mMode = PositionScroller.MOVE_DOWN_POS;
                    }
                    else {
                        this.scrollToVisible(clampedPosition, AbsListView.INVALID_POSITION, PositionScroller.SCROLL_DURATION);
                        return;
                    }
                    if (viewTravelCount > 0) {
                        this.mScrollDuration = PositionScroller.SCROLL_DURATION / viewTravelCount;
                    }
                    else {
                        this.mScrollDuration = PositionScroller.SCROLL_DURATION;
                    }
                    this.mTargetPos = clampedPosition;
                    this.mBoundPos = AbsListView.INVALID_POSITION;
                    this.mLastSeenPos = AbsListView.INVALID_POSITION;
                    this._AbsListView_this.postOnAnimation(this);
                }
                _start_2(position, boundPosition) {
                    this.stop();
                    if (boundPosition == AbsListView.INVALID_POSITION) {
                        this.start(position);
                        return;
                    }
                    if (this._AbsListView_this.mDataChanged) {
                        this._AbsListView_this.mPositionScrollAfterLayout = (() => {
                            const _this = this;
                            class _Inner {
                                run() {
                                    _this.start(position, boundPosition);
                                }
                            }
                            return new _Inner();
                        })();
                        return;
                    }
                    const childCount = this._AbsListView_this.getChildCount();
                    if (childCount == 0) {
                        return;
                    }
                    const firstPos = this._AbsListView_this.mFirstPosition;
                    const lastPos = firstPos + childCount - 1;
                    let viewTravelCount;
                    let clampedPosition = Math.max(0, Math.min(this._AbsListView_this.getCount() - 1, position));
                    if (clampedPosition < firstPos) {
                        const boundPosFromLast = lastPos - boundPosition;
                        if (boundPosFromLast < 1) {
                            return;
                        }
                        const posTravel = firstPos - clampedPosition + 1;
                        const boundTravel = boundPosFromLast - 1;
                        if (boundTravel < posTravel) {
                            viewTravelCount = boundTravel;
                            this.mMode = PositionScroller.MOVE_UP_BOUND;
                        }
                        else {
                            viewTravelCount = posTravel;
                            this.mMode = PositionScroller.MOVE_UP_POS;
                        }
                    }
                    else if (clampedPosition > lastPos) {
                        const boundPosFromFirst = boundPosition - firstPos;
                        if (boundPosFromFirst < 1) {
                            return;
                        }
                        const posTravel = clampedPosition - lastPos + 1;
                        const boundTravel = boundPosFromFirst - 1;
                        if (boundTravel < posTravel) {
                            viewTravelCount = boundTravel;
                            this.mMode = PositionScroller.MOVE_DOWN_BOUND;
                        }
                        else {
                            viewTravelCount = posTravel;
                            this.mMode = PositionScroller.MOVE_DOWN_POS;
                        }
                    }
                    else {
                        this.scrollToVisible(clampedPosition, boundPosition, PositionScroller.SCROLL_DURATION);
                        return;
                    }
                    if (viewTravelCount > 0) {
                        this.mScrollDuration = PositionScroller.SCROLL_DURATION / viewTravelCount;
                    }
                    else {
                        this.mScrollDuration = PositionScroller.SCROLL_DURATION;
                    }
                    this.mTargetPos = clampedPosition;
                    this.mBoundPos = boundPosition;
                    this.mLastSeenPos = AbsListView.INVALID_POSITION;
                    this._AbsListView_this.postOnAnimation(this);
                }
                startWithOffset(position, offset, duration = PositionScroller.SCROLL_DURATION) {
                    this.stop();
                    if (this._AbsListView_this.mDataChanged) {
                        const postOffset = offset;
                        this._AbsListView_this.mPositionScrollAfterLayout = (() => {
                            const _this = this;
                            class _Inner {
                                run() {
                                    _this.startWithOffset(position, postOffset, duration);
                                }
                            }
                            return new _Inner();
                        })();
                        return;
                    }
                    const childCount = this._AbsListView_this.getChildCount();
                    if (childCount == 0) {
                        return;
                    }
                    offset += this._AbsListView_this.getPaddingTop();
                    this.mTargetPos = Math.max(0, Math.min(this._AbsListView_this.getCount() - 1, position));
                    this.mOffsetFromTop = offset;
                    this.mBoundPos = AbsListView.INVALID_POSITION;
                    this.mLastSeenPos = AbsListView.INVALID_POSITION;
                    this.mMode = PositionScroller.MOVE_OFFSET;
                    const firstPos = this._AbsListView_this.mFirstPosition;
                    const lastPos = firstPos + childCount - 1;
                    let viewTravelCount;
                    if (this.mTargetPos < firstPos) {
                        viewTravelCount = firstPos - this.mTargetPos;
                    }
                    else if (this.mTargetPos > lastPos) {
                        viewTravelCount = this.mTargetPos - lastPos;
                    }
                    else {
                        const targetTop = this._AbsListView_this.getChildAt(this.mTargetPos - firstPos).getTop();
                        this._AbsListView_this.smoothScrollBy(targetTop - offset, duration, true);
                        return;
                    }
                    const screenTravelCount = viewTravelCount / childCount;
                    this.mScrollDuration = screenTravelCount < 1 ? duration : Math.floor((duration / screenTravelCount));
                    this.mLastSeenPos = AbsListView.INVALID_POSITION;
                    this._AbsListView_this.postOnAnimation(this);
                }
                scrollToVisible(targetPos, boundPos, duration) {
                    const firstPos = this._AbsListView_this.mFirstPosition;
                    const childCount = this._AbsListView_this.getChildCount();
                    const lastPos = firstPos + childCount - 1;
                    const paddedTop = this._AbsListView_this.mListPadding.top;
                    const paddedBottom = this._AbsListView_this.getHeight() - this._AbsListView_this.mListPadding.bottom;
                    if (targetPos < firstPos || targetPos > lastPos) {
                        Log.w(AbsListView.TAG_AbsListView, "scrollToVisible called with targetPos " + targetPos + " not visible [" + firstPos + ", " + lastPos + "]");
                    }
                    if (boundPos < firstPos || boundPos > lastPos) {
                        boundPos = AbsListView.INVALID_POSITION;
                    }
                    const targetChild = this._AbsListView_this.getChildAt(targetPos - firstPos);
                    const targetTop = targetChild.getTop();
                    const targetBottom = targetChild.getBottom();
                    let scrollBy = 0;
                    if (targetBottom > paddedBottom) {
                        scrollBy = targetBottom - paddedBottom;
                    }
                    if (targetTop < paddedTop) {
                        scrollBy = targetTop - paddedTop;
                    }
                    if (scrollBy == 0) {
                        return;
                    }
                    if (boundPos >= 0) {
                        const boundChild = this._AbsListView_this.getChildAt(boundPos - firstPos);
                        const boundTop = boundChild.getTop();
                        const boundBottom = boundChild.getBottom();
                        const absScroll = Math.abs(scrollBy);
                        if (scrollBy < 0 && boundBottom + absScroll > paddedBottom) {
                            scrollBy = Math.max(0, boundBottom - paddedBottom);
                        }
                        else if (scrollBy > 0 && boundTop - absScroll < paddedTop) {
                            scrollBy = Math.min(0, boundTop - paddedTop);
                        }
                    }
                    this._AbsListView_this.smoothScrollBy(scrollBy, duration);
                }
                stop() {
                    this._AbsListView_this.removeCallbacks(this);
                }
                run() {
                    const listHeight = this._AbsListView_this.getHeight();
                    const firstPos = this._AbsListView_this.mFirstPosition;
                    switch (this.mMode) {
                        case PositionScroller.MOVE_DOWN_POS:
                            {
                                const lastViewIndex = this._AbsListView_this.getChildCount() - 1;
                                const lastPos = firstPos + lastViewIndex;
                                if (lastViewIndex < 0) {
                                    return;
                                }
                                if (lastPos == this.mLastSeenPos) {
                                    this._AbsListView_this.postOnAnimation(this);
                                    return;
                                }
                                const lastView = this._AbsListView_this.getChildAt(lastViewIndex);
                                const lastViewHeight = lastView.getHeight();
                                const lastViewTop = lastView.getTop();
                                const lastViewPixelsShowing = listHeight - lastViewTop;
                                const extraScroll = lastPos < this._AbsListView_this.mItemCount - 1 ? Math.max(this._AbsListView_this.mListPadding.bottom, this.mExtraScroll) : this._AbsListView_this.mListPadding.bottom;
                                const scrollBy = lastViewHeight - lastViewPixelsShowing + extraScroll;
                                this._AbsListView_this.smoothScrollBy(scrollBy, this.mScrollDuration, true);
                                this.mLastSeenPos = lastPos;
                                if (lastPos < this.mTargetPos) {
                                    this._AbsListView_this.postOnAnimation(this);
                                }
                                break;
                            }
                        case PositionScroller.MOVE_DOWN_BOUND:
                            {
                                const nextViewIndex = 1;
                                const childCount = this._AbsListView_this.getChildCount();
                                if (firstPos == this.mBoundPos || childCount <= nextViewIndex || firstPos + childCount >= this._AbsListView_this.mItemCount) {
                                    return;
                                }
                                const nextPos = firstPos + nextViewIndex;
                                if (nextPos == this.mLastSeenPos) {
                                    this._AbsListView_this.postOnAnimation(this);
                                    return;
                                }
                                const nextView = this._AbsListView_this.getChildAt(nextViewIndex);
                                const nextViewHeight = nextView.getHeight();
                                const nextViewTop = nextView.getTop();
                                const extraScroll = Math.max(this._AbsListView_this.mListPadding.bottom, this.mExtraScroll);
                                if (nextPos < this.mBoundPos) {
                                    this._AbsListView_this.smoothScrollBy(Math.max(0, nextViewHeight + nextViewTop - extraScroll), this.mScrollDuration, true);
                                    this.mLastSeenPos = nextPos;
                                    this._AbsListView_this.postOnAnimation(this);
                                }
                                else {
                                    if (nextViewTop > extraScroll) {
                                        this._AbsListView_this.smoothScrollBy(nextViewTop - extraScroll, this.mScrollDuration, true);
                                    }
                                }
                                break;
                            }
                        case PositionScroller.MOVE_UP_POS:
                            {
                                if (firstPos == this.mLastSeenPos) {
                                    this._AbsListView_this.postOnAnimation(this);
                                    return;
                                }
                                const firstView = this._AbsListView_this.getChildAt(0);
                                if (firstView == null) {
                                    return;
                                }
                                const firstViewTop = firstView.getTop();
                                const extraScroll = firstPos > 0 ? Math.max(this.mExtraScroll, this._AbsListView_this.mListPadding.top) : this._AbsListView_this.mListPadding.top;
                                this._AbsListView_this.smoothScrollBy(firstViewTop - extraScroll, this.mScrollDuration, true);
                                this.mLastSeenPos = firstPos;
                                if (firstPos > this.mTargetPos) {
                                    this._AbsListView_this.postOnAnimation(this);
                                }
                                break;
                            }
                        case PositionScroller.MOVE_UP_BOUND:
                            {
                                const lastViewIndex = this._AbsListView_this.getChildCount() - 2;
                                if (lastViewIndex < 0) {
                                    return;
                                }
                                const lastPos = firstPos + lastViewIndex;
                                if (lastPos == this.mLastSeenPos) {
                                    this._AbsListView_this.postOnAnimation(this);
                                    return;
                                }
                                const lastView = this._AbsListView_this.getChildAt(lastViewIndex);
                                const lastViewHeight = lastView.getHeight();
                                const lastViewTop = lastView.getTop();
                                const lastViewPixelsShowing = listHeight - lastViewTop;
                                const extraScroll = Math.max(this._AbsListView_this.mListPadding.top, this.mExtraScroll);
                                this.mLastSeenPos = lastPos;
                                if (lastPos > this.mBoundPos) {
                                    this._AbsListView_this.smoothScrollBy(-(lastViewPixelsShowing - extraScroll), this.mScrollDuration, true);
                                    this._AbsListView_this.postOnAnimation(this);
                                }
                                else {
                                    const bottom = listHeight - extraScroll;
                                    const lastViewBottom = lastViewTop + lastViewHeight;
                                    if (bottom > lastViewBottom) {
                                        this._AbsListView_this.smoothScrollBy(-(bottom - lastViewBottom), this.mScrollDuration, true);
                                    }
                                }
                                break;
                            }
                        case PositionScroller.MOVE_OFFSET:
                            {
                                if (this.mLastSeenPos == firstPos) {
                                    this._AbsListView_this.postOnAnimation(this);
                                    return;
                                }
                                this.mLastSeenPos = firstPos;
                                const childCount = this._AbsListView_this.getChildCount();
                                const position = this.mTargetPos;
                                const lastPos = firstPos + childCount - 1;
                                let viewTravelCount = 0;
                                if (position < firstPos) {
                                    viewTravelCount = firstPos - position + 1;
                                }
                                else if (position > lastPos) {
                                    viewTravelCount = position - lastPos;
                                }
                                const screenTravelCount = viewTravelCount / childCount;
                                const modifier = Math.min(Math.abs(screenTravelCount), 1.);
                                if (position < firstPos) {
                                    const distance = Math.floor((-this._AbsListView_this.getHeight() * modifier));
                                    const duration = Math.floor((this.mScrollDuration * modifier));
                                    this._AbsListView_this.smoothScrollBy(distance, duration, true);
                                    this._AbsListView_this.postOnAnimation(this);
                                }
                                else if (position > lastPos) {
                                    const distance = Math.floor((this._AbsListView_this.getHeight() * modifier));
                                    const duration = Math.floor((this.mScrollDuration * modifier));
                                    this._AbsListView_this.smoothScrollBy(distance, duration, true);
                                    this._AbsListView_this.postOnAnimation(this);
                                }
                                else {
                                    const targetTop = this._AbsListView_this.getChildAt(position - firstPos).getTop();
                                    const distance = targetTop - this.mOffsetFromTop;
                                    const duration = Math.floor((this.mScrollDuration * (Math.abs(distance) / this._AbsListView_this.getHeight())));
                                    this._AbsListView_this.smoothScrollBy(distance, duration, true);
                                }
                                break;
                            }
                        default:
                            break;
                    }
                }
            }
            PositionScroller.SCROLL_DURATION = 200;
            PositionScroller.MOVE_DOWN_POS = 1;
            PositionScroller.MOVE_UP_POS = 2;
            PositionScroller.MOVE_DOWN_BOUND = 3;
            PositionScroller.MOVE_UP_BOUND = 4;
            PositionScroller.MOVE_OFFSET = 5;
            AbsListView.PositionScroller = PositionScroller;
            class AdapterDataSetObserver extends AdapterView.AdapterDataSetObserver {
                constructor(arg) {
                    super(arg);
                    this._AbsListView_this = arg;
                }
                onChanged() {
                    super.onChanged();
                }
                onInvalidated() {
                    super.onInvalidated();
                }
            }
            AbsListView.AdapterDataSetObserver = AdapterDataSetObserver;
            class LayoutParams extends ViewGroup.LayoutParams {
                constructor(...args) {
                    super();
                    this.viewType = 0;
                    this.scrappedFromPosition = 0;
                    this.itemId = -1;
                    if (args.length === 1) {
                        super(args[0]);
                    }
                    else if (args.length === 2) {
                        super(args[0], args[1]);
                    }
                    else if (args.length === 3) {
                        super(args[0], args[1]);
                        this.viewType = args[2];
                    }
                }
            }
            AbsListView.LayoutParams = LayoutParams;
            class RecycleBin {
                constructor(arg) {
                    this.mFirstActivePosition = 0;
                    this.mActiveViews = [];
                    this.mViewTypeCount = 0;
                    this._AbsListView_this = arg;
                }
                setViewTypeCount(viewTypeCount) {
                    if (viewTypeCount < 1) {
                        throw Error(`new IllegalArgumentException("Can't have a viewTypeCount < 1")`);
                    }
                    let scrapViews = new Array(viewTypeCount);
                    for (let i = 0; i < viewTypeCount; i++) {
                        scrapViews[i] = new ArrayList();
                    }
                    this.mViewTypeCount = viewTypeCount;
                    this.mCurrentScrap = scrapViews[0];
                    this.mScrapViews = scrapViews;
                }
                markChildrenDirty() {
                    if (this.mViewTypeCount == 1) {
                        const scrap = this.mCurrentScrap;
                        const scrapCount = scrap.size();
                        for (let i = 0; i < scrapCount; i++) {
                            scrap.get(i).forceLayout();
                        }
                    }
                    else {
                        const typeCount = this.mViewTypeCount;
                        for (let i = 0; i < typeCount; i++) {
                            const scrap = this.mScrapViews[i];
                            const scrapCount = scrap.size();
                            for (let j = 0; j < scrapCount; j++) {
                                scrap.get(j).forceLayout();
                            }
                        }
                    }
                    if (this.mTransientStateViews != null) {
                        const count = this.mTransientStateViews.size();
                        for (let i = 0; i < count; i++) {
                            this.mTransientStateViews.valueAt(i).forceLayout();
                        }
                    }
                    if (this.mTransientStateViewsById != null) {
                        const count = this.mTransientStateViewsById.size();
                        for (let i = 0; i < count; i++) {
                            this.mTransientStateViewsById.valueAt(i).forceLayout();
                        }
                    }
                }
                shouldRecycleViewType(viewType) {
                    return viewType >= 0;
                }
                clear() {
                    if (this.mViewTypeCount == 1) {
                        const scrap = this.mCurrentScrap;
                        const scrapCount = scrap.size();
                        for (let i = 0; i < scrapCount; i++) {
                            this._AbsListView_this.removeDetachedView(scrap.remove(scrapCount - 1 - i), false);
                        }
                    }
                    else {
                        const typeCount = this.mViewTypeCount;
                        for (let i = 0; i < typeCount; i++) {
                            const scrap = this.mScrapViews[i];
                            const scrapCount = scrap.size();
                            for (let j = 0; j < scrapCount; j++) {
                                this._AbsListView_this.removeDetachedView(scrap.remove(scrapCount - 1 - j), false);
                            }
                        }
                    }
                    if (this.mTransientStateViews != null) {
                        this.mTransientStateViews.clear();
                    }
                    if (this.mTransientStateViewsById != null) {
                        this.mTransientStateViewsById.clear();
                    }
                }
                fillActiveViews(childCount, firstActivePosition) {
                    if (this.mActiveViews.length < childCount) {
                        this.mActiveViews = new Array(childCount);
                    }
                    this.mFirstActivePosition = firstActivePosition;
                    const activeViews = this.mActiveViews;
                    for (let i = 0; i < childCount; i++) {
                        let child = this._AbsListView_this.getChildAt(i);
                        let lp = child.getLayoutParams();
                        if (lp != null && lp.viewType != AbsListView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER) {
                            activeViews[i] = child;
                        }
                    }
                }
                getActiveView(position) {
                    let index = position - this.mFirstActivePosition;
                    const activeViews = this.mActiveViews;
                    if (index >= 0 && index < activeViews.length) {
                        const match = activeViews[index];
                        activeViews[index] = null;
                        return match;
                    }
                    return null;
                }
                getTransientStateView(position) {
                    if (this._AbsListView_this.mAdapter != null && this._AbsListView_this.mAdapterHasStableIds && this.mTransientStateViewsById != null) {
                        let id = this._AbsListView_this.mAdapter.getItemId(position);
                        let result = this.mTransientStateViewsById.get(id);
                        this.mTransientStateViewsById.remove(id);
                        return result;
                    }
                    if (this.mTransientStateViews != null) {
                        const index = this.mTransientStateViews.indexOfKey(position);
                        if (index >= 0) {
                            let result = this.mTransientStateViews.valueAt(index);
                            this.mTransientStateViews.removeAt(index);
                            return result;
                        }
                    }
                    return null;
                }
                clearTransientStateViews() {
                    if (this.mTransientStateViews != null) {
                        this.mTransientStateViews.clear();
                    }
                    if (this.mTransientStateViewsById != null) {
                        this.mTransientStateViewsById.clear();
                    }
                }
                getScrapView(position) {
                    if (this.mViewTypeCount == 1) {
                        return AbsListView.retrieveFromScrap(this.mCurrentScrap, position);
                    }
                    else {
                        let whichScrap = this._AbsListView_this.mAdapter.getItemViewType(position);
                        if (whichScrap >= 0 && whichScrap < this.mScrapViews.length) {
                            return AbsListView.retrieveFromScrap(this.mScrapViews[whichScrap], position);
                        }
                    }
                    return null;
                }
                addScrapView(scrap, position) {
                    const lp = scrap.getLayoutParams();
                    if (lp == null) {
                        return;
                    }
                    lp.scrappedFromPosition = position;
                    const viewType = lp.viewType;
                    if (!this.shouldRecycleViewType(viewType)) {
                        return;
                    }
                    scrap.dispatchStartTemporaryDetach();
                    const scrapHasTransientState = scrap.hasTransientState();
                    if (scrapHasTransientState) {
                        if (this._AbsListView_this.mAdapter != null && this._AbsListView_this.mAdapterHasStableIds) {
                            if (this.mTransientStateViewsById == null) {
                                this.mTransientStateViewsById = new LongSparseArray();
                            }
                            this.mTransientStateViewsById.put(lp.itemId, scrap);
                        }
                        else if (!this._AbsListView_this.mDataChanged) {
                            if (this.mTransientStateViews == null) {
                                this.mTransientStateViews = new SparseArray();
                            }
                            this.mTransientStateViews.put(position, scrap);
                        }
                        else {
                            if (this.mSkippedScrap == null) {
                                this.mSkippedScrap = new ArrayList();
                            }
                            this.mSkippedScrap.add(scrap);
                        }
                    }
                    else {
                        if (this.mViewTypeCount == 1) {
                            this.mCurrentScrap.add(scrap);
                        }
                        else {
                            this.mScrapViews[viewType].add(scrap);
                        }
                        if (this.mRecyclerListener != null) {
                            this.mRecyclerListener.onMovedToScrapHeap(scrap);
                        }
                    }
                }
                removeSkippedScrap() {
                    if (this.mSkippedScrap == null) {
                        return;
                    }
                    const count = this.mSkippedScrap.size();
                    for (let i = 0; i < count; i++) {
                        this._AbsListView_this.removeDetachedView(this.mSkippedScrap.get(i), false);
                    }
                    this.mSkippedScrap.clear();
                }
                scrapActiveViews() {
                    const activeViews = this.mActiveViews;
                    const hasListener = this.mRecyclerListener != null;
                    const multipleScraps = this.mViewTypeCount > 1;
                    let scrapViews = this.mCurrentScrap;
                    const count = activeViews.length;
                    for (let i = count - 1; i >= 0; i--) {
                        const victim = activeViews[i];
                        if (victim != null) {
                            const lp = victim.getLayoutParams();
                            let whichScrap = lp.viewType;
                            activeViews[i] = null;
                            const scrapHasTransientState = victim.hasTransientState();
                            if (!this.shouldRecycleViewType(whichScrap) || scrapHasTransientState) {
                                if (whichScrap != AbsListView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER && scrapHasTransientState) {
                                    this._AbsListView_this.removeDetachedView(victim, false);
                                }
                                if (scrapHasTransientState) {
                                    if (this._AbsListView_this.mAdapter != null && this._AbsListView_this.mAdapterHasStableIds) {
                                        if (this.mTransientStateViewsById == null) {
                                            this.mTransientStateViewsById = new LongSparseArray();
                                        }
                                        let id = this._AbsListView_this.mAdapter.getItemId(this.mFirstActivePosition + i);
                                        this.mTransientStateViewsById.put(id, victim);
                                    }
                                    else {
                                        if (this.mTransientStateViews == null) {
                                            this.mTransientStateViews = new SparseArray();
                                        }
                                        this.mTransientStateViews.put(this.mFirstActivePosition + i, victim);
                                    }
                                }
                                continue;
                            }
                            if (multipleScraps) {
                                scrapViews = this.mScrapViews[whichScrap];
                            }
                            victim.dispatchStartTemporaryDetach();
                            lp.scrappedFromPosition = this.mFirstActivePosition + i;
                            scrapViews.add(victim);
                            if (hasListener) {
                                this.mRecyclerListener.onMovedToScrapHeap(victim);
                            }
                        }
                    }
                    this.pruneScrapViews();
                }
                pruneScrapViews() {
                    const maxViews = this.mActiveViews.length;
                    const viewTypeCount = this.mViewTypeCount;
                    const scrapViews = this.mScrapViews;
                    for (let i = 0; i < viewTypeCount; ++i) {
                        const scrapPile = scrapViews[i];
                        let size = scrapPile.size();
                        const extras = size - maxViews;
                        size--;
                        for (let j = 0; j < extras; j++) {
                            this._AbsListView_this.removeDetachedView(scrapPile.remove(size--), false);
                        }
                    }
                    if (this.mTransientStateViews != null) {
                        for (let i = 0; i < this.mTransientStateViews.size(); i++) {
                            const v = this.mTransientStateViews.valueAt(i);
                            if (!v.hasTransientState()) {
                                this.mTransientStateViews.removeAt(i);
                                i--;
                            }
                        }
                    }
                    if (this.mTransientStateViewsById != null) {
                        for (let i = 0; i < this.mTransientStateViewsById.size(); i++) {
                            const v = this.mTransientStateViewsById.valueAt(i);
                            if (!v.hasTransientState()) {
                                this.mTransientStateViewsById.removeAt(i);
                                i--;
                            }
                        }
                    }
                }
                reclaimScrapViews(views) {
                    if (this.mViewTypeCount == 1) {
                        views.addAll(this.mCurrentScrap);
                    }
                    else {
                        const viewTypeCount = this.mViewTypeCount;
                        const scrapViews = this.mScrapViews;
                        for (let i = 0; i < viewTypeCount; ++i) {
                            const scrapPile = scrapViews[i];
                            views.addAll(scrapPile);
                        }
                    }
                }
                setCacheColorHint(color) {
                    if (this.mViewTypeCount == 1) {
                        const scrap = this.mCurrentScrap;
                        const scrapCount = scrap.size();
                        for (let i = 0; i < scrapCount; i++) {
                            scrap.get(i).setDrawingCacheBackgroundColor(color);
                        }
                    }
                    else {
                        const typeCount = this.mViewTypeCount;
                        for (let i = 0; i < typeCount; i++) {
                            const scrap = this.mScrapViews[i];
                            const scrapCount = scrap.size();
                            for (let j = 0; j < scrapCount; j++) {
                                scrap.get(j).setDrawingCacheBackgroundColor(color);
                            }
                        }
                    }
                    const activeViews = this.mActiveViews;
                    const count = activeViews.length;
                    for (let i = 0; i < count; ++i) {
                        const victim = activeViews[i];
                        if (victim != null) {
                            victim.setDrawingCacheBackgroundColor(color);
                        }
                    }
                }
            }
            AbsListView.RecycleBin = RecycleBin;
        })(AbsListView = widget.AbsListView || (widget.AbsListView = {}));
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/widget/Adapter.ts"/>
///<reference path="../../android/widget/ListAdapter.ts"/>
///<reference path="../../android/widget/ListView.ts"/>
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/database/DataSetObserver.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../java/util/ArrayList.ts"/>
///<reference path="../../android/widget/Adapter.ts"/>
///<reference path="../../android/widget/AdapterView.ts"/>
///<reference path="../../android/widget/ListAdapter.ts"/>
///<reference path="../../android/widget/ListView.ts"/>
///<reference path="../../android/widget/WrapperListAdapter.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var ArrayList = java.util.ArrayList;
        var AdapterView = android.widget.AdapterView;
        class HeaderViewListAdapter {
            constructor(headerViewInfos, footerViewInfos, adapter) {
                this.mAdapter = adapter;
                this.mIsFilterable = false;
                if (headerViewInfos == null) {
                    this.mHeaderViewInfos = HeaderViewListAdapter.EMPTY_INFO_LIST;
                }
                else {
                    this.mHeaderViewInfos = headerViewInfos;
                }
                if (footerViewInfos == null) {
                    this.mFooterViewInfos = HeaderViewListAdapter.EMPTY_INFO_LIST;
                }
                else {
                    this.mFooterViewInfos = footerViewInfos;
                }
                this.mAreAllFixedViewsSelectable = this.areAllListInfosSelectable(this.mHeaderViewInfos) && this.areAllListInfosSelectable(this.mFooterViewInfos);
            }
            getHeadersCount() {
                return this.mHeaderViewInfos.size();
            }
            getFootersCount() {
                return this.mFooterViewInfos.size();
            }
            isEmpty() {
                return this.mAdapter == null || this.mAdapter.isEmpty();
            }
            areAllListInfosSelectable(infos) {
                if (infos != null) {
                    for (let info of infos.array) {
                        if (!info.isSelectable) {
                            return false;
                        }
                    }
                }
                return true;
            }
            removeHeader(v) {
                for (let i = 0; i < this.mHeaderViewInfos.size(); i++) {
                    let info = this.mHeaderViewInfos.get(i);
                    if (info.view == v) {
                        this.mHeaderViewInfos.remove(i);
                        this.mAreAllFixedViewsSelectable = this.areAllListInfosSelectable(this.mHeaderViewInfos) && this.areAllListInfosSelectable(this.mFooterViewInfos);
                        return true;
                    }
                }
                return false;
            }
            removeFooter(v) {
                for (let i = 0; i < this.mFooterViewInfos.size(); i++) {
                    let info = this.mFooterViewInfos.get(i);
                    if (info.view == v) {
                        this.mFooterViewInfos.remove(i);
                        this.mAreAllFixedViewsSelectable = this.areAllListInfosSelectable(this.mHeaderViewInfos) && this.areAllListInfosSelectable(this.mFooterViewInfos);
                        return true;
                    }
                }
                return false;
            }
            getCount() {
                if (this.mAdapter != null) {
                    return this.getFootersCount() + this.getHeadersCount() + this.mAdapter.getCount();
                }
                else {
                    return this.getFootersCount() + this.getHeadersCount();
                }
            }
            areAllItemsEnabled() {
                if (this.mAdapter != null) {
                    return this.mAreAllFixedViewsSelectable && this.mAdapter.areAllItemsEnabled();
                }
                else {
                    return true;
                }
            }
            isEnabled(position) {
                let numHeaders = this.getHeadersCount();
                if (position < numHeaders) {
                    return this.mHeaderViewInfos.get(position).isSelectable;
                }
                const adjPosition = position - numHeaders;
                let adapterCount = 0;
                if (this.mAdapter != null) {
                    adapterCount = this.mAdapter.getCount();
                    if (adjPosition < adapterCount) {
                        return this.mAdapter.isEnabled(adjPosition);
                    }
                }
                return this.mFooterViewInfos.get(adjPosition - adapterCount).isSelectable;
            }
            getItem(position) {
                let numHeaders = this.getHeadersCount();
                if (position < numHeaders) {
                    return this.mHeaderViewInfos.get(position).data;
                }
                const adjPosition = position - numHeaders;
                let adapterCount = 0;
                if (this.mAdapter != null) {
                    adapterCount = this.mAdapter.getCount();
                    if (adjPosition < adapterCount) {
                        return this.mAdapter.getItem(adjPosition);
                    }
                }
                return this.mFooterViewInfos.get(adjPosition - adapterCount).data;
            }
            getItemId(position) {
                let numHeaders = this.getHeadersCount();
                if (this.mAdapter != null && position >= numHeaders) {
                    let adjPosition = position - numHeaders;
                    let adapterCount = this.mAdapter.getCount();
                    if (adjPosition < adapterCount) {
                        return this.mAdapter.getItemId(adjPosition);
                    }
                }
                return -1;
            }
            hasStableIds() {
                if (this.mAdapter != null) {
                    return this.mAdapter.hasStableIds();
                }
                return false;
            }
            getView(position, convertView, parent) {
                let numHeaders = this.getHeadersCount();
                if (position < numHeaders) {
                    return this.mHeaderViewInfos.get(position).view;
                }
                const adjPosition = position - numHeaders;
                let adapterCount = 0;
                if (this.mAdapter != null) {
                    adapterCount = this.mAdapter.getCount();
                    if (adjPosition < adapterCount) {
                        return this.mAdapter.getView(adjPosition, convertView, parent);
                    }
                }
                return this.mFooterViewInfos.get(adjPosition - adapterCount).view;
            }
            getItemViewType(position) {
                let numHeaders = this.getHeadersCount();
                if (this.mAdapter != null && position >= numHeaders) {
                    let adjPosition = position - numHeaders;
                    let adapterCount = this.mAdapter.getCount();
                    if (adjPosition < adapterCount) {
                        return this.mAdapter.getItemViewType(adjPosition);
                    }
                }
                return AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER;
            }
            getViewTypeCount() {
                if (this.mAdapter != null) {
                    return this.mAdapter.getViewTypeCount();
                }
                return 1;
            }
            registerDataSetObserver(observer) {
                if (this.mAdapter != null) {
                    this.mAdapter.registerDataSetObserver(observer);
                }
            }
            unregisterDataSetObserver(observer) {
                if (this.mAdapter != null) {
                    this.mAdapter.unregisterDataSetObserver(observer);
                }
            }
            getFilter() {
                return null;
            }
            getWrappedAdapter() {
                return this.mAdapter;
            }
        }
        HeaderViewListAdapter.EMPTY_INFO_LIST = new ArrayList();
        widget.HeaderViewListAdapter = HeaderViewListAdapter;
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/5.
 */
///<reference path="../../java/util/ArrayList.ts"/>
var android;
(function (android) {
    var database;
    (function (database) {
        var ArrayList = java.util.ArrayList;
        class Observable {
            constructor() {
                this.mObservers = new ArrayList();
            }
            registerObserver(observer) {
                if (observer == null) {
                    throw new Error("The observer is null.");
                }
                if (this.mObservers.contains(observer)) {
                    throw new Error("Observer " + observer + " is already registered.");
                }
                this.mObservers.add(observer);
            }
            unregisterObserver(observer) {
                if (observer == null) {
                    throw new Error("The observer is null.");
                }
                let index = this.mObservers.indexOf(observer);
                if (index == -1) {
                    throw new Error("Observer " + observer + " was not registered.");
                }
                this.mObservers.remove(index);
            }
            unregisterAll() {
                this.mObservers.clear();
            }
        }
        database.Observable = Observable;
    })(database = android.database || (android.database = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/5.
 */
///<reference path="Observable.ts"/>
///<reference path="DataSetObserver.ts"/>
///<reference path="../../java/util/ArrayList.ts"/>
var android;
(function (android) {
    var database;
    (function (database) {
        var Observable = android.database.Observable;
        class DataSetObservable extends Observable {
            notifyChanged() {
                for (let i = this.mObservers.size() - 1; i >= 0; i--) {
                    this.mObservers.get(i).onChanged();
                }
            }
            notifyInvalidated() {
                for (let i = this.mObservers.size() - 1; i >= 0; i--) {
                    this.mObservers.get(i).onInvalidated();
                }
            }
        }
        database.DataSetObservable = DataSetObservable;
    })(database = android.database || (android.database = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../android/widget/Adapter.ts"/>
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/database/DataSetObservable.ts"/>
///<reference path="../../android/database/DataSetObserver.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../android/widget/Adapter.ts"/>
///<reference path="../../android/widget/ListAdapter.ts"/>
///<reference path="../../android/widget/ListView.ts"/>
///<reference path="../../android/widget/SpinnerAdapter.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var DataSetObservable = android.database.DataSetObservable;
        class BaseAdapter {
            constructor() {
                this.mDataSetObservable = new DataSetObservable();
            }
            hasStableIds() {
                return false;
            }
            registerDataSetObserver(observer) {
                this.mDataSetObservable.registerObserver(observer);
            }
            unregisterDataSetObserver(observer) {
                this.mDataSetObservable.unregisterObserver(observer);
            }
            notifyDataSetChanged() {
                this.mDataSetObservable.notifyChanged();
            }
            notifyDataSetInvalidated() {
                this.mDataSetObservable.notifyInvalidated();
            }
            areAllItemsEnabled() {
                return true;
            }
            isEnabled(position) {
                return true;
            }
            getDropDownView(position, convertView, parent) {
                return this.getView(position, convertView, parent);
            }
            getItemViewType(position) {
                return 0;
            }
            getViewTypeCount() {
                return 1;
            }
            isEmpty() {
                return this.getCount() == 0;
            }
        }
        widget.BaseAdapter = BaseAdapter;
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/graphics/Canvas.ts"/>
///<reference path="../../android/graphics/Paint.ts"/>
///<reference path="../../android/graphics/PixelFormat.ts"/>
///<reference path="../../android/graphics/Rect.ts"/>
///<reference path="../../android/graphics/drawable/Drawable.ts"/>
///<reference path="../../android/util/MathUtils.ts"/>
///<reference path="../../android/util/SparseBooleanArray.ts"/>
///<reference path="../../android/view/FocusFinder.ts"/>
///<reference path="../../android/view/KeyEvent.ts"/>
///<reference path="../../android/view/SoundEffectConstants.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../android/view/ViewParent.ts"/>
///<reference path="../../android/view/ViewRootImpl.ts"/>
///<reference path="../../android/os/Trace.ts"/>
///<reference path="../../java/util/ArrayList.ts"/>
///<reference path="../../java/lang/Integer.ts"/>
///<reference path="../../java/lang/System.ts"/>
///<reference path="../../java/lang/Runnable.ts"/>
///<reference path="../../android/widget/AbsListView.ts"/>
///<reference path="../../android/widget/Adapter.ts"/>
///<reference path="../../android/widget/AdapterView.ts"/>
///<reference path="../../android/widget/Checkable.ts"/>
///<reference path="../../android/widget/HeaderViewListAdapter.ts"/>
///<reference path="../../android/widget/ListAdapter.ts"/>
///<reference path="../../android/widget/WrapperListAdapter.ts"/>
///<reference path="../../android/widget/BaseAdapter.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var Paint = android.graphics.Paint;
        var PixelFormat = android.graphics.PixelFormat;
        var Rect = android.graphics.Rect;
        var MathUtils = android.util.MathUtils;
        var FocusFinder = android.view.FocusFinder;
        var KeyEvent = android.view.KeyEvent;
        var SoundEffectConstants = android.view.SoundEffectConstants;
        var View = android.view.View;
        var ViewGroup = android.view.ViewGroup;
        var Trace = android.os.Trace;
        var ArrayList = java.util.ArrayList;
        var Integer = java.lang.Integer;
        var System = java.lang.System;
        var AbsListView = android.widget.AbsListView;
        var AdapterView = android.widget.AdapterView;
        var HeaderViewListAdapter = android.widget.HeaderViewListAdapter;
        class ListView extends AbsListView {
            constructor() {
                super();
                this.mHeaderViewInfos = new ArrayList();
                this.mFooterViewInfos = new ArrayList();
                this.mDividerHeight = 0;
                this.mIsCacheColorOpaque = false;
                this.mDividerIsOpaque = false;
                this.mHeaderDividersEnabled = true;
                this.mFooterDividersEnabled = true;
                this.mAreAllItemsSelectable = true;
                this.mItemsCanFocus = false;
                this.mTempRect = new Rect();
                this.mArrowScrollFocusResult = new ListView.ArrowScrollFocusResult();
                this.setDivider(android.R.drawable.list_divider);
                this.setDividerHeight(1);
            }
            createAttrChangeHandler(mergeHandler) {
                super.createAttrChangeHandler(mergeHandler);
                const listView = this;
                mergeHandler.add({
                    set divider(value) {
                        let divider = mergeHandler.parseDrawable(value);
                        if (divider)
                            listView.setDivider(divider);
                    },
                    set overScrollHeader(value) {
                        let header = mergeHandler.parseDrawable(value);
                        if (header)
                            listView.setOverscrollHeader(header);
                    },
                    set overScrollFooter(value) {
                        let footer = mergeHandler.parseDrawable(value);
                        if (footer)
                            listView.setOverscrollFooter(footer);
                    },
                    set dividerHeight(value) {
                        let dividerHeight = mergeHandler.parseNumber(value, 0);
                        if (dividerHeight > 0) {
                            listView.setDividerHeight(dividerHeight);
                        }
                    },
                    set headerDividersEnabled(value) {
                        listView.setHeaderDividersEnabled(mergeHandler.parseBoolean(value, true));
                    },
                    set footerDividersEnabled(value) {
                        listView.setFooterDividersEnabled(mergeHandler.parseBoolean(value, true));
                    },
                });
            }
            getMaxScrollAmount() {
                return Math.floor((ListView.MAX_SCROLL_FACTOR * (this.mBottom - this.mTop)));
            }
            adjustViewsUpOrDown() {
                const childCount = this.getChildCount();
                let delta;
                if (childCount > 0) {
                    let child;
                    if (!this.mStackFromBottom) {
                        child = this.getChildAt(0);
                        delta = child.getTop() - this.mListPadding.top;
                        if (this.mFirstPosition != 0) {
                            delta -= this.mDividerHeight;
                        }
                        if (delta < 0) {
                            delta = 0;
                        }
                    }
                    else {
                        child = this.getChildAt(childCount - 1);
                        delta = child.getBottom() - (this.getHeight() - this.mListPadding.bottom);
                        if (this.mFirstPosition + childCount < this.mItemCount) {
                            delta += this.mDividerHeight;
                        }
                        if (delta > 0) {
                            delta = 0;
                        }
                    }
                    if (delta != 0) {
                        this.offsetChildrenTopAndBottom(-delta);
                    }
                }
            }
            addHeaderView(v, data = null, isSelectable = true) {
                const info = new ListView.FixedViewInfo(this);
                info.view = v;
                info.data = data;
                info.isSelectable = isSelectable;
                this.mHeaderViewInfos.add(info);
                if (this.mAdapter != null) {
                    if (!(this.mAdapter instanceof HeaderViewListAdapter)) {
                        this.mAdapter = new HeaderViewListAdapter(this.mHeaderViewInfos, this.mFooterViewInfos, this.mAdapter);
                    }
                    if (this.mDataSetObserver != null) {
                        this.mDataSetObserver.onChanged();
                    }
                }
            }
            getHeaderViewsCount() {
                return this.mHeaderViewInfos.size();
            }
            removeHeaderView(v) {
                if (this.mHeaderViewInfos.size() > 0) {
                    let result = false;
                    if (this.mAdapter != null && this.mAdapter.removeHeader(v)) {
                        if (this.mDataSetObserver != null) {
                            this.mDataSetObserver.onChanged();
                        }
                        result = true;
                    }
                    this.removeFixedViewInfo(v, this.mHeaderViewInfos);
                    return result;
                }
                return false;
            }
            removeFixedViewInfo(v, where) {
                let len = where.size();
                for (let i = 0; i < len; ++i) {
                    let info = where.get(i);
                    if (info.view == v) {
                        where.remove(i);
                        break;
                    }
                }
            }
            addFooterView(v, data = null, isSelectable = true) {
                const info = new ListView.FixedViewInfo(this);
                info.view = v;
                info.data = data;
                info.isSelectable = isSelectable;
                this.mFooterViewInfos.add(info);
                if (this.mAdapter != null) {
                    if (!(this.mAdapter instanceof HeaderViewListAdapter)) {
                        this.mAdapter = new HeaderViewListAdapter(this.mHeaderViewInfos, this.mFooterViewInfos, this.mAdapter);
                    }
                    if (this.mDataSetObserver != null) {
                        this.mDataSetObserver.onChanged();
                    }
                }
            }
            getFooterViewsCount() {
                return this.mFooterViewInfos.size();
            }
            removeFooterView(v) {
                if (this.mFooterViewInfos.size() > 0) {
                    let result = false;
                    if (this.mAdapter != null && this.mAdapter.removeFooter(v)) {
                        if (this.mDataSetObserver != null) {
                            this.mDataSetObserver.onChanged();
                        }
                        result = true;
                    }
                    this.removeFixedViewInfo(v, this.mFooterViewInfos);
                    return result;
                }
                return false;
            }
            getAdapter() {
                return this.mAdapter;
            }
            setAdapter(adapter) {
                if (this.mAdapter != null && this.mDataSetObserver != null) {
                    this.mAdapter.unregisterDataSetObserver(this.mDataSetObserver);
                }
                this.resetList();
                this.mRecycler.clear();
                if (this.mHeaderViewInfos.size() > 0 || this.mFooterViewInfos.size() > 0) {
                    this.mAdapter = new HeaderViewListAdapter(this.mHeaderViewInfos, this.mFooterViewInfos, adapter);
                }
                else {
                    this.mAdapter = adapter;
                }
                this.mOldSelectedPosition = ListView.INVALID_POSITION;
                this.mOldSelectedRowId = ListView.INVALID_ROW_ID;
                super.setAdapter(adapter);
                if (this.mAdapter != null) {
                    this.mAreAllItemsSelectable = this.mAdapter.areAllItemsEnabled();
                    this.mOldItemCount = this.mItemCount;
                    this.mItemCount = this.mAdapter.getCount();
                    this.checkFocus();
                    this.mDataSetObserver = new AbsListView.AdapterDataSetObserver(this);
                    this.mAdapter.registerDataSetObserver(this.mDataSetObserver);
                    this.mRecycler.setViewTypeCount(this.mAdapter.getViewTypeCount());
                    let position;
                    if (this.mStackFromBottom) {
                        position = this.lookForSelectablePosition(this.mItemCount - 1, false);
                    }
                    else {
                        position = this.lookForSelectablePosition(0, true);
                    }
                    this.setSelectedPositionInt(position);
                    this.setNextSelectedPositionInt(position);
                    if (this.mItemCount == 0) {
                        this.checkSelectionChanged();
                    }
                }
                else {
                    this.mAreAllItemsSelectable = true;
                    this.checkFocus();
                    this.checkSelectionChanged();
                }
                this.requestLayout();
            }
            resetList() {
                this.clearRecycledState(this.mHeaderViewInfos);
                this.clearRecycledState(this.mFooterViewInfos);
                super.resetList();
                this.mLayoutMode = ListView.LAYOUT_NORMAL;
            }
            clearRecycledState(infos) {
                if (infos != null) {
                    const count = infos.size();
                    for (let i = 0; i < count; i++) {
                        const child = infos.get(i).view;
                        const p = child.getLayoutParams();
                        if (p != null) {
                            p.recycledHeaderFooter = false;
                        }
                    }
                }
            }
            showingTopFadingEdge() {
                const listTop = this.mScrollY + this.mListPadding.top;
                return (this.mFirstPosition > 0) || (this.getChildAt(0).getTop() > listTop);
            }
            showingBottomFadingEdge() {
                const childCount = this.getChildCount();
                const bottomOfBottomChild = this.getChildAt(childCount - 1).getBottom();
                const lastVisiblePosition = this.mFirstPosition + childCount - 1;
                const listBottom = this.mScrollY + this.getHeight() - this.mListPadding.bottom;
                return (lastVisiblePosition < this.mItemCount - 1) || (bottomOfBottomChild < listBottom);
            }
            requestChildRectangleOnScreen(child, rect, immediate) {
                let rectTopWithinChild = rect.top;
                rect.offset(child.getLeft(), child.getTop());
                rect.offset(-child.getScrollX(), -child.getScrollY());
                const height = this.getHeight();
                let listUnfadedTop = this.getScrollY();
                let listUnfadedBottom = listUnfadedTop + height;
                const fadingEdge = this.getVerticalFadingEdgeLength();
                if (this.showingTopFadingEdge()) {
                    if ((this.mSelectedPosition > 0) || (rectTopWithinChild > fadingEdge)) {
                        listUnfadedTop += fadingEdge;
                    }
                }
                let childCount = this.getChildCount();
                let bottomOfBottomChild = this.getChildAt(childCount - 1).getBottom();
                if (this.showingBottomFadingEdge()) {
                    if ((this.mSelectedPosition < this.mItemCount - 1) || (rect.bottom < (bottomOfBottomChild - fadingEdge))) {
                        listUnfadedBottom -= fadingEdge;
                    }
                }
                let scrollYDelta = 0;
                if (rect.bottom > listUnfadedBottom && rect.top > listUnfadedTop) {
                    if (rect.height() > height) {
                        scrollYDelta += (rect.top - listUnfadedTop);
                    }
                    else {
                        scrollYDelta += (rect.bottom - listUnfadedBottom);
                    }
                    let distanceToBottom = bottomOfBottomChild - listUnfadedBottom;
                    scrollYDelta = Math.min(scrollYDelta, distanceToBottom);
                }
                else if (rect.top < listUnfadedTop && rect.bottom < listUnfadedBottom) {
                    if (rect.height() > height) {
                        scrollYDelta -= (listUnfadedBottom - rect.bottom);
                    }
                    else {
                        scrollYDelta -= (listUnfadedTop - rect.top);
                    }
                    let top = this.getChildAt(0).getTop();
                    let deltaToTop = top - listUnfadedTop;
                    scrollYDelta = Math.max(scrollYDelta, deltaToTop);
                }
                const scroll = scrollYDelta != 0;
                if (scroll) {
                    this.scrollListItemsBy(-scrollYDelta);
                    this.positionSelector(ListView.INVALID_POSITION, child);
                    this.mSelectedTop = child.getTop();
                    this.invalidate();
                }
                return scroll;
            }
            fillGap(down) {
                const count = this.getChildCount();
                if (down) {
                    let paddingTop = 0;
                    if ((this.mGroupFlags & ListView.CLIP_TO_PADDING_MASK) == ListView.CLIP_TO_PADDING_MASK) {
                        paddingTop = this.getListPaddingTop();
                    }
                    const startOffset = count > 0 ? this.getChildAt(count - 1).getBottom() + this.mDividerHeight : paddingTop;
                    this.fillDown(this.mFirstPosition + count, startOffset);
                    this.correctTooHigh(this.getChildCount());
                }
                else {
                    let paddingBottom = 0;
                    if ((this.mGroupFlags & ListView.CLIP_TO_PADDING_MASK) == ListView.CLIP_TO_PADDING_MASK) {
                        paddingBottom = this.getListPaddingBottom();
                    }
                    const startOffset = count > 0 ? this.getChildAt(0).getTop() - this.mDividerHeight : this.getHeight() - paddingBottom;
                    this.fillUp(this.mFirstPosition - 1, startOffset);
                    this.correctTooLow(this.getChildCount());
                }
            }
            fillDown(pos, nextTop) {
                let selectedView = null;
                let end = (this.mBottom - this.mTop);
                if ((this.mGroupFlags & ListView.CLIP_TO_PADDING_MASK) == ListView.CLIP_TO_PADDING_MASK) {
                    end -= this.mListPadding.bottom;
                }
                while (nextTop < end && pos < this.mItemCount) {
                    let selected = pos == this.mSelectedPosition;
                    let child = this.makeAndAddView(pos, nextTop, true, this.mListPadding.left, selected);
                    nextTop = child.getBottom() + this.mDividerHeight;
                    if (selected) {
                        selectedView = child;
                    }
                    pos++;
                }
                this.setVisibleRangeHint(this.mFirstPosition, this.mFirstPosition + this.getChildCount() - 1);
                return selectedView;
            }
            fillUp(pos, nextBottom) {
                let selectedView = null;
                let end = 0;
                if ((this.mGroupFlags & ListView.CLIP_TO_PADDING_MASK) == ListView.CLIP_TO_PADDING_MASK) {
                    end = this.mListPadding.top;
                }
                while (nextBottom > end && pos >= 0) {
                    let selected = pos == this.mSelectedPosition;
                    let child = this.makeAndAddView(pos, nextBottom, false, this.mListPadding.left, selected);
                    nextBottom = child.getTop() - this.mDividerHeight;
                    if (selected) {
                        selectedView = child;
                    }
                    pos--;
                }
                this.mFirstPosition = pos + 1;
                this.setVisibleRangeHint(this.mFirstPosition, this.mFirstPosition + this.getChildCount() - 1);
                return selectedView;
            }
            fillFromTop(nextTop) {
                this.mFirstPosition = Math.min(this.mFirstPosition, this.mSelectedPosition);
                this.mFirstPosition = Math.min(this.mFirstPosition, this.mItemCount - 1);
                if (this.mFirstPosition < 0) {
                    this.mFirstPosition = 0;
                }
                return this.fillDown(this.mFirstPosition, nextTop);
            }
            fillFromMiddle(childrenTop, childrenBottom) {
                let height = childrenBottom - childrenTop;
                let position = this.reconcileSelectedPosition();
                let sel = this.makeAndAddView(position, childrenTop, true, this.mListPadding.left, true);
                this.mFirstPosition = position;
                let selHeight = sel.getMeasuredHeight();
                if (selHeight <= height) {
                    sel.offsetTopAndBottom((height - selHeight) / 2);
                }
                this.fillAboveAndBelow(sel, position);
                if (!this.mStackFromBottom) {
                    this.correctTooHigh(this.getChildCount());
                }
                else {
                    this.correctTooLow(this.getChildCount());
                }
                return sel;
            }
            fillAboveAndBelow(sel, position) {
                const dividerHeight = this.mDividerHeight;
                if (!this.mStackFromBottom) {
                    this.fillUp(position - 1, sel.getTop() - dividerHeight);
                    this.adjustViewsUpOrDown();
                    this.fillDown(position + 1, sel.getBottom() + dividerHeight);
                }
                else {
                    this.fillDown(position + 1, sel.getBottom() + dividerHeight);
                    this.adjustViewsUpOrDown();
                    this.fillUp(position - 1, sel.getTop() - dividerHeight);
                }
            }
            fillFromSelection(selectedTop, childrenTop, childrenBottom) {
                let fadingEdgeLength = this.getVerticalFadingEdgeLength();
                const selectedPosition = this.mSelectedPosition;
                let sel;
                const topSelectionPixel = this.getTopSelectionPixel(childrenTop, fadingEdgeLength, selectedPosition);
                const bottomSelectionPixel = this.getBottomSelectionPixel(childrenBottom, fadingEdgeLength, selectedPosition);
                sel = this.makeAndAddView(selectedPosition, selectedTop, true, this.mListPadding.left, true);
                if (sel.getBottom() > bottomSelectionPixel) {
                    const spaceAbove = sel.getTop() - topSelectionPixel;
                    const spaceBelow = sel.getBottom() - bottomSelectionPixel;
                    const offset = Math.min(spaceAbove, spaceBelow);
                    sel.offsetTopAndBottom(-offset);
                }
                else if (sel.getTop() < topSelectionPixel) {
                    const spaceAbove = topSelectionPixel - sel.getTop();
                    const spaceBelow = bottomSelectionPixel - sel.getBottom();
                    const offset = Math.min(spaceAbove, spaceBelow);
                    sel.offsetTopAndBottom(offset);
                }
                this.fillAboveAndBelow(sel, selectedPosition);
                if (!this.mStackFromBottom) {
                    this.correctTooHigh(this.getChildCount());
                }
                else {
                    this.correctTooLow(this.getChildCount());
                }
                return sel;
            }
            getBottomSelectionPixel(childrenBottom, fadingEdgeLength, selectedPosition) {
                let bottomSelectionPixel = childrenBottom;
                if (selectedPosition != this.mItemCount - 1) {
                    bottomSelectionPixel -= fadingEdgeLength;
                }
                return bottomSelectionPixel;
            }
            getTopSelectionPixel(childrenTop, fadingEdgeLength, selectedPosition) {
                let topSelectionPixel = childrenTop;
                if (selectedPosition > 0) {
                    topSelectionPixel += fadingEdgeLength;
                }
                return topSelectionPixel;
            }
            smoothScrollToPosition(position) {
                super.smoothScrollToPosition(position);
            }
            smoothScrollByOffset(offset) {
                super.smoothScrollByOffset(offset);
            }
            moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom) {
                let fadingEdgeLength = this.getVerticalFadingEdgeLength();
                const selectedPosition = this.mSelectedPosition;
                let sel;
                const topSelectionPixel = this.getTopSelectionPixel(childrenTop, fadingEdgeLength, selectedPosition);
                const bottomSelectionPixel = this.getBottomSelectionPixel(childrenTop, fadingEdgeLength, selectedPosition);
                if (delta > 0) {
                    oldSel = this.makeAndAddView(selectedPosition - 1, oldSel.getTop(), true, this.mListPadding.left, false);
                    const dividerHeight = this.mDividerHeight;
                    sel = this.makeAndAddView(selectedPosition, oldSel.getBottom() + dividerHeight, true, this.mListPadding.left, true);
                    if (sel.getBottom() > bottomSelectionPixel) {
                        let spaceAbove = sel.getTop() - topSelectionPixel;
                        let spaceBelow = sel.getBottom() - bottomSelectionPixel;
                        let halfVerticalSpace = (childrenBottom - childrenTop) / 2;
                        let offset = Math.min(spaceAbove, spaceBelow);
                        offset = Math.min(offset, halfVerticalSpace);
                        oldSel.offsetTopAndBottom(-offset);
                        sel.offsetTopAndBottom(-offset);
                    }
                    if (!this.mStackFromBottom) {
                        this.fillUp(this.mSelectedPosition - 2, sel.getTop() - dividerHeight);
                        this.adjustViewsUpOrDown();
                        this.fillDown(this.mSelectedPosition + 1, sel.getBottom() + dividerHeight);
                    }
                    else {
                        this.fillDown(this.mSelectedPosition + 1, sel.getBottom() + dividerHeight);
                        this.adjustViewsUpOrDown();
                        this.fillUp(this.mSelectedPosition - 2, sel.getTop() - dividerHeight);
                    }
                }
                else if (delta < 0) {
                    if (newSel != null) {
                        sel = this.makeAndAddView(selectedPosition, newSel.getTop(), true, this.mListPadding.left, true);
                    }
                    else {
                        sel = this.makeAndAddView(selectedPosition, oldSel.getTop(), false, this.mListPadding.left, true);
                    }
                    if (sel.getTop() < topSelectionPixel) {
                        let spaceAbove = topSelectionPixel - sel.getTop();
                        let spaceBelow = bottomSelectionPixel - sel.getBottom();
                        let halfVerticalSpace = (childrenBottom - childrenTop) / 2;
                        let offset = Math.min(spaceAbove, spaceBelow);
                        offset = Math.min(offset, halfVerticalSpace);
                        sel.offsetTopAndBottom(offset);
                    }
                    this.fillAboveAndBelow(sel, selectedPosition);
                }
                else {
                    let oldTop = oldSel.getTop();
                    sel = this.makeAndAddView(selectedPosition, oldTop, true, this.mListPadding.left, true);
                    if (oldTop < childrenTop) {
                        let newBottom = sel.getBottom();
                        if (newBottom < childrenTop + 20) {
                            sel.offsetTopAndBottom(childrenTop - sel.getTop());
                        }
                    }
                    this.fillAboveAndBelow(sel, selectedPosition);
                }
                return sel;
            }
            onSizeChanged(w, h, oldw, oldh) {
                if (this.getChildCount() > 0) {
                    let focusedChild = this.getFocusedChild();
                    if (focusedChild != null) {
                        const childPosition = this.mFirstPosition + this.indexOfChild(focusedChild);
                        const childBottom = focusedChild.getBottom();
                        const offset = Math.max(0, childBottom - (h - this.mPaddingTop));
                        const top = focusedChild.getTop() - offset;
                        if (this.mFocusSelector == null) {
                            this.mFocusSelector = new ListView.FocusSelector(this);
                        }
                        this.post(this.mFocusSelector.setup(childPosition, top));
                    }
                }
                super.onSizeChanged(w, h, oldw, oldh);
            }
            onMeasure(widthMeasureSpec, heightMeasureSpec) {
                super.onMeasure(widthMeasureSpec, heightMeasureSpec);
                let widthMode = ListView.MeasureSpec.getMode(widthMeasureSpec);
                let heightMode = ListView.MeasureSpec.getMode(heightMeasureSpec);
                let widthSize = ListView.MeasureSpec.getSize(widthMeasureSpec);
                let heightSize = ListView.MeasureSpec.getSize(heightMeasureSpec);
                let childWidth = 0;
                let childHeight = 0;
                let childState = 0;
                this.mItemCount = this.mAdapter == null ? 0 : this.mAdapter.getCount();
                if (this.mItemCount > 0 && (widthMode == ListView.MeasureSpec.UNSPECIFIED || heightMode == ListView.MeasureSpec.UNSPECIFIED)) {
                    const child = this.obtainView(0, this.mIsScrap);
                    this.measureScrapChild(child, 0, widthMeasureSpec);
                    childWidth = child.getMeasuredWidth();
                    childHeight = child.getMeasuredHeight();
                    childState = ListView.combineMeasuredStates(childState, child.getMeasuredState());
                    if (this.recycleOnMeasure() && this.mRecycler.shouldRecycleViewType(child.getLayoutParams().viewType)) {
                        this.mRecycler.addScrapView(child, -1);
                    }
                }
                if (widthMode == ListView.MeasureSpec.UNSPECIFIED) {
                    widthSize = this.mListPadding.left + this.mListPadding.right + childWidth + this.getVerticalScrollbarWidth();
                }
                else {
                    widthSize |= (childState & ListView.MEASURED_STATE_MASK);
                }
                if (heightMode == ListView.MeasureSpec.UNSPECIFIED) {
                    heightSize = this.mListPadding.top + this.mListPadding.bottom + childHeight + this.getVerticalFadingEdgeLength() * 2;
                }
                if (heightMode == ListView.MeasureSpec.AT_MOST) {
                    heightSize = this.measureHeightOfChildren(widthMeasureSpec, 0, ListView.NO_POSITION, heightSize, -1);
                }
                this.setMeasuredDimension(widthSize, heightSize);
                this.mWidthMeasureSpec = widthMeasureSpec;
            }
            measureScrapChild(child, position, widthMeasureSpec) {
                let p = child.getLayoutParams();
                if (p == null) {
                    p = this.generateDefaultLayoutParams();
                    child.setLayoutParams(p);
                }
                p.viewType = this.mAdapter.getItemViewType(position);
                p.forceAdd = true;
                let childWidthSpec = ViewGroup.getChildMeasureSpec(widthMeasureSpec, this.mListPadding.left + this.mListPadding.right, p.width);
                let lpHeight = p.height;
                let childHeightSpec;
                if (lpHeight > 0) {
                    childHeightSpec = ListView.MeasureSpec.makeMeasureSpec(lpHeight, ListView.MeasureSpec.EXACTLY);
                }
                else {
                    childHeightSpec = ListView.MeasureSpec.makeMeasureSpec(0, ListView.MeasureSpec.UNSPECIFIED);
                }
                child.measure(childWidthSpec, childHeightSpec);
            }
            recycleOnMeasure() {
                return true;
            }
            measureHeightOfChildren(widthMeasureSpec, startPosition, endPosition, maxHeight, disallowPartialChildPosition) {
                const adapter = this.mAdapter;
                if (adapter == null) {
                    return this.mListPadding.top + this.mListPadding.bottom;
                }
                let returnedHeight = this.mListPadding.top + this.mListPadding.bottom;
                const dividerHeight = ((this.mDividerHeight > 0) && this.mDivider != null) ? this.mDividerHeight : 0;
                let prevHeightWithoutPartialChild = 0;
                let i;
                let child;
                endPosition = (endPosition == ListView.NO_POSITION) ? adapter.getCount() - 1 : endPosition;
                const recycleBin = this.mRecycler;
                const recyle = this.recycleOnMeasure();
                const isScrap = this.mIsScrap;
                for (i = startPosition; i <= endPosition; ++i) {
                    child = this.obtainView(i, isScrap);
                    this.measureScrapChild(child, i, widthMeasureSpec);
                    if (i > 0) {
                        returnedHeight += dividerHeight;
                    }
                    if (recyle && recycleBin.shouldRecycleViewType(child.getLayoutParams().viewType)) {
                        recycleBin.addScrapView(child, -1);
                    }
                    returnedHeight += child.getMeasuredHeight();
                    if (returnedHeight >= maxHeight) {
                        return;
                        (disallowPartialChildPosition >= 0) &&
                            (i > disallowPartialChildPosition) &&
                            (prevHeightWithoutPartialChild > 0) &&
                            (returnedHeight != maxHeight) ? prevHeightWithoutPartialChild : maxHeight;
                    }
                    if ((disallowPartialChildPosition >= 0) && (i >= disallowPartialChildPosition)) {
                        prevHeightWithoutPartialChild = returnedHeight;
                    }
                }
                return returnedHeight;
            }
            findMotionRow(y) {
                let childCount = this.getChildCount();
                if (childCount > 0) {
                    if (!this.mStackFromBottom) {
                        for (let i = 0; i < childCount; i++) {
                            let v = this.getChildAt(i);
                            if (y <= v.getBottom()) {
                                return this.mFirstPosition + i;
                            }
                        }
                    }
                    else {
                        for (let i = childCount - 1; i >= 0; i--) {
                            let v = this.getChildAt(i);
                            if (y >= v.getTop()) {
                                return this.mFirstPosition + i;
                            }
                        }
                    }
                }
                return ListView.INVALID_POSITION;
            }
            fillSpecific(position, top) {
                let tempIsSelected = position == this.mSelectedPosition;
                let temp = this.makeAndAddView(position, top, true, this.mListPadding.left, tempIsSelected);
                this.mFirstPosition = position;
                let above;
                let below;
                const dividerHeight = this.mDividerHeight;
                if (!this.mStackFromBottom) {
                    above = this.fillUp(position - 1, temp.getTop() - dividerHeight);
                    this.adjustViewsUpOrDown();
                    below = this.fillDown(position + 1, temp.getBottom() + dividerHeight);
                    let childCount = this.getChildCount();
                    if (childCount > 0) {
                        this.correctTooHigh(childCount);
                    }
                }
                else {
                    below = this.fillDown(position + 1, temp.getBottom() + dividerHeight);
                    this.adjustViewsUpOrDown();
                    above = this.fillUp(position - 1, temp.getTop() - dividerHeight);
                    let childCount = this.getChildCount();
                    if (childCount > 0) {
                        this.correctTooLow(childCount);
                    }
                }
                if (tempIsSelected) {
                    return temp;
                }
                else if (above != null) {
                    return above;
                }
                else {
                    return below;
                }
            }
            correctTooHigh(childCount) {
                let lastPosition = this.mFirstPosition + childCount - 1;
                if (lastPosition == this.mItemCount - 1 && childCount > 0) {
                    const lastChild = this.getChildAt(childCount - 1);
                    const lastBottom = lastChild.getBottom();
                    const end = (this.mBottom - this.mTop) - this.mListPadding.bottom;
                    let bottomOffset = end - lastBottom;
                    let firstChild = this.getChildAt(0);
                    const firstTop = firstChild.getTop();
                    if (bottomOffset > 0 && (this.mFirstPosition > 0 || firstTop < this.mListPadding.top)) {
                        if (this.mFirstPosition == 0) {
                            bottomOffset = Math.min(bottomOffset, this.mListPadding.top - firstTop);
                        }
                        this.offsetChildrenTopAndBottom(bottomOffset);
                        if (this.mFirstPosition > 0) {
                            this.fillUp(this.mFirstPosition - 1, firstChild.getTop() - this.mDividerHeight);
                            this.adjustViewsUpOrDown();
                        }
                    }
                }
            }
            correctTooLow(childCount) {
                if (this.mFirstPosition == 0 && childCount > 0) {
                    const firstChild = this.getChildAt(0);
                    const firstTop = firstChild.getTop();
                    const start = this.mListPadding.top;
                    const end = (this.mBottom - this.mTop) - this.mListPadding.bottom;
                    let topOffset = firstTop - start;
                    let lastChild = this.getChildAt(childCount - 1);
                    const lastBottom = lastChild.getBottom();
                    let lastPosition = this.mFirstPosition + childCount - 1;
                    if (topOffset > 0) {
                        if (lastPosition < this.mItemCount - 1 || lastBottom > end) {
                            if (lastPosition == this.mItemCount - 1) {
                                topOffset = Math.min(topOffset, lastBottom - end);
                            }
                            this.offsetChildrenTopAndBottom(-topOffset);
                            if (lastPosition < this.mItemCount - 1) {
                                this.fillDown(lastPosition + 1, lastChild.getBottom() + this.mDividerHeight);
                                this.adjustViewsUpOrDown();
                            }
                        }
                        else if (lastPosition == this.mItemCount - 1) {
                            this.adjustViewsUpOrDown();
                        }
                    }
                }
            }
            layoutChildren() {
                const blockLayoutRequests = this.mBlockLayoutRequests;
                if (blockLayoutRequests) {
                    return;
                }
                this.mBlockLayoutRequests = true;
                try {
                    super.layoutChildren();
                    this.invalidate();
                    if (this.mAdapter == null) {
                        this.resetList();
                        this.invokeOnItemScrollListener();
                        return;
                    }
                    const childrenTop = this.mListPadding.top;
                    const childrenBottom = this.mBottom - this.mTop - this.mListPadding.bottom;
                    const childCount = this.getChildCount();
                    let index = 0;
                    let delta = 0;
                    let sel;
                    let oldSel = null;
                    let oldFirst = null;
                    let newSel = null;
                    switch (this.mLayoutMode) {
                        case ListView.LAYOUT_SET_SELECTION:
                            index = this.mNextSelectedPosition - this.mFirstPosition;
                            if (index >= 0 && index < childCount) {
                                newSel = this.getChildAt(index);
                            }
                            break;
                        case ListView.LAYOUT_FORCE_TOP:
                        case ListView.LAYOUT_FORCE_BOTTOM:
                        case ListView.LAYOUT_SPECIFIC:
                        case ListView.LAYOUT_SYNC:
                            break;
                        case ListView.LAYOUT_MOVE_SELECTION:
                        default:
                            index = this.mSelectedPosition - this.mFirstPosition;
                            if (index >= 0 && index < childCount) {
                                oldSel = this.getChildAt(index);
                            }
                            oldFirst = this.getChildAt(0);
                            if (this.mNextSelectedPosition >= 0) {
                                delta = this.mNextSelectedPosition - this.mSelectedPosition;
                            }
                            newSel = this.getChildAt(index + delta);
                    }
                    let dataChanged = this.mDataChanged;
                    if (dataChanged) {
                        this.handleDataChanged();
                    }
                    if (this.mItemCount == 0) {
                        this.resetList();
                        this.invokeOnItemScrollListener();
                        return;
                    }
                    else if (this.mItemCount != this.mAdapter.getCount()) {
                        throw Error(`IllegalStateException("The content of the adapter has changed but
                ListView did not receive a notification. Make sure the content of
                your adapter is not modified from a background thread, but only from
                the UI thread. Make sure your adapter calls notifyDataSetChanged()
                when its content changes. [in ListView(${this.getId()},${this.constructor.name})
                with Adapter(${this.mAdapter.constructor.name})]")`);
                    }
                    this.setSelectedPositionInt(this.mNextSelectedPosition);
                    const accessFocusedChild = null;
                    const focusedChild = this.getFocusedChild();
                    if (focusedChild != null) {
                        focusedChild.setHasTransientState(true);
                    }
                    const firstPosition = this.mFirstPosition;
                    const recycleBin = this.mRecycler;
                    if (dataChanged) {
                        for (let i = 0; i < childCount; i++) {
                            recycleBin.addScrapView(this.getChildAt(i), firstPosition + i);
                        }
                    }
                    else {
                        recycleBin.fillActiveViews(childCount, firstPosition);
                    }
                    this.detachAllViewsFromParent();
                    recycleBin.removeSkippedScrap();
                    switch (this.mLayoutMode) {
                        case ListView.LAYOUT_SET_SELECTION:
                            if (newSel != null) {
                                sel = this.fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);
                            }
                            else {
                                sel = this.fillFromMiddle(childrenTop, childrenBottom);
                            }
                            break;
                        case ListView.LAYOUT_SYNC:
                            sel = this.fillSpecific(this.mSyncPosition, this.mSpecificTop);
                            break;
                        case ListView.LAYOUT_FORCE_BOTTOM:
                            sel = this.fillUp(this.mItemCount - 1, childrenBottom);
                            this.adjustViewsUpOrDown();
                            break;
                        case ListView.LAYOUT_FORCE_TOP:
                            this.mFirstPosition = 0;
                            sel = this.fillFromTop(childrenTop);
                            this.adjustViewsUpOrDown();
                            break;
                        case ListView.LAYOUT_SPECIFIC:
                            sel = this.fillSpecific(this.reconcileSelectedPosition(), this.mSpecificTop);
                            break;
                        case ListView.LAYOUT_MOVE_SELECTION:
                            sel = this.moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom);
                            break;
                        default:
                            if (childCount == 0) {
                                if (!this.mStackFromBottom) {
                                    const position = this.lookForSelectablePosition(0, true);
                                    this.setSelectedPositionInt(position);
                                    sel = this.fillFromTop(childrenTop);
                                }
                                else {
                                    const position = this.lookForSelectablePosition(this.mItemCount - 1, false);
                                    this.setSelectedPositionInt(position);
                                    sel = this.fillUp(this.mItemCount - 1, childrenBottom);
                                }
                            }
                            else {
                                if (this.mSelectedPosition >= 0 && this.mSelectedPosition < this.mItemCount) {
                                    sel = this.fillSpecific(this.mSelectedPosition, oldSel == null ? childrenTop : oldSel.getTop());
                                }
                                else if (this.mFirstPosition < this.mItemCount) {
                                    sel = this.fillSpecific(this.mFirstPosition, oldFirst == null ? childrenTop : oldFirst.getTop());
                                }
                                else {
                                    sel = this.fillSpecific(0, childrenTop);
                                }
                            }
                            break;
                    }
                    recycleBin.scrapActiveViews();
                    if (sel != null) {
                        const shouldPlaceFocus = this.mItemsCanFocus && this.hasFocus();
                        const maintainedFocus = focusedChild != null && focusedChild.hasFocus();
                        if (shouldPlaceFocus && !maintainedFocus && !sel.hasFocus()) {
                            if (sel.requestFocus()) {
                                sel.setSelected(false);
                                this.mSelectorRect.setEmpty();
                            }
                            else {
                                const focused = this.getFocusedChild();
                                if (focused != null) {
                                    focused.clearFocus();
                                }
                                this.positionSelector(ListView.INVALID_POSITION, sel);
                            }
                        }
                        else {
                            this.positionSelector(ListView.INVALID_POSITION, sel);
                        }
                        this.mSelectedTop = sel.getTop();
                    }
                    else {
                        if (this.mTouchMode == ListView.TOUCH_MODE_TAP || this.mTouchMode == ListView.TOUCH_MODE_DONE_WAITING) {
                            const child = this.getChildAt(this.mMotionPosition - this.mFirstPosition);
                            if (child != null) {
                                this.positionSelector(this.mMotionPosition, child);
                            }
                        }
                        else {
                            this.mSelectedTop = 0;
                            this.mSelectorRect.setEmpty();
                        }
                    }
                    if (accessFocusedChild != null) {
                        accessFocusedChild.setHasTransientState(false);
                    }
                    if (focusedChild != null) {
                        focusedChild.setHasTransientState(false);
                    }
                    this.mLayoutMode = ListView.LAYOUT_NORMAL;
                    this.mDataChanged = false;
                    if (this.mPositionScrollAfterLayout != null) {
                        this.post(this.mPositionScrollAfterLayout);
                        this.mPositionScrollAfterLayout = null;
                    }
                    this.mNeedSync = false;
                    this.setNextSelectedPositionInt(this.mSelectedPosition);
                    this.updateScrollIndicators();
                    if (this.mItemCount > 0) {
                        this.checkSelectionChanged();
                    }
                    this.invokeOnItemScrollListener();
                }
                finally {
                    if (!blockLayoutRequests) {
                        this.mBlockLayoutRequests = false;
                    }
                }
            }
            makeAndAddView(position, y, flow, childrenLeft, selected) {
                let child;
                if (!this.mDataChanged) {
                    child = this.mRecycler.getActiveView(position);
                    if (child != null) {
                        this.setupChild(child, position, y, flow, childrenLeft, selected, true);
                        return child;
                    }
                }
                child = this.obtainView(position, this.mIsScrap);
                this.setupChild(child, position, y, flow, childrenLeft, selected, this.mIsScrap[0]);
                return child;
            }
            setupChild(child, position, y, flowDown, childrenLeft, selected, recycled) {
                Trace.traceBegin(Trace.TRACE_TAG_VIEW, "setupListItem");
                const isSelected = selected && this.shouldShowSelector();
                const updateChildSelected = isSelected != child.isSelected();
                const mode = this.mTouchMode;
                const isPressed = mode > ListView.TOUCH_MODE_DOWN && mode < ListView.TOUCH_MODE_SCROLL && this.mMotionPosition == position;
                const updateChildPressed = isPressed != child.isPressed();
                const needToMeasure = !recycled || updateChildSelected || child.isLayoutRequested();
                let p = child.getLayoutParams();
                if (p == null) {
                    p = this.generateDefaultLayoutParams();
                }
                p.viewType = this.mAdapter.getItemViewType(position);
                if ((recycled && !p.forceAdd) || (p.recycledHeaderFooter && p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER)) {
                    this.attachViewToParent(child, flowDown ? -1 : 0, p);
                }
                else {
                    p.forceAdd = false;
                    if (p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER) {
                        p.recycledHeaderFooter = true;
                    }
                    this.addViewInLayout(child, flowDown ? -1 : 0, p, true);
                }
                if (updateChildSelected) {
                    child.setSelected(isSelected);
                }
                if (updateChildPressed) {
                    child.setPressed(isPressed);
                }
                if (this.mChoiceMode != ListView.CHOICE_MODE_NONE && this.mCheckStates != null) {
                    if (child['setChecked']) {
                        child.setChecked(this.mCheckStates.get(position));
                    }
                    else {
                        child.setActivated(this.mCheckStates.get(position));
                    }
                }
                if (needToMeasure) {
                    let childWidthSpec = ViewGroup.getChildMeasureSpec(this.mWidthMeasureSpec, this.mListPadding.left + this.mListPadding.right, p.width);
                    let lpHeight = p.height;
                    let childHeightSpec;
                    if (lpHeight > 0) {
                        childHeightSpec = ListView.MeasureSpec.makeMeasureSpec(lpHeight, ListView.MeasureSpec.EXACTLY);
                    }
                    else {
                        childHeightSpec = ListView.MeasureSpec.makeMeasureSpec(0, ListView.MeasureSpec.UNSPECIFIED);
                    }
                    child.measure(childWidthSpec, childHeightSpec);
                }
                else {
                    this.cleanupLayoutState(child);
                }
                const w = child.getMeasuredWidth();
                const h = child.getMeasuredHeight();
                const childTop = flowDown ? y : y - h;
                if (needToMeasure) {
                    const childRight = childrenLeft + w;
                    const childBottom = childTop + h;
                    child.layout(childrenLeft, childTop, childRight, childBottom);
                }
                else {
                    child.offsetLeftAndRight(childrenLeft - child.getLeft());
                    child.offsetTopAndBottom(childTop - child.getTop());
                }
                if (this.mCachingStarted && !child.isDrawingCacheEnabled()) {
                    child.setDrawingCacheEnabled(true);
                }
                if (recycled && (child.getLayoutParams().scrappedFromPosition) != position) {
                    child.jumpDrawablesToCurrentState();
                }
                Trace.traceEnd(Trace.TRACE_TAG_VIEW);
            }
            canAnimate() {
                return super.canAnimate() && this.mItemCount > 0;
            }
            setSelection(position) {
                this.setSelectionFromTop(position, 0);
            }
            setSelectionFromTop(position, y) {
                if (this.mAdapter == null) {
                    return;
                }
                if (!this.isInTouchMode()) {
                    position = this.lookForSelectablePosition(position, true);
                    if (position >= 0) {
                        this.setNextSelectedPositionInt(position);
                    }
                }
                else {
                    this.mResurrectToPosition = position;
                }
                if (position >= 0) {
                    this.mLayoutMode = ListView.LAYOUT_SPECIFIC;
                    this.mSpecificTop = this.mListPadding.top + y;
                    if (this.mNeedSync) {
                        this.mSyncPosition = position;
                        this.mSyncRowId = this.mAdapter.getItemId(position);
                    }
                    if (this.mPositionScroller != null) {
                        this.mPositionScroller.stop();
                    }
                    this.requestLayout();
                }
            }
            setSelectionInt(position) {
                this.setNextSelectedPositionInt(position);
                let awakeScrollbars = false;
                const selectedPosition = this.mSelectedPosition;
                if (selectedPosition >= 0) {
                    if (position == selectedPosition - 1) {
                        awakeScrollbars = true;
                    }
                    else if (position == selectedPosition + 1) {
                        awakeScrollbars = true;
                    }
                }
                if (this.mPositionScroller != null) {
                    this.mPositionScroller.stop();
                }
                this.layoutChildren();
                if (awakeScrollbars) {
                    this.awakenScrollBars();
                }
            }
            lookForSelectablePosition(position, lookDown) {
                const adapter = this.mAdapter;
                if (adapter == null || this.isInTouchMode()) {
                    return ListView.INVALID_POSITION;
                }
                const count = adapter.getCount();
                if (!this.mAreAllItemsSelectable) {
                    if (lookDown) {
                        position = Math.max(0, position);
                        while (position < count && !adapter.isEnabled(position)) {
                            position++;
                        }
                    }
                    else {
                        position = Math.min(position, count - 1);
                        while (position >= 0 && !adapter.isEnabled(position)) {
                            position--;
                        }
                    }
                }
                if (position < 0 || position >= count) {
                    return ListView.INVALID_POSITION;
                }
                return position;
            }
            lookForSelectablePositionAfter(current, position, lookDown) {
                const adapter = this.mAdapter;
                if (adapter == null || this.isInTouchMode()) {
                    return ListView.INVALID_POSITION;
                }
                const after = this.lookForSelectablePosition(position, lookDown);
                if (after != ListView.INVALID_POSITION) {
                    return after;
                }
                const count = adapter.getCount();
                current = MathUtils.constrain(current, -1, count - 1);
                if (lookDown) {
                    position = Math.min(position - 1, count - 1);
                    while ((position > current) && !adapter.isEnabled(position)) {
                        position--;
                    }
                    if (position <= current) {
                        return ListView.INVALID_POSITION;
                    }
                }
                else {
                    position = Math.max(0, position + 1);
                    while ((position < current) && !adapter.isEnabled(position)) {
                        position++;
                    }
                    if (position >= current) {
                        return ListView.INVALID_POSITION;
                    }
                }
                return position;
            }
            setSelectionAfterHeaderView() {
                const count = this.mHeaderViewInfos.size();
                if (count > 0) {
                    this.mNextSelectedPosition = 0;
                    return;
                }
                if (this.mAdapter != null) {
                    this.setSelection(count);
                }
                else {
                    this.mNextSelectedPosition = count;
                    this.mLayoutMode = ListView.LAYOUT_SET_SELECTION;
                }
            }
            dispatchKeyEvent(event) {
                let handled = super.dispatchKeyEvent(event);
                if (!handled) {
                    let focused = this.getFocusedChild();
                    if (focused != null && event.getAction() == KeyEvent.ACTION_DOWN) {
                        handled = this.onKeyDown(event.getKeyCode(), event);
                    }
                }
                return handled;
            }
            onKeyDown(keyCode, event) {
                return this.commonKey(keyCode, 1, event);
            }
            onKeyMultiple(keyCode, repeatCount, event) {
                return this.commonKey(keyCode, repeatCount, event);
            }
            onKeyUp(keyCode, event) {
                return this.commonKey(keyCode, 1, event);
            }
            commonKey(keyCode, count, event) {
                if (this.mAdapter == null || !this.isAttachedToWindow()) {
                    return false;
                }
                if (this.mDataChanged) {
                    this.layoutChildren();
                }
                let handled = false;
                let action = event.getAction();
                if (action != KeyEvent.ACTION_UP) {
                    switch (keyCode) {
                        case KeyEvent.KEYCODE_DPAD_UP:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded();
                                if (!handled) {
                                    while (count-- > 0) {
                                        if (this.arrowScroll(ListView.FOCUS_UP)) {
                                            handled = true;
                                        }
                                        else {
                                            break;
                                        }
                                    }
                                }
                            }
                            else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
                                handled = this.resurrectSelectionIfNeeded() || this.fullScroll(ListView.FOCUS_UP);
                            }
                            break;
                        case KeyEvent.KEYCODE_DPAD_DOWN:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded();
                                if (!handled) {
                                    while (count-- > 0) {
                                        if (this.arrowScroll(ListView.FOCUS_DOWN)) {
                                            handled = true;
                                        }
                                        else {
                                            break;
                                        }
                                    }
                                }
                            }
                            else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
                                handled = this.resurrectSelectionIfNeeded() || this.fullScroll(ListView.FOCUS_DOWN);
                            }
                            break;
                        case KeyEvent.KEYCODE_DPAD_LEFT:
                            if (event.hasNoModifiers()) {
                                handled = this.handleHorizontalFocusWithinListItem(View.FOCUS_LEFT);
                            }
                            break;
                        case KeyEvent.KEYCODE_DPAD_RIGHT:
                            if (event.hasNoModifiers()) {
                                handled = this.handleHorizontalFocusWithinListItem(View.FOCUS_RIGHT);
                            }
                            break;
                        case KeyEvent.KEYCODE_DPAD_CENTER:
                        case KeyEvent.KEYCODE_ENTER:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded();
                                if (!handled && event.getRepeatCount() == 0 && this.getChildCount() > 0) {
                                    this.keyPressed();
                                    handled = true;
                                }
                            }
                            break;
                        case KeyEvent.KEYCODE_SPACE:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded() || this.pageScroll(ListView.FOCUS_DOWN);
                            }
                            else if (event.hasModifiers(KeyEvent.META_SHIFT_ON)) {
                                handled = this.resurrectSelectionIfNeeded() || this.pageScroll(ListView.FOCUS_UP);
                            }
                            handled = true;
                            break;
                        case KeyEvent.KEYCODE_PAGE_UP:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded() || this.pageScroll(ListView.FOCUS_UP);
                            }
                            else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
                                handled = this.resurrectSelectionIfNeeded() || this.fullScroll(ListView.FOCUS_UP);
                            }
                            break;
                        case KeyEvent.KEYCODE_PAGE_DOWN:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded() || this.pageScroll(ListView.FOCUS_DOWN);
                            }
                            else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
                                handled = this.resurrectSelectionIfNeeded() || this.fullScroll(ListView.FOCUS_DOWN);
                            }
                            break;
                        case KeyEvent.KEYCODE_MOVE_HOME:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded() || this.fullScroll(ListView.FOCUS_UP);
                            }
                            break;
                        case KeyEvent.KEYCODE_MOVE_END:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded() || this.fullScroll(ListView.FOCUS_DOWN);
                            }
                            break;
                        case KeyEvent.KEYCODE_TAB:
                            if (false) {
                                if (event.hasNoModifiers()) {
                                    handled = this.resurrectSelectionIfNeeded() || this.arrowScroll(ListView.FOCUS_DOWN);
                                }
                                else if (event.hasModifiers(KeyEvent.META_SHIFT_ON)) {
                                    handled = this.resurrectSelectionIfNeeded() || this.arrowScroll(ListView.FOCUS_UP);
                                }
                            }
                            break;
                    }
                }
                if (handled) {
                    return true;
                }
                switch (action) {
                    case KeyEvent.ACTION_DOWN:
                        return super.onKeyDown(keyCode, event);
                    case KeyEvent.ACTION_UP:
                        return super.onKeyUp(keyCode, event);
                    default:
                        return false;
                }
            }
            pageScroll(direction) {
                let nextPage;
                let down;
                if (direction == ListView.FOCUS_UP) {
                    nextPage = Math.max(0, this.mSelectedPosition - this.getChildCount() - 1);
                    down = false;
                }
                else if (direction == ListView.FOCUS_DOWN) {
                    nextPage = Math.min(this.mItemCount - 1, this.mSelectedPosition + this.getChildCount() - 1);
                    down = true;
                }
                else {
                    return false;
                }
                if (nextPage >= 0) {
                    const position = this.lookForSelectablePositionAfter(this.mSelectedPosition, nextPage, down);
                    if (position >= 0) {
                        this.mLayoutMode = ListView.LAYOUT_SPECIFIC;
                        this.mSpecificTop = this.mPaddingTop + this.getVerticalFadingEdgeLength();
                        if (down && (position > (this.mItemCount - this.getChildCount()))) {
                            this.mLayoutMode = ListView.LAYOUT_FORCE_BOTTOM;
                        }
                        if (!down && (position < this.getChildCount())) {
                            this.mLayoutMode = ListView.LAYOUT_FORCE_TOP;
                        }
                        this.setSelectionInt(position);
                        this.invokeOnItemScrollListener();
                        if (!this.awakenScrollBars()) {
                            this.invalidate();
                        }
                        return true;
                    }
                }
                return false;
            }
            fullScroll(direction) {
                let moved = false;
                if (direction == ListView.FOCUS_UP) {
                    if (this.mSelectedPosition != 0) {
                        const position = this.lookForSelectablePositionAfter(this.mSelectedPosition, 0, true);
                        if (position >= 0) {
                            this.mLayoutMode = ListView.LAYOUT_FORCE_TOP;
                            this.setSelectionInt(position);
                            this.invokeOnItemScrollListener();
                        }
                        moved = true;
                    }
                }
                else if (direction == ListView.FOCUS_DOWN) {
                    const lastItem = (this.mItemCount - 1);
                    if (this.mSelectedPosition < lastItem) {
                        const position = this.lookForSelectablePositionAfter(this.mSelectedPosition, lastItem, false);
                        if (position >= 0) {
                            this.mLayoutMode = ListView.LAYOUT_FORCE_BOTTOM;
                            this.setSelectionInt(position);
                            this.invokeOnItemScrollListener();
                        }
                        moved = true;
                    }
                }
                if (moved && !this.awakenScrollBars()) {
                    this.awakenScrollBars();
                    this.invalidate();
                }
                return moved;
            }
            handleHorizontalFocusWithinListItem(direction) {
                if (direction != View.FOCUS_LEFT && direction != View.FOCUS_RIGHT) {
                    throw Error(`new IllegalArgumentException("direction must be one of" + " {View.FOCUS_LEFT, View.FOCUS_RIGHT}")`);
                }
                const numChildren = this.getChildCount();
                if (this.mItemsCanFocus && numChildren > 0 && this.mSelectedPosition != ListView.INVALID_POSITION) {
                    const selectedView = this.getSelectedView();
                    if (selectedView != null && selectedView.hasFocus() && selectedView instanceof ViewGroup) {
                        const currentFocus = selectedView.findFocus();
                        const nextFocus = FocusFinder.getInstance().findNextFocus(selectedView, currentFocus, direction);
                        if (nextFocus != null) {
                            currentFocus.getFocusedRect(this.mTempRect);
                            this.offsetDescendantRectToMyCoords(currentFocus, this.mTempRect);
                            this.offsetRectIntoDescendantCoords(nextFocus, this.mTempRect);
                            if (nextFocus.requestFocus(direction, this.mTempRect)) {
                                return true;
                            }
                        }
                        const globalNextFocus = FocusFinder.getInstance().findNextFocus(this.getRootView(), currentFocus, direction);
                        if (globalNextFocus != null) {
                            return this.isViewAncestorOf(globalNextFocus, this);
                        }
                    }
                }
                return false;
            }
            arrowScroll(direction) {
                try {
                    this.mInLayout = true;
                    const handled = this.arrowScrollImpl(direction);
                    if (handled) {
                        this.playSoundEffect(SoundEffectConstants.getContantForFocusDirection(direction));
                    }
                    return handled;
                }
                finally {
                    this.mInLayout = false;
                }
            }
            nextSelectedPositionForDirection(selectedView, selectedPos, direction) {
                let nextSelected;
                if (direction == View.FOCUS_DOWN) {
                    const listBottom = this.getHeight() - this.mListPadding.bottom;
                    if (selectedView != null && selectedView.getBottom() <= listBottom) {
                        nextSelected = selectedPos != ListView.INVALID_POSITION && selectedPos >= this.mFirstPosition ? selectedPos + 1 : this.mFirstPosition;
                    }
                    else {
                        return ListView.INVALID_POSITION;
                    }
                }
                else {
                    const listTop = this.mListPadding.top;
                    if (selectedView != null && selectedView.getTop() >= listTop) {
                        const lastPos = this.mFirstPosition + this.getChildCount() - 1;
                        nextSelected = selectedPos != ListView.INVALID_POSITION && selectedPos <= lastPos ? selectedPos - 1 : lastPos;
                    }
                    else {
                        return ListView.INVALID_POSITION;
                    }
                }
                if (nextSelected < 0 || nextSelected >= this.mAdapter.getCount()) {
                    return ListView.INVALID_POSITION;
                }
                return this.lookForSelectablePosition(nextSelected, direction == View.FOCUS_DOWN);
            }
            arrowScrollImpl(direction) {
                if (this.getChildCount() <= 0) {
                    return false;
                }
                let selectedView = this.getSelectedView();
                let selectedPos = this.mSelectedPosition;
                let nextSelectedPosition = this.nextSelectedPositionForDirection(selectedView, selectedPos, direction);
                let amountToScroll = this.amountToScroll(direction, nextSelectedPosition);
                const focusResult = this.mItemsCanFocus ? this.arrowScrollFocused(direction) : null;
                if (focusResult != null) {
                    nextSelectedPosition = focusResult.getSelectedPosition();
                    amountToScroll = focusResult.getAmountToScroll();
                }
                let needToRedraw = focusResult != null;
                if (nextSelectedPosition != ListView.INVALID_POSITION) {
                    this.handleNewSelectionChange(selectedView, direction, nextSelectedPosition, focusResult != null);
                    this.setSelectedPositionInt(nextSelectedPosition);
                    this.setNextSelectedPositionInt(nextSelectedPosition);
                    selectedView = this.getSelectedView();
                    selectedPos = nextSelectedPosition;
                    if (this.mItemsCanFocus && focusResult == null) {
                        const focused = this.getFocusedChild();
                        if (focused != null) {
                            focused.clearFocus();
                        }
                    }
                    needToRedraw = true;
                    this.checkSelectionChanged();
                }
                if (amountToScroll > 0) {
                    this.scrollListItemsBy((direction == View.FOCUS_UP) ? amountToScroll : -amountToScroll);
                    needToRedraw = true;
                }
                if (this.mItemsCanFocus && (focusResult == null) && selectedView != null && selectedView.hasFocus()) {
                    const focused = selectedView.findFocus();
                    if (!this.isViewAncestorOf(focused, this) || this.distanceToView(focused) > 0) {
                        focused.clearFocus();
                    }
                }
                if (nextSelectedPosition == ListView.INVALID_POSITION && selectedView != null && !this.isViewAncestorOf(selectedView, this)) {
                    selectedView = null;
                    this.hideSelector();
                    this.mResurrectToPosition = ListView.INVALID_POSITION;
                }
                if (needToRedraw) {
                    if (selectedView != null) {
                        this.positionSelector(selectedPos, selectedView);
                        this.mSelectedTop = selectedView.getTop();
                    }
                    if (!this.awakenScrollBars()) {
                        this.invalidate();
                    }
                    this.invokeOnItemScrollListener();
                    return true;
                }
                return false;
            }
            handleNewSelectionChange(selectedView, direction, newSelectedPosition, newFocusAssigned) {
                if (newSelectedPosition == ListView.INVALID_POSITION) {
                    throw Error(`new IllegalArgumentException("newSelectedPosition needs to be valid")`);
                }
                let topView;
                let bottomView;
                let topViewIndex, bottomViewIndex;
                let topSelected = false;
                const selectedIndex = this.mSelectedPosition - this.mFirstPosition;
                const nextSelectedIndex = newSelectedPosition - this.mFirstPosition;
                if (direction == View.FOCUS_UP) {
                    topViewIndex = nextSelectedIndex;
                    bottomViewIndex = selectedIndex;
                    topView = this.getChildAt(topViewIndex);
                    bottomView = selectedView;
                    topSelected = true;
                }
                else {
                    topViewIndex = selectedIndex;
                    bottomViewIndex = nextSelectedIndex;
                    topView = selectedView;
                    bottomView = this.getChildAt(bottomViewIndex);
                }
                const numChildren = this.getChildCount();
                if (topView != null) {
                    topView.setSelected(!newFocusAssigned && topSelected);
                    this.measureAndAdjustDown(topView, topViewIndex, numChildren);
                }
                if (bottomView != null) {
                    bottomView.setSelected(!newFocusAssigned && !topSelected);
                    this.measureAndAdjustDown(bottomView, bottomViewIndex, numChildren);
                }
            }
            measureAndAdjustDown(child, childIndex, numChildren) {
                let oldHeight = child.getHeight();
                this.measureItem(child);
                if (child.getMeasuredHeight() != oldHeight) {
                    this.relayoutMeasuredItem(child);
                    const heightDelta = child.getMeasuredHeight() - oldHeight;
                    for (let i = childIndex + 1; i < numChildren; i++) {
                        this.getChildAt(i).offsetTopAndBottom(heightDelta);
                    }
                }
            }
            measureItem(child) {
                let p = child.getLayoutParams();
                if (p == null) {
                    p = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT);
                }
                let childWidthSpec = ViewGroup.getChildMeasureSpec(this.mWidthMeasureSpec, this.mListPadding.left + this.mListPadding.right, p.width);
                let lpHeight = p.height;
                let childHeightSpec;
                if (lpHeight > 0) {
                    childHeightSpec = ListView.MeasureSpec.makeMeasureSpec(lpHeight, ListView.MeasureSpec.EXACTLY);
                }
                else {
                    childHeightSpec = ListView.MeasureSpec.makeMeasureSpec(0, ListView.MeasureSpec.UNSPECIFIED);
                }
                child.measure(childWidthSpec, childHeightSpec);
            }
            relayoutMeasuredItem(child) {
                const w = child.getMeasuredWidth();
                const h = child.getMeasuredHeight();
                const childLeft = this.mListPadding.left;
                const childRight = childLeft + w;
                const childTop = child.getTop();
                const childBottom = childTop + h;
                child.layout(childLeft, childTop, childRight, childBottom);
            }
            getArrowScrollPreviewLength() {
                return Math.max(ListView.MIN_SCROLL_PREVIEW_PIXELS, this.getVerticalFadingEdgeLength());
            }
            amountToScroll(direction, nextSelectedPosition) {
                const listBottom = this.getHeight() - this.mListPadding.bottom;
                const listTop = this.mListPadding.top;
                let numChildren = this.getChildCount();
                if (direction == View.FOCUS_DOWN) {
                    let indexToMakeVisible = numChildren - 1;
                    if (nextSelectedPosition != ListView.INVALID_POSITION) {
                        indexToMakeVisible = nextSelectedPosition - this.mFirstPosition;
                    }
                    while (numChildren <= indexToMakeVisible) {
                        this.addViewBelow(this.getChildAt(numChildren - 1), this.mFirstPosition + numChildren - 1);
                        numChildren++;
                    }
                    const positionToMakeVisible = this.mFirstPosition + indexToMakeVisible;
                    const viewToMakeVisible = this.getChildAt(indexToMakeVisible);
                    let goalBottom = listBottom;
                    if (positionToMakeVisible < this.mItemCount - 1) {
                        goalBottom -= this.getArrowScrollPreviewLength();
                    }
                    if (viewToMakeVisible.getBottom() <= goalBottom) {
                        return 0;
                    }
                    if (nextSelectedPosition != ListView.INVALID_POSITION && (goalBottom - viewToMakeVisible.getTop()) >= this.getMaxScrollAmount()) {
                        return 0;
                    }
                    let amountToScroll = (viewToMakeVisible.getBottom() - goalBottom);
                    if ((this.mFirstPosition + numChildren) == this.mItemCount) {
                        const max = this.getChildAt(numChildren - 1).getBottom() - listBottom;
                        amountToScroll = Math.min(amountToScroll, max);
                    }
                    return Math.min(amountToScroll, this.getMaxScrollAmount());
                }
                else {
                    let indexToMakeVisible = 0;
                    if (nextSelectedPosition != ListView.INVALID_POSITION) {
                        indexToMakeVisible = nextSelectedPosition - this.mFirstPosition;
                    }
                    while (indexToMakeVisible < 0) {
                        this.addViewAbove(this.getChildAt(0), this.mFirstPosition);
                        this.mFirstPosition--;
                        indexToMakeVisible = nextSelectedPosition - this.mFirstPosition;
                    }
                    const positionToMakeVisible = this.mFirstPosition + indexToMakeVisible;
                    const viewToMakeVisible = this.getChildAt(indexToMakeVisible);
                    let goalTop = listTop;
                    if (positionToMakeVisible > 0) {
                        goalTop += this.getArrowScrollPreviewLength();
                    }
                    if (viewToMakeVisible.getTop() >= goalTop) {
                        return 0;
                    }
                    if (nextSelectedPosition != ListView.INVALID_POSITION && (viewToMakeVisible.getBottom() - goalTop) >= this.getMaxScrollAmount()) {
                        return 0;
                    }
                    let amountToScroll = (goalTop - viewToMakeVisible.getTop());
                    if (this.mFirstPosition == 0) {
                        const max = listTop - this.getChildAt(0).getTop();
                        amountToScroll = Math.min(amountToScroll, max);
                    }
                    return Math.min(amountToScroll, this.getMaxScrollAmount());
                }
            }
            lookForSelectablePositionOnScreen(direction) {
                const firstPosition = this.mFirstPosition;
                if (direction == View.FOCUS_DOWN) {
                    let startPos = (this.mSelectedPosition != ListView.INVALID_POSITION) ? this.mSelectedPosition + 1 : firstPosition;
                    if (startPos >= this.mAdapter.getCount()) {
                        return ListView.INVALID_POSITION;
                    }
                    if (startPos < firstPosition) {
                        startPos = firstPosition;
                    }
                    const lastVisiblePos = this.getLastVisiblePosition();
                    const adapter = this.getAdapter();
                    for (let pos = startPos; pos <= lastVisiblePos; pos++) {
                        if (adapter.isEnabled(pos) && this.getChildAt(pos - firstPosition).getVisibility() == View.VISIBLE) {
                            return pos;
                        }
                    }
                }
                else {
                    let last = firstPosition + this.getChildCount() - 1;
                    let startPos = (this.mSelectedPosition != ListView.INVALID_POSITION) ? this.mSelectedPosition - 1 : firstPosition + this.getChildCount() - 1;
                    if (startPos < 0 || startPos >= this.mAdapter.getCount()) {
                        return ListView.INVALID_POSITION;
                    }
                    if (startPos > last) {
                        startPos = last;
                    }
                    const adapter = this.getAdapter();
                    for (let pos = startPos; pos >= firstPosition; pos--) {
                        if (adapter.isEnabled(pos) && this.getChildAt(pos - firstPosition).getVisibility() == View.VISIBLE) {
                            return pos;
                        }
                    }
                }
                return ListView.INVALID_POSITION;
            }
            arrowScrollFocused(direction) {
                const selectedView = this.getSelectedView();
                let newFocus;
                if (selectedView != null && selectedView.hasFocus()) {
                    let oldFocus = selectedView.findFocus();
                    newFocus = FocusFinder.getInstance().findNextFocus(this, oldFocus, direction);
                }
                else {
                    if (direction == View.FOCUS_DOWN) {
                        const topFadingEdgeShowing = (this.mFirstPosition > 0);
                        const listTop = this.mListPadding.top + (topFadingEdgeShowing ? this.getArrowScrollPreviewLength() : 0);
                        const ySearchPoint = (selectedView != null && selectedView.getTop() > listTop) ? selectedView.getTop() : listTop;
                        this.mTempRect.set(0, ySearchPoint, 0, ySearchPoint);
                    }
                    else {
                        const bottomFadingEdgeShowing = (this.mFirstPosition + this.getChildCount() - 1) < this.mItemCount;
                        const listBottom = this.getHeight() - this.mListPadding.bottom - (bottomFadingEdgeShowing ? this.getArrowScrollPreviewLength() : 0);
                        const ySearchPoint = (selectedView != null && selectedView.getBottom() < listBottom) ? selectedView.getBottom() : listBottom;
                        this.mTempRect.set(0, ySearchPoint, 0, ySearchPoint);
                    }
                    newFocus = FocusFinder.getInstance().findNextFocusFromRect(this, this.mTempRect, direction);
                }
                if (newFocus != null) {
                    const positionOfNewFocus = this.positionOfNewFocus(newFocus);
                    if (this.mSelectedPosition != ListView.INVALID_POSITION && positionOfNewFocus != this.mSelectedPosition) {
                        const selectablePosition = this.lookForSelectablePositionOnScreen(direction);
                        if (selectablePosition != ListView.INVALID_POSITION && ((direction == View.FOCUS_DOWN && selectablePosition < positionOfNewFocus) || (direction == View.FOCUS_UP && selectablePosition > positionOfNewFocus))) {
                            return null;
                        }
                    }
                    let focusScroll = this.amountToScrollToNewFocus(direction, newFocus, positionOfNewFocus);
                    const maxScrollAmount = this.getMaxScrollAmount();
                    if (focusScroll < maxScrollAmount) {
                        newFocus.requestFocus(direction);
                        this.mArrowScrollFocusResult.populate(positionOfNewFocus, focusScroll);
                        return this.mArrowScrollFocusResult;
                    }
                    else if (this.distanceToView(newFocus) < maxScrollAmount) {
                        newFocus.requestFocus(direction);
                        this.mArrowScrollFocusResult.populate(positionOfNewFocus, maxScrollAmount);
                        return this.mArrowScrollFocusResult;
                    }
                }
                return null;
            }
            positionOfNewFocus(newFocus) {
                const numChildren = this.getChildCount();
                for (let i = 0; i < numChildren; i++) {
                    const child = this.getChildAt(i);
                    if (this.isViewAncestorOf(newFocus, child)) {
                        return this.mFirstPosition + i;
                    }
                }
                throw Error(`new IllegalArgumentException("newFocus is not a child of any of the" + " children of the list!")`);
            }
            isViewAncestorOf(child, parent) {
                if (child == parent) {
                    return true;
                }
                const theParent = child.getParent();
                return (theParent instanceof ViewGroup) && this.isViewAncestorOf(theParent, parent);
            }
            amountToScrollToNewFocus(direction, newFocus, positionOfNewFocus) {
                let amountToScroll = 0;
                newFocus.getDrawingRect(this.mTempRect);
                this.offsetDescendantRectToMyCoords(newFocus, this.mTempRect);
                if (direction == View.FOCUS_UP) {
                    if (this.mTempRect.top < this.mListPadding.top) {
                        amountToScroll = this.mListPadding.top - this.mTempRect.top;
                        if (positionOfNewFocus > 0) {
                            amountToScroll += this.getArrowScrollPreviewLength();
                        }
                    }
                }
                else {
                    const listBottom = this.getHeight() - this.mListPadding.bottom;
                    if (this.mTempRect.bottom > listBottom) {
                        amountToScroll = this.mTempRect.bottom - listBottom;
                        if (positionOfNewFocus < this.mItemCount - 1) {
                            amountToScroll += this.getArrowScrollPreviewLength();
                        }
                    }
                }
                return amountToScroll;
            }
            distanceToView(descendant) {
                let distance = 0;
                descendant.getDrawingRect(this.mTempRect);
                this.offsetDescendantRectToMyCoords(descendant, this.mTempRect);
                const listBottom = this.mBottom - this.mTop - this.mListPadding.bottom;
                if (this.mTempRect.bottom < this.mListPadding.top) {
                    distance = this.mListPadding.top - this.mTempRect.bottom;
                }
                else if (this.mTempRect.top > listBottom) {
                    distance = this.mTempRect.top - listBottom;
                }
                return distance;
            }
            scrollListItemsBy(amount) {
                this.offsetChildrenTopAndBottom(amount);
                const listBottom = this.getHeight() - this.mListPadding.bottom;
                const listTop = this.mListPadding.top;
                const recycleBin = this.mRecycler;
                if (amount < 0) {
                    let numChildren = this.getChildCount();
                    let last = this.getChildAt(numChildren - 1);
                    while (last.getBottom() < listBottom) {
                        const lastVisiblePosition = this.mFirstPosition + numChildren - 1;
                        if (lastVisiblePosition < this.mItemCount - 1) {
                            last = this.addViewBelow(last, lastVisiblePosition);
                            numChildren++;
                        }
                        else {
                            break;
                        }
                    }
                    if (last.getBottom() < listBottom) {
                        this.offsetChildrenTopAndBottom(listBottom - last.getBottom());
                    }
                    let first = this.getChildAt(0);
                    while (first.getBottom() < listTop) {
                        let layoutParams = first.getLayoutParams();
                        if (recycleBin.shouldRecycleViewType(layoutParams.viewType)) {
                            recycleBin.addScrapView(first, this.mFirstPosition);
                        }
                        this.detachViewFromParent(first);
                        first = this.getChildAt(0);
                        this.mFirstPosition++;
                    }
                }
                else {
                    let first = this.getChildAt(0);
                    while ((first.getTop() > listTop) && (this.mFirstPosition > 0)) {
                        first = this.addViewAbove(first, this.mFirstPosition);
                        this.mFirstPosition--;
                    }
                    if (first.getTop() > listTop) {
                        this.offsetChildrenTopAndBottom(listTop - first.getTop());
                    }
                    let lastIndex = this.getChildCount() - 1;
                    let last = this.getChildAt(lastIndex);
                    while (last.getTop() > listBottom) {
                        let layoutParams = last.getLayoutParams();
                        if (recycleBin.shouldRecycleViewType(layoutParams.viewType)) {
                            recycleBin.addScrapView(last, this.mFirstPosition + lastIndex);
                        }
                        this.detachViewFromParent(last);
                        last = this.getChildAt(--lastIndex);
                    }
                }
            }
            addViewAbove(theView, position) {
                let abovePosition = position - 1;
                let view = this.obtainView(abovePosition, this.mIsScrap);
                let edgeOfNewChild = theView.getTop() - this.mDividerHeight;
                this.setupChild(view, abovePosition, edgeOfNewChild, false, this.mListPadding.left, false, this.mIsScrap[0]);
                return view;
            }
            addViewBelow(theView, position) {
                let belowPosition = position + 1;
                let view = this.obtainView(belowPosition, this.mIsScrap);
                let edgeOfNewChild = theView.getBottom() + this.mDividerHeight;
                this.setupChild(view, belowPosition, edgeOfNewChild, true, this.mListPadding.left, false, this.mIsScrap[0]);
                return view;
            }
            setItemsCanFocus(itemsCanFocus) {
                this.mItemsCanFocus = itemsCanFocus;
                if (!itemsCanFocus) {
                    this.setDescendantFocusability(ViewGroup.FOCUS_BLOCK_DESCENDANTS);
                }
            }
            getItemsCanFocus() {
                return this.mItemsCanFocus;
            }
            isOpaque() {
                let retValue = (this.mCachingActive && this.mIsCacheColorOpaque && this.mDividerIsOpaque && this.hasOpaqueScrollbars()) || super.isOpaque();
                if (retValue) {
                    const listTop = this.mListPadding != null ? this.mListPadding.top : this.mPaddingTop;
                    let first = this.getChildAt(0);
                    if (first == null || first.getTop() > listTop) {
                        return false;
                    }
                    const listBottom = this.getHeight() - (this.mListPadding != null ? this.mListPadding.bottom : this.mPaddingBottom);
                    let last = this.getChildAt(this.getChildCount() - 1);
                    if (last == null || last.getBottom() < listBottom) {
                        return false;
                    }
                }
                return retValue;
            }
            setCacheColorHint(color) {
                const opaque = (color >>> 24) == 0xFF;
                this.mIsCacheColorOpaque = opaque;
                if (opaque) {
                    if (this.mDividerPaint == null) {
                        this.mDividerPaint = new Paint();
                    }
                    this.mDividerPaint.setColor(color);
                }
                super.setCacheColorHint(color);
            }
            drawOverscrollHeader(canvas, drawable, bounds) {
                const height = drawable.getMinimumHeight();
                canvas.save();
                canvas.clipRect(bounds);
                const span = bounds.bottom - bounds.top;
                if (span < height) {
                    bounds.top = bounds.bottom - height;
                }
                drawable.setBounds(bounds);
                drawable.draw(canvas);
                canvas.restore();
            }
            drawOverscrollFooter(canvas, drawable, bounds) {
                const height = drawable.getMinimumHeight();
                canvas.save();
                canvas.clipRect(bounds);
                const span = bounds.bottom - bounds.top;
                if (span < height) {
                    bounds.bottom = bounds.top + height;
                }
                drawable.setBounds(bounds);
                drawable.draw(canvas);
                canvas.restore();
            }
            dispatchDraw(canvas) {
                if (this.mCachingStarted) {
                    this.mCachingActive = true;
                }
                const dividerHeight = this.mDividerHeight;
                const overscrollHeader = this.mOverScrollHeader;
                const overscrollFooter = this.mOverScrollFooter;
                const drawOverscrollHeader = overscrollHeader != null;
                const drawOverscrollFooter = overscrollFooter != null;
                const drawDividers = dividerHeight > 0 && this.mDivider != null;
                if (drawDividers || drawOverscrollHeader || drawOverscrollFooter) {
                    const bounds = this.mTempRect;
                    bounds.left = this.mPaddingLeft;
                    bounds.right = this.mRight - this.mLeft - this.mPaddingRight;
                    const count = this.getChildCount();
                    const headerCount = this.mHeaderViewInfos.size();
                    const itemCount = this.mItemCount;
                    const footerLimit = (itemCount - this.mFooterViewInfos.size());
                    const headerDividers = this.mHeaderDividersEnabled;
                    const footerDividers = this.mFooterDividersEnabled;
                    const first = this.mFirstPosition;
                    const areAllItemsSelectable = this.mAreAllItemsSelectable;
                    const adapter = this.mAdapter;
                    const fillForMissingDividers = this.isOpaque() && !super.isOpaque();
                    if (fillForMissingDividers && this.mDividerPaint == null && this.mIsCacheColorOpaque) {
                        this.mDividerPaint = new Paint();
                        this.mDividerPaint.setColor(this.getCacheColorHint());
                    }
                    const paint = this.mDividerPaint;
                    let effectivePaddingTop = 0;
                    let effectivePaddingBottom = 0;
                    if ((this.mGroupFlags & ListView.CLIP_TO_PADDING_MASK) == ListView.CLIP_TO_PADDING_MASK) {
                        effectivePaddingTop = this.mListPadding.top;
                        effectivePaddingBottom = this.mListPadding.bottom;
                    }
                    const listBottom = this.mBottom - this.mTop - effectivePaddingBottom + this.mScrollY;
                    if (!this.mStackFromBottom) {
                        let bottom = 0;
                        const scrollY = this.mScrollY;
                        if (count > 0 && scrollY < 0) {
                            if (drawOverscrollHeader) {
                                bounds.bottom = 0;
                                bounds.top = scrollY;
                                this.drawOverscrollHeader(canvas, overscrollHeader, bounds);
                            }
                            else if (drawDividers) {
                                bounds.bottom = 0;
                                bounds.top = -dividerHeight;
                                this.drawDivider(canvas, bounds, -1);
                            }
                        }
                        for (let i = 0; i < count; i++) {
                            const itemIndex = (first + i);
                            const isHeader = (itemIndex < headerCount);
                            const isFooter = (itemIndex >= footerLimit);
                            if ((headerDividers || !isHeader) && (footerDividers || !isFooter)) {
                                const child = this.getChildAt(i);
                                bottom = child.getBottom();
                                const isLastItem = (i == (count - 1));
                                if (drawDividers && (bottom < listBottom) && !(drawOverscrollFooter && isLastItem)) {
                                    const nextIndex = (itemIndex + 1);
                                    if (areAllItemsSelectable || ((adapter.isEnabled(itemIndex) || (headerDividers && isHeader) || (footerDividers && isFooter)) && (isLastItem || adapter.isEnabled(nextIndex) || (headerDividers && (nextIndex < headerCount)) || (footerDividers && (nextIndex >= footerLimit))))) {
                                        bounds.top = bottom;
                                        bounds.bottom = bottom + dividerHeight;
                                        this.drawDivider(canvas, bounds, i);
                                    }
                                    else if (fillForMissingDividers) {
                                        bounds.top = bottom;
                                        bounds.bottom = bottom + dividerHeight;
                                        canvas.drawRect(bounds, paint);
                                    }
                                }
                            }
                        }
                        const overFooterBottom = this.mBottom + this.mScrollY;
                        if (drawOverscrollFooter && first + count == itemCount && overFooterBottom > bottom) {
                            bounds.top = bottom;
                            bounds.bottom = overFooterBottom;
                            this.drawOverscrollFooter(canvas, overscrollFooter, bounds);
                        }
                    }
                    else {
                        let top;
                        const scrollY = this.mScrollY;
                        if (count > 0 && drawOverscrollHeader) {
                            bounds.top = scrollY;
                            bounds.bottom = this.getChildAt(0).getTop();
                            this.drawOverscrollHeader(canvas, overscrollHeader, bounds);
                        }
                        const start = drawOverscrollHeader ? 1 : 0;
                        for (let i = start; i < count; i++) {
                            const itemIndex = (first + i);
                            const isHeader = (itemIndex < headerCount);
                            const isFooter = (itemIndex >= footerLimit);
                            if ((headerDividers || !isHeader) && (footerDividers || !isFooter)) {
                                const child = this.getChildAt(i);
                                top = child.getTop();
                                if (drawDividers && (top > effectivePaddingTop)) {
                                    const isFirstItem = (i == start);
                                    const previousIndex = (itemIndex - 1);
                                    if (areAllItemsSelectable || ((adapter.isEnabled(itemIndex) || (headerDividers && isHeader) || (footerDividers && isFooter)) && (isFirstItem || adapter.isEnabled(previousIndex) || (headerDividers && (previousIndex < headerCount)) || (footerDividers && (previousIndex >= footerLimit))))) {
                                        bounds.top = top - dividerHeight;
                                        bounds.bottom = top;
                                        this.drawDivider(canvas, bounds, i - 1);
                                    }
                                    else if (fillForMissingDividers) {
                                        bounds.top = top - dividerHeight;
                                        bounds.bottom = top;
                                        canvas.drawRect(bounds, paint);
                                    }
                                }
                            }
                        }
                        if (count > 0 && scrollY > 0) {
                            if (drawOverscrollFooter) {
                                const absListBottom = this.mBottom;
                                bounds.top = absListBottom;
                                bounds.bottom = absListBottom + scrollY;
                                this.drawOverscrollFooter(canvas, overscrollFooter, bounds);
                            }
                            else if (drawDividers) {
                                bounds.top = listBottom;
                                bounds.bottom = listBottom + dividerHeight;
                                this.drawDivider(canvas, bounds, -1);
                            }
                        }
                    }
                }
                super.dispatchDraw(canvas);
            }
            drawChild(canvas, child, drawingTime) {
                let more = super.drawChild(canvas, child, drawingTime);
                if (this.mCachingActive && child.mCachingFailed) {
                    this.mCachingActive = false;
                }
                return more;
            }
            drawDivider(canvas, bounds, childIndex) {
                const divider = this.mDivider;
                divider.setBounds(bounds);
                divider.draw(canvas);
            }
            getDivider() {
                return this.mDivider;
            }
            setDivider(divider) {
                if (divider != null) {
                    this.mDividerHeight = divider.getIntrinsicHeight();
                }
                else {
                    this.mDividerHeight = 0;
                }
                this.mDivider = divider;
                this.mDividerIsOpaque = divider == null || divider.getOpacity() == PixelFormat.OPAQUE;
                this.requestLayout();
                this.invalidate();
            }
            getDividerHeight() {
                return this.mDividerHeight;
            }
            setDividerHeight(height) {
                this.mDividerHeight = height;
                this.requestLayout();
                this.invalidate();
            }
            setHeaderDividersEnabled(headerDividersEnabled) {
                this.mHeaderDividersEnabled = headerDividersEnabled;
                this.invalidate();
            }
            areHeaderDividersEnabled() {
                return this.mHeaderDividersEnabled;
            }
            setFooterDividersEnabled(footerDividersEnabled) {
                this.mFooterDividersEnabled = footerDividersEnabled;
                this.invalidate();
            }
            areFooterDividersEnabled() {
                return this.mFooterDividersEnabled;
            }
            setOverscrollHeader(header) {
                this.mOverScrollHeader = header;
                if (this.mScrollY < 0) {
                    this.invalidate();
                }
            }
            getOverscrollHeader() {
                return this.mOverScrollHeader;
            }
            setOverscrollFooter(footer) {
                this.mOverScrollFooter = footer;
                this.invalidate();
            }
            getOverscrollFooter() {
                return this.mOverScrollFooter;
            }
            onFocusChanged(gainFocus, direction, previouslyFocusedRect) {
                super.onFocusChanged(gainFocus, direction, previouslyFocusedRect);
                const adapter = this.mAdapter;
                let closetChildIndex = -1;
                let closestChildTop = 0;
                if (adapter != null && gainFocus && previouslyFocusedRect != null) {
                    previouslyFocusedRect.offset(this.mScrollX, this.mScrollY);
                    if (adapter.getCount() < this.getChildCount() + this.mFirstPosition) {
                        this.mLayoutMode = ListView.LAYOUT_NORMAL;
                        this.layoutChildren();
                    }
                    let otherRect = this.mTempRect;
                    let minDistance = Integer.MAX_VALUE;
                    const childCount = this.getChildCount();
                    const firstPosition = this.mFirstPosition;
                    for (let i = 0; i < childCount; i++) {
                        if (!adapter.isEnabled(firstPosition + i)) {
                            continue;
                        }
                        let other = this.getChildAt(i);
                        other.getDrawingRect(otherRect);
                        this.offsetDescendantRectToMyCoords(other, otherRect);
                        let distance = ListView.getDistance(previouslyFocusedRect, otherRect, direction);
                        if (distance < minDistance) {
                            minDistance = distance;
                            closetChildIndex = i;
                            closestChildTop = other.getTop();
                        }
                    }
                }
                if (closetChildIndex >= 0) {
                    this.setSelectionFromTop(closetChildIndex + this.mFirstPosition, closestChildTop);
                }
                else {
                    this.requestLayout();
                }
            }
            onFinishInflate() {
                super.onFinishInflate();
                let count = this.getChildCount();
                if (count > 0) {
                    for (let i = 0; i < count; ++i) {
                        this.addHeaderView(this.getChildAt(i));
                    }
                    this.removeAllViews();
                }
            }
            findViewTraversal(id) {
                let v;
                v = super.findViewTraversal(id);
                if (v == null) {
                    v = this.findViewInHeadersOrFooters(this.mHeaderViewInfos, id);
                    if (v != null) {
                        return v;
                    }
                    v = this.findViewInHeadersOrFooters(this.mFooterViewInfos, id);
                    if (v != null) {
                        return v;
                    }
                }
                return v;
            }
            findViewInHeadersOrFooters(where, id) {
                if (where != null) {
                    let len = where.size();
                    let v;
                    for (let i = 0; i < len; i++) {
                        v = where.get(i).view;
                        if (!v.isRootNamespace()) {
                            v = v.findViewById(id);
                            if (v != null) {
                                return v;
                            }
                        }
                    }
                }
                return null;
            }
            findViewByPredicateTraversal(predicate, childToSkip) {
                let v;
                v = super.findViewByPredicateTraversal(predicate, childToSkip);
                if (v == null) {
                    v = this.findViewByPredicateInHeadersOrFooters(this.mHeaderViewInfos, predicate, childToSkip);
                    if (v != null) {
                        return v;
                    }
                    v = this.findViewByPredicateInHeadersOrFooters(this.mFooterViewInfos, predicate, childToSkip);
                    if (v != null) {
                        return v;
                    }
                }
                return v;
            }
            findViewByPredicateInHeadersOrFooters(where, predicate, childToSkip) {
                if (where != null) {
                    let len = where.size();
                    let v;
                    for (let i = 0; i < len; i++) {
                        v = where.get(i).view;
                        if (v != childToSkip && !v.isRootNamespace()) {
                            v = v.findViewByPredicate(predicate);
                            if (v != null) {
                                return v;
                            }
                        }
                    }
                }
                return null;
            }
            getCheckItemIds() {
                if (this.mAdapter != null && this.mAdapter.hasStableIds()) {
                    return this.getCheckedItemIds();
                }
                if (this.mChoiceMode != ListView.CHOICE_MODE_NONE && this.mCheckStates != null && this.mAdapter != null) {
                    const states = this.mCheckStates;
                    const count = states.size();
                    const ids = new Array(count);
                    const adapter = this.mAdapter;
                    let checkedCount = 0;
                    for (let i = 0; i < count; i++) {
                        if (states.valueAt(i)) {
                            ids[checkedCount++] = adapter.getItemId(states.keyAt(i));
                        }
                    }
                    if (checkedCount == count) {
                        return ids;
                    }
                    else {
                        const result = new Array(checkedCount);
                        System.arraycopy(ids, 0, result, 0, checkedCount);
                        return result;
                    }
                }
                return new Array(0);
            }
        }
        ListView.NO_POSITION = -1;
        ListView.MAX_SCROLL_FACTOR = 0.33;
        ListView.MIN_SCROLL_PREVIEW_PIXELS = 2;
        widget.ListView = ListView;
        (function (ListView) {
            class FixedViewInfo {
                constructor(arg) {
                    this._ListView_this = arg;
                }
            }
            ListView.FixedViewInfo = FixedViewInfo;
            class FocusSelector {
                constructor(arg) {
                    this.mPosition = 0;
                    this.mPositionTop = 0;
                    this._ListView_this = arg;
                }
                setup(position, top) {
                    this.mPosition = position;
                    this.mPositionTop = top;
                    return this;
                }
                run() {
                    this._ListView_this.setSelectionFromTop(this.mPosition, this.mPositionTop);
                }
            }
            ListView.FocusSelector = FocusSelector;
            class ArrowScrollFocusResult {
                constructor() {
                    this.mSelectedPosition = 0;
                    this.mAmountToScroll = 0;
                }
                populate(selectedPosition, amountToScroll) {
                    this.mSelectedPosition = selectedPosition;
                    this.mAmountToScroll = amountToScroll;
                }
                getSelectedPosition() {
                    return this.mSelectedPosition;
                }
                getAmountToScroll() {
                    return this.mAmountToScroll;
                }
            }
            ListView.ArrowScrollFocusResult = ArrowScrollFocusResult;
        })(ListView = widget.ListView || (widget.ListView = {}));
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/graphics/Rect.ts"/>
///<reference path="../../android/os/Trace.ts"/>
///<reference path="../../android/view/Gravity.ts"/>
///<reference path="../../android/view/KeyEvent.ts"/>
///<reference path="../../android/view/SoundEffectConstants.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../java/lang/Integer.ts"/>
///<reference path="../../android/widget/AbsListView.ts"/>
///<reference path="../../android/widget/Adapter.ts"/>
///<reference path="../../android/widget/Checkable.ts"/>
///<reference path="../../android/widget/ListAdapter.ts"/>
///<reference path="../../android/widget/ListView.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var Rect = android.graphics.Rect;
        var Trace = android.os.Trace;
        var Gravity = android.view.Gravity;
        var KeyEvent = android.view.KeyEvent;
        var SoundEffectConstants = android.view.SoundEffectConstants;
        var View = android.view.View;
        var ViewGroup = android.view.ViewGroup;
        var Integer = java.lang.Integer;
        var AbsListView = android.widget.AbsListView;
        class GridView extends AbsListView {
            constructor() {
                super();
                this.mNumColumns = GridView.AUTO_FIT;
                this.mHorizontalSpacing = 0;
                this.mRequestedHorizontalSpacing = 0;
                this.mVerticalSpacing = 0;
                this.mStretchMode = GridView.STRETCH_COLUMN_WIDTH;
                this.mColumnWidth = 0;
                this.mRequestedColumnWidth = 0;
                this.mRequestedNumColumns = 0;
                this.mReferenceView = null;
                this.mReferenceViewInSelectedRow = null;
                this.mGravity = Gravity.LEFT;
                this.mTempRect = new Rect();
                this.setNumColumns(1);
            }
            createAttrChangeHandler(mergeHandler) {
                super.createAttrChangeHandler(mergeHandler);
                let gridView = this;
                mergeHandler.add({
                    set horizontalSpacing(value) {
                        gridView.setHorizontalSpacing(mergeHandler.parseNumber(value, 0));
                    },
                    set verticalSpacing(value) {
                        gridView.setVerticalSpacing(mergeHandler.parseNumber(value, 0));
                    },
                    set stretchMode(value) {
                        let strechMode = mergeHandler.parseNumber(value, -1);
                        if (strechMode >= 0) {
                            gridView.setStretchMode(strechMode);
                        }
                    },
                    set columnWidth(value) {
                        let columnWidth = mergeHandler.parseNumber(value, -1);
                        if (columnWidth > 0) {
                            gridView.setColumnWidth(columnWidth);
                        }
                    },
                    set numColumns(value) {
                        gridView.setNumColumns(mergeHandler.parseNumber(value, 1));
                    },
                    set gravity(value) {
                        let gravity = mergeHandler.parseGravity(value, -1);
                        if (gravity >= 0)
                            gridView.setGravity(gravity);
                    },
                });
            }
            getAdapter() {
                return this.mAdapter;
            }
            setAdapter(adapter) {
                if (this.mAdapter != null && this.mDataSetObserver != null) {
                    this.mAdapter.unregisterDataSetObserver(this.mDataSetObserver);
                }
                this.resetList();
                this.mRecycler.clear();
                this.mAdapter = adapter;
                this.mOldSelectedPosition = GridView.INVALID_POSITION;
                this.mOldSelectedRowId = GridView.INVALID_ROW_ID;
                super.setAdapter(adapter);
                if (this.mAdapter != null) {
                    this.mOldItemCount = this.mItemCount;
                    this.mItemCount = this.mAdapter.getCount();
                    this.mDataChanged = true;
                    this.checkFocus();
                    this.mDataSetObserver = new AbsListView.AdapterDataSetObserver(this);
                    this.mAdapter.registerDataSetObserver(this.mDataSetObserver);
                    this.mRecycler.setViewTypeCount(this.mAdapter.getViewTypeCount());
                    let position;
                    if (this.mStackFromBottom) {
                        position = this.lookForSelectablePosition(this.mItemCount - 1, false);
                    }
                    else {
                        position = this.lookForSelectablePosition(0, true);
                    }
                    this.setSelectedPositionInt(position);
                    this.setNextSelectedPositionInt(position);
                    this.checkSelectionChanged();
                }
                else {
                    this.checkFocus();
                    this.checkSelectionChanged();
                }
                this.requestLayout();
            }
            lookForSelectablePosition(position, lookDown) {
                const adapter = this.mAdapter;
                if (adapter == null || this.isInTouchMode()) {
                    return GridView.INVALID_POSITION;
                }
                if (position < 0 || position >= this.mItemCount) {
                    return GridView.INVALID_POSITION;
                }
                return position;
            }
            fillGap(down) {
                const numColumns = this.mNumColumns;
                const verticalSpacing = this.mVerticalSpacing;
                const count = this.getChildCount();
                if (down) {
                    let paddingTop = 0;
                    if ((this.mGroupFlags & GridView.CLIP_TO_PADDING_MASK) == GridView.CLIP_TO_PADDING_MASK) {
                        paddingTop = this.getListPaddingTop();
                    }
                    const startOffset = count > 0 ? this.getChildAt(count - 1).getBottom() + verticalSpacing : paddingTop;
                    let position = this.mFirstPosition + count;
                    if (this.mStackFromBottom) {
                        position += numColumns - 1;
                    }
                    this.fillDown(position, startOffset);
                    this.correctTooHigh(numColumns, verticalSpacing, this.getChildCount());
                }
                else {
                    let paddingBottom = 0;
                    if ((this.mGroupFlags & GridView.CLIP_TO_PADDING_MASK) == GridView.CLIP_TO_PADDING_MASK) {
                        paddingBottom = this.getListPaddingBottom();
                    }
                    const startOffset = count > 0 ? this.getChildAt(0).getTop() - verticalSpacing : this.getHeight() - paddingBottom;
                    let position = this.mFirstPosition;
                    if (!this.mStackFromBottom) {
                        position -= numColumns;
                    }
                    else {
                        position--;
                    }
                    this.fillUp(position, startOffset);
                    this.correctTooLow(numColumns, verticalSpacing, this.getChildCount());
                }
            }
            fillDown(pos, nextTop) {
                let selectedView = null;
                let end = (this.mBottom - this.mTop);
                if ((this.mGroupFlags & GridView.CLIP_TO_PADDING_MASK) == GridView.CLIP_TO_PADDING_MASK) {
                    end -= this.mListPadding.bottom;
                }
                while (nextTop < end && pos < this.mItemCount) {
                    let temp = this.makeRow(pos, nextTop, true);
                    if (temp != null) {
                        selectedView = temp;
                    }
                    nextTop = this.mReferenceView.getBottom() + this.mVerticalSpacing;
                    pos += this.mNumColumns;
                }
                this.setVisibleRangeHint(this.mFirstPosition, this.mFirstPosition + this.getChildCount() - 1);
                return selectedView;
            }
            makeRow(startPos, y, flow) {
                const columnWidth = this.mColumnWidth;
                const horizontalSpacing = this.mHorizontalSpacing;
                const isLayoutRtl = this.isLayoutRtl();
                let last;
                let nextLeft;
                if (isLayoutRtl) {
                    nextLeft = this.getWidth() - this.mListPadding.right - columnWidth - ((this.mStretchMode == GridView.STRETCH_SPACING_UNIFORM) ? horizontalSpacing : 0);
                }
                else {
                    nextLeft = this.mListPadding.left + ((this.mStretchMode == GridView.STRETCH_SPACING_UNIFORM) ? horizontalSpacing : 0);
                }
                if (!this.mStackFromBottom) {
                    last = Math.min(startPos + this.mNumColumns, this.mItemCount);
                }
                else {
                    last = startPos + 1;
                    startPos = Math.max(0, startPos - this.mNumColumns + 1);
                    if (last - startPos < this.mNumColumns) {
                        const deltaLeft = (this.mNumColumns - (last - startPos)) * (columnWidth + horizontalSpacing);
                        nextLeft += (isLayoutRtl ? -1 : +1) * deltaLeft;
                    }
                }
                let selectedView = null;
                const hasFocus = this.shouldShowSelector();
                const inClick = this.touchModeDrawsInPressedState();
                const selectedPosition = this.mSelectedPosition;
                let child = null;
                for (let pos = startPos; pos < last; pos++) {
                    let selected = pos == selectedPosition;
                    const where = flow ? -1 : pos - startPos;
                    child = this.makeAndAddView(pos, y, flow, nextLeft, selected, where);
                    nextLeft += (isLayoutRtl ? -1 : +1) * columnWidth;
                    if (pos < last - 1) {
                        nextLeft += horizontalSpacing;
                    }
                    if (selected && (hasFocus || inClick)) {
                        selectedView = child;
                    }
                }
                this.mReferenceView = child;
                if (selectedView != null) {
                    this.mReferenceViewInSelectedRow = this.mReferenceView;
                }
                return selectedView;
            }
            fillUp(pos, nextBottom) {
                let selectedView = null;
                let end = 0;
                if ((this.mGroupFlags & GridView.CLIP_TO_PADDING_MASK) == GridView.CLIP_TO_PADDING_MASK) {
                    end = this.mListPadding.top;
                }
                while (nextBottom > end && pos >= 0) {
                    let temp = this.makeRow(pos, nextBottom, false);
                    if (temp != null) {
                        selectedView = temp;
                    }
                    nextBottom = this.mReferenceView.getTop() - this.mVerticalSpacing;
                    this.mFirstPosition = pos;
                    pos -= this.mNumColumns;
                }
                if (this.mStackFromBottom) {
                    this.mFirstPosition = Math.max(0, pos + 1);
                }
                this.setVisibleRangeHint(this.mFirstPosition, this.mFirstPosition + this.getChildCount() - 1);
                return selectedView;
            }
            fillFromTop(nextTop) {
                this.mFirstPosition = Math.min(this.mFirstPosition, this.mSelectedPosition);
                this.mFirstPosition = Math.min(this.mFirstPosition, this.mItemCount - 1);
                if (this.mFirstPosition < 0) {
                    this.mFirstPosition = 0;
                }
                this.mFirstPosition -= this.mFirstPosition % this.mNumColumns;
                return this.fillDown(this.mFirstPosition, nextTop);
            }
            fillFromBottom(lastPosition, nextBottom) {
                lastPosition = Math.max(lastPosition, this.mSelectedPosition);
                lastPosition = Math.min(lastPosition, this.mItemCount - 1);
                const invertedPosition = this.mItemCount - 1 - lastPosition;
                lastPosition = this.mItemCount - 1 - (invertedPosition - (invertedPosition % this.mNumColumns));
                return this.fillUp(lastPosition, nextBottom);
            }
            fillSelection(childrenTop, childrenBottom) {
                const selectedPosition = this.reconcileSelectedPosition();
                const numColumns = this.mNumColumns;
                const verticalSpacing = this.mVerticalSpacing;
                let rowStart;
                let rowEnd = -1;
                if (!this.mStackFromBottom) {
                    rowStart = selectedPosition - (selectedPosition % numColumns);
                }
                else {
                    const invertedSelection = this.mItemCount - 1 - selectedPosition;
                    rowEnd = this.mItemCount - 1 - (invertedSelection - (invertedSelection % numColumns));
                    rowStart = Math.max(0, rowEnd - numColumns + 1);
                }
                const fadingEdgeLength = this.getVerticalFadingEdgeLength();
                const topSelectionPixel = this.getTopSelectionPixel(childrenTop, fadingEdgeLength, rowStart);
                const sel = this.makeRow(this.mStackFromBottom ? rowEnd : rowStart, topSelectionPixel, true);
                this.mFirstPosition = rowStart;
                const referenceView = this.mReferenceView;
                if (!this.mStackFromBottom) {
                    this.fillDown(rowStart + numColumns, referenceView.getBottom() + verticalSpacing);
                    this.pinToBottom(childrenBottom);
                    this.fillUp(rowStart - numColumns, referenceView.getTop() - verticalSpacing);
                    this.adjustViewsUpOrDown();
                }
                else {
                    const bottomSelectionPixel = this.getBottomSelectionPixel(childrenBottom, fadingEdgeLength, numColumns, rowStart);
                    const offset = bottomSelectionPixel - referenceView.getBottom();
                    this.offsetChildrenTopAndBottom(offset);
                    this.fillUp(rowStart - 1, referenceView.getTop() - verticalSpacing);
                    this.pinToTop(childrenTop);
                    this.fillDown(rowEnd + numColumns, referenceView.getBottom() + verticalSpacing);
                    this.adjustViewsUpOrDown();
                }
                return sel;
            }
            pinToTop(childrenTop) {
                if (this.mFirstPosition == 0) {
                    const top = this.getChildAt(0).getTop();
                    const offset = childrenTop - top;
                    if (offset < 0) {
                        this.offsetChildrenTopAndBottom(offset);
                    }
                }
            }
            pinToBottom(childrenBottom) {
                const count = this.getChildCount();
                if (this.mFirstPosition + count == this.mItemCount) {
                    const bottom = this.getChildAt(count - 1).getBottom();
                    const offset = childrenBottom - bottom;
                    if (offset > 0) {
                        this.offsetChildrenTopAndBottom(offset);
                    }
                }
            }
            findMotionRow(y) {
                const childCount = this.getChildCount();
                if (childCount > 0) {
                    const numColumns = this.mNumColumns;
                    if (!this.mStackFromBottom) {
                        for (let i = 0; i < childCount; i += numColumns) {
                            if (y <= this.getChildAt(i).getBottom()) {
                                return this.mFirstPosition + i;
                            }
                        }
                    }
                    else {
                        for (let i = childCount - 1; i >= 0; i -= numColumns) {
                            if (y >= this.getChildAt(i).getTop()) {
                                return this.mFirstPosition + i;
                            }
                        }
                    }
                }
                return GridView.INVALID_POSITION;
            }
            fillSpecific(position, top) {
                const numColumns = this.mNumColumns;
                let motionRowStart;
                let motionRowEnd = -1;
                if (!this.mStackFromBottom) {
                    motionRowStart = position - (position % numColumns);
                }
                else {
                    const invertedSelection = this.mItemCount - 1 - position;
                    motionRowEnd = this.mItemCount - 1 - (invertedSelection - (invertedSelection % numColumns));
                    motionRowStart = Math.max(0, motionRowEnd - numColumns + 1);
                }
                const temp = this.makeRow(this.mStackFromBottom ? motionRowEnd : motionRowStart, top, true);
                this.mFirstPosition = motionRowStart;
                const referenceView = this.mReferenceView;
                if (referenceView == null) {
                    return null;
                }
                const verticalSpacing = this.mVerticalSpacing;
                let above;
                let below;
                if (!this.mStackFromBottom) {
                    above = this.fillUp(motionRowStart - numColumns, referenceView.getTop() - verticalSpacing);
                    this.adjustViewsUpOrDown();
                    below = this.fillDown(motionRowStart + numColumns, referenceView.getBottom() + verticalSpacing);
                    const childCount = this.getChildCount();
                    if (childCount > 0) {
                        this.correctTooHigh(numColumns, verticalSpacing, childCount);
                    }
                }
                else {
                    below = this.fillDown(motionRowEnd + numColumns, referenceView.getBottom() + verticalSpacing);
                    this.adjustViewsUpOrDown();
                    above = this.fillUp(motionRowStart - 1, referenceView.getTop() - verticalSpacing);
                    const childCount = this.getChildCount();
                    if (childCount > 0) {
                        this.correctTooLow(numColumns, verticalSpacing, childCount);
                    }
                }
                if (temp != null) {
                    return temp;
                }
                else if (above != null) {
                    return above;
                }
                else {
                    return below;
                }
            }
            correctTooHigh(numColumns, verticalSpacing, childCount) {
                const lastPosition = this.mFirstPosition + childCount - 1;
                if (lastPosition == this.mItemCount - 1 && childCount > 0) {
                    const lastChild = this.getChildAt(childCount - 1);
                    const lastBottom = lastChild.getBottom();
                    const end = (this.mBottom - this.mTop) - this.mListPadding.bottom;
                    let bottomOffset = end - lastBottom;
                    const firstChild = this.getChildAt(0);
                    const firstTop = firstChild.getTop();
                    if (bottomOffset > 0 && (this.mFirstPosition > 0 || firstTop < this.mListPadding.top)) {
                        if (this.mFirstPosition == 0) {
                            bottomOffset = Math.min(bottomOffset, this.mListPadding.top - firstTop);
                        }
                        this.offsetChildrenTopAndBottom(bottomOffset);
                        if (this.mFirstPosition > 0) {
                            this.fillUp(this.mFirstPosition - (this.mStackFromBottom ? 1 : numColumns), firstChild.getTop() - verticalSpacing);
                            this.adjustViewsUpOrDown();
                        }
                    }
                }
            }
            correctTooLow(numColumns, verticalSpacing, childCount) {
                if (this.mFirstPosition == 0 && childCount > 0) {
                    const firstChild = this.getChildAt(0);
                    const firstTop = firstChild.getTop();
                    const start = this.mListPadding.top;
                    const end = (this.mBottom - this.mTop) - this.mListPadding.bottom;
                    let topOffset = firstTop - start;
                    const lastChild = this.getChildAt(childCount - 1);
                    const lastBottom = lastChild.getBottom();
                    const lastPosition = this.mFirstPosition + childCount - 1;
                    if (topOffset > 0 && (lastPosition < this.mItemCount - 1 || lastBottom > end)) {
                        if (lastPosition == this.mItemCount - 1) {
                            topOffset = Math.min(topOffset, lastBottom - end);
                        }
                        this.offsetChildrenTopAndBottom(-topOffset);
                        if (lastPosition < this.mItemCount - 1) {
                            this.fillDown(lastPosition + (!this.mStackFromBottom ? 1 : numColumns), lastChild.getBottom() + verticalSpacing);
                            this.adjustViewsUpOrDown();
                        }
                    }
                }
            }
            fillFromSelection(selectedTop, childrenTop, childrenBottom) {
                const fadingEdgeLength = this.getVerticalFadingEdgeLength();
                const selectedPosition = this.mSelectedPosition;
                const numColumns = this.mNumColumns;
                const verticalSpacing = this.mVerticalSpacing;
                let rowStart;
                let rowEnd = -1;
                if (!this.mStackFromBottom) {
                    rowStart = selectedPosition - (selectedPosition % numColumns);
                }
                else {
                    let invertedSelection = this.mItemCount - 1 - selectedPosition;
                    rowEnd = this.mItemCount - 1 - (invertedSelection - (invertedSelection % numColumns));
                    rowStart = Math.max(0, rowEnd - numColumns + 1);
                }
                let sel;
                let referenceView;
                let topSelectionPixel = this.getTopSelectionPixel(childrenTop, fadingEdgeLength, rowStart);
                let bottomSelectionPixel = this.getBottomSelectionPixel(childrenBottom, fadingEdgeLength, numColumns, rowStart);
                sel = this.makeRow(this.mStackFromBottom ? rowEnd : rowStart, selectedTop, true);
                this.mFirstPosition = rowStart;
                referenceView = this.mReferenceView;
                this.adjustForTopFadingEdge(referenceView, topSelectionPixel, bottomSelectionPixel);
                this.adjustForBottomFadingEdge(referenceView, topSelectionPixel, bottomSelectionPixel);
                if (!this.mStackFromBottom) {
                    this.fillUp(rowStart - numColumns, referenceView.getTop() - verticalSpacing);
                    this.adjustViewsUpOrDown();
                    this.fillDown(rowStart + numColumns, referenceView.getBottom() + verticalSpacing);
                }
                else {
                    this.fillDown(rowEnd + numColumns, referenceView.getBottom() + verticalSpacing);
                    this.adjustViewsUpOrDown();
                    this.fillUp(rowStart - 1, referenceView.getTop() - verticalSpacing);
                }
                return sel;
            }
            getBottomSelectionPixel(childrenBottom, fadingEdgeLength, numColumns, rowStart) {
                let bottomSelectionPixel = childrenBottom;
                if (rowStart + numColumns - 1 < this.mItemCount - 1) {
                    bottomSelectionPixel -= fadingEdgeLength;
                }
                return bottomSelectionPixel;
            }
            getTopSelectionPixel(childrenTop, fadingEdgeLength, rowStart) {
                let topSelectionPixel = childrenTop;
                if (rowStart > 0) {
                    topSelectionPixel += fadingEdgeLength;
                }
                return topSelectionPixel;
            }
            adjustForBottomFadingEdge(childInSelectedRow, topSelectionPixel, bottomSelectionPixel) {
                if (childInSelectedRow.getBottom() > bottomSelectionPixel) {
                    let spaceAbove = childInSelectedRow.getTop() - topSelectionPixel;
                    let spaceBelow = childInSelectedRow.getBottom() - bottomSelectionPixel;
                    let offset = Math.min(spaceAbove, spaceBelow);
                    this.offsetChildrenTopAndBottom(-offset);
                }
            }
            adjustForTopFadingEdge(childInSelectedRow, topSelectionPixel, bottomSelectionPixel) {
                if (childInSelectedRow.getTop() < topSelectionPixel) {
                    let spaceAbove = topSelectionPixel - childInSelectedRow.getTop();
                    let spaceBelow = bottomSelectionPixel - childInSelectedRow.getBottom();
                    let offset = Math.min(spaceAbove, spaceBelow);
                    this.offsetChildrenTopAndBottom(offset);
                }
            }
            smoothScrollToPosition(position) {
                super.smoothScrollToPosition(position);
            }
            smoothScrollByOffset(offset) {
                super.smoothScrollByOffset(offset);
            }
            moveSelection(delta, childrenTop, childrenBottom) {
                const fadingEdgeLength = this.getVerticalFadingEdgeLength();
                const selectedPosition = this.mSelectedPosition;
                const numColumns = this.mNumColumns;
                const verticalSpacing = this.mVerticalSpacing;
                let oldRowStart;
                let rowStart;
                let rowEnd = -1;
                if (!this.mStackFromBottom) {
                    oldRowStart = (selectedPosition - delta) - ((selectedPosition - delta) % numColumns);
                    rowStart = selectedPosition - (selectedPosition % numColumns);
                }
                else {
                    let invertedSelection = this.mItemCount - 1 - selectedPosition;
                    rowEnd = this.mItemCount - 1 - (invertedSelection - (invertedSelection % numColumns));
                    rowStart = Math.max(0, rowEnd - numColumns + 1);
                    invertedSelection = this.mItemCount - 1 - (selectedPosition - delta);
                    oldRowStart = this.mItemCount - 1 - (invertedSelection - (invertedSelection % numColumns));
                    oldRowStart = Math.max(0, oldRowStart - numColumns + 1);
                }
                const rowDelta = rowStart - oldRowStart;
                const topSelectionPixel = this.getTopSelectionPixel(childrenTop, fadingEdgeLength, rowStart);
                const bottomSelectionPixel = this.getBottomSelectionPixel(childrenBottom, fadingEdgeLength, numColumns, rowStart);
                this.mFirstPosition = rowStart;
                let sel;
                let referenceView;
                if (rowDelta > 0) {
                    const oldBottom = this.mReferenceViewInSelectedRow == null ? 0 : this.mReferenceViewInSelectedRow.getBottom();
                    sel = this.makeRow(this.mStackFromBottom ? rowEnd : rowStart, oldBottom + verticalSpacing, true);
                    referenceView = this.mReferenceView;
                    this.adjustForBottomFadingEdge(referenceView, topSelectionPixel, bottomSelectionPixel);
                }
                else if (rowDelta < 0) {
                    const oldTop = this.mReferenceViewInSelectedRow == null ? 0 : this.mReferenceViewInSelectedRow.getTop();
                    sel = this.makeRow(this.mStackFromBottom ? rowEnd : rowStart, oldTop - verticalSpacing, false);
                    referenceView = this.mReferenceView;
                    this.adjustForTopFadingEdge(referenceView, topSelectionPixel, bottomSelectionPixel);
                }
                else {
                    const oldTop = this.mReferenceViewInSelectedRow == null ? 0 : this.mReferenceViewInSelectedRow.getTop();
                    sel = this.makeRow(this.mStackFromBottom ? rowEnd : rowStart, oldTop, true);
                    referenceView = this.mReferenceView;
                }
                if (!this.mStackFromBottom) {
                    this.fillUp(rowStart - numColumns, referenceView.getTop() - verticalSpacing);
                    this.adjustViewsUpOrDown();
                    this.fillDown(rowStart + numColumns, referenceView.getBottom() + verticalSpacing);
                }
                else {
                    this.fillDown(rowEnd + numColumns, referenceView.getBottom() + verticalSpacing);
                    this.adjustViewsUpOrDown();
                    this.fillUp(rowStart - 1, referenceView.getTop() - verticalSpacing);
                }
                return sel;
            }
            determineColumns(availableSpace) {
                const requestedHorizontalSpacing = this.mRequestedHorizontalSpacing;
                const stretchMode = this.mStretchMode;
                const requestedColumnWidth = this.mRequestedColumnWidth;
                let didNotInitiallyFit = false;
                if (this.mRequestedNumColumns == GridView.AUTO_FIT) {
                    if (requestedColumnWidth > 0) {
                        this.mNumColumns = (availableSpace + requestedHorizontalSpacing) / (requestedColumnWidth + requestedHorizontalSpacing);
                    }
                    else {
                        this.mNumColumns = 2;
                    }
                }
                else {
                    this.mNumColumns = this.mRequestedNumColumns;
                }
                if (this.mNumColumns <= 0) {
                    this.mNumColumns = 1;
                }
                switch (stretchMode) {
                    case GridView.NO_STRETCH:
                        this.mColumnWidth = requestedColumnWidth;
                        this.mHorizontalSpacing = requestedHorizontalSpacing;
                        break;
                    default:
                        let spaceLeftOver = availableSpace - (this.mNumColumns * requestedColumnWidth) - ((this.mNumColumns - 1) * requestedHorizontalSpacing);
                        if (spaceLeftOver < 0) {
                            didNotInitiallyFit = true;
                        }
                        switch (stretchMode) {
                            case GridView.STRETCH_COLUMN_WIDTH:
                                this.mColumnWidth = requestedColumnWidth + spaceLeftOver / this.mNumColumns;
                                this.mHorizontalSpacing = requestedHorizontalSpacing;
                                break;
                            case GridView.STRETCH_SPACING:
                                this.mColumnWidth = requestedColumnWidth;
                                if (this.mNumColumns > 1) {
                                    this.mHorizontalSpacing = requestedHorizontalSpacing + spaceLeftOver / (this.mNumColumns - 1);
                                }
                                else {
                                    this.mHorizontalSpacing = requestedHorizontalSpacing + spaceLeftOver;
                                }
                                break;
                            case GridView.STRETCH_SPACING_UNIFORM:
                                this.mColumnWidth = requestedColumnWidth;
                                if (this.mNumColumns > 1) {
                                    this.mHorizontalSpacing = requestedHorizontalSpacing + spaceLeftOver / (this.mNumColumns + 1);
                                }
                                else {
                                    this.mHorizontalSpacing = requestedHorizontalSpacing + spaceLeftOver;
                                }
                                break;
                        }
                        break;
                }
                return didNotInitiallyFit;
            }
            onMeasure(widthMeasureSpec, heightMeasureSpec) {
                super.onMeasure(widthMeasureSpec, heightMeasureSpec);
                let widthMode = GridView.MeasureSpec.getMode(widthMeasureSpec);
                let heightMode = GridView.MeasureSpec.getMode(heightMeasureSpec);
                let widthSize = GridView.MeasureSpec.getSize(widthMeasureSpec);
                let heightSize = GridView.MeasureSpec.getSize(heightMeasureSpec);
                if (widthMode == GridView.MeasureSpec.UNSPECIFIED) {
                    if (this.mColumnWidth > 0) {
                        widthSize = this.mColumnWidth + this.mListPadding.left + this.mListPadding.right;
                    }
                    else {
                        widthSize = this.mListPadding.left + this.mListPadding.right;
                    }
                    widthSize += this.getVerticalScrollbarWidth();
                }
                let childWidth = widthSize - this.mListPadding.left - this.mListPadding.right;
                let didNotInitiallyFit = this.determineColumns(childWidth);
                let childHeight = 0;
                let childState = 0;
                this.mItemCount = this.mAdapter == null ? 0 : this.mAdapter.getCount();
                const count = this.mItemCount;
                if (count > 0) {
                    const child = this.obtainView(0, this.mIsScrap);
                    let p = child.getLayoutParams();
                    if (p == null) {
                        p = this.generateDefaultLayoutParams();
                        child.setLayoutParams(p);
                    }
                    p.viewType = this.mAdapter.getItemViewType(0);
                    p.forceAdd = true;
                    let childHeightSpec = GridView.getChildMeasureSpec(GridView.MeasureSpec.makeMeasureSpec(0, GridView.MeasureSpec.UNSPECIFIED), 0, p.height);
                    let childWidthSpec = GridView.getChildMeasureSpec(GridView.MeasureSpec.makeMeasureSpec(this.mColumnWidth, GridView.MeasureSpec.EXACTLY), 0, p.width);
                    child.measure(childWidthSpec, childHeightSpec);
                    childHeight = child.getMeasuredHeight();
                    childState = GridView.combineMeasuredStates(childState, child.getMeasuredState());
                    if (this.mRecycler.shouldRecycleViewType(p.viewType)) {
                        this.mRecycler.addScrapView(child, -1);
                    }
                }
                if (heightMode == GridView.MeasureSpec.UNSPECIFIED) {
                    heightSize = this.mListPadding.top + this.mListPadding.bottom + childHeight + this.getVerticalFadingEdgeLength() * 2;
                }
                if (heightMode == GridView.MeasureSpec.AT_MOST) {
                    let ourSize = this.mListPadding.top + this.mListPadding.bottom;
                    const numColumns = this.mNumColumns;
                    for (let i = 0; i < count; i += numColumns) {
                        ourSize += childHeight;
                        if (i + numColumns < count) {
                            ourSize += this.mVerticalSpacing;
                        }
                        if (ourSize >= heightSize) {
                            ourSize = heightSize;
                            break;
                        }
                    }
                    heightSize = ourSize;
                }
                if (widthMode == GridView.MeasureSpec.AT_MOST && this.mRequestedNumColumns != GridView.AUTO_FIT) {
                    let ourSize = (this.mRequestedNumColumns * this.mColumnWidth) + ((this.mRequestedNumColumns - 1) * this.mHorizontalSpacing) + this.mListPadding.left + this.mListPadding.right;
                    if (ourSize > widthSize || didNotInitiallyFit) {
                        widthSize |= GridView.MEASURED_STATE_TOO_SMALL;
                    }
                }
                this.setMeasuredDimension(widthSize, heightSize);
                this.mWidthMeasureSpec = widthMeasureSpec;
            }
            layoutChildren() {
                const blockLayoutRequests = this.mBlockLayoutRequests;
                if (!blockLayoutRequests) {
                    this.mBlockLayoutRequests = true;
                }
                try {
                    super.layoutChildren();
                    this.invalidate();
                    if (this.mAdapter == null) {
                        this.resetList();
                        this.invokeOnItemScrollListener();
                        return;
                    }
                    const childrenTop = this.mListPadding.top;
                    const childrenBottom = this.mBottom - this.mTop - this.mListPadding.bottom;
                    let childCount = this.getChildCount();
                    let index;
                    let delta = 0;
                    let sel;
                    let oldSel = null;
                    let oldFirst = null;
                    let newSel = null;
                    switch (this.mLayoutMode) {
                        case GridView.LAYOUT_SET_SELECTION:
                            index = this.mNextSelectedPosition - this.mFirstPosition;
                            if (index >= 0 && index < childCount) {
                                newSel = this.getChildAt(index);
                            }
                            break;
                        case GridView.LAYOUT_FORCE_TOP:
                        case GridView.LAYOUT_FORCE_BOTTOM:
                        case GridView.LAYOUT_SPECIFIC:
                        case GridView.LAYOUT_SYNC:
                            break;
                        case GridView.LAYOUT_MOVE_SELECTION:
                            if (this.mNextSelectedPosition >= 0) {
                                delta = this.mNextSelectedPosition - this.mSelectedPosition;
                            }
                            break;
                        default:
                            index = this.mSelectedPosition - this.mFirstPosition;
                            if (index >= 0 && index < childCount) {
                                oldSel = this.getChildAt(index);
                            }
                            oldFirst = this.getChildAt(0);
                    }
                    let dataChanged = this.mDataChanged;
                    if (dataChanged) {
                        this.handleDataChanged();
                    }
                    if (this.mItemCount == 0) {
                        this.resetList();
                        this.invokeOnItemScrollListener();
                        return;
                    }
                    this.setSelectedPositionInt(this.mNextSelectedPosition);
                    const firstPosition = this.mFirstPosition;
                    const recycleBin = this.mRecycler;
                    if (dataChanged) {
                        for (let i = 0; i < childCount; i++) {
                            recycleBin.addScrapView(this.getChildAt(i), firstPosition + i);
                        }
                    }
                    else {
                        recycleBin.fillActiveViews(childCount, firstPosition);
                    }
                    this.detachAllViewsFromParent();
                    recycleBin.removeSkippedScrap();
                    switch (this.mLayoutMode) {
                        case GridView.LAYOUT_SET_SELECTION:
                            if (newSel != null) {
                                sel = this.fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);
                            }
                            else {
                                sel = this.fillSelection(childrenTop, childrenBottom);
                            }
                            break;
                        case GridView.LAYOUT_FORCE_TOP:
                            this.mFirstPosition = 0;
                            sel = this.fillFromTop(childrenTop);
                            this.adjustViewsUpOrDown();
                            break;
                        case GridView.LAYOUT_FORCE_BOTTOM:
                            sel = this.fillUp(this.mItemCount - 1, childrenBottom);
                            this.adjustViewsUpOrDown();
                            break;
                        case GridView.LAYOUT_SPECIFIC:
                            sel = this.fillSpecific(this.mSelectedPosition, this.mSpecificTop);
                            break;
                        case GridView.LAYOUT_SYNC:
                            sel = this.fillSpecific(this.mSyncPosition, this.mSpecificTop);
                            break;
                        case GridView.LAYOUT_MOVE_SELECTION:
                            sel = this.moveSelection(delta, childrenTop, childrenBottom);
                            break;
                        default:
                            if (childCount == 0) {
                                if (!this.mStackFromBottom) {
                                    this.setSelectedPositionInt(this.mAdapter == null || this.isInTouchMode() ? GridView.INVALID_POSITION : 0);
                                    sel = this.fillFromTop(childrenTop);
                                }
                                else {
                                    const last = this.mItemCount - 1;
                                    this.setSelectedPositionInt(this.mAdapter == null || this.isInTouchMode() ? GridView.INVALID_POSITION : last);
                                    sel = this.fillFromBottom(last, childrenBottom);
                                }
                            }
                            else {
                                if (this.mSelectedPosition >= 0 && this.mSelectedPosition < this.mItemCount) {
                                    sel = this.fillSpecific(this.mSelectedPosition, oldSel == null ? childrenTop : oldSel.getTop());
                                }
                                else if (this.mFirstPosition < this.mItemCount) {
                                    sel = this.fillSpecific(this.mFirstPosition, oldFirst == null ? childrenTop : oldFirst.getTop());
                                }
                                else {
                                    sel = this.fillSpecific(0, childrenTop);
                                }
                            }
                            break;
                    }
                    recycleBin.scrapActiveViews();
                    if (sel != null) {
                        this.positionSelector(GridView.INVALID_POSITION, sel);
                        this.mSelectedTop = sel.getTop();
                    }
                    else if (this.mTouchMode > GridView.TOUCH_MODE_DOWN && this.mTouchMode < GridView.TOUCH_MODE_SCROLL) {
                        let child = this.getChildAt(this.mMotionPosition - this.mFirstPosition);
                        if (child != null)
                            this.positionSelector(this.mMotionPosition, child);
                    }
                    else {
                        this.mSelectedTop = 0;
                        this.mSelectorRect.setEmpty();
                    }
                    this.mLayoutMode = GridView.LAYOUT_NORMAL;
                    this.mDataChanged = false;
                    if (this.mPositionScrollAfterLayout != null) {
                        this.post(this.mPositionScrollAfterLayout);
                        this.mPositionScrollAfterLayout = null;
                    }
                    this.mNeedSync = false;
                    this.setNextSelectedPositionInt(this.mSelectedPosition);
                    this.updateScrollIndicators();
                    if (this.mItemCount > 0) {
                        this.checkSelectionChanged();
                    }
                    this.invokeOnItemScrollListener();
                }
                finally {
                    if (!blockLayoutRequests) {
                        this.mBlockLayoutRequests = false;
                    }
                }
            }
            makeAndAddView(position, y, flow, childrenLeft, selected, where) {
                let child;
                if (!this.mDataChanged) {
                    child = this.mRecycler.getActiveView(position);
                    if (child != null) {
                        this.setupChild(child, position, y, flow, childrenLeft, selected, true, where);
                        return child;
                    }
                }
                child = this.obtainView(position, this.mIsScrap);
                this.setupChild(child, position, y, flow, childrenLeft, selected, this.mIsScrap[0], where);
                return child;
            }
            setupChild(child, position, y, flow, childrenLeft, selected, recycled, where) {
                Trace.traceBegin(Trace.TRACE_TAG_VIEW, "setupGridItem");
                let isSelected = selected && this.shouldShowSelector();
                const updateChildSelected = isSelected != child.isSelected();
                const mode = this.mTouchMode;
                const isPressed = mode > GridView.TOUCH_MODE_DOWN && mode < GridView.TOUCH_MODE_SCROLL && this.mMotionPosition == position;
                const updateChildPressed = isPressed != child.isPressed();
                let needToMeasure = !recycled || updateChildSelected || child.isLayoutRequested();
                let p = child.getLayoutParams();
                if (p == null) {
                    p = this.generateDefaultLayoutParams();
                }
                p.viewType = this.mAdapter.getItemViewType(position);
                if (recycled && !p.forceAdd) {
                    this.attachViewToParent(child, where, p);
                }
                else {
                    p.forceAdd = false;
                    this.addViewInLayout(child, where, p, true);
                }
                if (updateChildSelected) {
                    child.setSelected(isSelected);
                    if (isSelected) {
                        this.requestFocus();
                    }
                }
                if (updateChildPressed) {
                    child.setPressed(isPressed);
                }
                if (this.mChoiceMode != GridView.CHOICE_MODE_NONE && this.mCheckStates != null) {
                    if (child['setChecked']) {
                        child.setChecked(this.mCheckStates.get(position));
                    }
                    else {
                        child.setActivated(this.mCheckStates.get(position));
                    }
                }
                if (needToMeasure) {
                    let childHeightSpec = ViewGroup.getChildMeasureSpec(GridView.MeasureSpec.makeMeasureSpec(0, GridView.MeasureSpec.UNSPECIFIED), 0, p.height);
                    let childWidthSpec = ViewGroup.getChildMeasureSpec(GridView.MeasureSpec.makeMeasureSpec(this.mColumnWidth, GridView.MeasureSpec.EXACTLY), 0, p.width);
                    child.measure(childWidthSpec, childHeightSpec);
                }
                else {
                    this.cleanupLayoutState(child);
                }
                const w = child.getMeasuredWidth();
                const h = child.getMeasuredHeight();
                let childLeft;
                const childTop = flow ? y : y - h;
                const absoluteGravity = this.mGravity;
                switch (absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
                    case Gravity.LEFT:
                        childLeft = childrenLeft;
                        break;
                    case Gravity.CENTER_HORIZONTAL:
                        childLeft = childrenLeft + ((this.mColumnWidth - w) / 2);
                        break;
                    case Gravity.RIGHT:
                        childLeft = childrenLeft + this.mColumnWidth - w;
                        break;
                    default:
                        childLeft = childrenLeft;
                        break;
                }
                if (needToMeasure) {
                    const childRight = childLeft + w;
                    const childBottom = childTop + h;
                    child.layout(childLeft, childTop, childRight, childBottom);
                }
                else {
                    child.offsetLeftAndRight(childLeft - child.getLeft());
                    child.offsetTopAndBottom(childTop - child.getTop());
                }
                if (this.mCachingStarted) {
                    child.setDrawingCacheEnabled(true);
                }
                if (recycled && (child.getLayoutParams().scrappedFromPosition) != position) {
                    child.jumpDrawablesToCurrentState();
                }
                Trace.traceEnd(Trace.TRACE_TAG_VIEW);
            }
            setSelection(position) {
                if (!this.isInTouchMode()) {
                    this.setNextSelectedPositionInt(position);
                }
                else {
                    this.mResurrectToPosition = position;
                }
                this.mLayoutMode = GridView.LAYOUT_SET_SELECTION;
                if (this.mPositionScroller != null) {
                    this.mPositionScroller.stop();
                }
                this.requestLayout();
            }
            setSelectionInt(position) {
                let previousSelectedPosition = this.mNextSelectedPosition;
                if (this.mPositionScroller != null) {
                    this.mPositionScroller.stop();
                }
                this.setNextSelectedPositionInt(position);
                this.layoutChildren();
                const next = this.mStackFromBottom ? this.mItemCount - 1 - this.mNextSelectedPosition : this.mNextSelectedPosition;
                const previous = this.mStackFromBottom ? this.mItemCount - 1 - previousSelectedPosition : previousSelectedPosition;
                const nextRow = next / this.mNumColumns;
                const previousRow = previous / this.mNumColumns;
                if (nextRow != previousRow) {
                    this.awakenScrollBars();
                }
            }
            onKeyDown(keyCode, event) {
                return this.commonKey(keyCode, 1, event);
            }
            onKeyMultiple(keyCode, repeatCount, event) {
                return this.commonKey(keyCode, repeatCount, event);
            }
            onKeyUp(keyCode, event) {
                return this.commonKey(keyCode, 1, event);
            }
            commonKey(keyCode, count, event) {
                if (this.mAdapter == null) {
                    return false;
                }
                if (this.mDataChanged) {
                    this.layoutChildren();
                }
                let handled = false;
                let action = event.getAction();
                if (action != KeyEvent.ACTION_UP) {
                    switch (keyCode) {
                        case KeyEvent.KEYCODE_DPAD_LEFT:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded() || this.arrowScroll(GridView.FOCUS_LEFT);
                            }
                            break;
                        case KeyEvent.KEYCODE_DPAD_RIGHT:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded() || this.arrowScroll(GridView.FOCUS_RIGHT);
                            }
                            break;
                        case KeyEvent.KEYCODE_DPAD_UP:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded() || this.arrowScroll(GridView.FOCUS_UP);
                            }
                            else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
                                handled = this.resurrectSelectionIfNeeded() || this.fullScroll(GridView.FOCUS_UP);
                            }
                            break;
                        case KeyEvent.KEYCODE_DPAD_DOWN:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded() || this.arrowScroll(GridView.FOCUS_DOWN);
                            }
                            else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
                                handled = this.resurrectSelectionIfNeeded() || this.fullScroll(GridView.FOCUS_DOWN);
                            }
                            break;
                        case KeyEvent.KEYCODE_DPAD_CENTER:
                        case KeyEvent.KEYCODE_ENTER:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded();
                                if (!handled && event.getRepeatCount() == 0 && this.getChildCount() > 0) {
                                    this.keyPressed();
                                    handled = true;
                                }
                            }
                            break;
                        case KeyEvent.KEYCODE_SPACE:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded() || this.pageScroll(GridView.FOCUS_DOWN);
                            }
                            else if (event.hasModifiers(KeyEvent.META_SHIFT_ON)) {
                                handled = this.resurrectSelectionIfNeeded() || this.pageScroll(GridView.FOCUS_UP);
                            }
                            break;
                        case KeyEvent.KEYCODE_PAGE_UP:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded() || this.pageScroll(GridView.FOCUS_UP);
                            }
                            else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
                                handled = this.resurrectSelectionIfNeeded() || this.fullScroll(GridView.FOCUS_UP);
                            }
                            break;
                        case KeyEvent.KEYCODE_PAGE_DOWN:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded() || this.pageScroll(GridView.FOCUS_DOWN);
                            }
                            else if (event.hasModifiers(KeyEvent.META_ALT_ON)) {
                                handled = this.resurrectSelectionIfNeeded() || this.fullScroll(GridView.FOCUS_DOWN);
                            }
                            break;
                        case KeyEvent.KEYCODE_MOVE_HOME:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded() || this.fullScroll(GridView.FOCUS_UP);
                            }
                            break;
                        case KeyEvent.KEYCODE_MOVE_END:
                            if (event.hasNoModifiers()) {
                                handled = this.resurrectSelectionIfNeeded() || this.fullScroll(GridView.FOCUS_DOWN);
                            }
                            break;
                        case KeyEvent.KEYCODE_TAB:
                            if (false) {
                                if (event.hasNoModifiers()) {
                                    handled = this.resurrectSelectionIfNeeded() || this.sequenceScroll(GridView.FOCUS_FORWARD);
                                }
                                else if (event.hasModifiers(KeyEvent.META_SHIFT_ON)) {
                                    handled = this.resurrectSelectionIfNeeded() || this.sequenceScroll(GridView.FOCUS_BACKWARD);
                                }
                            }
                            break;
                    }
                }
                if (handled) {
                    return true;
                }
                switch (action) {
                    case KeyEvent.ACTION_DOWN:
                        return super.onKeyDown(keyCode, event);
                    case KeyEvent.ACTION_UP:
                        return super.onKeyUp(keyCode, event);
                    default:
                        return false;
                }
            }
            pageScroll(direction) {
                let nextPage = -1;
                if (direction == GridView.FOCUS_UP) {
                    nextPage = Math.max(0, this.mSelectedPosition - this.getChildCount());
                }
                else if (direction == GridView.FOCUS_DOWN) {
                    nextPage = Math.min(this.mItemCount - 1, this.mSelectedPosition + this.getChildCount());
                }
                if (nextPage >= 0) {
                    this.setSelectionInt(nextPage);
                    this.invokeOnItemScrollListener();
                    this.awakenScrollBars();
                    return true;
                }
                return false;
            }
            fullScroll(direction) {
                let moved = false;
                if (direction == GridView.FOCUS_UP) {
                    this.mLayoutMode = GridView.LAYOUT_SET_SELECTION;
                    this.setSelectionInt(0);
                    this.invokeOnItemScrollListener();
                    moved = true;
                }
                else if (direction == GridView.FOCUS_DOWN) {
                    this.mLayoutMode = GridView.LAYOUT_SET_SELECTION;
                    this.setSelectionInt(this.mItemCount - 1);
                    this.invokeOnItemScrollListener();
                    moved = true;
                }
                if (moved) {
                    this.awakenScrollBars();
                }
                return moved;
            }
            arrowScroll(direction) {
                const selectedPosition = this.mSelectedPosition;
                const numColumns = this.mNumColumns;
                let startOfRowPos;
                let endOfRowPos;
                let moved = false;
                if (!this.mStackFromBottom) {
                    startOfRowPos = Math.floor(selectedPosition / numColumns) * numColumns;
                    endOfRowPos = Math.min(startOfRowPos + numColumns - 1, this.mItemCount - 1);
                }
                else {
                    const invertedSelection = this.mItemCount - 1 - selectedPosition;
                    endOfRowPos = this.mItemCount - 1 - (invertedSelection / numColumns) * numColumns;
                    startOfRowPos = Math.max(0, endOfRowPos - numColumns + 1);
                }
                switch (direction) {
                    case GridView.FOCUS_UP:
                        if (startOfRowPos > 0) {
                            this.mLayoutMode = GridView.LAYOUT_MOVE_SELECTION;
                            this.setSelectionInt(Math.max(0, selectedPosition - numColumns));
                            moved = true;
                        }
                        break;
                    case GridView.FOCUS_DOWN:
                        if (endOfRowPos < this.mItemCount - 1) {
                            this.mLayoutMode = GridView.LAYOUT_MOVE_SELECTION;
                            this.setSelectionInt(Math.min(selectedPosition + numColumns, this.mItemCount - 1));
                            moved = true;
                        }
                        break;
                    case GridView.FOCUS_LEFT:
                        if (selectedPosition > startOfRowPos) {
                            this.mLayoutMode = GridView.LAYOUT_MOVE_SELECTION;
                            this.setSelectionInt(Math.max(0, selectedPosition - 1));
                            moved = true;
                        }
                        break;
                    case GridView.FOCUS_RIGHT:
                        if (selectedPosition < endOfRowPos) {
                            this.mLayoutMode = GridView.LAYOUT_MOVE_SELECTION;
                            this.setSelectionInt(Math.min(selectedPosition + 1, this.mItemCount - 1));
                            moved = true;
                        }
                        break;
                }
                if (moved) {
                    this.playSoundEffect(SoundEffectConstants.getContantForFocusDirection(direction));
                    this.invokeOnItemScrollListener();
                }
                if (moved) {
                    this.awakenScrollBars();
                }
                return moved;
            }
            sequenceScroll(direction) {
                let selectedPosition = this.mSelectedPosition;
                let numColumns = this.mNumColumns;
                let count = this.mItemCount;
                let startOfRow;
                let endOfRow;
                if (!this.mStackFromBottom) {
                    startOfRow = (selectedPosition / numColumns) * numColumns;
                    endOfRow = Math.min(startOfRow + numColumns - 1, count - 1);
                }
                else {
                    let invertedSelection = count - 1 - selectedPosition;
                    endOfRow = count - 1 - (invertedSelection / numColumns) * numColumns;
                    startOfRow = Math.max(0, endOfRow - numColumns + 1);
                }
                let moved = false;
                let showScroll = false;
                switch (direction) {
                    case GridView.FOCUS_FORWARD:
                        if (selectedPosition < count - 1) {
                            this.mLayoutMode = GridView.LAYOUT_MOVE_SELECTION;
                            this.setSelectionInt(selectedPosition + 1);
                            moved = true;
                            showScroll = selectedPosition == endOfRow;
                        }
                        break;
                    case GridView.FOCUS_BACKWARD:
                        if (selectedPosition > 0) {
                            this.mLayoutMode = GridView.LAYOUT_MOVE_SELECTION;
                            this.setSelectionInt(selectedPosition - 1);
                            moved = true;
                            showScroll = selectedPosition == startOfRow;
                        }
                        break;
                }
                if (moved) {
                    this.playSoundEffect(SoundEffectConstants.getContantForFocusDirection(direction));
                    this.invokeOnItemScrollListener();
                }
                if (showScroll) {
                    this.awakenScrollBars();
                }
                return moved;
            }
            onFocusChanged(gainFocus, direction, previouslyFocusedRect) {
                super.onFocusChanged(gainFocus, direction, previouslyFocusedRect);
                let closestChildIndex = -1;
                if (gainFocus && previouslyFocusedRect != null) {
                    previouslyFocusedRect.offset(this.mScrollX, this.mScrollY);
                    let otherRect = this.mTempRect;
                    let minDistance = Integer.MAX_VALUE;
                    const childCount = this.getChildCount();
                    for (let i = 0; i < childCount; i++) {
                        if (!this.isCandidateSelection(i, direction)) {
                            continue;
                        }
                        const other = this.getChildAt(i);
                        other.getDrawingRect(otherRect);
                        this.offsetDescendantRectToMyCoords(other, otherRect);
                        let distance = GridView.getDistance(previouslyFocusedRect, otherRect, direction);
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestChildIndex = i;
                        }
                    }
                }
                if (closestChildIndex >= 0) {
                    this.setSelection(closestChildIndex + this.mFirstPosition);
                }
                else {
                    this.requestLayout();
                }
            }
            isCandidateSelection(childIndex, direction) {
                const count = this.getChildCount();
                const invertedIndex = count - 1 - childIndex;
                let rowStart;
                let rowEnd;
                if (!this.mStackFromBottom) {
                    rowStart = childIndex - (childIndex % this.mNumColumns);
                    rowEnd = Math.max(rowStart + this.mNumColumns - 1, count);
                }
                else {
                    rowEnd = count - 1 - (invertedIndex - (invertedIndex % this.mNumColumns));
                    rowStart = Math.max(0, rowEnd - this.mNumColumns + 1);
                }
                switch (direction) {
                    case View.FOCUS_RIGHT:
                        return childIndex == rowStart;
                    case View.FOCUS_DOWN:
                        return rowStart == 0;
                    case View.FOCUS_LEFT:
                        return childIndex == rowEnd;
                    case View.FOCUS_UP:
                        return rowEnd == count - 1;
                    case View.FOCUS_FORWARD:
                        return childIndex == rowStart && rowStart == 0;
                    case View.FOCUS_BACKWARD:
                        return childIndex == rowEnd && rowEnd == count - 1;
                    default:
                        throw Error(`new IllegalArgumentException("direction must be one of " + "{FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT, " + "FOCUS_FORWARD, FOCUS_BACKWARD}.")`);
                }
            }
            setGravity(gravity) {
                if (this.mGravity != gravity) {
                    this.mGravity = gravity;
                    this.requestLayoutIfNecessary();
                }
            }
            getGravity() {
                return this.mGravity;
            }
            setHorizontalSpacing(horizontalSpacing) {
                if (horizontalSpacing != this.mRequestedHorizontalSpacing) {
                    this.mRequestedHorizontalSpacing = horizontalSpacing;
                    this.requestLayoutIfNecessary();
                }
            }
            getHorizontalSpacing() {
                return this.mHorizontalSpacing;
            }
            getRequestedHorizontalSpacing() {
                return this.mRequestedHorizontalSpacing;
            }
            setVerticalSpacing(verticalSpacing) {
                if (verticalSpacing != this.mVerticalSpacing) {
                    this.mVerticalSpacing = verticalSpacing;
                    this.requestLayoutIfNecessary();
                }
            }
            getVerticalSpacing() {
                return this.mVerticalSpacing;
            }
            setStretchMode(stretchMode) {
                if (stretchMode != this.mStretchMode) {
                    this.mStretchMode = stretchMode;
                    this.requestLayoutIfNecessary();
                }
            }
            getStretchMode() {
                return this.mStretchMode;
            }
            setColumnWidth(columnWidth) {
                if (columnWidth != this.mRequestedColumnWidth) {
                    this.mRequestedColumnWidth = columnWidth;
                    this.requestLayoutIfNecessary();
                }
            }
            getColumnWidth() {
                return this.mColumnWidth;
            }
            getRequestedColumnWidth() {
                return this.mRequestedColumnWidth;
            }
            setNumColumns(numColumns) {
                if (numColumns != this.mRequestedNumColumns) {
                    this.mRequestedNumColumns = numColumns;
                    this.requestLayoutIfNecessary();
                }
            }
            getNumColumns() {
                return this.mNumColumns;
            }
            adjustViewsUpOrDown() {
                const childCount = this.getChildCount();
                if (childCount > 0) {
                    let delta;
                    let child;
                    if (!this.mStackFromBottom) {
                        child = this.getChildAt(0);
                        delta = child.getTop() - this.mListPadding.top;
                        if (this.mFirstPosition != 0) {
                            delta -= this.mVerticalSpacing;
                        }
                        if (delta < 0) {
                            delta = 0;
                        }
                    }
                    else {
                        child = this.getChildAt(childCount - 1);
                        delta = child.getBottom() - (this.getHeight() - this.mListPadding.bottom);
                        if (this.mFirstPosition + childCount < this.mItemCount) {
                            delta += this.mVerticalSpacing;
                        }
                        if (delta > 0) {
                            delta = 0;
                        }
                    }
                    if (delta != 0) {
                        this.offsetChildrenTopAndBottom(-delta);
                    }
                }
            }
            computeVerticalScrollExtent() {
                const count = this.getChildCount();
                if (count > 0) {
                    const numColumns = this.mNumColumns;
                    const rowCount = (count + numColumns - 1) / numColumns;
                    let extent = rowCount * 100;
                    let view = this.getChildAt(0);
                    const top = view.getTop();
                    let height = view.getHeight();
                    if (height > 0) {
                        extent += (top * 100) / height;
                    }
                    view = this.getChildAt(count - 1);
                    const bottom = view.getBottom();
                    height = view.getHeight();
                    if (height > 0) {
                        extent -= ((bottom - this.getHeight()) * 100) / height;
                    }
                    return extent;
                }
                return 0;
            }
            computeVerticalScrollOffset() {
                if (this.mFirstPosition >= 0 && this.getChildCount() > 0) {
                    const view = this.getChildAt(0);
                    const top = view.getTop();
                    let height = view.getHeight();
                    if (height > 0) {
                        const numColumns = this.mNumColumns;
                        const rowCount = (this.mItemCount + numColumns - 1) / numColumns;
                        const oddItemsOnFirstRow = this.isStackFromBottom() ? ((rowCount * numColumns) - this.mItemCount) : 0;
                        const whichRow = (this.mFirstPosition + oddItemsOnFirstRow) / numColumns;
                        return Math.max(whichRow * 100 - (top * 100) / height + Math.floor((this.mScrollY / this.getHeight() * rowCount * 100)), 0);
                    }
                }
                return 0;
            }
            computeVerticalScrollRange() {
                const numColumns = this.mNumColumns;
                const rowCount = (this.mItemCount + numColumns - 1) / numColumns;
                let result = Math.max(rowCount * 100, 0);
                if (this.mScrollY != 0) {
                    result += Math.abs(Math.floor((this.mScrollY / this.getHeight() * rowCount * 100)));
                }
                return result;
            }
        }
        GridView.NO_STRETCH = 0;
        GridView.STRETCH_SPACING = 1;
        GridView.STRETCH_COLUMN_WIDTH = 2;
        GridView.STRETCH_SPACING_UNIFORM = 3;
        GridView.AUTO_FIT = -1;
        widget.GridView = GridView;
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../android/graphics/Canvas.ts"/>
///<reference path="../../android/graphics/Rect.ts"/>
///<reference path="../../android/util/Log.ts"/>
///<reference path="../../android/view/FocusFinder.ts"/>
///<reference path="../../android/view/KeyEvent.ts"/>
///<reference path="../../android/view/MotionEvent.ts"/>
///<reference path="../../android/view/VelocityTracker.ts"/>
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewConfiguration.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../android/view/ViewParent.ts"/>
///<reference path="../../android/view/animation/AnimationUtils.ts"/>
///<reference path="../../java/util/List.ts"/>
///<reference path="../../java/lang/Integer.ts"/>
///<reference path="../../java/lang/System.ts"/>
///<reference path="../../android/widget/FrameLayout.ts"/>
///<reference path="../../android/widget/LinearLayout.ts"/>
///<reference path="../../android/widget/ListView.ts"/>
///<reference path="../../android/widget/OverScroller.ts"/>
///<reference path="../../android/widget/ScrollView.ts"/>
///<reference path="../../android/widget/TextView.ts"/>
var android;
(function (android) {
    var widget;
    (function (widget) {
        var Rect = android.graphics.Rect;
        var Log = android.util.Log;
        var FocusFinder = android.view.FocusFinder;
        var KeyEvent = android.view.KeyEvent;
        var MotionEvent = android.view.MotionEvent;
        var VelocityTracker = android.view.VelocityTracker;
        var View = android.view.View;
        var ViewConfiguration = android.view.ViewConfiguration;
        var ViewGroup = android.view.ViewGroup;
        var AnimationUtils = android.view.animation.AnimationUtils;
        var FrameLayout = android.widget.FrameLayout;
        var OverScroller = android.widget.OverScroller;
        var ScrollView = android.widget.ScrollView;
        class HorizontalScrollView extends FrameLayout {
            constructor() {
                super();
                this.mLastScroll = 0;
                this.mTempRect = new Rect();
                this.mLastMotionX = 0;
                this.mIsLayoutDirty = true;
                this.mChildToScrollTo = null;
                this.mIsBeingDragged = false;
                this.mSmoothScrollingEnabled = true;
                this.mMinimumVelocity = 0;
                this.mMaximumVelocity = 0;
                this.mOverscrollDistance = 0;
                this._mOverflingDistance = 0;
                this.mActivePointerId = HorizontalScrollView.INVALID_POINTER;
                this.initScrollView();
            }
            get mOverflingDistance() {
                if (this.mScrollX < -this._mOverflingDistance)
                    return -this.mScrollX;
                let overDistance = this.mScrollX - this.getScrollRange();
                if (overDistance > this._mOverflingDistance)
                    return overDistance;
                return this._mOverflingDistance;
            }
            set mOverflingDistance(value) {
                this._mOverflingDistance = value;
            }
            createAttrChangeHandler(mergeHandler) {
                super.createAttrChangeHandler(mergeHandler);
                let scrollView = this;
                mergeHandler.add({
                    set fillViewport(value) {
                        scrollView.setFillViewport(View.AttrChangeHandler.parseBoolean(value));
                    },
                    get fillViewport() {
                        return scrollView.mFillViewport;
                    }
                });
            }
            getLeftFadingEdgeStrength() {
                if (this.getChildCount() == 0) {
                    return 0.0;
                }
                const length = this.getHorizontalFadingEdgeLength();
                if (this.mScrollX < length) {
                    return this.mScrollX / length;
                }
                return 1.0;
            }
            getRightFadingEdgeStrength() {
                if (this.getChildCount() == 0) {
                    return 0.0;
                }
                const length = this.getHorizontalFadingEdgeLength();
                const rightEdge = this.getWidth() - this.mPaddingRight;
                const span = this.getChildAt(0).getRight() - this.mScrollX - rightEdge;
                if (span < length) {
                    return span / length;
                }
                return 1.0;
            }
            getMaxScrollAmount() {
                return Math.floor((HorizontalScrollView.MAX_SCROLL_FACTOR * (this.mRight - this.mLeft)));
            }
            initScrollView() {
                this.mScroller = new OverScroller();
                this.setFocusable(true);
                this.setDescendantFocusability(HorizontalScrollView.FOCUS_AFTER_DESCENDANTS);
                this.setWillNotDraw(false);
                const configuration = ViewConfiguration.get();
                this.mTouchSlop = configuration.getScaledTouchSlop();
                this.mMinimumVelocity = configuration.getScaledMinimumFlingVelocity();
                this.mMaximumVelocity = configuration.getScaledMaximumFlingVelocity();
                this.mOverscrollDistance = configuration.getScaledOverscrollDistance();
                this._mOverflingDistance = configuration.getScaledOverflingDistance();
                this.initScrollCache();
                this.setHorizontalScrollBarEnabled(true);
            }
            addView(...args) {
                if (this.getChildCount() > 0) {
                    throw new Error("ScrollView can host only one direct child");
                }
                return super.addView(...args);
            }
            canScroll() {
                let child = this.getChildAt(0);
                if (child != null) {
                    let childWidth = child.getWidth();
                    return this.getWidth() < childWidth + this.mPaddingLeft + this.mPaddingRight;
                }
                return false;
            }
            isFillViewport() {
                return this.mFillViewport;
            }
            setFillViewport(fillViewport) {
                if (fillViewport != this.mFillViewport) {
                    this.mFillViewport = fillViewport;
                    this.requestLayout();
                }
            }
            isSmoothScrollingEnabled() {
                return this.mSmoothScrollingEnabled;
            }
            setSmoothScrollingEnabled(smoothScrollingEnabled) {
                this.mSmoothScrollingEnabled = smoothScrollingEnabled;
            }
            onMeasure(widthMeasureSpec, heightMeasureSpec) {
                super.onMeasure(widthMeasureSpec, heightMeasureSpec);
                if (!this.mFillViewport) {
                    return;
                }
                const widthMode = HorizontalScrollView.MeasureSpec.getMode(widthMeasureSpec);
                if (widthMode == HorizontalScrollView.MeasureSpec.UNSPECIFIED) {
                    return;
                }
                if (this.getChildCount() > 0) {
                    const child = this.getChildAt(0);
                    let width = this.getMeasuredWidth();
                    if (child.getMeasuredWidth() < width) {
                        const lp = child.getLayoutParams();
                        let childHeightMeasureSpec = HorizontalScrollView.getChildMeasureSpec(heightMeasureSpec, this.mPaddingTop + this.mPaddingBottom, lp.height);
                        width -= this.mPaddingLeft;
                        width -= this.mPaddingRight;
                        let childWidthMeasureSpec = HorizontalScrollView.MeasureSpec.makeMeasureSpec(width, HorizontalScrollView.MeasureSpec.EXACTLY);
                        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
                    }
                }
            }
            dispatchKeyEvent(event) {
                return super.dispatchKeyEvent(event) || this.executeKeyEvent(event);
            }
            executeKeyEvent(event) {
                this.mTempRect.setEmpty();
                if (!this.canScroll()) {
                    if (this.isFocused()) {
                        let currentFocused = this.findFocus();
                        if (currentFocused == this)
                            currentFocused = null;
                        let nextFocused = FocusFinder.getInstance().findNextFocus(this, currentFocused, View.FOCUS_RIGHT);
                        return nextFocused != null && nextFocused != this && nextFocused.requestFocus(View.FOCUS_RIGHT);
                    }
                    return false;
                }
                let handled = false;
                if (event.getAction() == KeyEvent.ACTION_DOWN) {
                    switch (event.getKeyCode()) {
                        case KeyEvent.KEYCODE_DPAD_LEFT:
                            if (!event.isAltPressed()) {
                                handled = this.arrowScroll(View.FOCUS_LEFT);
                            }
                            else {
                                handled = this.fullScroll(View.FOCUS_LEFT);
                            }
                            break;
                        case KeyEvent.KEYCODE_DPAD_RIGHT:
                            if (!event.isAltPressed()) {
                                handled = this.arrowScroll(View.FOCUS_RIGHT);
                            }
                            else {
                                handled = this.fullScroll(View.FOCUS_RIGHT);
                            }
                            break;
                        case KeyEvent.KEYCODE_SPACE:
                            this.pageScroll(event.isShiftPressed() ? View.FOCUS_LEFT : View.FOCUS_RIGHT);
                            break;
                    }
                }
                return handled;
            }
            inChild(x, y) {
                if (this.getChildCount() > 0) {
                    const scrollX = this.mScrollX;
                    const child = this.getChildAt(0);
                    return !(y < child.getTop() || y >= child.getBottom() || x < child.getLeft() - scrollX || x >= child.getRight() - scrollX);
                }
                return false;
            }
            initOrResetVelocityTracker() {
                if (this.mVelocityTracker == null) {
                    this.mVelocityTracker = VelocityTracker.obtain();
                }
                else {
                    this.mVelocityTracker.clear();
                }
            }
            initVelocityTrackerIfNotExists() {
                if (this.mVelocityTracker == null) {
                    this.mVelocityTracker = VelocityTracker.obtain();
                }
            }
            recycleVelocityTracker() {
                if (this.mVelocityTracker != null) {
                    this.mVelocityTracker.recycle();
                    this.mVelocityTracker = null;
                }
            }
            requestDisallowInterceptTouchEvent(disallowIntercept) {
                if (disallowIntercept) {
                    this.recycleVelocityTracker();
                }
                super.requestDisallowInterceptTouchEvent(disallowIntercept);
            }
            onInterceptTouchEvent(ev) {
                const action = ev.getAction();
                if ((action == MotionEvent.ACTION_MOVE) && (this.mIsBeingDragged)) {
                    return true;
                }
                switch (action & MotionEvent.ACTION_MASK) {
                    case MotionEvent.ACTION_MOVE:
                        {
                            const activePointerId = this.mActivePointerId;
                            if (activePointerId == HorizontalScrollView.INVALID_POINTER) {
                                break;
                            }
                            const pointerIndex = ev.findPointerIndex(activePointerId);
                            if (pointerIndex == -1) {
                                Log.e(HorizontalScrollView.TAG, "Invalid pointerId=" + activePointerId + " in onInterceptTouchEvent");
                                break;
                            }
                            const x = Math.floor(ev.getX(pointerIndex));
                            const xDiff = Math.floor(Math.abs(x - this.mLastMotionX));
                            if (xDiff > this.mTouchSlop) {
                                this.mIsBeingDragged = true;
                                this.mLastMotionX = x;
                                this.initVelocityTrackerIfNotExists();
                                this.mVelocityTracker.addMovement(ev);
                                if (this.mParent != null)
                                    this.mParent.requestDisallowInterceptTouchEvent(true);
                            }
                            break;
                        }
                    case MotionEvent.ACTION_DOWN:
                        {
                            const x = Math.floor(ev.getX());
                            if (!this.inChild(Math.floor(x), Math.floor(ev.getY()))) {
                                this.mIsBeingDragged = false;
                                this.recycleVelocityTracker();
                                break;
                            }
                            this.mLastMotionX = x;
                            this.mActivePointerId = ev.getPointerId(0);
                            this.initOrResetVelocityTracker();
                            this.mVelocityTracker.addMovement(ev);
                            this.mIsBeingDragged = !this.mScroller.isFinished();
                            break;
                        }
                    case MotionEvent.ACTION_CANCEL:
                    case MotionEvent.ACTION_UP:
                        this.mIsBeingDragged = false;
                        this.mActivePointerId = HorizontalScrollView.INVALID_POINTER;
                        if (this.mScroller.springBack(this.mScrollX, this.mScrollY, 0, this.getScrollRange(), 0, 0)) {
                            this.postInvalidateOnAnimation();
                        }
                        break;
                    case MotionEvent.ACTION_POINTER_DOWN:
                        {
                            const index = ev.getActionIndex();
                            this.mLastMotionX = Math.floor(ev.getX(index));
                            this.mActivePointerId = ev.getPointerId(index);
                            break;
                        }
                    case MotionEvent.ACTION_POINTER_UP:
                        this.onSecondaryPointerUp(ev);
                        this.mLastMotionX = Math.floor(ev.getX(ev.findPointerIndex(this.mActivePointerId)));
                        break;
                }
                return this.mIsBeingDragged;
            }
            onTouchEvent(ev) {
                this.initVelocityTrackerIfNotExists();
                this.mVelocityTracker.addMovement(ev);
                const action = ev.getAction();
                switch (action & MotionEvent.ACTION_MASK) {
                    case MotionEvent.ACTION_DOWN:
                        {
                            if (this.getChildCount() == 0) {
                                return false;
                            }
                            if ((this.mIsBeingDragged = !this.mScroller.isFinished())) {
                                const parent = this.getParent();
                                if (parent != null) {
                                    parent.requestDisallowInterceptTouchEvent(true);
                                }
                            }
                            if (!this.mScroller.isFinished()) {
                                this.mScroller.abortAnimation();
                            }
                            this.mLastMotionX = Math.floor(ev.getX());
                            this.mActivePointerId = ev.getPointerId(0);
                            break;
                        }
                    case MotionEvent.ACTION_MOVE:
                        const activePointerIndex = ev.findPointerIndex(this.mActivePointerId);
                        if (activePointerIndex == -1) {
                            Log.e(HorizontalScrollView.TAG, "Invalid pointerId=" + this.mActivePointerId + " in onTouchEvent");
                            break;
                        }
                        const x = Math.floor(ev.getX(activePointerIndex));
                        let deltaX = this.mLastMotionX - x;
                        if (!this.mIsBeingDragged && Math.abs(deltaX) > this.mTouchSlop) {
                            const parent = this.getParent();
                            if (parent != null) {
                                parent.requestDisallowInterceptTouchEvent(true);
                            }
                            this.mIsBeingDragged = true;
                            if (deltaX > 0) {
                                deltaX -= this.mTouchSlop;
                            }
                            else {
                                deltaX += this.mTouchSlop;
                            }
                        }
                        if (this.mIsBeingDragged) {
                            this.mLastMotionX = x;
                            const oldX = this.mScrollX;
                            const oldY = this.mScrollY;
                            const range = this.getScrollRange();
                            const overscrollMode = this.getOverScrollMode();
                            const canOverscroll = overscrollMode == HorizontalScrollView.OVER_SCROLL_ALWAYS || (overscrollMode == HorizontalScrollView.OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
                            if (this.overScrollBy(deltaX, 0, this.mScrollX, 0, range, 0, this.mOverscrollDistance, 0, true)) {
                                this.mVelocityTracker.clear();
                            }
                            if (canOverscroll) {
                            }
                        }
                        break;
                    case MotionEvent.ACTION_UP:
                        if (this.mIsBeingDragged) {
                            const velocityTracker = this.mVelocityTracker;
                            velocityTracker.computeCurrentVelocity(1000, this.mMaximumVelocity);
                            let initialVelocity = Math.floor(velocityTracker.getXVelocity(this.mActivePointerId));
                            if (this.getChildCount() > 0) {
                                let isOverDrag = this.mScrollX < 0 || this.mScrollX > this.getScrollRange();
                                if (!isOverDrag && (Math.abs(initialVelocity) > this.mMinimumVelocity)) {
                                    this.fling(-initialVelocity);
                                }
                                else {
                                    if (this.mScroller.springBack(this.mScrollX, this.mScrollY, 0, this.getScrollRange(), 0, 0)) {
                                        this.postInvalidateOnAnimation();
                                    }
                                }
                            }
                            this.mActivePointerId = HorizontalScrollView.INVALID_POINTER;
                            this.mIsBeingDragged = false;
                            this.recycleVelocityTracker();
                        }
                        break;
                    case MotionEvent.ACTION_CANCEL:
                        if (this.mIsBeingDragged && this.getChildCount() > 0) {
                            if (this.mScroller.springBack(this.mScrollX, this.mScrollY, 0, this.getScrollRange(), 0, 0)) {
                                this.postInvalidateOnAnimation();
                            }
                            this.mActivePointerId = HorizontalScrollView.INVALID_POINTER;
                            this.mIsBeingDragged = false;
                            this.recycleVelocityTracker();
                        }
                        break;
                    case MotionEvent.ACTION_POINTER_UP:
                        this.onSecondaryPointerUp(ev);
                        break;
                }
                return true;
            }
            onSecondaryPointerUp(ev) {
                const pointerIndex = (ev.getAction() & MotionEvent.ACTION_POINTER_INDEX_MASK) >> MotionEvent.ACTION_POINTER_INDEX_SHIFT;
                const pointerId = ev.getPointerId(pointerIndex);
                if (pointerId == this.mActivePointerId) {
                    const newPointerIndex = pointerIndex == 0 ? 1 : 0;
                    this.mLastMotionX = Math.floor(ev.getX(newPointerIndex));
                    this.mActivePointerId = ev.getPointerId(newPointerIndex);
                    if (this.mVelocityTracker != null) {
                        this.mVelocityTracker.clear();
                    }
                }
            }
            onGenericMotionEvent(event) {
                if (event.isPointerEvent()) {
                    switch (event.getAction()) {
                        case MotionEvent.ACTION_SCROLL:
                            {
                                if (!this.mIsBeingDragged) {
                                    let hscroll;
                                    hscroll = event.getAxisValue(MotionEvent.AXIS_HSCROLL);
                                    if (hscroll != 0) {
                                        const delta = Math.floor((hscroll * this.getHorizontalScrollFactor()));
                                        const range = this.getScrollRange();
                                        let oldScrollX = this.mScrollX;
                                        let newScrollX = oldScrollX + delta;
                                        if (newScrollX < 0) {
                                            newScrollX = 0;
                                        }
                                        else if (newScrollX > range) {
                                            newScrollX = range;
                                        }
                                        if (newScrollX != oldScrollX) {
                                            super.scrollTo(newScrollX, this.mScrollY);
                                            return true;
                                        }
                                    }
                                }
                            }
                    }
                }
                return super.onGenericMotionEvent(event);
            }
            shouldDelayChildPressedState() {
                return true;
            }
            onOverScrolled(scrollX, scrollY, clampedX, clampedY) {
                if (!this.mScroller.isFinished()) {
                    const oldX = this.mScrollX;
                    const oldY = this.mScrollY;
                    this.mScrollX = scrollX;
                    this.mScrollY = scrollY;
                    this.invalidateParentIfNeeded();
                    this.onScrollChanged(this.mScrollX, this.mScrollY, oldX, oldY);
                    if (clampedX) {
                        this.mScroller.springBack(this.mScrollX, this.mScrollY, 0, this.getScrollRange(), 0, 0);
                    }
                }
                else {
                    super.scrollTo(scrollX, scrollY);
                }
                this.awakenScrollBars();
            }
            getScrollRange() {
                let scrollRange = 0;
                if (this.getChildCount() > 0) {
                    let child = this.getChildAt(0);
                    scrollRange = Math.max(0, child.getWidth() - (this.getWidth() - this.mPaddingLeft - this.mPaddingRight));
                }
                return scrollRange;
            }
            findFocusableViewInMyBounds(leftFocus, left, preferredFocusable) {
                const fadingEdgeLength = this.getHorizontalFadingEdgeLength() / 2;
                const leftWithoutFadingEdge = left + fadingEdgeLength;
                const rightWithoutFadingEdge = left + this.getWidth() - fadingEdgeLength;
                if ((preferredFocusable != null) && (preferredFocusable.getLeft() < rightWithoutFadingEdge) && (preferredFocusable.getRight() > leftWithoutFadingEdge)) {
                    return preferredFocusable;
                }
                return this.findFocusableViewInBounds(leftFocus, leftWithoutFadingEdge, rightWithoutFadingEdge);
            }
            findFocusableViewInBounds(leftFocus, left, right) {
                let focusables = this.getFocusables(View.FOCUS_FORWARD);
                let focusCandidate = null;
                let foundFullyContainedFocusable = false;
                let count = focusables.size();
                for (let i = 0; i < count; i++) {
                    let view = focusables.get(i);
                    let viewLeft = view.getLeft();
                    let viewRight = view.getRight();
                    if (left < viewRight && viewLeft < right) {
                        const viewIsFullyContained = (left < viewLeft) && (viewRight < right);
                        if (focusCandidate == null) {
                            focusCandidate = view;
                            foundFullyContainedFocusable = viewIsFullyContained;
                        }
                        else {
                            const viewIsCloserToBoundary = (leftFocus && viewLeft < focusCandidate.getLeft()) || (!leftFocus && viewRight > focusCandidate.getRight());
                            if (foundFullyContainedFocusable) {
                                if (viewIsFullyContained && viewIsCloserToBoundary) {
                                    focusCandidate = view;
                                }
                            }
                            else {
                                if (viewIsFullyContained) {
                                    focusCandidate = view;
                                    foundFullyContainedFocusable = true;
                                }
                                else if (viewIsCloserToBoundary) {
                                    focusCandidate = view;
                                }
                            }
                        }
                    }
                }
                return focusCandidate;
            }
            pageScroll(direction) {
                let right = direction == View.FOCUS_RIGHT;
                let width = this.getWidth();
                if (right) {
                    this.mTempRect.left = this.getScrollX() + width;
                    let count = this.getChildCount();
                    if (count > 0) {
                        let view = this.getChildAt(0);
                        if (this.mTempRect.left + width > view.getRight()) {
                            this.mTempRect.left = view.getRight() - width;
                        }
                    }
                }
                else {
                    this.mTempRect.left = this.getScrollX() - width;
                    if (this.mTempRect.left < 0) {
                        this.mTempRect.left = 0;
                    }
                }
                this.mTempRect.right = this.mTempRect.left + width;
                return this.scrollAndFocus(direction, this.mTempRect.left, this.mTempRect.right);
            }
            fullScroll(direction) {
                let right = direction == View.FOCUS_RIGHT;
                let width = this.getWidth();
                this.mTempRect.left = 0;
                this.mTempRect.right = width;
                if (right) {
                    let count = this.getChildCount();
                    if (count > 0) {
                        let view = this.getChildAt(0);
                        this.mTempRect.right = view.getRight();
                        this.mTempRect.left = this.mTempRect.right - width;
                    }
                }
                return this.scrollAndFocus(direction, this.mTempRect.left, this.mTempRect.right);
            }
            scrollAndFocus(direction, left, right) {
                let handled = true;
                let width = this.getWidth();
                let containerLeft = this.getScrollX();
                let containerRight = containerLeft + width;
                let goLeft = direction == View.FOCUS_LEFT;
                let newFocused = this.findFocusableViewInBounds(goLeft, left, right);
                if (newFocused == null) {
                    newFocused = this;
                }
                if (left >= containerLeft && right <= containerRight) {
                    handled = false;
                }
                else {
                    let delta = goLeft ? (left - containerLeft) : (right - containerRight);
                    this.doScrollX(delta);
                }
                if (newFocused != this.findFocus())
                    newFocused.requestFocus(direction);
                return handled;
            }
            arrowScroll(direction) {
                let currentFocused = this.findFocus();
                if (currentFocused == this)
                    currentFocused = null;
                let nextFocused = FocusFinder.getInstance().findNextFocus(this, currentFocused, direction);
                const maxJump = this.getMaxScrollAmount();
                if (nextFocused != null && this.isWithinDeltaOfScreen(nextFocused, maxJump)) {
                    nextFocused.getDrawingRect(this.mTempRect);
                    this.offsetDescendantRectToMyCoords(nextFocused, this.mTempRect);
                    let scrollDelta = this.computeScrollDeltaToGetChildRectOnScreen(this.mTempRect);
                    this.doScrollX(scrollDelta);
                    nextFocused.requestFocus(direction);
                }
                else {
                    let scrollDelta = maxJump;
                    if (direction == View.FOCUS_LEFT && this.getScrollX() < scrollDelta) {
                        scrollDelta = this.getScrollX();
                    }
                    else if (direction == View.FOCUS_RIGHT && this.getChildCount() > 0) {
                        let daRight = this.getChildAt(0).getRight();
                        let screenRight = this.getScrollX() + this.getWidth();
                        if (daRight - screenRight < maxJump) {
                            scrollDelta = daRight - screenRight;
                        }
                    }
                    if (scrollDelta == 0) {
                        return false;
                    }
                    this.doScrollX(direction == View.FOCUS_RIGHT ? scrollDelta : -scrollDelta);
                }
                if (currentFocused != null && currentFocused.isFocused() && this.isOffScreen(currentFocused)) {
                    const descendantFocusability = this.getDescendantFocusability();
                    this.setDescendantFocusability(ViewGroup.FOCUS_BEFORE_DESCENDANTS);
                    this.requestFocus();
                    this.setDescendantFocusability(descendantFocusability);
                }
                return true;
            }
            isOffScreen(descendant) {
                return !this.isWithinDeltaOfScreen(descendant, 0);
            }
            isWithinDeltaOfScreen(descendant, delta) {
                descendant.getDrawingRect(this.mTempRect);
                this.offsetDescendantRectToMyCoords(descendant, this.mTempRect);
                return (this.mTempRect.right + delta) >= this.getScrollX() && (this.mTempRect.left - delta) <= (this.getScrollX() + this.getWidth());
            }
            doScrollX(delta) {
                if (delta != 0) {
                    if (this.mSmoothScrollingEnabled) {
                        this.smoothScrollBy(delta, 0);
                    }
                    else {
                        this.scrollBy(delta, 0);
                    }
                }
            }
            smoothScrollBy(dx, dy) {
                if (this.getChildCount() == 0) {
                    return;
                }
                let duration = AnimationUtils.currentAnimationTimeMillis() - this.mLastScroll;
                if (duration > HorizontalScrollView.ANIMATED_SCROLL_GAP) {
                    const width = this.getWidth() - this.mPaddingRight - this.mPaddingLeft;
                    const right = this.getChildAt(0).getWidth();
                    const maxX = Math.max(0, right - width);
                    const scrollX = this.mScrollX;
                    dx = Math.max(0, Math.min(scrollX + dx, maxX)) - scrollX;
                    this.mScroller.startScroll(scrollX, this.mScrollY, dx, 0);
                    this.postInvalidateOnAnimation();
                }
                else {
                    if (!this.mScroller.isFinished()) {
                        this.mScroller.abortAnimation();
                    }
                    this.scrollBy(dx, dy);
                }
                this.mLastScroll = AnimationUtils.currentAnimationTimeMillis();
            }
            smoothScrollTo(x, y) {
                this.smoothScrollBy(x - this.mScrollX, y - this.mScrollY);
            }
            computeHorizontalScrollRange() {
                const count = this.getChildCount();
                const contentWidth = this.getWidth() - this.mPaddingLeft - this.mPaddingRight;
                if (count == 0) {
                    return contentWidth;
                }
                let scrollRange = this.getChildAt(0).getRight();
                const scrollX = this.mScrollX;
                const overscrollRight = Math.max(0, scrollRange - contentWidth);
                if (scrollX < 0) {
                    scrollRange -= scrollX;
                }
                else if (scrollX > overscrollRight) {
                    scrollRange += scrollX - overscrollRight;
                }
                return scrollRange;
            }
            computeHorizontalScrollOffset() {
                return Math.max(0, super.computeHorizontalScrollOffset());
            }
            measureChild(child, parentWidthMeasureSpec, parentHeightMeasureSpec) {
                let lp = child.getLayoutParams();
                let childWidthMeasureSpec;
                let childHeightMeasureSpec;
                childHeightMeasureSpec = HorizontalScrollView.getChildMeasureSpec(parentHeightMeasureSpec, this.mPaddingTop + this.mPaddingBottom, lp.height);
                childWidthMeasureSpec = HorizontalScrollView.MeasureSpec.makeMeasureSpec(0, HorizontalScrollView.MeasureSpec.UNSPECIFIED);
                child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
            }
            measureChildWithMargins(child, parentWidthMeasureSpec, widthUsed, parentHeightMeasureSpec, heightUsed) {
                const lp = child.getLayoutParams();
                const childHeightMeasureSpec = HorizontalScrollView.getChildMeasureSpec(parentHeightMeasureSpec, this.mPaddingTop + this.mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height);
                const childWidthMeasureSpec = HorizontalScrollView.MeasureSpec.makeMeasureSpec(lp.leftMargin + lp.rightMargin, HorizontalScrollView.MeasureSpec.UNSPECIFIED);
                child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
            }
            computeScroll() {
                if (this.mScroller.computeScrollOffset()) {
                    let oldX = this.mScrollX;
                    let oldY = this.mScrollY;
                    let x = this.mScroller.getCurrX();
                    let y = this.mScroller.getCurrY();
                    if (oldX != x || oldY != y) {
                        const range = this.getScrollRange();
                        const overscrollMode = this.getOverScrollMode();
                        const canOverscroll = overscrollMode == HorizontalScrollView.OVER_SCROLL_ALWAYS || (overscrollMode == HorizontalScrollView.OVER_SCROLL_IF_CONTENT_SCROLLS && range > 0);
                        this.overScrollBy(x - oldX, y - oldY, oldX, oldY, range, 0, this.mOverflingDistance, 0, false);
                        this.onScrollChanged(this.mScrollX, this.mScrollY, oldX, oldY);
                        if (canOverscroll) {
                        }
                    }
                    if (!this.awakenScrollBars()) {
                        this.postInvalidateOnAnimation();
                    }
                }
            }
            scrollToChild(child) {
                child.getDrawingRect(this.mTempRect);
                this.offsetDescendantRectToMyCoords(child, this.mTempRect);
                let scrollDelta = this.computeScrollDeltaToGetChildRectOnScreen(this.mTempRect);
                if (scrollDelta != 0) {
                    this.scrollBy(scrollDelta, 0);
                }
            }
            scrollToChildRect(rect, immediate) {
                const delta = this.computeScrollDeltaToGetChildRectOnScreen(rect);
                const scroll = delta != 0;
                if (scroll) {
                    if (immediate) {
                        this.scrollBy(delta, 0);
                    }
                    else {
                        this.smoothScrollBy(delta, 0);
                    }
                }
                return scroll;
            }
            computeScrollDeltaToGetChildRectOnScreen(rect) {
                if (this.getChildCount() == 0)
                    return 0;
                let width = this.getWidth();
                let screenLeft = this.getScrollX();
                let screenRight = screenLeft + width;
                let fadingEdge = this.getHorizontalFadingEdgeLength();
                if (rect.left > 0) {
                    screenLeft += fadingEdge;
                }
                if (rect.right < this.getChildAt(0).getWidth()) {
                    screenRight -= fadingEdge;
                }
                let scrollXDelta = 0;
                if (rect.right > screenRight && rect.left > screenLeft) {
                    if (rect.width() > width) {
                        scrollXDelta += (rect.left - screenLeft);
                    }
                    else {
                        scrollXDelta += (rect.right - screenRight);
                    }
                    let right = this.getChildAt(0).getRight();
                    let distanceToRight = right - screenRight;
                    scrollXDelta = Math.min(scrollXDelta, distanceToRight);
                }
                else if (rect.left < screenLeft && rect.right < screenRight) {
                    if (rect.width() > width) {
                        scrollXDelta -= (screenRight - rect.right);
                    }
                    else {
                        scrollXDelta -= (screenLeft - rect.left);
                    }
                    scrollXDelta = Math.max(scrollXDelta, -this.getScrollX());
                }
                return scrollXDelta;
            }
            requestChildFocus(child, focused) {
                if (!this.mIsLayoutDirty) {
                    this.scrollToChild(focused);
                }
                else {
                    this.mChildToScrollTo = focused;
                }
                super.requestChildFocus(child, focused);
            }
            onRequestFocusInDescendants(direction, previouslyFocusedRect) {
                if (direction == View.FOCUS_FORWARD) {
                    direction = View.FOCUS_RIGHT;
                }
                else if (direction == View.FOCUS_BACKWARD) {
                    direction = View.FOCUS_LEFT;
                }
                const nextFocus = previouslyFocusedRect == null ? FocusFinder.getInstance().findNextFocus(this, null, direction) : FocusFinder.getInstance().findNextFocusFromRect(this, previouslyFocusedRect, direction);
                if (nextFocus == null) {
                    return false;
                }
                if (this.isOffScreen(nextFocus)) {
                    return false;
                }
                return nextFocus.requestFocus(direction, previouslyFocusedRect);
            }
            requestChildRectangleOnScreen(child, rectangle, immediate) {
                rectangle.offset(child.getLeft() - child.getScrollX(), child.getTop() - child.getScrollY());
                return this.scrollToChildRect(rectangle, immediate);
            }
            requestLayout() {
                this.mIsLayoutDirty = true;
                super.requestLayout();
            }
            onLayout(changed, l, t, r, b) {
                let childWidth = 0;
                let childMargins = 0;
                if (this.getChildCount() > 0) {
                    childWidth = this.getChildAt(0).getMeasuredWidth();
                    let childParams = this.getChildAt(0).getLayoutParams();
                    childMargins = childParams.leftMargin + childParams.rightMargin;
                }
                const available = r - l - this.getPaddingLeftWithForeground() - this.getPaddingRightWithForeground() - childMargins;
                const forceLeftGravity = (childWidth > available);
                this.layoutChildren(l, t, r, b, forceLeftGravity);
                this.mIsLayoutDirty = false;
                if (this.mChildToScrollTo != null && HorizontalScrollView.isViewDescendantOf(this.mChildToScrollTo, this)) {
                    this.scrollToChild(this.mChildToScrollTo);
                }
                this.mChildToScrollTo = null;
                if (!this.isLaidOut()) {
                    const scrollRange = Math.max(0, childWidth - (r - l - this.mPaddingLeft - this.mPaddingRight));
                    {
                        if (this.isLayoutRtl()) {
                            this.mScrollX = scrollRange - this.mScrollX;
                        }
                    }
                    if (this.mScrollX > scrollRange) {
                        this.mScrollX = scrollRange;
                    }
                    else if (this.mScrollX < 0) {
                        this.mScrollX = 0;
                    }
                }
                this.scrollTo(this.mScrollX, this.mScrollY);
            }
            onSizeChanged(w, h, oldw, oldh) {
                super.onSizeChanged(w, h, oldw, oldh);
                let currentFocused = this.findFocus();
                if (null == currentFocused || this == currentFocused)
                    return;
                const maxJump = this.mRight - this.mLeft;
                if (this.isWithinDeltaOfScreen(currentFocused, maxJump)) {
                    currentFocused.getDrawingRect(this.mTempRect);
                    this.offsetDescendantRectToMyCoords(currentFocused, this.mTempRect);
                    let scrollDelta = this.computeScrollDeltaToGetChildRectOnScreen(this.mTempRect);
                    this.doScrollX(scrollDelta);
                }
            }
            static isViewDescendantOf(child, parent) {
                if (child == parent) {
                    return true;
                }
                const theParent = child.getParent();
                return (theParent instanceof ViewGroup) && HorizontalScrollView.isViewDescendantOf(theParent, parent);
            }
            fling(velocityX) {
                if (this.getChildCount() > 0) {
                    let width = this.getWidth() - this.mPaddingRight - this.mPaddingLeft;
                    let right = this.getChildAt(0).getWidth();
                    this.mScroller.fling(this.mScrollX, this.mScrollY, velocityX, 0, 0, Math.max(0, right - width), 0, 0, width / 2, 0);
                    const movingRight = velocityX > 0;
                    let currentFocused = this.findFocus();
                    let newFocused = this.findFocusableViewInMyBounds(movingRight, this.mScroller.getFinalX(), currentFocused);
                    if (newFocused == null) {
                        newFocused = this;
                    }
                    if (newFocused != currentFocused) {
                        newFocused.requestFocus(movingRight ? View.FOCUS_RIGHT : View.FOCUS_LEFT);
                    }
                    this.postInvalidateOnAnimation();
                }
            }
            scrollTo(x, y) {
                if (this.getChildCount() > 0) {
                    let child = this.getChildAt(0);
                    x = HorizontalScrollView.clamp(x, this.getWidth() - this.mPaddingRight - this.mPaddingLeft, child.getWidth());
                    y = HorizontalScrollView.clamp(y, this.getHeight() - this.mPaddingBottom - this.mPaddingTop, child.getHeight());
                    if (x != this.mScrollX || y != this.mScrollY) {
                        super.scrollTo(x, y);
                    }
                }
            }
            setOverScrollMode(mode) {
                super.setOverScrollMode(mode);
            }
            draw(canvas) {
                super.draw(canvas);
            }
            static clamp(n, my, child) {
                if (my >= child || n < 0) {
                    return 0;
                }
                if ((my + n) > child) {
                    return child - my;
                }
                return n;
            }
        }
        HorizontalScrollView.ANIMATED_SCROLL_GAP = ScrollView.ANIMATED_SCROLL_GAP;
        HorizontalScrollView.MAX_SCROLL_FACTOR = ScrollView.MAX_SCROLL_FACTOR;
        HorizontalScrollView.TAG = "HorizontalScrollView";
        HorizontalScrollView.INVALID_POINTER = -1;
        widget.HorizontalScrollView = HorizontalScrollView;
    })(widget = android.widget || (android.widget = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/5.
 */
///<reference path="../../../database/DataSetObservable.ts"/>
///<reference path="../../../database/Observable.ts"/>
///<reference path="../../../database/DataSetObserver.ts"/>
///<reference path="../../../view/ViewGroup.ts"/>
var android;
(function (android) {
    var support;
    (function (support) {
        var v4;
        (function (v4) {
            var view;
            (function (view_5) {
                var DataSetObservable = android.database.DataSetObservable;
                class PagerAdapter {
                    constructor() {
                        this.mObservable = new DataSetObservable();
                    }
                    startUpdate(container) {
                    }
                    instantiateItem(container, position) {
                        throw new Error("Required method instantiateItem was not overridden");
                    }
                    destroyItem(container, position, object) {
                        throw new Error("Required method destroyItem was not overridden");
                    }
                    setPrimaryItem(container, position, object) {
                    }
                    finishUpdate(container) {
                    }
                    getItemPosition(object) {
                        return PagerAdapter.POSITION_UNCHANGED;
                    }
                    notifyDataSetChanged() {
                        this.mObservable.notifyChanged();
                    }
                    registerDataSetObserver(observer) {
                        this.mObservable.registerObserver(observer);
                    }
                    unregisterDataSetObserver(observer) {
                        this.mObservable.unregisterObserver(observer);
                    }
                    getPageTitle(position) {
                        return null;
                    }
                    getPageWidth(position) {
                        return 1;
                    }
                }
                PagerAdapter.POSITION_UNCHANGED = -1;
                PagerAdapter.POSITION_NONE = -2;
                view_5.PagerAdapter = PagerAdapter;
            })(view = v4.view || (v4.view = {}));
        })(v4 = support.v4 || (support.v4 = {}));
    })(support = android.support || (android.support = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/5.
 */
///<reference path="../../../view/View.ts"/>
///<reference path="../../../view/VelocityTracker.ts"/>
///<reference path="../../../widget/OverScroller.ts"/>
///<reference path="../../../view/ViewGroup.ts"/>
///<reference path="../../../view/MotionEvent.ts"/>
///<reference path="../../../view/animation/Interpolator.ts"/>
///<reference path="../../../../java/util/ArrayList.ts"/>
///<reference path="../../../database/DataSetObservable.ts"/>
///<reference path="../../../database/Observable.ts"/>
///<reference path="../../../database/DataSetObserver.ts"/>
///<reference path="PagerAdapter.ts"/>
var android;
(function (android) {
    var support;
    (function (support) {
        var v4;
        (function (v4) {
            var view;
            (function (view_6) {
                var View = android.view.View;
                var Gravity = android.view.Gravity;
                var MeasureSpec = View.MeasureSpec;
                var OverScroller = android.widget.OverScroller;
                var ViewGroup = android.view.ViewGroup;
                var ArrayList = java.util.ArrayList;
                var Rect = android.graphics.Rect;
                var PagerAdapter = android.support.v4.view.PagerAdapter;
                var DataSetObserver = android.database.DataSetObserver;
                var VelocityTracker = android.view.VelocityTracker;
                var ViewConfiguration = android.view.ViewConfiguration;
                var Resources = android.content.res.Resources;
                var Log = android.util.Log;
                var MotionEvent = android.view.MotionEvent;
                var KeyEvent = android.view.KeyEvent;
                const TAG = "ViewPager";
                const DEBUG = false;
                const SymbolDecor = Symbol();
                class ViewPager extends ViewGroup {
                    constructor() {
                        super();
                        this.mExpectedAdapterCount = 0;
                        this.mItems = new ArrayList();
                        this.mTempItem = new ItemInfo();
                        this.mTempRect = new Rect();
                        this.mCurItem = 0;
                        this.mRestoredCurItem = -1;
                        this.mPageMargin = 0;
                        this.mTopPageBounds = 0;
                        this.mBottomPageBounds = 0;
                        this.mFirstOffset = -Number.MAX_VALUE;
                        this.mLastOffset = Number.MAX_VALUE;
                        this.mChildWidthMeasureSpec = 0;
                        this.mChildHeightMeasureSpec = 0;
                        this.mInLayout = false;
                        this.mScrollingCacheEnabled = false;
                        this.mPopulatePending = false;
                        this.mOffscreenPageLimit = ViewPager.DEFAULT_OFFSCREEN_PAGES;
                        this.mIsBeingDragged = false;
                        this.mIsUnableToDrag = false;
                        this.mDefaultGutterSize = 0;
                        this.mGutterSize = 0;
                        this.mLastMotionX = 0;
                        this.mLastMotionY = 0;
                        this.mInitialMotionX = 0;
                        this.mInitialMotionY = 0;
                        this.mActivePointerId = ViewPager.INVALID_POINTER;
                        this.mMinimumVelocity = 0;
                        this.mMaximumVelocity = 0;
                        this.mFlingDistance = 0;
                        this.mCloseEnough = 0;
                        this.mFakeDragging = false;
                        this.mFakeDragBeginTime = 0;
                        this.mFirstLayout = true;
                        this.mNeedCalculatePageOffsets = false;
                        this.mCalledSuper = false;
                        this.mDecorChildCount = 0;
                        this.mDrawingOrder = 0;
                        this.mEndScrollRunnable = (() => {
                            let ViewPager_this = this;
                            class InnerClass {
                                run() {
                                    ViewPager_this.setScrollState(ViewPager.SCROLL_STATE_IDLE);
                                    ViewPager_this.populate();
                                }
                            }
                            return new InnerClass();
                        })();
                        this.mScrollState = ViewPager.SCROLL_STATE_IDLE;
                        this.initViewPager();
                    }
                    initViewPager() {
                        this.setWillNotDraw(false);
                        this.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);
                        this.setFocusable(true);
                        this.mScroller = new OverScroller(ViewPager.sInterpolator);
                        let density = Resources.getDisplayMetrics().density;
                        this.mTouchSlop = ViewConfiguration.get().getScaledPagingTouchSlop();
                        this.mMinimumVelocity = Math.floor(ViewPager.MIN_FLING_VELOCITY * density);
                        this.mMaximumVelocity = ViewConfiguration.get().getScaledMaximumFlingVelocity();
                        this.mFlingDistance = Math.floor(ViewPager.MIN_DISTANCE_FOR_FLING * density);
                        this.mCloseEnough = Math.floor(ViewPager.CLOSE_ENOUGH * density);
                        this.mDefaultGutterSize = Math.floor(ViewPager.DEFAULT_GUTTER_SIZE * density);
                    }
                    onDetachedFromWindow() {
                        this.removeCallbacks(this.mEndScrollRunnable);
                        super.onDetachedFromWindow();
                    }
                    setScrollState(newState) {
                        if (this.mScrollState == newState) {
                            return;
                        }
                        this.mScrollState = newState;
                        if (this.mPageTransformer != null) {
                            this.enableLayers(newState != ViewPager.SCROLL_STATE_IDLE);
                        }
                        this.dispatchOnScrollStateChanged(newState);
                    }
                    setAdapter(adapter) {
                        if (this.mAdapter != null) {
                            this.mAdapter.unregisterDataSetObserver(this.mObserver);
                            this.mAdapter.startUpdate(this);
                            for (let i = 0; i < this.mItems.size(); i++) {
                                const ii = this.mItems.get(i);
                                this.mAdapter.destroyItem(this, ii.position, ii.object);
                            }
                            this.mAdapter.finishUpdate(this);
                            this.mItems.clear();
                            this.removeNonDecorViews();
                            this.mCurItem = 0;
                            this.scrollTo(0, 0);
                        }
                        const oldAdapter = this.mAdapter;
                        this.mAdapter = adapter;
                        this.mExpectedAdapterCount = 0;
                        if (this.mAdapter != null) {
                            if (this.mObserver == null) {
                                this.mObserver = new PagerObserver(this);
                            }
                            this.mAdapter.registerDataSetObserver(this.mObserver);
                            this.mPopulatePending = false;
                            const wasFirstLayout = this.mFirstLayout;
                            this.mFirstLayout = true;
                            this.mExpectedAdapterCount = this.mAdapter.getCount();
                            if (this.mRestoredCurItem >= 0) {
                                this.setCurrentItemInternal(this.mRestoredCurItem, false, true);
                                this.mRestoredCurItem = -1;
                            }
                            else if (!wasFirstLayout) {
                                this.populate();
                            }
                            else {
                                this.requestLayout();
                            }
                        }
                        if (this.mAdapterChangeListener != null && oldAdapter != adapter) {
                            this.mAdapterChangeListener.onAdapterChanged(oldAdapter, adapter);
                        }
                    }
                    removeNonDecorViews() {
                        for (let i = 0; i < this.getChildCount(); i++) {
                            const child = this.getChildAt(i);
                            const lp = child.getLayoutParams();
                            if (!lp.isDecor) {
                                this.removeViewAt(i);
                                i--;
                            }
                        }
                    }
                    getAdapter() {
                        return this.mAdapter;
                    }
                    setOnAdapterChangeListener(listener) {
                        this.mAdapterChangeListener = listener;
                    }
                    getClientWidth() {
                        return this.getMeasuredWidth() - this.getPaddingLeft() - this.getPaddingRight();
                    }
                    setCurrentItem(item, smoothScroll = !this.mFirstLayout) {
                        this.mPopulatePending = false;
                        this.setCurrentItemInternal(item, smoothScroll, false);
                    }
                    getCurrentItem() {
                        return this.mCurItem;
                    }
                    setCurrentItemInternal(item, smoothScroll, always, velocity = 0) {
                        if (this.mAdapter == null || this.mAdapter.getCount() <= 0) {
                            this.setScrollingCacheEnabled(false);
                            return;
                        }
                        if (!always && this.mCurItem == item && this.mItems.size() != 0) {
                            this.setScrollingCacheEnabled(false);
                            return;
                        }
                        if (item < 0) {
                            item = 0;
                        }
                        else if (item >= this.mAdapter.getCount()) {
                            item = this.mAdapter.getCount() - 1;
                        }
                        const pageLimit = this.mOffscreenPageLimit;
                        if (item > (this.mCurItem + pageLimit) || item < (this.mCurItem - pageLimit)) {
                            for (let i = 0; i < this.mItems.size(); i++) {
                                this.mItems.get(i).scrolling = true;
                            }
                        }
                        const dispatchSelected = this.mCurItem != item;
                        if (this.mFirstLayout) {
                            this.mCurItem = item;
                            if (dispatchSelected) {
                                this.dispatchOnPageSelected(item);
                            }
                            this.requestLayout();
                        }
                        else {
                            this.populate(item);
                            this.scrollToItem(item, smoothScroll, velocity, dispatchSelected);
                        }
                    }
                    scrollToItem(item, smoothScroll, velocity, dispatchSelected) {
                        const curInfo = this.infoForPosition(item);
                        let destX = 0;
                        if (curInfo != null) {
                            const width = this.getClientWidth();
                            destX = Math.floor(width * Math.max(this.mFirstOffset, Math.min(curInfo.offset, this.mLastOffset)));
                        }
                        if (smoothScroll) {
                            this.smoothScrollTo(destX, 0, velocity);
                            if (dispatchSelected) {
                                this.dispatchOnPageSelected(item);
                            }
                        }
                        else {
                            if (dispatchSelected) {
                                this.dispatchOnPageSelected(item);
                            }
                            this.completeScroll(false);
                            this.scrollTo(destX, 0);
                            this.pageScrolled(destX);
                        }
                    }
                    setOnPageChangeListener(listener) {
                        this.mOnPageChangeListener = listener;
                    }
                    addOnPageChangeListener(listener) {
                        if (this.mOnPageChangeListeners == null) {
                            this.mOnPageChangeListeners = new ArrayList();
                        }
                        this.mOnPageChangeListeners.add(listener);
                    }
                    removeOnPageChangeListener(listener) {
                        if (this.mOnPageChangeListeners != null) {
                            this.mOnPageChangeListeners.remove(listener);
                        }
                    }
                    clearOnPageChangeListeners() {
                        if (this.mOnPageChangeListeners != null) {
                            this.mOnPageChangeListeners.clear();
                        }
                    }
                    setPageTransformer(reverseDrawingOrder, transformer) {
                        const hasTransformer = transformer != null;
                        const needsPopulate = hasTransformer != (this.mPageTransformer != null);
                        this.mPageTransformer = transformer;
                        this.setChildrenDrawingOrderEnabledCompat(hasTransformer);
                        if (hasTransformer) {
                            this.mDrawingOrder = reverseDrawingOrder ? ViewPager.DRAW_ORDER_REVERSE : ViewPager.DRAW_ORDER_FORWARD;
                        }
                        else {
                            this.mDrawingOrder = ViewPager.DRAW_ORDER_DEFAULT;
                        }
                        if (needsPopulate)
                            this.populate();
                    }
                    setChildrenDrawingOrderEnabledCompat(enable = true) {
                        this.setChildrenDrawingOrderEnabled(enable);
                    }
                    getChildDrawingOrder(childCount, i) {
                        const index = this.mDrawingOrder == ViewPager.DRAW_ORDER_REVERSE ? childCount - 1 - i : i;
                        const result = this.mDrawingOrderedChildren.get(index).getLayoutParams().childIndex;
                        return result;
                    }
                    setInternalPageChangeListener(listener) {
                        let oldListener = this.mInternalPageChangeListener;
                        this.mInternalPageChangeListener = listener;
                        return oldListener;
                    }
                    getOffscreenPageLimit() {
                        return this.mOffscreenPageLimit;
                    }
                    setOffscreenPageLimit(limit) {
                        if (limit < ViewPager.DEFAULT_OFFSCREEN_PAGES) {
                            Log.w(TAG, "Requested offscreen page limit " + limit + " too small; defaulting to " +
                                ViewPager.DEFAULT_OFFSCREEN_PAGES);
                            limit = ViewPager.DEFAULT_OFFSCREEN_PAGES;
                        }
                        if (limit != this.mOffscreenPageLimit) {
                            this.mOffscreenPageLimit = limit;
                            this.populate();
                        }
                    }
                    setPageMargin(marginPixels) {
                        const oldMargin = this.mPageMargin;
                        this.mPageMargin = marginPixels;
                        const width = this.getWidth();
                        this.recomputeScrollPosition(width, width, marginPixels, oldMargin);
                        this.requestLayout();
                    }
                    getPageMargin() {
                        return this.mPageMargin;
                    }
                    setPageMarginDrawable(d) {
                        this.mMarginDrawable = d;
                        if (d != null)
                            this.refreshDrawableState();
                        this.setWillNotDraw(d == null);
                        this.invalidate();
                    }
                    verifyDrawable(who) {
                        return super.verifyDrawable(who) || who == this.mMarginDrawable;
                    }
                    drawableStateChanged() {
                        super.drawableStateChanged();
                        const d = this.mMarginDrawable;
                        if (d != null && d.isStateful()) {
                            d.setState(this.getDrawableState());
                        }
                    }
                    distanceInfluenceForSnapDuration(f) {
                        f -= 0.5;
                        f *= 0.3 * Math.PI / 2.0;
                        return Math.sin(f);
                    }
                    smoothScrollTo(x, y, velocity = 0) {
                        if (this.getChildCount() == 0) {
                            this.setScrollingCacheEnabled(false);
                            return;
                        }
                        let sx = this.getScrollX();
                        let sy = this.getScrollY();
                        let dx = x - sx;
                        let dy = y - sy;
                        if (dx == 0 && dy == 0) {
                            this.completeScroll(false);
                            this.populate();
                            this.setScrollState(ViewPager.SCROLL_STATE_IDLE);
                            return;
                        }
                        this.setScrollingCacheEnabled(true);
                        this.setScrollState(ViewPager.SCROLL_STATE_SETTLING);
                        const width = this.getClientWidth();
                        const halfWidth = width / 2;
                        const distanceRatio = Math.min(1, 1.0 * Math.abs(dx) / width);
                        const distance = halfWidth + halfWidth *
                            this.distanceInfluenceForSnapDuration(distanceRatio);
                        let duration = 0;
                        velocity = Math.abs(velocity);
                        if (velocity > 0) {
                            duration = 4 * Math.round(1000 * Math.abs(distance / velocity));
                        }
                        else {
                            const pageWidth = width * this.mAdapter.getPageWidth(this.mCurItem);
                            const pageDelta = Math.abs(dx) / (pageWidth + this.mPageMargin);
                            duration = Math.floor((pageDelta + 1) * 100);
                        }
                        duration = Math.min(duration, ViewPager.MAX_SETTLE_DURATION);
                        this.mScroller.startScroll(sx, sy, dx, dy, duration);
                        this.postInvalidateOnAnimation();
                    }
                    addNewItem(position, index) {
                        let ii = new ItemInfo();
                        ii.position = position;
                        ii.object = this.mAdapter.instantiateItem(this, position);
                        ii.widthFactor = this.mAdapter.getPageWidth(position);
                        if (index < 0 || index >= this.mItems.size()) {
                            this.mItems.add(ii);
                        }
                        else {
                            this.mItems.add(index, ii);
                        }
                        return ii;
                    }
                    dataSetChanged() {
                        // This method only gets called if our observer is attached, so mAdapter is non-null.
                        const adapterCount = this.mAdapter.getCount();
                        this.mExpectedAdapterCount = adapterCount;
                        let needPopulate = this.mItems.size() < this.mOffscreenPageLimit * 2 + 1 &&
                            this.mItems.size() < adapterCount;
                        let newCurrItem = this.mCurItem;
                        let isUpdating = false;
                        for (let i = 0; i < this.mItems.size(); i++) {
                            const ii = this.mItems.get(i);
                            const newPos = this.mAdapter.getItemPosition(ii.object);
                            if (newPos == PagerAdapter.POSITION_UNCHANGED) {
                                continue;
                            }
                            if (newPos == PagerAdapter.POSITION_NONE) {
                                this.mItems.remove(i);
                                i--;
                                if (!isUpdating) {
                                    this.mAdapter.startUpdate(this);
                                    isUpdating = true;
                                }
                                this.mAdapter.destroyItem(this, ii.position, ii.object);
                                needPopulate = true;
                                if (this.mCurItem == ii.position) {
                                    newCurrItem = Math.max(0, Math.min(this.mCurItem, adapterCount - 1));
                                    needPopulate = true;
                                }
                                continue;
                            }
                            if (ii.position != newPos) {
                                if (ii.position == this.mCurItem) {
                                    newCurrItem = newPos;
                                }
                                ii.position = newPos;
                                needPopulate = true;
                            }
                        }
                        if (isUpdating) {
                            this.mAdapter.finishUpdate(this);
                        }
                        this.mItems.sort(ViewPager.COMPARATOR);
                        if (needPopulate) {
                            const childCount = this.getChildCount();
                            for (let i = 0; i < childCount; i++) {
                                const child = this.getChildAt(i);
                                const lp = child.getLayoutParams();
                                if (!lp.isDecor) {
                                    lp.widthFactor = 0;
                                }
                            }
                            this.setCurrentItemInternal(newCurrItem, false, true);
                            this.requestLayout();
                        }
                    }
                    populate(newCurrentItem = this.mCurItem) {
                        let oldCurInfo = null;
                        let focusDirection = View.FOCUS_FORWARD;
                        if (this.mCurItem != newCurrentItem) {
                            focusDirection = this.mCurItem < newCurrentItem ? View.FOCUS_RIGHT : View.FOCUS_LEFT;
                            oldCurInfo = this.infoForPosition(this.mCurItem);
                            this.mCurItem = newCurrentItem;
                        }
                        if (this.mAdapter == null) {
                            this.sortChildDrawingOrder();
                            return;
                        }
                        if (this.mPopulatePending) {
                            if (DEBUG)
                                Log.i(TAG, "populate is pending, skipping for now...");
                            this.sortChildDrawingOrder();
                            return;
                        }
                        if (!this.isAttachedToWindow()) {
                            return;
                        }
                        this.mAdapter.startUpdate(this);
                        const pageLimit = this.mOffscreenPageLimit;
                        const startPos = Math.max(0, this.mCurItem - pageLimit);
                        const N = this.mAdapter.getCount();
                        const endPos = Math.min(N - 1, this.mCurItem + pageLimit);
                        if (N != this.mExpectedAdapterCount) {
                            throw new Error("The application's PagerAdapter changed the adapter's" +
                                " contents without calling PagerAdapter#notifyDataSetChanged!" +
                                " Expected adapter item count: " + this.mExpectedAdapterCount + ", found: " + N +
                                " Pager id: " + this.getId() +
                                " Pager class: " + this.constructor.name +
                                " Problematic adapter: " + this.mAdapter.constructor.name);
                        }
                        let curIndex = -1;
                        let curItem = null;
                        for (curIndex = 0; curIndex < this.mItems.size(); curIndex++) {
                            const ii = this.mItems.get(curIndex);
                            if (ii.position >= this.mCurItem) {
                                if (ii.position == this.mCurItem)
                                    curItem = ii;
                                break;
                            }
                        }
                        if (curItem == null && N > 0) {
                            curItem = this.addNewItem(this.mCurItem, curIndex);
                        }
                        if (curItem != null) {
                            let extraWidthLeft = 0;
                            let itemIndex = curIndex - 1;
                            let ii = itemIndex >= 0 ? this.mItems.get(itemIndex) : null;
                            const clientWidth = this.getClientWidth();
                            const leftWidthNeeded = clientWidth <= 0 ? 0 :
                                2 - curItem.widthFactor + this.getPaddingLeft() / clientWidth;
                            for (let pos = this.mCurItem - 1; pos >= 0; pos--) {
                                if (extraWidthLeft >= leftWidthNeeded && pos < startPos) {
                                    if (ii == null) {
                                        break;
                                    }
                                    if (pos == ii.position && !ii.scrolling) {
                                        this.mItems.remove(itemIndex);
                                        this.mAdapter.destroyItem(this, pos, ii.object);
                                        if (DEBUG) {
                                            Log.i(TAG, "populate() - destroyItem() with pos: " + pos +
                                                " view: " + ii.object);
                                        }
                                        itemIndex--;
                                        curIndex--;
                                        ii = itemIndex >= 0 ? this.mItems.get(itemIndex) : null;
                                    }
                                }
                                else if (ii != null && pos == ii.position) {
                                    extraWidthLeft += ii.widthFactor;
                                    itemIndex--;
                                    ii = itemIndex >= 0 ? this.mItems.get(itemIndex) : null;
                                }
                                else {
                                    ii = this.addNewItem(pos, itemIndex + 1);
                                    extraWidthLeft += ii.widthFactor;
                                    curIndex++;
                                    ii = itemIndex >= 0 ? this.mItems.get(itemIndex) : null;
                                }
                            }
                            let extraWidthRight = curItem.widthFactor;
                            itemIndex = curIndex + 1;
                            if (extraWidthRight < 2) {
                                ii = itemIndex < this.mItems.size() ? this.mItems.get(itemIndex) : null;
                                const rightWidthNeeded = clientWidth <= 0 ? 0 :
                                    this.getPaddingRight() / clientWidth + 2;
                                for (let pos = this.mCurItem + 1; pos < N; pos++) {
                                    if (extraWidthRight >= rightWidthNeeded && pos > endPos) {
                                        if (ii == null) {
                                            break;
                                        }
                                        if (pos == ii.position && !ii.scrolling) {
                                            this.mItems.remove(itemIndex);
                                            this.mAdapter.destroyItem(this, pos, ii.object);
                                            if (DEBUG) {
                                                Log.i(TAG, "populate() - destroyItem() with pos: " + pos +
                                                    " view: " + ii.object);
                                            }
                                            ii = itemIndex < this.mItems.size() ? this.mItems.get(itemIndex) : null;
                                        }
                                    }
                                    else if (ii != null && pos == ii.position) {
                                        extraWidthRight += ii.widthFactor;
                                        itemIndex++;
                                        ii = itemIndex < this.mItems.size() ? this.mItems.get(itemIndex) : null;
                                    }
                                    else {
                                        ii = this.addNewItem(pos, itemIndex);
                                        itemIndex++;
                                        extraWidthRight += ii.widthFactor;
                                        ii = itemIndex < this.mItems.size() ? this.mItems.get(itemIndex) : null;
                                    }
                                }
                            }
                            this.calculatePageOffsets(curItem, curIndex, oldCurInfo);
                        }
                        if (DEBUG) {
                            Log.i(TAG, "Current page list:");
                            for (let i = 0; i < this.mItems.size(); i++) {
                                Log.i(TAG, "#" + i + ": page " + this.mItems.get(i).position);
                            }
                        }
                        this.mAdapter.setPrimaryItem(this, this.mCurItem, curItem != null ? curItem.object : null);
                        this.mAdapter.finishUpdate(this);
                        const childCount = this.getChildCount();
                        for (let i = 0; i < childCount; i++) {
                            const child = this.getChildAt(i);
                            const lp = child.getLayoutParams();
                            lp.childIndex = i;
                            if (!lp.isDecor && lp.widthFactor == 0) {
                                const ii = this.infoForChild(child);
                                if (ii != null) {
                                    lp.widthFactor = ii.widthFactor;
                                    lp.position = ii.position;
                                }
                            }
                        }
                        this.sortChildDrawingOrder();
                        if (this.hasFocus()) {
                            let currentFocused = this.findFocus();
                            let ii = currentFocused != null ? this.infoForAnyChild(currentFocused) : null;
                            if (ii == null || ii.position != this.mCurItem) {
                                for (let i = 0; i < this.getChildCount(); i++) {
                                    let child = this.getChildAt(i);
                                    ii = this.infoForChild(child);
                                    if (ii != null && ii.position == this.mCurItem) {
                                        if (child.requestFocus(focusDirection)) {
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    sortChildDrawingOrder() {
                        if (this.mDrawingOrder != ViewPager.DRAW_ORDER_DEFAULT) {
                            if (this.mDrawingOrderedChildren == null) {
                                this.mDrawingOrderedChildren = new ArrayList();
                            }
                            else {
                                this.mDrawingOrderedChildren.clear();
                            }
                            const childCount = this.getChildCount();
                            for (let i = 0; i < childCount; i++) {
                                const child = this.getChildAt(i);
                                this.mDrawingOrderedChildren.add(child);
                            }
                            this.mDrawingOrderedChildren.sort(ViewPager.sPositionComparator);
                        }
                    }
                    calculatePageOffsets(curItem, curIndex, oldCurInfo) {
                        const N = this.mAdapter.getCount();
                        const width = this.getClientWidth();
                        const marginOffset = width > 0 ? this.mPageMargin / width : 0;
                        if (oldCurInfo != null) {
                            const oldCurPosition = oldCurInfo.position;
                            if (oldCurPosition < curItem.position) {
                                let itemIndex = 0;
                                let ii = null;
                                let offset = oldCurInfo.offset + oldCurInfo.widthFactor + marginOffset;
                                for (let pos = oldCurPosition + 1; pos <= curItem.position && itemIndex < this.mItems.size(); pos++) {
                                    ii = this.mItems.get(itemIndex);
                                    while (pos > ii.position && itemIndex < this.mItems.size() - 1) {
                                        itemIndex++;
                                        ii = this.mItems.get(itemIndex);
                                    }
                                    while (pos < ii.position) {
                                        offset += this.mAdapter.getPageWidth(pos) + marginOffset;
                                        pos++;
                                    }
                                    ii.offset = offset;
                                    offset += ii.widthFactor + marginOffset;
                                }
                            }
                            else if (oldCurPosition > curItem.position) {
                                let itemIndex = this.mItems.size() - 1;
                                let ii = null;
                                let offset = oldCurInfo.offset;
                                for (let pos = oldCurPosition - 1; pos >= curItem.position && itemIndex >= 0; pos--) {
                                    ii = this.mItems.get(itemIndex);
                                    while (pos < ii.position && itemIndex > 0) {
                                        itemIndex--;
                                        ii = this.mItems.get(itemIndex);
                                    }
                                    while (pos > ii.position) {
                                        offset -= this.mAdapter.getPageWidth(pos) + marginOffset;
                                        pos--;
                                    }
                                    offset -= ii.widthFactor + marginOffset;
                                    ii.offset = offset;
                                }
                            }
                        }
                        const itemCount = this.mItems.size();
                        let offset = curItem.offset;
                        let pos = curItem.position - 1;
                        this.mFirstOffset = curItem.position == 0 ? curItem.offset : -Number.MAX_VALUE;
                        this.mLastOffset = curItem.position == N - 1 ?
                            curItem.offset + curItem.widthFactor - 1 : Number.MAX_VALUE;
                        for (let i = curIndex - 1; i >= 0; i--, pos--) {
                            const ii = this.mItems.get(i);
                            while (pos > ii.position) {
                                offset -= this.mAdapter.getPageWidth(pos--) + marginOffset;
                            }
                            offset -= ii.widthFactor + marginOffset;
                            ii.offset = offset;
                            if (ii.position == 0)
                                this.mFirstOffset = offset;
                        }
                        offset = curItem.offset + curItem.widthFactor + marginOffset;
                        pos = curItem.position + 1;
                        for (let i = curIndex + 1; i < itemCount; i++, pos++) {
                            const ii = this.mItems.get(i);
                            while (pos < ii.position) {
                                offset += this.mAdapter.getPageWidth(pos++) + marginOffset;
                            }
                            if (ii.position == N - 1) {
                                this.mLastOffset = offset + ii.widthFactor - 1;
                            }
                            ii.offset = offset;
                            offset += ii.widthFactor + marginOffset;
                        }
                        this.mNeedCalculatePageOffsets = false;
                    }
                    addView(...args) {
                        if (args.length === 3 && args[2] instanceof ViewGroup.LayoutParams) {
                            this._addViewOverride(args[0], args[1], args[2]);
                        }
                        else {
                            super.addView(...args);
                        }
                    }
                    _addViewOverride(child, index, params) {
                        if (!this.checkLayoutParams(params)) {
                            params = this.generateLayoutParams(params);
                        }
                        const lp = params;
                        lp.isDecor = lp.isDecor || ViewPager.isImplDecor(child);
                        if (this.mInLayout) {
                            if (lp != null && lp.isDecor) {
                                throw new Error("Cannot add pager decor view during layout");
                            }
                            lp.needsMeasure = true;
                            this.addViewInLayout(child, index, params);
                        }
                        else {
                            super.addView(child, index, params);
                        }
                        if (ViewPager.USE_CACHE) {
                            if (child.getVisibility() != View.GONE) {
                                child.setDrawingCacheEnabled(this.mScrollingCacheEnabled);
                            }
                            else {
                                child.setDrawingCacheEnabled(false);
                            }
                        }
                    }
                    removeView(view) {
                        if (this.mInLayout) {
                            this.removeViewInLayout(view);
                        }
                        else {
                            super.removeView(view);
                        }
                    }
                    infoForChild(child) {
                        for (let i = 0; i < this.mItems.size(); i++) {
                            let ii = this.mItems.get(i);
                            if (this.mAdapter.isViewFromObject(child, ii.object)) {
                                return ii;
                            }
                        }
                        return null;
                    }
                    infoForAnyChild(child) {
                        let parent;
                        while ((parent = child.getParent()) != this) {
                            if (parent == null || !(parent instanceof View)) {
                                return null;
                            }
                            child = parent;
                        }
                        return this.infoForChild(child);
                    }
                    infoForPosition(position) {
                        for (let i = 0; i < this.mItems.size(); i++) {
                            let ii = this.mItems.get(i);
                            if (ii.position == position) {
                                return ii;
                            }
                        }
                        return null;
                    }
                    onAttachedToWindow() {
                        super.onAttachedToWindow();
                        this.mFirstLayout = true;
                    }
                    onMeasure(widthMeasureSpec, heightMeasureSpec) {
                        this.setMeasuredDimension(ViewPager.getDefaultSize(0, widthMeasureSpec), ViewPager.getDefaultSize(0, heightMeasureSpec));
                        const measuredWidth = this.getMeasuredWidth();
                        const maxGutterSize = measuredWidth / 10;
                        this.mGutterSize = Math.min(maxGutterSize, this.mDefaultGutterSize);
                        let childWidthSize = measuredWidth - this.getPaddingLeft() - this.getPaddingRight();
                        let childHeightSize = this.getMeasuredHeight() - this.getPaddingTop() - this.getPaddingBottom();
                        let size = this.getChildCount();
                        for (let i = 0; i < size; ++i) {
                            const child = this.getChildAt(i);
                            if (child.getVisibility() != View.GONE) {
                                const lp = child.getLayoutParams();
                                if (lp != null && lp.isDecor) {
                                    const hgrav = lp.gravity & Gravity.HORIZONTAL_GRAVITY_MASK;
                                    const vgrav = lp.gravity & Gravity.VERTICAL_GRAVITY_MASK;
                                    let widthMode = MeasureSpec.AT_MOST;
                                    let heightMode = MeasureSpec.AT_MOST;
                                    let consumeVertical = vgrav == Gravity.TOP || vgrav == Gravity.BOTTOM;
                                    let consumeHorizontal = hgrav == Gravity.LEFT || hgrav == Gravity.RIGHT;
                                    if (consumeVertical) {
                                        widthMode = MeasureSpec.EXACTLY;
                                    }
                                    else if (consumeHorizontal) {
                                        heightMode = MeasureSpec.EXACTLY;
                                    }
                                    let widthSize = childWidthSize;
                                    let heightSize = childHeightSize;
                                    if (lp.width != ViewPager.LayoutParams.WRAP_CONTENT) {
                                        widthMode = MeasureSpec.EXACTLY;
                                        if (lp.width != ViewPager.LayoutParams.FILL_PARENT) {
                                            widthSize = lp.width;
                                        }
                                    }
                                    if (lp.height != ViewPager.LayoutParams.WRAP_CONTENT) {
                                        heightMode = MeasureSpec.EXACTLY;
                                        if (lp.height != ViewPager.LayoutParams.FILL_PARENT) {
                                            heightSize = lp.height;
                                        }
                                    }
                                    const widthSpec = MeasureSpec.makeMeasureSpec(widthSize, widthMode);
                                    const heightSpec = MeasureSpec.makeMeasureSpec(heightSize, heightMode);
                                    child.measure(widthSpec, heightSpec);
                                    if (consumeVertical) {
                                        childHeightSize -= child.getMeasuredHeight();
                                    }
                                    else if (consumeHorizontal) {
                                        childWidthSize -= child.getMeasuredWidth();
                                    }
                                }
                            }
                        }
                        this.mChildWidthMeasureSpec = MeasureSpec.makeMeasureSpec(childWidthSize, MeasureSpec.EXACTLY);
                        this.mChildHeightMeasureSpec = MeasureSpec.makeMeasureSpec(childHeightSize, MeasureSpec.EXACTLY);
                        this.mInLayout = true;
                        this.populate();
                        this.mInLayout = false;
                        size = this.getChildCount();
                        for (let i = 0; i < size; ++i) {
                            const child = this.getChildAt(i);
                            if (child.getVisibility() != View.GONE) {
                                if (DEBUG)
                                    Log.v(TAG, "Measuring #" + i + " " + child
                                        + ": " + this.mChildWidthMeasureSpec);
                                const lp = child.getLayoutParams();
                                if (lp == null || !lp.isDecor) {
                                    const widthSpec = MeasureSpec.makeMeasureSpec((childWidthSize * lp.widthFactor), MeasureSpec.EXACTLY);
                                    child.measure(widthSpec, this.mChildHeightMeasureSpec);
                                }
                            }
                        }
                    }
                    onSizeChanged(w, h, oldw, oldh) {
                        super.onSizeChanged(w, h, oldw, oldh);
                        if (w != oldw) {
                            this.recomputeScrollPosition(w, oldw, this.mPageMargin, this.mPageMargin);
                        }
                    }
                    recomputeScrollPosition(width, oldWidth, margin, oldMargin) {
                        if (oldWidth > 0 && !this.mItems.isEmpty()) {
                            const widthWithMargin = width - this.getPaddingLeft() - this.getPaddingRight() + margin;
                            const oldWidthWithMargin = oldWidth - this.getPaddingLeft() - this.getPaddingRight()
                                + oldMargin;
                            const xpos = this.getScrollX();
                            const pageOffset = xpos / oldWidthWithMargin;
                            const newOffsetPixels = Math.floor(pageOffset * widthWithMargin);
                            this.scrollTo(newOffsetPixels, this.getScrollY());
                            if (!this.mScroller.isFinished()) {
                                const newDuration = this.mScroller.getDuration() - this.mScroller.timePassed();
                                let targetInfo = this.infoForPosition(this.mCurItem);
                                this.mScroller.startScroll(newOffsetPixels, 0, Math.floor(targetInfo.offset * width), 0, newDuration);
                            }
                        }
                        else {
                            const ii = this.infoForPosition(this.mCurItem);
                            const scrollOffset = ii != null ? Math.min(ii.offset, this.mLastOffset) : 0;
                            const scrollPos = Math.floor(scrollOffset *
                                (width - this.getPaddingLeft() - this.getPaddingRight()));
                            if (scrollPos != this.getScrollX()) {
                                this.completeScroll(false);
                                this.scrollTo(scrollPos, this.getScrollY());
                            }
                        }
                    }
                    onLayout(changed, l, t, r, b) {
                        const count = this.getChildCount();
                        let width = r - l;
                        let height = b - t;
                        let paddingLeft = this.getPaddingLeft();
                        let paddingTop = this.getPaddingTop();
                        let paddingRight = this.getPaddingRight();
                        let paddingBottom = this.getPaddingBottom();
                        const scrollX = this.getScrollX();
                        let decorCount = 0;
                        for (let i = 0; i < count; i++) {
                            const child = this.getChildAt(i);
                            if (child.getVisibility() != View.GONE) {
                                const lp = child.getLayoutParams();
                                let childLeft = 0;
                                let childTop = 0;
                                if (lp.isDecor) {
                                    const hgrav = lp.gravity & Gravity.HORIZONTAL_GRAVITY_MASK;
                                    const vgrav = lp.gravity & Gravity.VERTICAL_GRAVITY_MASK;
                                    switch (hgrav) {
                                        default:
                                            childLeft = paddingLeft;
                                            break;
                                        case Gravity.LEFT:
                                            childLeft = paddingLeft;
                                            paddingLeft += child.getMeasuredWidth();
                                            break;
                                        case Gravity.CENTER_HORIZONTAL:
                                            childLeft = Math.max((width - child.getMeasuredWidth()) / 2, paddingLeft);
                                            break;
                                        case Gravity.RIGHT:
                                            childLeft = width - paddingRight - child.getMeasuredWidth();
                                            paddingRight += child.getMeasuredWidth();
                                            break;
                                    }
                                    switch (vgrav) {
                                        default:
                                            childTop = paddingTop;
                                            break;
                                        case Gravity.TOP:
                                            childTop = paddingTop;
                                            paddingTop += child.getMeasuredHeight();
                                            break;
                                        case Gravity.CENTER_VERTICAL:
                                            childTop = Math.max((height - child.getMeasuredHeight()) / 2, paddingTop);
                                            break;
                                        case Gravity.BOTTOM:
                                            childTop = height - paddingBottom - child.getMeasuredHeight();
                                            paddingBottom += child.getMeasuredHeight();
                                            break;
                                    }
                                    childLeft += scrollX;
                                    child.layout(childLeft, childTop, childLeft + child.getMeasuredWidth(), childTop + child.getMeasuredHeight());
                                    decorCount++;
                                }
                            }
                        }
                        const childWidth = width - paddingLeft - paddingRight;
                        for (let i = 0; i < count; i++) {
                            const child = this.getChildAt(i);
                            if (child.getVisibility() != View.GONE) {
                                const lp = child.getLayoutParams();
                                let ii;
                                if (!lp.isDecor && (ii = this.infoForChild(child)) != null) {
                                    let loff = Math.floor(childWidth * ii.offset);
                                    let childLeft = paddingLeft + loff;
                                    let childTop = paddingTop;
                                    if (lp.needsMeasure) {
                                        lp.needsMeasure = false;
                                        const widthSpec = MeasureSpec.makeMeasureSpec(Math.floor(childWidth * lp.widthFactor), MeasureSpec.EXACTLY);
                                        const heightSpec = MeasureSpec.makeMeasureSpec(Math.floor(height - paddingTop - paddingBottom), MeasureSpec.EXACTLY);
                                        child.measure(widthSpec, heightSpec);
                                    }
                                    if (DEBUG)
                                        Log.v(TAG, "Positioning #" + i + " " + child + " f=" + ii.object
                                            + ":" + childLeft + "," + childTop + " " + child.getMeasuredWidth()
                                            + "x" + child.getMeasuredHeight());
                                    child.layout(childLeft, childTop, childLeft + child.getMeasuredWidth(), childTop + child.getMeasuredHeight());
                                }
                            }
                        }
                        this.mTopPageBounds = paddingTop;
                        this.mBottomPageBounds = height - paddingBottom;
                        this.mDecorChildCount = decorCount;
                        if (this.mFirstLayout) {
                            this.scrollToItem(this.mCurItem, false, 0, false);
                        }
                        this.mFirstLayout = false;
                    }
                    computeScroll() {
                        if (!this.mScroller.isFinished() && this.mScroller.computeScrollOffset()) {
                            let oldX = this.getScrollX();
                            let oldY = this.getScrollY();
                            let x = this.mScroller.getCurrX();
                            let y = this.mScroller.getCurrY();
                            if (oldX != x || oldY != y) {
                                this.scrollTo(x, y);
                                if (!this.pageScrolled(x)) {
                                    this.mScroller.abortAnimation();
                                    this.scrollTo(0, y);
                                }
                            }
                            this.postInvalidateOnAnimation();
                            return;
                        }
                        this.completeScroll(true);
                    }
                    pageScrolled(xpos) {
                        if (this.mItems.size() == 0) {
                            this.mCalledSuper = false;
                            this.onPageScrolled(0, 0, 0);
                            if (!this.mCalledSuper) {
                                throw new Error("onPageScrolled did not call superclass implementation");
                            }
                            return false;
                        }
                        const ii = this.infoForCurrentScrollPosition();
                        const width = this.getClientWidth();
                        const widthWithMargin = width + this.mPageMargin;
                        const marginOffset = this.mPageMargin / width;
                        const currentPage = ii.position;
                        const pageOffset = ((xpos / width) - ii.offset) / (ii.widthFactor + marginOffset);
                        const offsetPixels = Math.floor(pageOffset * widthWithMargin);
                        this.mCalledSuper = false;
                        this.onPageScrolled(currentPage, pageOffset, offsetPixels);
                        if (!this.mCalledSuper) {
                            throw new Error("onPageScrolled did not call superclass implementation");
                        }
                        return true;
                    }
                    onPageScrolled(position, offset, offsetPixels) {
                        if (this.mDecorChildCount > 0) {
                            const scrollX = this.getScrollX();
                            let paddingLeft = this.getPaddingLeft();
                            let paddingRight = this.getPaddingRight();
                            const width = this.getWidth();
                            const childCount = this.getChildCount();
                            for (let i = 0; i < childCount; i++) {
                                const child = this.getChildAt(i);
                                const lp = child.getLayoutParams();
                                if (!lp.isDecor)
                                    continue;
                                const hgrav = lp.gravity & Gravity.HORIZONTAL_GRAVITY_MASK;
                                let childLeft = 0;
                                switch (hgrav) {
                                    default:
                                        childLeft = paddingLeft;
                                        break;
                                    case Gravity.LEFT:
                                        childLeft = paddingLeft;
                                        paddingLeft += child.getWidth();
                                        break;
                                    case Gravity.CENTER_HORIZONTAL:
                                        childLeft = Math.max((width - child.getMeasuredWidth()) / 2, paddingLeft);
                                        break;
                                    case Gravity.RIGHT:
                                        childLeft = width - paddingRight - child.getMeasuredWidth();
                                        paddingRight += child.getMeasuredWidth();
                                        break;
                                }
                                childLeft += scrollX;
                                const childOffset = childLeft - child.getLeft();
                                if (childOffset != 0) {
                                    child.offsetLeftAndRight(childOffset);
                                }
                            }
                        }
                        this.dispatchOnPageScrolled(position, offset, offsetPixels);
                        if (this.mPageTransformer != null) {
                            const scrollX = this.getScrollX();
                            const childCount = this.getChildCount();
                            for (let i = 0; i < childCount; i++) {
                                const child = this.getChildAt(i);
                                const lp = child.getLayoutParams();
                                if (lp.isDecor)
                                    continue;
                                const transformPos = (child.getLeft() - scrollX) / this.getClientWidth();
                                this.mPageTransformer.transformPage(child, transformPos);
                            }
                        }
                        this.mCalledSuper = true;
                    }
                    dispatchOnPageScrolled(position, offset, offsetPixels) {
                        if (this.mOnPageChangeListener != null) {
                            this.mOnPageChangeListener.onPageScrolled(position, offset, offsetPixels);
                        }
                        if (this.mOnPageChangeListeners != null) {
                            for (let i = 0, z = this.mOnPageChangeListeners.size(); i < z; i++) {
                                let listener = this.mOnPageChangeListeners.get(i);
                                if (listener != null) {
                                    listener.onPageScrolled(position, offset, offsetPixels);
                                }
                            }
                        }
                        if (this.mInternalPageChangeListener != null) {
                            this.mInternalPageChangeListener.onPageScrolled(position, offset, offsetPixels);
                        }
                    }
                    dispatchOnPageSelected(position) {
                        if (this.mOnPageChangeListener != null) {
                            this.mOnPageChangeListener.onPageSelected(position);
                        }
                        if (this.mOnPageChangeListeners != null) {
                            for (let i = 0, z = this.mOnPageChangeListeners.size(); i < z; i++) {
                                let listener = this.mOnPageChangeListeners.get(i);
                                if (listener != null) {
                                    listener.onPageSelected(position);
                                }
                            }
                        }
                        if (this.mInternalPageChangeListener != null) {
                            this.mInternalPageChangeListener.onPageSelected(position);
                        }
                    }
                    dispatchOnScrollStateChanged(state) {
                        if (this.mOnPageChangeListener != null) {
                            this.mOnPageChangeListener.onPageScrollStateChanged(state);
                        }
                        if (this.mOnPageChangeListeners != null) {
                            for (let i = 0, z = this.mOnPageChangeListeners.size(); i < z; i++) {
                                let listener = this.mOnPageChangeListeners.get(i);
                                if (listener != null) {
                                    listener.onPageScrollStateChanged(state);
                                }
                            }
                        }
                        if (this.mInternalPageChangeListener != null) {
                            this.mInternalPageChangeListener.onPageScrollStateChanged(state);
                        }
                    }
                    completeScroll(postEvents) {
                        let needPopulate = this.mScrollState == ViewPager.SCROLL_STATE_SETTLING;
                        if (needPopulate) {
                            this.setScrollingCacheEnabled(false);
                            this.mScroller.abortAnimation();
                            let oldX = this.getScrollX();
                            let oldY = this.getScrollY();
                            let x = this.mScroller.getCurrX();
                            let y = this.mScroller.getCurrY();
                            if (oldX != x || oldY != y) {
                                this.scrollTo(x, y);
                                if (x != oldX) {
                                    this.pageScrolled(x);
                                }
                            }
                        }
                        this.mPopulatePending = false;
                        for (let i = 0; i < this.mItems.size(); i++) {
                            let ii = this.mItems.get(i);
                            if (ii.scrolling) {
                                needPopulate = true;
                                ii.scrolling = false;
                            }
                        }
                        if (needPopulate) {
                            if (postEvents) {
                                this.postOnAnimation(this.mEndScrollRunnable);
                            }
                            else {
                                this.mEndScrollRunnable.run();
                            }
                        }
                    }
                    isGutterDrag(x, dx) {
                        return (x < this.mGutterSize && dx > 0) || (x > this.getWidth() - this.mGutterSize && dx < 0);
                    }
                    enableLayers(enable) {
                    }
                    onInterceptTouchEvent(ev) {
                        /*
                         * This method JUST determines whether we want to intercept the motion.
                         * If we return true, onMotionEvent will be called and we do the actual
                         * scrolling there.
                         */
                        const action = ev.getAction() & MotionEvent.ACTION_MASK;
                        if (action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_UP) {
                            if (DEBUG)
                                Log.v(TAG, "Intercept done!");
                            this.resetTouch();
                            return false;
                        }
                        if (action != MotionEvent.ACTION_DOWN) {
                            if (this.mIsBeingDragged) {
                                if (DEBUG)
                                    Log.v(TAG, "Intercept returning true!");
                                return true;
                            }
                            if (this.mIsUnableToDrag) {
                                if (DEBUG)
                                    Log.v(TAG, "Intercept returning false!");
                                return false;
                            }
                        }
                        switch (action) {
                            case MotionEvent.ACTION_MOVE: {
                                const activePointerId = this.mActivePointerId;
                                if (activePointerId == ViewPager.INVALID_POINTER) {
                                    break;
                                }
                                const pointerIndex = ev.findPointerIndex(activePointerId);
                                const x = ev.getX(pointerIndex);
                                const dx = x - this.mLastMotionX;
                                const xDiff = Math.abs(dx);
                                const y = ev.getY(pointerIndex);
                                const yDiff = Math.abs(y - this.mInitialMotionY);
                                if (DEBUG)
                                    Log.v(TAG, "Moved x to " + x + "," + y + " diff=" + xDiff + "," + yDiff);
                                if (dx != 0 && !this.isGutterDrag(this.mLastMotionX, dx) &&
                                    this.canScroll(this, false, Math.floor(dx), Math.floor(x), Math.floor(y))) {
                                    this.mLastMotionX = x;
                                    this.mLastMotionY = y;
                                    this.mIsUnableToDrag = true;
                                    return false;
                                }
                                if (xDiff > this.mTouchSlop && xDiff * 0.5 > yDiff) {
                                    if (DEBUG)
                                        Log.v(TAG, "Starting drag!");
                                    this.mIsBeingDragged = true;
                                    this.requestParentDisallowInterceptTouchEvent(true);
                                    this.setScrollState(ViewPager.SCROLL_STATE_DRAGGING);
                                    this.mLastMotionX = dx > 0 ? this.mInitialMotionX + this.mTouchSlop :
                                        this.mInitialMotionX - this.mTouchSlop;
                                    this.mLastMotionY = y;
                                    this.setScrollingCacheEnabled(true);
                                }
                                else if (yDiff > this.mTouchSlop) {
                                    if (DEBUG)
                                        Log.v(TAG, "Starting unable to drag!");
                                    this.mIsUnableToDrag = true;
                                }
                                if (this.mIsBeingDragged) {
                                    if (this.performDrag(x)) {
                                        this.postInvalidateOnAnimation();
                                    }
                                }
                                break;
                            }
                            case MotionEvent.ACTION_DOWN: {
                                this.mLastMotionX = this.mInitialMotionX = ev.getX();
                                this.mLastMotionY = this.mInitialMotionY = ev.getY();
                                this.mActivePointerId = ev.getPointerId(0);
                                this.mIsUnableToDrag = false;
                                this.mScroller.computeScrollOffset();
                                if (this.mScrollState == ViewPager.SCROLL_STATE_SETTLING &&
                                    Math.abs(this.mScroller.getFinalX() - this.mScroller.getCurrX()) > this.mCloseEnough) {
                                    this.mScroller.abortAnimation();
                                    this.mPopulatePending = false;
                                    this.populate();
                                    this.mIsBeingDragged = true;
                                    this.requestParentDisallowInterceptTouchEvent(true);
                                    this.setScrollState(ViewPager.SCROLL_STATE_DRAGGING);
                                }
                                else {
                                    this.completeScroll(false);
                                    this.mIsBeingDragged = false;
                                }
                                if (DEBUG)
                                    Log.v(TAG, "Down at " + this.mLastMotionX + "," + this.mLastMotionY
                                        + " mIsBeingDragged=" + this.mIsBeingDragged
                                        + "mIsUnableToDrag=" + this.mIsUnableToDrag);
                                break;
                            }
                            case MotionEvent.ACTION_POINTER_UP:
                                this.onSecondaryPointerUp(ev);
                                break;
                        }
                        if (this.mVelocityTracker == null) {
                            this.mVelocityTracker = VelocityTracker.obtain();
                        }
                        this.mVelocityTracker.addMovement(ev);
                        return this.mIsBeingDragged;
                    }
                    onTouchEvent(ev) {
                        if (this.mFakeDragging) {
                            return true;
                        }
                        if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
                            return false;
                        }
                        if (this.mAdapter == null || this.mAdapter.getCount() == 0) {
                            return false;
                        }
                        if (this.mVelocityTracker == null) {
                            this.mVelocityTracker = VelocityTracker.obtain();
                        }
                        this.mVelocityTracker.addMovement(ev);
                        const action = ev.getAction();
                        let needsInvalidate = false;
                        switch (action & MotionEvent.ACTION_MASK) {
                            case MotionEvent.ACTION_DOWN: {
                                this.mScroller.abortAnimation();
                                this.mPopulatePending = false;
                                this.populate();
                                this.mLastMotionX = this.mInitialMotionX = ev.getX();
                                this.mLastMotionY = this.mInitialMotionY = ev.getY();
                                this.mActivePointerId = ev.getPointerId(0);
                                break;
                            }
                            case MotionEvent.ACTION_MOVE:
                                if (!this.mIsBeingDragged) {
                                    const pointerIndex = ev.findPointerIndex(this.mActivePointerId);
                                    if (pointerIndex == -1) {
                                        needsInvalidate = this.resetTouch();
                                        break;
                                    }
                                    const x = ev.getX(pointerIndex);
                                    const xDiff = Math.abs(x - this.mLastMotionX);
                                    const y = ev.getY(pointerIndex);
                                    const yDiff = Math.abs(y - this.mLastMotionY);
                                    if (DEBUG)
                                        Log.v(TAG, "Moved x to " + x + "," + y + " diff=" + xDiff + "," + yDiff);
                                    if (xDiff > this.mTouchSlop && xDiff > yDiff) {
                                        if (DEBUG)
                                            Log.v(TAG, "Starting drag!");
                                        this.mIsBeingDragged = true;
                                        this.requestParentDisallowInterceptTouchEvent(true);
                                        this.mLastMotionX = x - this.mInitialMotionX > 0 ? this.mInitialMotionX + this.mTouchSlop :
                                            this.mInitialMotionX - this.mTouchSlop;
                                        this.mLastMotionY = y;
                                        this.setScrollState(ViewPager.SCROLL_STATE_DRAGGING);
                                        this.setScrollingCacheEnabled(true);
                                        let parent = this.getParent();
                                        if (parent != null) {
                                            parent.requestDisallowInterceptTouchEvent(true);
                                        }
                                    }
                                }
                                if (this.mIsBeingDragged) {
                                    const activePointerIndex = ev.findPointerIndex(this.mActivePointerId);
                                    const x = ev.getX(activePointerIndex);
                                    needsInvalidate = needsInvalidate || this.performDrag(x);
                                }
                                break;
                            case MotionEvent.ACTION_UP:
                                if (this.mIsBeingDragged) {
                                    const velocityTracker = this.mVelocityTracker;
                                    velocityTracker.computeCurrentVelocity(1000, this.mMaximumVelocity);
                                    let initialVelocity = velocityTracker.getXVelocity(this.mActivePointerId);
                                    this.mPopulatePending = true;
                                    const width = this.getClientWidth();
                                    const scrollX = this.getScrollX();
                                    const ii = this.infoForCurrentScrollPosition();
                                    const currentPage = ii.position;
                                    const pageOffset = ((scrollX / width) - ii.offset) / ii.widthFactor;
                                    const activePointerIndex = ev.findPointerIndex(this.mActivePointerId);
                                    const x = ev.getX(activePointerIndex);
                                    const totalDelta = (x - this.mInitialMotionX);
                                    let nextPage = this.determineTargetPage(currentPage, pageOffset, initialVelocity, totalDelta);
                                    this.setCurrentItemInternal(nextPage, true, true, initialVelocity);
                                    needsInvalidate = this.resetTouch();
                                }
                                break;
                            case MotionEvent.ACTION_CANCEL:
                                if (this.mIsBeingDragged) {
                                    this.scrollToItem(this.mCurItem, true, 0, false);
                                    needsInvalidate = this.resetTouch();
                                }
                                break;
                            case MotionEvent.ACTION_POINTER_DOWN: {
                                const index = ev.getActionIndex();
                                const x = ev.getX(index);
                                this.mLastMotionX = x;
                                this.mActivePointerId = ev.getPointerId(index);
                                break;
                            }
                            case MotionEvent.ACTION_POINTER_UP:
                                this.onSecondaryPointerUp(ev);
                                this.mLastMotionX = ev.getX(ev.findPointerIndex(this.mActivePointerId));
                                break;
                        }
                        if (needsInvalidate) {
                            this.postInvalidateOnAnimation();
                        }
                        return true;
                    }
                    resetTouch() {
                        let needsInvalidate = false;
                        this.mActivePointerId = ViewPager.INVALID_POINTER;
                        this.endDrag();
                        return needsInvalidate;
                    }
                    requestParentDisallowInterceptTouchEvent(disallowIntercept) {
                        const parent = this.getParent();
                        if (parent != null) {
                            parent.requestDisallowInterceptTouchEvent(disallowIntercept);
                        }
                    }
                    performDrag(x) {
                        let needsInvalidate = false;
                        const deltaX = this.mLastMotionX - x;
                        this.mLastMotionX = x;
                        let oldScrollX = this.getScrollX();
                        let scrollX = oldScrollX + deltaX;
                        const width = this.getClientWidth();
                        let leftBound = width * this.mFirstOffset;
                        let rightBound = width * this.mLastOffset;
                        let leftAbsolute = true;
                        let rightAbsolute = true;
                        const firstItem = this.mItems.get(0);
                        const lastItem = this.mItems.get(this.mItems.size() - 1);
                        if (firstItem.position != 0) {
                            leftAbsolute = false;
                            leftBound = firstItem.offset * width;
                        }
                        if (lastItem.position != this.mAdapter.getCount() - 1) {
                            rightAbsolute = false;
                            rightBound = lastItem.offset * width;
                        }
                        if (scrollX < leftBound) {
                            if (leftAbsolute) {
                                let over = leftBound - scrollX;
                                needsInvalidate = false;
                            }
                            scrollX -= deltaX / 2;
                        }
                        else if (scrollX > rightBound) {
                            if (rightAbsolute) {
                                let over = scrollX - rightBound;
                                needsInvalidate = false;
                            }
                            scrollX -= deltaX / 2;
                        }
                        this.mLastMotionX += scrollX - Math.floor(scrollX);
                        this.scrollTo(scrollX, this.getScrollY());
                        this.pageScrolled(scrollX);
                        return needsInvalidate;
                    }
                    infoForCurrentScrollPosition() {
                        const width = this.getClientWidth();
                        const scrollOffset = width > 0 ? this.getScrollX() / width : 0;
                        const marginOffset = width > 0 ? this.mPageMargin / width : 0;
                        let lastPos = -1;
                        let lastOffset = 0;
                        let lastWidth = 0;
                        let first = true;
                        let lastItem = null;
                        for (let i = 0; i < this.mItems.size(); i++) {
                            let ii = this.mItems.get(i);
                            let offset;
                            if (!first && ii.position != lastPos + 1) {
                                ii = this.mTempItem;
                                ii.offset = lastOffset + lastWidth + marginOffset;
                                ii.position = lastPos + 1;
                                ii.widthFactor = this.mAdapter.getPageWidth(ii.position);
                                i--;
                            }
                            offset = ii.offset;
                            const leftBound = offset;
                            const rightBound = offset + ii.widthFactor + marginOffset;
                            if (first || scrollOffset >= leftBound) {
                                if (scrollOffset < rightBound || i == this.mItems.size() - 1) {
                                    return ii;
                                }
                            }
                            else {
                                return lastItem;
                            }
                            first = false;
                            lastPos = ii.position;
                            lastOffset = offset;
                            lastWidth = ii.widthFactor;
                            lastItem = ii;
                        }
                        return lastItem;
                    }
                    determineTargetPage(currentPage, pageOffset, velocity, deltaX) {
                        let targetPage;
                        if (Math.abs(deltaX) > this.mFlingDistance && Math.abs(velocity) > this.mMinimumVelocity) {
                            targetPage = velocity > 0 ? currentPage : currentPage + 1;
                        }
                        else {
                            const truncator = currentPage >= this.mCurItem ? 0.4 : 0.6;
                            targetPage = Math.floor(currentPage + pageOffset + truncator);
                        }
                        if (this.mItems.size() > 0) {
                            const firstItem = this.mItems.get(0);
                            const lastItem = this.mItems.get(this.mItems.size() - 1);
                            targetPage = Math.max(firstItem.position, Math.min(targetPage, lastItem.position));
                        }
                        return targetPage;
                    }
                    draw(canvas) {
                        super.draw(canvas);
                        let needsInvalidate = false;
                        if (needsInvalidate) {
                            this.postInvalidateOnAnimation();
                        }
                    }
                    onDraw(canvas) {
                        super.onDraw(canvas);
                        if (this.mPageMargin > 0 && this.mMarginDrawable != null && this.mItems.size() > 0 && this.mAdapter != null) {
                            const scrollX = this.getScrollX();
                            const width = this.getWidth();
                            const marginOffset = this.mPageMargin / width;
                            let itemIndex = 0;
                            let ii = this.mItems.get(0);
                            let offset = ii.offset;
                            const itemCount = this.mItems.size();
                            const firstPos = ii.position;
                            const lastPos = this.mItems.get(itemCount - 1).position;
                            for (let pos = firstPos; pos < lastPos; pos++) {
                                while (pos > ii.position && itemIndex < itemCount) {
                                    ii = this.mItems.get(++itemIndex);
                                }
                                let drawAt;
                                if (pos == ii.position) {
                                    drawAt = (ii.offset + ii.widthFactor) * width;
                                    offset = ii.offset + ii.widthFactor + marginOffset;
                                }
                                else {
                                    let widthFactor = this.mAdapter.getPageWidth(pos);
                                    drawAt = (offset + widthFactor) * width;
                                    offset += widthFactor + marginOffset;
                                }
                                if (drawAt + this.mPageMargin > scrollX) {
                                    this.mMarginDrawable.setBounds(drawAt, this.mTopPageBounds, drawAt + this.mPageMargin, this.mBottomPageBounds);
                                    this.mMarginDrawable.draw(canvas);
                                }
                                if (drawAt > scrollX + width) {
                                    break;
                                }
                            }
                        }
                    }
                    beginFakeDrag() {
                        if (this.mIsBeingDragged) {
                            return false;
                        }
                        this.mFakeDragging = true;
                        this.setScrollState(ViewPager.SCROLL_STATE_DRAGGING);
                        this.mInitialMotionX = this.mLastMotionX = 0;
                        if (this.mVelocityTracker == null) {
                            this.mVelocityTracker = VelocityTracker.obtain();
                        }
                        else {
                            this.mVelocityTracker.clear();
                        }
                        const time = android.os.SystemClock.uptimeMillis();
                        const ev = MotionEvent.obtainWithAction(time, time, MotionEvent.ACTION_DOWN, 0, 0, 0);
                        this.mVelocityTracker.addMovement(ev);
                        ev.recycle();
                        this.mFakeDragBeginTime = time;
                        return true;
                    }
                    endFakeDrag() {
                        if (!this.mFakeDragging) {
                            throw new Error("No fake drag in progress. Call beginFakeDrag first.");
                        }
                        const velocityTracker = this.mVelocityTracker;
                        velocityTracker.computeCurrentVelocity(1000, this.mMaximumVelocity);
                        let initialVelocity = Math.floor(velocityTracker.getXVelocity(this.mActivePointerId));
                        this.mPopulatePending = true;
                        const width = this.getClientWidth();
                        const scrollX = this.getScrollX();
                        const ii = this.infoForCurrentScrollPosition();
                        const currentPage = ii.position;
                        const pageOffset = ((scrollX / width) - ii.offset) / ii.widthFactor;
                        const totalDelta = Math.floor(this.mLastMotionX - this.mInitialMotionX);
                        let nextPage = this.determineTargetPage(currentPage, pageOffset, initialVelocity, totalDelta);
                        this.setCurrentItemInternal(nextPage, true, true, initialVelocity);
                        this.endDrag();
                        this.mFakeDragging = false;
                    }
                    fakeDragBy(xOffset) {
                        if (!this.mFakeDragging) {
                            throw new Error("No fake drag in progress. Call beginFakeDrag first.");
                        }
                        this.mLastMotionX += xOffset;
                        let oldScrollX = this.getScrollX();
                        let scrollX = oldScrollX - xOffset;
                        const width = this.getClientWidth();
                        let leftBound = width * this.mFirstOffset;
                        let rightBound = width * this.mLastOffset;
                        const firstItem = this.mItems.get(0);
                        const lastItem = this.mItems.get(this.mItems.size() - 1);
                        if (firstItem.position != 0) {
                            leftBound = firstItem.offset * width;
                        }
                        if (lastItem.position != this.mAdapter.getCount() - 1) {
                            rightBound = lastItem.offset * width;
                        }
                        if (scrollX < leftBound) {
                            scrollX = leftBound;
                        }
                        else if (scrollX > rightBound) {
                            scrollX = rightBound;
                        }
                        this.mLastMotionX += scrollX - Math.floor(scrollX);
                        this.scrollTo(Math.floor(scrollX), this.getScrollY());
                        this.pageScrolled(Math.floor(scrollX));
                        const time = android.os.SystemClock.uptimeMillis();
                        const ev = MotionEvent.obtainWithAction(this.mFakeDragBeginTime, time, MotionEvent.ACTION_MOVE, this.mLastMotionX, 0, 0);
                        this.mVelocityTracker.addMovement(ev);
                        ev.recycle();
                    }
                    isFakeDragging() {
                        return this.mFakeDragging;
                    }
                    onSecondaryPointerUp(ev) {
                        const pointerIndex = ev.getActionIndex();
                        const pointerId = ev.getPointerId(pointerIndex);
                        if (pointerId == this.mActivePointerId) {
                            const newPointerIndex = pointerIndex == 0 ? 1 : 0;
                            this.mLastMotionX = ev.getX(newPointerIndex);
                            this.mActivePointerId = ev.getPointerId(newPointerIndex);
                            if (this.mVelocityTracker != null) {
                                this.mVelocityTracker.clear();
                            }
                        }
                    }
                    endDrag() {
                        this.mIsBeingDragged = false;
                        this.mIsUnableToDrag = false;
                        if (this.mVelocityTracker != null) {
                            this.mVelocityTracker.recycle();
                            this.mVelocityTracker = null;
                        }
                    }
                    setScrollingCacheEnabled(enabled) {
                        if (this.mScrollingCacheEnabled != enabled) {
                            this.mScrollingCacheEnabled = enabled;
                            if (ViewPager.USE_CACHE) {
                                const size = this.getChildCount();
                                for (let i = 0; i < size; ++i) {
                                    const child = this.getChildAt(i);
                                    if (child.getVisibility() != View.GONE) {
                                        child.setDrawingCacheEnabled(enabled);
                                    }
                                }
                            }
                        }
                    }
                    canScrollHorizontally(direction) {
                        if (this.mAdapter == null) {
                            return false;
                        }
                        const width = this.getClientWidth();
                        const scrollX = this.getScrollX();
                        if (direction < 0) {
                            return (scrollX > (width * this.mFirstOffset));
                        }
                        else if (direction > 0) {
                            return (scrollX < (width * this.mLastOffset));
                        }
                        else {
                            return false;
                        }
                    }
                    canScroll(v, checkV, dx, x, y) {
                        if (v instanceof ViewGroup) {
                            const group = v;
                            const scrollX = v.getScrollX();
                            const scrollY = v.getScrollY();
                            const count = group.getChildCount();
                            for (let i = count - 1; i >= 0; i--) {
                                const child = group.getChildAt(i);
                                if (x + scrollX >= child.getLeft() && x + scrollX < child.getRight() &&
                                    y + scrollY >= child.getTop() && y + scrollY < child.getBottom() &&
                                    this.canScroll(child, true, dx, x + scrollX - child.getLeft(), y + scrollY - child.getTop())) {
                                    return true;
                                }
                            }
                        }
                        return checkV && v.canScrollHorizontally(-dx);
                    }
                    dispatchKeyEvent(event) {
                        return super.dispatchKeyEvent(event) || this.executeKeyEvent(event);
                    }
                    executeKeyEvent(event) {
                        let handled = false;
                        if (event.getAction() == KeyEvent.ACTION_DOWN) {
                            switch (event.getKeyCode()) {
                                case KeyEvent.KEYCODE_DPAD_LEFT:
                                    handled = this.arrowScroll(View.FOCUS_LEFT);
                                    break;
                                case KeyEvent.KEYCODE_DPAD_RIGHT:
                                    handled = this.arrowScroll(View.FOCUS_RIGHT);
                                    break;
                                case KeyEvent.KEYCODE_TAB:
                                    if (event.isShiftPressed()) {
                                        handled = this.arrowScroll(View.FOCUS_BACKWARD);
                                    }
                                    else {
                                        handled = this.arrowScroll(View.FOCUS_FORWARD);
                                    }
                                    break;
                            }
                        }
                        return handled;
                    }
                    arrowScroll(direction) {
                        let currentFocused = this.findFocus();
                        if (currentFocused == this) {
                            currentFocused = null;
                        }
                        else if (currentFocused != null) {
                            let isChild = false;
                            for (let parent = currentFocused.getParent(); parent instanceof ViewGroup; parent = parent.getParent()) {
                                if (parent == this) {
                                    isChild = true;
                                    break;
                                }
                            }
                            if (!isChild) {
                                const sb = new java.lang.StringBuilder();
                                sb.append(currentFocused.toString());
                                for (let parent = currentFocused.getParent(); parent instanceof ViewGroup; parent = parent.getParent()) {
                                    sb.append(" => ").append(parent.toString());
                                }
                                Log.e(TAG, "arrowScroll tried to find focus based on non-child " +
                                    "current focused view " + sb.toString());
                                currentFocused = null;
                            }
                        }
                        let handled = false;
                        let nextFocused = android.view.FocusFinder.getInstance().findNextFocus(this, currentFocused, direction);
                        if (nextFocused != null && nextFocused != currentFocused) {
                            if (direction == View.FOCUS_LEFT) {
                                const nextLeft = this.getChildRectInPagerCoordinates(this.mTempRect, nextFocused).left;
                                const currLeft = this.getChildRectInPagerCoordinates(this.mTempRect, currentFocused).left;
                                if (currentFocused != null && nextLeft >= currLeft) {
                                    handled = this.pageLeft();
                                }
                                else {
                                    handled = nextFocused.requestFocus();
                                }
                            }
                            else if (direction == View.FOCUS_RIGHT) {
                                const nextLeft = this.getChildRectInPagerCoordinates(this.mTempRect, nextFocused).left;
                                const currLeft = this.getChildRectInPagerCoordinates(this.mTempRect, currentFocused).left;
                                if (currentFocused != null && nextLeft <= currLeft) {
                                    handled = this.pageRight();
                                }
                                else {
                                    handled = nextFocused.requestFocus();
                                }
                            }
                        }
                        else if (direction == View.FOCUS_LEFT || direction == View.FOCUS_BACKWARD) {
                            handled = this.pageLeft();
                        }
                        else if (direction == View.FOCUS_RIGHT || direction == View.FOCUS_FORWARD) {
                            handled = this.pageRight();
                        }
                        return handled;
                    }
                    getChildRectInPagerCoordinates(outRect, child) {
                        if (outRect == null) {
                            outRect = new Rect();
                        }
                        if (child == null) {
                            outRect.set(0, 0, 0, 0);
                            return outRect;
                        }
                        outRect.left = child.getLeft();
                        outRect.right = child.getRight();
                        outRect.top = child.getTop();
                        outRect.bottom = child.getBottom();
                        let parent = child.getParent();
                        while (parent instanceof ViewGroup && parent != this) {
                            const group = parent;
                            outRect.left += group.getLeft();
                            outRect.right += group.getRight();
                            outRect.top += group.getTop();
                            outRect.bottom += group.getBottom();
                            parent = group.getParent();
                        }
                        return outRect;
                    }
                    pageLeft() {
                        if (this.mCurItem > 0) {
                            this.setCurrentItem(this.mCurItem - 1, true);
                            return true;
                        }
                        return false;
                    }
                    pageRight() {
                        if (this.mAdapter != null && this.mCurItem < (this.mAdapter.getCount() - 1)) {
                            this.setCurrentItem(this.mCurItem + 1, true);
                            return true;
                        }
                        return false;
                    }
                    addFocusables(views, direction, focusableMode) {
                        const focusableCount = views.size();
                        const descendantFocusability = this.getDescendantFocusability();
                        if (descendantFocusability != ViewGroup.FOCUS_BLOCK_DESCENDANTS) {
                            for (let i = 0; i < this.getChildCount(); i++) {
                                const child = this.getChildAt(i);
                                if (child.getVisibility() == View.VISIBLE) {
                                    let ii = this.infoForChild(child);
                                    if (ii != null && ii.position == this.mCurItem) {
                                        child.addFocusables(views, direction, focusableMode);
                                    }
                                }
                            }
                        }
                        if (descendantFocusability != ViewGroup.FOCUS_AFTER_DESCENDANTS ||
                            (focusableCount == views.size())) {
                            if (!this.isFocusable()) {
                                return;
                            }
                            if ((focusableMode & ViewGroup.FOCUSABLES_TOUCH_MODE) == ViewGroup.FOCUSABLES_TOUCH_MODE &&
                                this.isInTouchMode() && !this.isFocusableInTouchMode()) {
                                return;
                            }
                            if (views != null) {
                                views.add(this);
                            }
                        }
                    }
                    addTouchables(views) {
                        for (let i = 0; i < this.getChildCount(); i++) {
                            const child = this.getChildAt(i);
                            if (child.getVisibility() == View.VISIBLE) {
                                let ii = this.infoForChild(child);
                                if (ii != null && ii.position == this.mCurItem) {
                                    child.addTouchables(views);
                                }
                            }
                        }
                    }
                    onRequestFocusInDescendants(direction, previouslyFocusedRect) {
                        let index;
                        let increment;
                        let end;
                        let count = this.getChildCount();
                        if ((direction & View.FOCUS_FORWARD) != 0) {
                            index = 0;
                            increment = 1;
                            end = count;
                        }
                        else {
                            index = count - 1;
                            increment = -1;
                            end = -1;
                        }
                        for (let i = index; i != end; i += increment) {
                            let child = this.getChildAt(i);
                            if (child.getVisibility() == View.VISIBLE) {
                                let ii = this.infoForChild(child);
                                if (ii != null && ii.position == this.mCurItem) {
                                    if (child.requestFocus(direction, previouslyFocusedRect)) {
                                        return true;
                                    }
                                }
                            }
                        }
                        return false;
                    }
                    generateDefaultLayoutParams() {
                        return new ViewPager.LayoutParams();
                    }
                    generateLayoutParams(p) {
                        return this.generateDefaultLayoutParams();
                    }
                    checkLayoutParams(p) {
                        return p instanceof ViewPager.LayoutParams && super.checkLayoutParams(p);
                    }
                    static isImplDecor(view) {
                        return view[SymbolDecor] || view.constructor[SymbolDecor];
                    }
                    static setClassImplDecor(clazz) {
                        clazz[SymbolDecor] = true;
                    }
                }
                ViewPager.COMPARATOR = (lhs, rhs) => {
                    return lhs.position - rhs.position;
                };
                ViewPager.USE_CACHE = false;
                ViewPager.DEFAULT_OFFSCREEN_PAGES = 1;
                ViewPager.MAX_SETTLE_DURATION = 600;
                ViewPager.MIN_DISTANCE_FOR_FLING = 25;
                ViewPager.DEFAULT_GUTTER_SIZE = 16;
                ViewPager.MIN_FLING_VELOCITY = 400;
                ViewPager.sInterpolator = {
                    getInterpolation(t) {
                        t -= 1.0;
                        return t * t * t * t * t + 1.0;
                    }
                };
                ViewPager.INVALID_POINTER = -1;
                ViewPager.CLOSE_ENOUGH = 2;
                ViewPager.DRAW_ORDER_DEFAULT = 0;
                ViewPager.DRAW_ORDER_FORWARD = 1;
                ViewPager.DRAW_ORDER_REVERSE = 2;
                ViewPager.sPositionComparator = (lhs, rhs) => {
                    let llp = lhs.getLayoutParams();
                    let rlp = rhs.getLayoutParams();
                    if (llp.isDecor != rlp.isDecor) {
                        return llp.isDecor ? 1 : -1;
                    }
                    return llp.position - rlp.position;
                };
                ViewPager.SCROLL_STATE_IDLE = 0;
                ViewPager.SCROLL_STATE_DRAGGING = 1;
                ViewPager.SCROLL_STATE_SETTLING = 2;
                view_6.ViewPager = ViewPager;
                (function (ViewPager) {
                    class SimpleOnPageChangeListener {
                        onPageScrolled(position, positionOffset, positionOffsetPixels) {
                        }
                        onPageSelected(position) {
                        }
                        onPageScrollStateChanged(state) {
                        }
                    }
                    ViewPager.SimpleOnPageChangeListener = SimpleOnPageChangeListener;
                    class LayoutParams extends ViewGroup.LayoutParams {
                        constructor() {
                            super(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
                            this.isDecor = false;
                            this.gravity = 0;
                            this.widthFactor = 0;
                            this.needsMeasure = false;
                            this.position = 0;
                            this.childIndex = 0;
                        }
                        _createAttrChangeHandler(mergeHandler) {
                            super._createAttrChangeHandler(mergeHandler);
                            let params = this;
                            mergeHandler.add({
                                set gravity(value) {
                                    params.gravity = View.AttrChangeHandler.parseGravity(value, params.gravity);
                                },
                                get gravity() {
                                    return params.gravity;
                                }
                            });
                        }
                    }
                    ViewPager.LayoutParams = LayoutParams;
                })(ViewPager = view_6.ViewPager || (view_6.ViewPager = {}));
                class ItemInfo {
                    constructor() {
                        this.position = 0;
                        this.scrolling = false;
                        this.widthFactor = 0;
                        this.offset = 0;
                    }
                }
                class PagerObserver extends DataSetObserver {
                    constructor(viewPager) {
                        super();
                        this.ViewPager_this = viewPager;
                    }
                    onChanged() {
                        this.ViewPager_this.dataSetChanged();
                    }
                    onInvalidated() {
                        this.ViewPager_this.dataSetChanged();
                    }
                }
            })(view = v4.view || (v4.view = {}));
        })(v4 = support.v4 || (support.v4 = {}));
    })(support = android.support || (android.support = {}));
})(android || (android = {}));
/*
 * Copyright (C) 2013 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path="../../../../android/view/MotionEvent.ts"/>
///<reference path="../../../../android/view/VelocityTracker.ts"/>
///<reference path="../../../../android/view/View.ts"/>
///<reference path="../../../../android/view/ViewConfiguration.ts"/>
///<reference path="../../../../android/view/ViewGroup.ts"/>
///<reference path="../../../../android/widget/OverScroller.ts"/>
///<reference path="../../../../android/view/animation/Interpolator.ts"/>
///<reference path="../../../../java/lang/System.ts"/>
var android;
(function (android) {
    var support;
    (function (support) {
        var v4;
        (function (v4) {
            var widget;
            (function (widget) {
                var MotionEvent = android.view.MotionEvent;
                var VelocityTracker = android.view.VelocityTracker;
                var ViewConfiguration = android.view.ViewConfiguration;
                var ViewGroup = android.view.ViewGroup;
                var OverScroller = android.widget.OverScroller;
                var System = java.lang.System;
                class ViewDragHelper {
                    constructor(forParent, cb) {
                        this.mDragState = 0;
                        this.mTouchSlop = 0;
                        this.mActivePointerId = ViewDragHelper.INVALID_POINTER;
                        this.mPointersDown = 0;
                        this.mMaxVelocity = 0;
                        this.mMinVelocity = 0;
                        this.mEdgeSize = 0;
                        this.mTrackingEdges = 0;
                        this.mSetIdleRunnable = (() => {
                            const _this = this;
                            class _Inner {
                                run() {
                                    _this.setDragState(ViewDragHelper.STATE_IDLE);
                                }
                            }
                            return new _Inner();
                        })();
                        if (forParent == null) {
                            throw Error(`new IllegalArgumentException("Parent view may not be null")`);
                        }
                        if (cb == null) {
                            throw Error(`new IllegalArgumentException("Callback may not be null")`);
                        }
                        this.mParentView = forParent;
                        this.mCallback = cb;
                        const vc = ViewConfiguration.get();
                        const density = android.content.res.Resources.getDisplayMetrics().density;
                        this.mEdgeSize = Math.floor((ViewDragHelper.EDGE_SIZE * density + 0.5));
                        this.mTouchSlop = vc.getScaledTouchSlop();
                        this.mMaxVelocity = vc.getScaledMaximumFlingVelocity();
                        this.mMinVelocity = vc.getScaledMinimumFlingVelocity();
                        this.mScroller = new OverScroller(ViewDragHelper.sInterpolator);
                    }
                    static create(...args) {
                        if (args.length === 2)
                            return new ViewDragHelper(args[0], args[1]);
                        else if (args.length === 3) {
                            let [forParent, sensitivity, cb] = args;
                            const helper = ViewDragHelper.create(forParent, cb);
                            helper.mTouchSlop = Math.floor((helper.mTouchSlop * (1 / sensitivity)));
                            return helper;
                        }
                    }
                    setMinVelocity(minVel) {
                        this.mMinVelocity = minVel;
                    }
                    getMinVelocity() {
                        return this.mMinVelocity;
                    }
                    getViewDragState() {
                        return this.mDragState;
                    }
                    setEdgeTrackingEnabled(edgeFlags) {
                        this.mTrackingEdges = edgeFlags;
                    }
                    getEdgeSize() {
                        return this.mEdgeSize;
                    }
                    captureChildView(childView, activePointerId) {
                        if (childView.getParent() != this.mParentView) {
                            throw Error(`new IllegalArgumentException("captureChildView: parameter must be a descendant " + "of the ViewDragHelper's tracked parent view (" + this.mParentView + ")")`);
                        }
                        this.mCapturedView = childView;
                        this.mActivePointerId = activePointerId;
                        this.mCallback.onViewCaptured(childView, activePointerId);
                        this.setDragState(ViewDragHelper.STATE_DRAGGING);
                    }
                    getCapturedView() {
                        return this.mCapturedView;
                    }
                    getActivePointerId() {
                        return this.mActivePointerId;
                    }
                    getTouchSlop() {
                        return this.mTouchSlop;
                    }
                    cancel() {
                        this.mActivePointerId = ViewDragHelper.INVALID_POINTER;
                        this.clearMotionHistory();
                        if (this.mVelocityTracker != null) {
                            this.mVelocityTracker.recycle();
                            this.mVelocityTracker = null;
                        }
                    }
                    abort() {
                        this.cancel();
                        if (this.mDragState == ViewDragHelper.STATE_SETTLING) {
                            const oldX = this.mScroller.getCurrX();
                            const oldY = this.mScroller.getCurrY();
                            this.mScroller.abortAnimation();
                            const newX = this.mScroller.getCurrX();
                            const newY = this.mScroller.getCurrY();
                            this.mCallback.onViewPositionChanged(this.mCapturedView, newX, newY, newX - oldX, newY - oldY);
                        }
                        this.setDragState(ViewDragHelper.STATE_IDLE);
                    }
                    smoothSlideViewTo(child, finalLeft, finalTop) {
                        this.mCapturedView = child;
                        this.mActivePointerId = ViewDragHelper.INVALID_POINTER;
                        return this.forceSettleCapturedViewAt(finalLeft, finalTop, 0, 0);
                    }
                    settleCapturedViewAt(finalLeft, finalTop) {
                        if (!this.mReleaseInProgress) {
                            throw Error(`new IllegalStateException("Cannot settleCapturedViewAt outside of a call to " + "Callback#onViewReleased")`);
                        }
                        return this.forceSettleCapturedViewAt(finalLeft, finalTop, Math.floor(this.mVelocityTracker.getXVelocity(this.mActivePointerId)), Math.floor(this.mVelocityTracker.getYVelocity(this.mActivePointerId)));
                    }
                    forceSettleCapturedViewAt(finalLeft, finalTop, xvel, yvel) {
                        const startLeft = this.mCapturedView.getLeft();
                        const startTop = this.mCapturedView.getTop();
                        const dx = finalLeft - startLeft;
                        const dy = finalTop - startTop;
                        if (dx == 0 && dy == 0) {
                            this.mScroller.abortAnimation();
                            this.setDragState(ViewDragHelper.STATE_IDLE);
                            return false;
                        }
                        const duration = this.computeSettleDuration(this.mCapturedView, dx, dy, xvel, yvel);
                        this.mScroller.startScroll(startLeft, startTop, dx, dy, duration);
                        this.setDragState(ViewDragHelper.STATE_SETTLING);
                        return true;
                    }
                    computeSettleDuration(child, dx, dy, xvel, yvel) {
                        xvel = this.clampMag(xvel, Math.floor(this.mMinVelocity), Math.floor(this.mMaxVelocity));
                        yvel = this.clampMag(yvel, Math.floor(this.mMinVelocity), Math.floor(this.mMaxVelocity));
                        const absDx = Math.abs(dx);
                        const absDy = Math.abs(dy);
                        const absXVel = Math.abs(xvel);
                        const absYVel = Math.abs(yvel);
                        const addedVel = absXVel + absYVel;
                        const addedDistance = absDx + absDy;
                        const xweight = xvel != 0 ? absXVel / addedVel : absDx / addedDistance;
                        const yweight = yvel != 0 ? absYVel / addedVel : absDy / addedDistance;
                        let xduration = this.computeAxisDuration(dx, xvel, this.mCallback.getViewHorizontalDragRange(child));
                        let yduration = this.computeAxisDuration(dy, yvel, this.mCallback.getViewVerticalDragRange(child));
                        return Math.floor((xduration * xweight + yduration * yweight));
                    }
                    computeAxisDuration(delta, velocity, motionRange) {
                        if (delta == 0) {
                            return 0;
                        }
                        const width = this.mParentView.getWidth();
                        const halfWidth = width / 2;
                        const distanceRatio = Math.min(1, Math.abs(delta) / width);
                        const distance = halfWidth + halfWidth * this.distanceInfluenceForSnapDuration(distanceRatio);
                        let duration;
                        velocity = Math.abs(velocity);
                        if (velocity > 0) {
                            duration = 4 * Math.round(1000 * Math.abs(distance / velocity));
                        }
                        else {
                            const range = Math.abs(delta) / motionRange;
                            duration = Math.floor(((range + 1) * ViewDragHelper.BASE_SETTLE_DURATION));
                        }
                        return Math.min(duration, ViewDragHelper.MAX_SETTLE_DURATION);
                    }
                    clampMag(value, absMin, absMax) {
                        const absValue = Math.abs(value);
                        if (absValue < absMin)
                            return 0;
                        if (absValue > absMax)
                            return value > 0 ? absMax : -absMax;
                        return value;
                    }
                    distanceInfluenceForSnapDuration(f) {
                        f -= 0.5;
                        f *= 0.3 * Math.PI / 2.0;
                        return Math.sin(f);
                    }
                    flingCapturedView(minLeft, minTop, maxLeft, maxTop) {
                        if (!this.mReleaseInProgress) {
                            throw Error(`new IllegalStateException("Cannot flingCapturedView outside of a call to " + "Callback#onViewReleased")`);
                        }
                        this.mScroller.fling(this.mCapturedView.getLeft(), this.mCapturedView.getTop(), Math.floor(this.mVelocityTracker.getXVelocity(this.mActivePointerId)), Math.floor(this.mVelocityTracker.getYVelocity(this.mActivePointerId)), minLeft, maxLeft, minTop, maxTop);
                        this.setDragState(ViewDragHelper.STATE_SETTLING);
                    }
                    continueSettling(deferCallbacks) {
                        if (this.mDragState == ViewDragHelper.STATE_SETTLING) {
                            let keepGoing = this.mScroller.computeScrollOffset();
                            const x = this.mScroller.getCurrX();
                            const y = this.mScroller.getCurrY();
                            const dx = x - this.mCapturedView.getLeft();
                            const dy = y - this.mCapturedView.getTop();
                            if (dx != 0) {
                                this.mCapturedView.offsetLeftAndRight(dx);
                            }
                            if (dy != 0) {
                                this.mCapturedView.offsetTopAndBottom(dy);
                            }
                            if (dx != 0 || dy != 0) {
                                this.mCallback.onViewPositionChanged(this.mCapturedView, x, y, dx, dy);
                            }
                            if (keepGoing && x == this.mScroller.getFinalX() && y == this.mScroller.getFinalY()) {
                                this.mScroller.abortAnimation();
                                keepGoing = this.mScroller.isFinished();
                            }
                            if (!keepGoing) {
                                if (deferCallbacks) {
                                    this.mParentView.post(this.mSetIdleRunnable);
                                }
                                else {
                                    this.setDragState(ViewDragHelper.STATE_IDLE);
                                }
                            }
                        }
                        return this.mDragState == ViewDragHelper.STATE_SETTLING;
                    }
                    dispatchViewReleased(xvel, yvel) {
                        this.mReleaseInProgress = true;
                        this.mCallback.onViewReleased(this.mCapturedView, xvel, yvel);
                        this.mReleaseInProgress = false;
                        if (this.mDragState == ViewDragHelper.STATE_DRAGGING) {
                            this.setDragState(ViewDragHelper.STATE_IDLE);
                        }
                    }
                    clearMotionHistory(pointerId) {
                        if (this.mInitialMotionX == null) {
                            return;
                        }
                        if (pointerId == null) {
                            this.mInitialMotionX = [];
                            this.mInitialMotionY = [];
                            this.mLastMotionX = [];
                            this.mLastMotionY = [];
                            this.mInitialEdgesTouched = [];
                            this.mEdgeDragsInProgress = [];
                            this.mEdgeDragsLocked = [];
                            this.mPointersDown = 0;
                        }
                        else {
                            this.mInitialMotionX[pointerId] = 0;
                            this.mInitialMotionY[pointerId] = 0;
                            this.mLastMotionX[pointerId] = 0;
                            this.mLastMotionY[pointerId] = 0;
                            this.mInitialEdgesTouched[pointerId] = 0;
                            this.mEdgeDragsInProgress[pointerId] = 0;
                            this.mEdgeDragsLocked[pointerId] = 0;
                            this.mPointersDown &= ~(1 << pointerId);
                        }
                    }
                    ensureMotionHistorySizeForId(pointerId) {
                        if (this.mInitialMotionX == null || this.mInitialMotionX.length <= pointerId) {
                            let imx = new Array(pointerId + 1);
                            let imy = new Array(pointerId + 1);
                            let lmx = new Array(pointerId + 1);
                            let lmy = new Array(pointerId + 1);
                            let iit = new Array(pointerId + 1);
                            let edip = new Array(pointerId + 1);
                            let edl = new Array(pointerId + 1);
                            if (this.mInitialMotionX != null) {
                                System.arraycopy(this.mInitialMotionX, 0, imx, 0, this.mInitialMotionX.length);
                                System.arraycopy(this.mInitialMotionY, 0, imy, 0, this.mInitialMotionY.length);
                                System.arraycopy(this.mLastMotionX, 0, lmx, 0, this.mLastMotionX.length);
                                System.arraycopy(this.mLastMotionY, 0, lmy, 0, this.mLastMotionY.length);
                                System.arraycopy(this.mInitialEdgesTouched, 0, iit, 0, this.mInitialEdgesTouched.length);
                                System.arraycopy(this.mEdgeDragsInProgress, 0, edip, 0, this.mEdgeDragsInProgress.length);
                                System.arraycopy(this.mEdgeDragsLocked, 0, edl, 0, this.mEdgeDragsLocked.length);
                            }
                            this.mInitialMotionX = imx;
                            this.mInitialMotionY = imy;
                            this.mLastMotionX = lmx;
                            this.mLastMotionY = lmy;
                            this.mInitialEdgesTouched = iit;
                            this.mEdgeDragsInProgress = edip;
                            this.mEdgeDragsLocked = edl;
                        }
                    }
                    saveInitialMotion(x, y, pointerId) {
                        this.ensureMotionHistorySizeForId(pointerId);
                        this.mInitialMotionX[pointerId] = this.mLastMotionX[pointerId] = x;
                        this.mInitialMotionY[pointerId] = this.mLastMotionY[pointerId] = y;
                        this.mInitialEdgesTouched[pointerId] = this.getEdgesTouched(Math.floor(x), Math.floor(y));
                        this.mPointersDown |= 1 << pointerId;
                    }
                    saveLastMotion(ev) {
                        const pointerCount = ev.getPointerCount();
                        for (let i = 0; i < pointerCount; i++) {
                            const pointerId = ev.getPointerId(i);
                            const x = ev.getX(i);
                            const y = ev.getY(i);
                            this.mLastMotionX[pointerId] = x;
                            this.mLastMotionY[pointerId] = y;
                        }
                    }
                    isPointerDown(pointerId) {
                        return (this.mPointersDown & 1 << pointerId) != 0;
                    }
                    setDragState(state) {
                        if (this.mDragState != state) {
                            this.mDragState = state;
                            this.mCallback.onViewDragStateChanged(state);
                            if (state == ViewDragHelper.STATE_IDLE) {
                                this.mCapturedView = null;
                            }
                        }
                    }
                    tryCaptureViewForDrag(toCapture, pointerId) {
                        if (toCapture == this.mCapturedView && this.mActivePointerId == pointerId) {
                            return true;
                        }
                        if (toCapture != null && this.mCallback.tryCaptureView(toCapture, pointerId)) {
                            this.mActivePointerId = pointerId;
                            this.captureChildView(toCapture, pointerId);
                            return true;
                        }
                        return false;
                    }
                    canScroll(v, checkV, dx, dy, x, y) {
                        if (v instanceof ViewGroup) {
                            const group = v;
                            const scrollX = v.getScrollX();
                            const scrollY = v.getScrollY();
                            const count = group.getChildCount();
                            for (let i = count - 1; i >= 0; i--) {
                                const child = group.getChildAt(i);
                                if (x + scrollX >= child.getLeft() && x + scrollX < child.getRight()
                                    && y + scrollY >= child.getTop() && y + scrollY < child.getBottom()
                                    && this.canScroll(child, true, dx, dy, x + scrollX - child.getLeft(), y + scrollY - child.getTop())) {
                                    return true;
                                }
                            }
                        }
                        return checkV && (v.canScrollHorizontally(-dx) || v.canScrollVertically(-dy));
                    }
                    shouldInterceptTouchEvent(ev) {
                        const action = ev.getActionMasked();
                        const actionIndex = ev.getActionIndex();
                        if (action == MotionEvent.ACTION_DOWN) {
                            this.cancel();
                        }
                        if (this.mVelocityTracker == null) {
                            this.mVelocityTracker = VelocityTracker.obtain();
                        }
                        this.mVelocityTracker.addMovement(ev);
                        switch (action) {
                            case MotionEvent.ACTION_DOWN:
                                {
                                    const x = ev.getX();
                                    const y = ev.getY();
                                    const pointerId = ev.getPointerId(0);
                                    this.saveInitialMotion(x, y, pointerId);
                                    const toCapture = this.findTopChildUnder(Math.floor(x), Math.floor(y));
                                    if (toCapture == this.mCapturedView && this.mDragState == ViewDragHelper.STATE_SETTLING) {
                                        this.tryCaptureViewForDrag(toCapture, pointerId);
                                    }
                                    const edgesTouched = this.mInitialEdgesTouched[pointerId];
                                    if ((edgesTouched & this.mTrackingEdges) != 0) {
                                        this.mCallback.onEdgeTouched(edgesTouched & this.mTrackingEdges, pointerId);
                                    }
                                    break;
                                }
                            case MotionEvent.ACTION_POINTER_DOWN:
                                {
                                    const pointerId = ev.getPointerId(actionIndex);
                                    const x = ev.getX(actionIndex);
                                    const y = ev.getY(actionIndex);
                                    this.saveInitialMotion(x, y, pointerId);
                                    if (this.mDragState == ViewDragHelper.STATE_IDLE) {
                                        const edgesTouched = this.mInitialEdgesTouched[pointerId];
                                        if ((edgesTouched & this.mTrackingEdges) != 0) {
                                            this.mCallback.onEdgeTouched(edgesTouched & this.mTrackingEdges, pointerId);
                                        }
                                    }
                                    else if (this.mDragState == ViewDragHelper.STATE_SETTLING) {
                                        const toCapture = this.findTopChildUnder(Math.floor(x), Math.floor(y));
                                        if (toCapture == this.mCapturedView) {
                                            this.tryCaptureViewForDrag(toCapture, pointerId);
                                        }
                                    }
                                    break;
                                }
                            case MotionEvent.ACTION_MOVE:
                                {
                                    const pointerCount = ev.getPointerCount();
                                    for (let i = 0; i < pointerCount; i++) {
                                        const pointerId = ev.getPointerId(i);
                                        const x = ev.getX(i);
                                        const y = ev.getY(i);
                                        const dx = x - this.mInitialMotionX[pointerId];
                                        const dy = y - this.mInitialMotionY[pointerId];
                                        this.reportNewEdgeDrags(dx, dy, pointerId);
                                        if (this.mDragState == ViewDragHelper.STATE_DRAGGING) {
                                            break;
                                        }
                                        const toCapture = this.findTopChildUnder(Math.floor(x), Math.floor(y));
                                        if (toCapture != null && this.checkTouchSlop(toCapture, dx, dy) && this.tryCaptureViewForDrag(toCapture, pointerId)) {
                                            break;
                                        }
                                    }
                                    this.saveLastMotion(ev);
                                    break;
                                }
                            case MotionEvent.ACTION_POINTER_UP:
                                {
                                    const pointerId = ev.getPointerId(actionIndex);
                                    this.clearMotionHistory(pointerId);
                                    break;
                                }
                            case MotionEvent.ACTION_UP:
                            case MotionEvent.ACTION_CANCEL:
                                {
                                    this.cancel();
                                    break;
                                }
                        }
                        return this.mDragState == ViewDragHelper.STATE_DRAGGING;
                    }
                    processTouchEvent(ev) {
                        const action = ev.getActionMasked();
                        const actionIndex = ev.getActionIndex();
                        if (action == MotionEvent.ACTION_DOWN) {
                            this.cancel();
                        }
                        if (this.mVelocityTracker == null) {
                            this.mVelocityTracker = VelocityTracker.obtain();
                        }
                        this.mVelocityTracker.addMovement(ev);
                        switch (action) {
                            case MotionEvent.ACTION_DOWN:
                                {
                                    const x = ev.getX();
                                    const y = ev.getY();
                                    const pointerId = ev.getPointerId(0);
                                    const toCapture = this.findTopChildUnder(Math.floor(x), Math.floor(y));
                                    this.saveInitialMotion(x, y, pointerId);
                                    this.tryCaptureViewForDrag(toCapture, pointerId);
                                    const edgesTouched = this.mInitialEdgesTouched[pointerId];
                                    if ((edgesTouched & this.mTrackingEdges) != 0) {
                                        this.mCallback.onEdgeTouched(edgesTouched & this.mTrackingEdges, pointerId);
                                    }
                                    break;
                                }
                            case MotionEvent.ACTION_POINTER_DOWN:
                                {
                                    const pointerId = ev.getPointerId(actionIndex);
                                    const x = ev.getX(actionIndex);
                                    const y = ev.getY(actionIndex);
                                    this.saveInitialMotion(x, y, pointerId);
                                    if (this.mDragState == ViewDragHelper.STATE_IDLE) {
                                        const toCapture = this.findTopChildUnder(Math.floor(x), Math.floor(y));
                                        this.tryCaptureViewForDrag(toCapture, pointerId);
                                        const edgesTouched = this.mInitialEdgesTouched[pointerId];
                                        if ((edgesTouched & this.mTrackingEdges) != 0) {
                                            this.mCallback.onEdgeTouched(edgesTouched & this.mTrackingEdges, pointerId);
                                        }
                                    }
                                    else if (this.isCapturedViewUnder(Math.floor(x), Math.floor(y))) {
                                        this.tryCaptureViewForDrag(this.mCapturedView, pointerId);
                                    }
                                    break;
                                }
                            case MotionEvent.ACTION_MOVE:
                                {
                                    if (this.mDragState == ViewDragHelper.STATE_DRAGGING) {
                                        const index = ev.findPointerIndex(this.mActivePointerId);
                                        const x = ev.getX(index);
                                        const y = ev.getY(index);
                                        const idx = Math.floor((x - this.mLastMotionX[this.mActivePointerId]));
                                        const idy = Math.floor((y - this.mLastMotionY[this.mActivePointerId]));
                                        this.dragTo(this.mCapturedView.getLeft() + idx, this.mCapturedView.getTop() + idy, idx, idy);
                                        this.saveLastMotion(ev);
                                    }
                                    else {
                                        const pointerCount = ev.getPointerCount();
                                        for (let i = 0; i < pointerCount; i++) {
                                            const pointerId = ev.getPointerId(i);
                                            const x = ev.getX(i);
                                            const y = ev.getY(i);
                                            const dx = x - this.mInitialMotionX[pointerId];
                                            const dy = y - this.mInitialMotionY[pointerId];
                                            this.reportNewEdgeDrags(dx, dy, pointerId);
                                            if (this.mDragState == ViewDragHelper.STATE_DRAGGING) {
                                                break;
                                            }
                                            const toCapture = this.findTopChildUnder(Math.floor(x), Math.floor(y));
                                            if (this.checkTouchSlop(toCapture, dx, dy) && this.tryCaptureViewForDrag(toCapture, pointerId)) {
                                                break;
                                            }
                                        }
                                        this.saveLastMotion(ev);
                                    }
                                    break;
                                }
                            case MotionEvent.ACTION_POINTER_UP:
                                {
                                    const pointerId = ev.getPointerId(actionIndex);
                                    if (this.mDragState == ViewDragHelper.STATE_DRAGGING && pointerId == this.mActivePointerId) {
                                        let newActivePointer = ViewDragHelper.INVALID_POINTER;
                                        const pointerCount = ev.getPointerCount();
                                        for (let i = 0; i < pointerCount; i++) {
                                            const id = ev.getPointerId(i);
                                            if (id == this.mActivePointerId) {
                                                continue;
                                            }
                                            const x = ev.getX(i);
                                            const y = ev.getY(i);
                                            if (this.findTopChildUnder(Math.floor(x), Math.floor(y)) == this.mCapturedView && this.tryCaptureViewForDrag(this.mCapturedView, id)) {
                                                newActivePointer = this.mActivePointerId;
                                                break;
                                            }
                                        }
                                        if (newActivePointer == ViewDragHelper.INVALID_POINTER) {
                                            this.releaseViewForPointerUp();
                                        }
                                    }
                                    this.clearMotionHistory(pointerId);
                                    break;
                                }
                            case MotionEvent.ACTION_UP:
                                {
                                    if (this.mDragState == ViewDragHelper.STATE_DRAGGING) {
                                        this.releaseViewForPointerUp();
                                    }
                                    this.cancel();
                                    break;
                                }
                            case MotionEvent.ACTION_CANCEL:
                                {
                                    if (this.mDragState == ViewDragHelper.STATE_DRAGGING) {
                                        this.dispatchViewReleased(0, 0);
                                    }
                                    this.cancel();
                                    break;
                                }
                        }
                    }
                    reportNewEdgeDrags(dx, dy, pointerId) {
                        let dragsStarted = 0;
                        if (this.checkNewEdgeDrag(dx, dy, pointerId, ViewDragHelper.EDGE_LEFT)) {
                            dragsStarted |= ViewDragHelper.EDGE_LEFT;
                        }
                        if (this.checkNewEdgeDrag(dy, dx, pointerId, ViewDragHelper.EDGE_TOP)) {
                            dragsStarted |= ViewDragHelper.EDGE_TOP;
                        }
                        if (this.checkNewEdgeDrag(dx, dy, pointerId, ViewDragHelper.EDGE_RIGHT)) {
                            dragsStarted |= ViewDragHelper.EDGE_RIGHT;
                        }
                        if (this.checkNewEdgeDrag(dy, dx, pointerId, ViewDragHelper.EDGE_BOTTOM)) {
                            dragsStarted |= ViewDragHelper.EDGE_BOTTOM;
                        }
                        if (dragsStarted != 0) {
                            this.mEdgeDragsInProgress[pointerId] |= dragsStarted;
                            this.mCallback.onEdgeDragStarted(dragsStarted, pointerId);
                        }
                    }
                    checkNewEdgeDrag(delta, odelta, pointerId, edge) {
                        const absDelta = Math.abs(delta);
                        const absODelta = Math.abs(odelta);
                        if ((this.mInitialEdgesTouched[pointerId] & edge) != edge || (this.mTrackingEdges & edge) == 0 || (this.mEdgeDragsLocked[pointerId] & edge) == edge || (this.mEdgeDragsInProgress[pointerId] & edge) == edge || (absDelta <= this.mTouchSlop && absODelta <= this.mTouchSlop)) {
                            return false;
                        }
                        if (absDelta < absODelta * 0.5 && this.mCallback.onEdgeLock(edge)) {
                            this.mEdgeDragsLocked[pointerId] |= edge;
                            return false;
                        }
                        return (this.mEdgeDragsInProgress[pointerId] & edge) == 0 && absDelta > this.mTouchSlop;
                    }
                    checkTouchSlop(...args) {
                        if (args.length === 1)
                            return this._checkTouchSlop_1(args[0]);
                        if (args.length === 2)
                            return this._checkTouchSlop_2(args[0], args[1]);
                        if (args.length === 3)
                            return this._checkTouchSlop_3(args[0], args[2], args[3]);
                        return false;
                    }
                    _checkTouchSlop_3(child, dx, dy) {
                        if (child == null) {
                            return false;
                        }
                        const checkHorizontal = this.mCallback.getViewHorizontalDragRange(child) > 0;
                        const checkVertical = this.mCallback.getViewVerticalDragRange(child) > 0;
                        if (checkHorizontal && checkVertical) {
                            return dx * dx + dy * dy > this.mTouchSlop * this.mTouchSlop;
                        }
                        else if (checkHorizontal) {
                            return Math.abs(dx) > this.mTouchSlop;
                        }
                        else if (checkVertical) {
                            return Math.abs(dy) > this.mTouchSlop;
                        }
                        return false;
                    }
                    _checkTouchSlop_1(directions) {
                        const count = this.mInitialMotionX.length;
                        for (let i = 0; i < count; i++) {
                            if (this.checkTouchSlop(directions, i)) {
                                return true;
                            }
                        }
                        return false;
                    }
                    _checkTouchSlop_2(directions, pointerId) {
                        if (!this.isPointerDown(pointerId)) {
                            return false;
                        }
                        const checkHorizontal = (directions & ViewDragHelper.DIRECTION_HORIZONTAL) == ViewDragHelper.DIRECTION_HORIZONTAL;
                        const checkVertical = (directions & ViewDragHelper.DIRECTION_VERTICAL) == ViewDragHelper.DIRECTION_VERTICAL;
                        const dx = this.mLastMotionX[pointerId] - this.mInitialMotionX[pointerId];
                        const dy = this.mLastMotionY[pointerId] - this.mInitialMotionY[pointerId];
                        if (checkHorizontal && checkVertical) {
                            return dx * dx + dy * dy > this.mTouchSlop * this.mTouchSlop;
                        }
                        else if (checkHorizontal) {
                            return Math.abs(dx) > this.mTouchSlop;
                        }
                        else if (checkVertical) {
                            return Math.abs(dy) > this.mTouchSlop;
                        }
                        return false;
                    }
                    isEdgeTouched(edges, pointerId) {
                        if (pointerId == null) {
                            const count = this.mInitialEdgesTouched.length;
                            for (let i = 0; i < count; i++) {
                                if (this.isEdgeTouched(edges, i)) {
                                    return true;
                                }
                            }
                        }
                        return this.isPointerDown(pointerId) && (this.mInitialEdgesTouched[pointerId] & edges) != 0;
                    }
                    releaseViewForPointerUp() {
                        this.mVelocityTracker.computeCurrentVelocity(1000, this.mMaxVelocity);
                        const xvel = this.clampMag(this.mVelocityTracker.getXVelocity(this.mActivePointerId), this.mMinVelocity, this.mMaxVelocity);
                        const yvel = this.clampMag(this.mVelocityTracker.getYVelocity(this.mActivePointerId), this.mMinVelocity, this.mMaxVelocity);
                        this.dispatchViewReleased(xvel, yvel);
                    }
                    dragTo(left, top, dx, dy) {
                        let clampedX = left;
                        let clampedY = top;
                        const oldLeft = this.mCapturedView.getLeft();
                        const oldTop = this.mCapturedView.getTop();
                        if (dx != 0) {
                            clampedX = this.mCallback.clampViewPositionHorizontal(this.mCapturedView, left, dx);
                            this.mCapturedView.offsetLeftAndRight(clampedX - oldLeft);
                        }
                        if (dy != 0) {
                            clampedY = this.mCallback.clampViewPositionVertical(this.mCapturedView, top, dy);
                            this.mCapturedView.offsetTopAndBottom(clampedY - oldTop);
                        }
                        if (dx != 0 || dy != 0) {
                            const clampedDx = clampedX - oldLeft;
                            const clampedDy = clampedY - oldTop;
                            this.mCallback.onViewPositionChanged(this.mCapturedView, clampedX, clampedY, clampedDx, clampedDy);
                        }
                    }
                    isCapturedViewUnder(x, y) {
                        return this.isViewUnder(this.mCapturedView, x, y);
                    }
                    isViewUnder(view, x, y) {
                        if (view == null) {
                            return false;
                        }
                        return x >= view.getLeft() && x < view.getRight() && y >= view.getTop() && y < view.getBottom();
                    }
                    findTopChildUnder(x, y) {
                        const childCount = this.mParentView.getChildCount();
                        for (let i = childCount - 1; i >= 0; i--) {
                            const child = this.mParentView.getChildAt(this.mCallback.getOrderedChildIndex(i));
                            if (x >= child.getLeft() && x < child.getRight() && y >= child.getTop() && y < child.getBottom()) {
                                return child;
                            }
                        }
                        return null;
                    }
                    getEdgesTouched(x, y) {
                        let result = 0;
                        if (x < this.mParentView.getLeft() + this.mEdgeSize)
                            result |= ViewDragHelper.EDGE_LEFT;
                        if (y < this.mParentView.getTop() + this.mEdgeSize)
                            result |= ViewDragHelper.EDGE_TOP;
                        if (x > this.mParentView.getRight() - this.mEdgeSize)
                            result |= ViewDragHelper.EDGE_RIGHT;
                        if (y > this.mParentView.getBottom() - this.mEdgeSize)
                            result |= ViewDragHelper.EDGE_BOTTOM;
                        return result;
                    }
                }
                ViewDragHelper.TAG = "ViewDragHelper";
                ViewDragHelper.INVALID_POINTER = -1;
                ViewDragHelper.STATE_IDLE = 0;
                ViewDragHelper.STATE_DRAGGING = 1;
                ViewDragHelper.STATE_SETTLING = 2;
                ViewDragHelper.EDGE_LEFT = 1 << 0;
                ViewDragHelper.EDGE_RIGHT = 1 << 1;
                ViewDragHelper.EDGE_TOP = 1 << 2;
                ViewDragHelper.EDGE_BOTTOM = 1 << 3;
                ViewDragHelper.EDGE_ALL = ViewDragHelper.EDGE_LEFT | ViewDragHelper.EDGE_TOP | ViewDragHelper.EDGE_RIGHT | ViewDragHelper.EDGE_BOTTOM;
                ViewDragHelper.DIRECTION_HORIZONTAL = 1 << 0;
                ViewDragHelper.DIRECTION_VERTICAL = 1 << 1;
                ViewDragHelper.DIRECTION_ALL = ViewDragHelper.DIRECTION_HORIZONTAL | ViewDragHelper.DIRECTION_VERTICAL;
                ViewDragHelper.EDGE_SIZE = 20;
                ViewDragHelper.BASE_SETTLE_DURATION = 256;
                ViewDragHelper.MAX_SETTLE_DURATION = 600;
                ViewDragHelper.sInterpolator = (() => {
                    class _Inner {
                        getInterpolation(t) {
                            t -= 1.0;
                            return t * t * t * t * t + 1.0;
                        }
                    }
                    return new _Inner();
                })();
                widget.ViewDragHelper = ViewDragHelper;
                (function (ViewDragHelper) {
                    class Callback {
                        onViewDragStateChanged(state) {
                        }
                        onViewPositionChanged(changedView, left, top, dx, dy) {
                        }
                        onViewCaptured(capturedChild, activePointerId) {
                        }
                        onViewReleased(releasedChild, xvel, yvel) {
                        }
                        onEdgeTouched(edgeFlags, pointerId) {
                        }
                        onEdgeLock(edgeFlags) {
                            return false;
                        }
                        onEdgeDragStarted(edgeFlags, pointerId) {
                        }
                        getOrderedChildIndex(index) {
                            return index;
                        }
                        getViewHorizontalDragRange(child) {
                            return 0;
                        }
                        getViewVerticalDragRange(child) {
                            return 0;
                        }
                        clampViewPositionHorizontal(child, left, dx) {
                            return 0;
                        }
                        clampViewPositionVertical(child, top, dy) {
                            return 0;
                        }
                    }
                    ViewDragHelper.Callback = Callback;
                })(ViewDragHelper = widget.ViewDragHelper || (widget.ViewDragHelper = {}));
            })(widget = v4.widget || (v4.widget = {}));
        })(v4 = support.v4 || (support.v4 = {}));
    })(support = android.support || (android.support = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/6.
 */
///<reference path="../../../../android/view/View.ts"/>
///<reference path="../../../../android/view/ViewGroup.ts"/>
///<reference path="../../../../android/support/v4/view/ViewPager.ts"/>
///<reference path="../../../../android/support/v4/view/PagerAdapter.ts"/>
var com;
(function (com) {
    var jakewharton;
    (function (jakewharton) {
        var salvage;
        (function (salvage) {
            var SparseArray = android.util.SparseArray;
            var PagerAdapter = android.support.v4.view.PagerAdapter;
            class RecyclingPagerAdapter extends PagerAdapter {
                constructor() {
                    super();
                    this.recycleBin = new RecycleBin();
                    this.recycleBin.setViewTypeCount(this.getViewTypeCount());
                }
                notifyDataSetChanged() {
                    this.recycleBin.scrapActiveViews();
                    super.notifyDataSetChanged();
                }
                instantiateItem(container, position) {
                    let viewType = this.getItemViewType(position);
                    let view = null;
                    if (viewType != RecyclingPagerAdapter.IGNORE_ITEM_VIEW_TYPE) {
                        view = this.recycleBin.getScrapView(position, viewType);
                    }
                    view = this.getView(position, view, container);
                    container.addView(view);
                    return view;
                }
                destroyItem(container, position, object) {
                    let view = object;
                    container.removeView(view);
                    let viewType = this.getItemViewType(position);
                    if (viewType != RecyclingPagerAdapter.IGNORE_ITEM_VIEW_TYPE) {
                        this.recycleBin.addScrapView(view, position, viewType);
                    }
                }
                isViewFromObject(view, object) {
                    return view === object;
                }
                getViewTypeCount() {
                    return 1;
                }
                getItemViewType(position) {
                    return 0;
                }
            }
            RecyclingPagerAdapter.IGNORE_ITEM_VIEW_TYPE = -1;
            salvage.RecyclingPagerAdapter = RecyclingPagerAdapter;
            class RecycleBin {
                constructor() {
                    this.activeViews = [];
                    this.activeViewTypes = [];
                    this.viewTypeCount = 0;
                }
                setViewTypeCount(viewTypeCount) {
                    if (viewTypeCount < 1) {
                        throw new Error("Can't have a viewTypeCount < 1");
                    }
                    let scrapViews = new Array(viewTypeCount);
                    for (let i = 0; i < viewTypeCount; i++) {
                        scrapViews[i] = new SparseArray();
                    }
                    this.viewTypeCount = viewTypeCount;
                    this.currentScrapViews = scrapViews[0];
                    this.scrapViews = scrapViews;
                }
                shouldRecycleViewType(viewType) {
                    return viewType >= 0;
                }
                getScrapView(position, viewType) {
                    if (this.viewTypeCount == 1) {
                        return this.retrieveFromScrap(this.currentScrapViews, position);
                    }
                    else if (viewType >= 0 && viewType < this.scrapViews.length) {
                        return this.retrieveFromScrap(this.scrapViews[viewType], position);
                    }
                    return null;
                }
                addScrapView(scrap, position, viewType) {
                    if (this.viewTypeCount == 1) {
                        this.currentScrapViews.put(position, scrap);
                    }
                    else {
                        this.scrapViews[viewType].put(position, scrap);
                    }
                }
                scrapActiveViews() {
                    const activeViews = this.activeViews;
                    const activeViewTypes = this.activeViewTypes;
                    const multipleScraps = this.viewTypeCount > 1;
                    let scrapViews = this.currentScrapViews;
                    const count = activeViews.length;
                    for (let i = count - 1; i >= 0; i--) {
                        const victim = activeViews[i];
                        if (victim != null) {
                            let whichScrap = activeViewTypes[i];
                            activeViews[i] = null;
                            activeViewTypes[i] = -1;
                            if (!this.shouldRecycleViewType(whichScrap)) {
                                continue;
                            }
                            if (multipleScraps) {
                                scrapViews = this.scrapViews[whichScrap];
                            }
                            scrapViews.put(i, victim);
                        }
                    }
                    this.pruneScrapViews();
                }
                pruneScrapViews() {
                    const maxViews = this.activeViews.length;
                    const viewTypeCount = this.viewTypeCount;
                    const scrapViews = this.scrapViews;
                    for (let i = 0; i < viewTypeCount; ++i) {
                        const scrapPile = scrapViews[i];
                        let size = scrapPile.size();
                        const extras = size - maxViews;
                        size--;
                        for (let j = 0; j < extras; j++) {
                            scrapPile.remove(scrapPile.keyAt(size--));
                        }
                    }
                }
                retrieveFromScrap(scrapViews, position) {
                    let size = scrapViews.size();
                    if (size > 0) {
                        for (let i = 0; i < size; i++) {
                            let fromPosition = scrapViews.keyAt(i);
                            let view = scrapViews.get(fromPosition);
                            if (fromPosition == position) {
                                scrapViews.remove(fromPosition);
                                return view;
                            }
                        }
                        let index = size - 1;
                        let r = scrapViews.valueAt(index);
                        scrapViews.remove(scrapViews.keyAt(index));
                        return r;
                    }
                    else {
                        return null;
                    }
                }
            }
        })(salvage = jakewharton.salvage || (jakewharton.salvage = {}));
    })(jakewharton = com.jakewharton || (com.jakewharton = {}));
})(com || (com = {}));
/**
 * Created by linfaxin on 15/10/23.
 */
///<reference path="../android/view/View.ts"/>
///<reference path="../android/view/ViewGroup.ts"/>
///<reference path="../android/view/ViewRootImpl.ts"/>
///<reference path="../android/widget/FrameLayout.ts"/>
///<reference path="../android/view/MotionEvent.ts"/>
///<reference path="../android/view/KeyEvent.ts"/>
var androidui;
(function (androidui) {
    var View = android.view.View;
    var ViewGroup = android.view.ViewGroup;
    var ViewRootImpl = android.view.ViewRootImpl;
    var FrameLayout = android.widget.FrameLayout;
    var MotionEvent = android.view.MotionEvent;
    var KeyEvent = android.view.KeyEvent;
    let sNextAndroidID = 0;
    class AndroidUI {
        constructor(element) {
            this._windowBound = new android.graphics.Rect();
            this.tempRect = new android.graphics.Rect();
            this.touchEvent = new MotionEvent();
            this.ketEvent = new KeyEvent();
            this.element = element;
            if (element[AndroidUI.BindTOElementName]) {
                throw Error('already init a AndroidUI with this element');
            }
            element[AndroidUI.BindTOElementName] = this;
            this.init();
        }
        get windowBound() {
            return this._windowBound;
        }
        init() {
            this.AndroidID = sNextAndroidID++;
            this.element.classList.add(AndroidUI.DomClassName);
            this.element.classList.add('id-' + this.AndroidID);
            this._viewRootImpl = new ViewRootImpl();
            this._viewRootImpl.rootElement = this.element;
            this._rootLayout = new RootLayout();
            this._canvas = document.createElement("canvas");
            this.initInflateView();
            this.element.innerHTML = '';
            this.initElementStyle();
            if (this.rootResourceElement)
                this.element.appendChild(this.rootResourceElement);
            if (this.rootStyleElement)
                this.element.appendChild(this.rootStyleElement);
            this.element.appendChild(this._canvas);
            this.element.appendChild(this._rootLayout.bindElement);
            this._viewRootImpl.setView(this._rootLayout);
            this._viewRootImpl.initSurface(this._canvas);
            this.initFocus();
            this.initEvent();
            this.initListenSizeChange();
        }
        initInflateView() {
            Array.from(this.element.children).forEach((item) => {
                if (item.tagName.toLowerCase() === 'resources') {
                    this.rootResourceElement = item;
                }
                else if (item instanceof HTMLStyleElement) {
                    this.rootStyleElement = item;
                }
                else if (item instanceof HTMLElement) {
                    let view = View.inflate(item, this.element, this._rootLayout);
                    if (view)
                        this._rootLayout.addView(view);
                }
            });
        }
        initElementStyle() {
            if (!this.rootStyleElement) {
                this.rootStyleElement = document.createElement("style");
            }
            this.rootStyleElement.setAttribute('scoped', '');
            let density = android.content.res.Resources.getDisplayMetrics().density;
            if (density != 1) {
                this.rootStyleElement.innerHTML += `
                .${AndroidUI.DomClassName}.id-${this.AndroidID} RootLayout {
                    transform:scale(${1 / density},${1 / density});
                    -webkit-transform:scale(${1 / density},${1 / density});
                    transform-origin:0 0;
                    -webkit-transform-origin:0 0;
                }
                `;
            }
            if (this.element.style.display === 'none') {
                this.element.style.display = '';
            }
            if (this.rootStyleElement.innerHTML.length == 0) {
                this.rootStyleElement = null;
            }
        }
        refreshWindowBound() {
            let rootViewBound = this.element.getBoundingClientRect();
            this._windowBound.set(rootViewBound.left, rootViewBound.top, rootViewBound.right, rootViewBound.bottom);
        }
        initFocus() {
            this.element.setAttribute('tabindex', '0');
            this.element.focus();
        }
        initEvent() {
            this.initTouchEvent();
            this.initMouseEvent();
            this.initKeyEvent();
            this.initGenericEvent();
        }
        initTouchEvent() {
            this.element.addEventListener('touchstart', (e) => {
                this.refreshWindowBound();
                e.preventDefault();
                e.stopPropagation();
                this.element.focus();
                this.touchEvent.initWithTouch(e, MotionEvent.ACTION_DOWN, this._windowBound);
                this._viewRootImpl.dispatchInputEvent(this.touchEvent);
            }, true);
            this.element.addEventListener('touchmove', (e) => {
                e.preventDefault();
                e.stopPropagation();
                this.touchEvent.initWithTouch(e, MotionEvent.ACTION_MOVE, this._windowBound);
                this._viewRootImpl.dispatchInputEvent(this.touchEvent);
            }, true);
            this.element.addEventListener('touchend', (e) => {
                e.preventDefault();
                e.stopPropagation();
                this.touchEvent.initWithTouch(e, MotionEvent.ACTION_UP, this._windowBound);
                this._viewRootImpl.dispatchInputEvent(this.touchEvent);
            }, true);
            this.element.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                e.stopPropagation();
                this.touchEvent.initWithTouch(e, MotionEvent.ACTION_CANCEL, this._windowBound);
                this._viewRootImpl.dispatchInputEvent(this.touchEvent);
            }, true);
        }
        initMouseEvent() {
            function mouseToTouchEvent(e) {
                let touch = {
                    identifier: 0,
                    target: null,
                    screenX: e.screenX,
                    screenY: e.screenY,
                    clientX: e.clientX,
                    clientY: e.clientY,
                    pageX: e.pageX,
                    pageY: e.pageY
                };
                return {
                    changedTouches: [touch],
                    targetTouches: [touch],
                    touches: e.type === 'mouseup' ? [] : [touch],
                    timeStamp: e.timeStamp
                };
            }
            let isMouseDown = false;
            this.element.addEventListener('mousedown', (e) => {
                isMouseDown = true;
                this.refreshWindowBound();
                e.preventDefault();
                e.stopPropagation();
                this.element.focus();
                this.touchEvent.initWithTouch(mouseToTouchEvent(e), MotionEvent.ACTION_DOWN, this._windowBound);
                this._viewRootImpl.dispatchInputEvent(this.touchEvent);
            }, true);
            this.element.addEventListener('mousemove', (e) => {
                if (!isMouseDown)
                    return;
                e.preventDefault();
                e.stopPropagation();
                this.touchEvent.initWithTouch(mouseToTouchEvent(e), MotionEvent.ACTION_MOVE, this._windowBound);
                this._viewRootImpl.dispatchInputEvent(this.touchEvent);
            }, true);
            this.element.addEventListener('mouseup', (e) => {
                isMouseDown = false;
                e.preventDefault();
                e.stopPropagation();
                this.touchEvent.initWithTouch(mouseToTouchEvent(e), MotionEvent.ACTION_UP, this._windowBound);
                this._viewRootImpl.dispatchInputEvent(this.touchEvent);
            }, true);
            this.element.addEventListener('mouseleave', (e) => {
                if (e.fromElement === this.element) {
                    isMouseDown = false;
                    e.preventDefault();
                    e.stopPropagation();
                    this.touchEvent.initWithTouch(mouseToTouchEvent(e), MotionEvent.ACTION_CANCEL, this._windowBound);
                    this._viewRootImpl.dispatchInputEvent(this.touchEvent);
                }
            }, true);
            let scrollEvent = new MotionEvent();
            this.element.addEventListener('mousewheel', (e) => {
                scrollEvent.initWithMouseWheel(e);
                if (this._viewRootImpl.dispatchInputEvent(scrollEvent)) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            }, true);
        }
        initKeyEvent() {
            this.element.addEventListener('keydown', (e) => {
                this.ketEvent.appendKeyEvent(e, KeyEvent.ACTION_DOWN);
                if (this._viewRootImpl.dispatchInputEvent(this.ketEvent)) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            }, true);
            this.element.addEventListener('keyup', (e) => {
                this.ketEvent.appendKeyEvent(e, KeyEvent.ACTION_UP);
                if (this._viewRootImpl.dispatchInputEvent(this.ketEvent)) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            }, true);
        }
        initGenericEvent() {
        }
        initListenSizeChange() {
            window.addEventListener('resize', () => {
                this.notifySizeChange();
            });
            let lastWidth = this.element.offsetWidth;
            let lastHeight = this.element.offsetHeight;
            if (lastWidth > 0 && lastHeight > 0)
                this.notifySizeChange();
            setInterval(() => {
                let width = this.element.offsetWidth;
                let height = this.element.offsetHeight;
                if (lastHeight !== height || lastWidth !== width) {
                    lastWidth = width;
                    lastHeight = height;
                    this.notifySizeChange();
                }
            }, 300);
        }
        notifySizeChange() {
            this.refreshWindowBound();
            let density = android.content.res.Resources.getDisplayMetrics().density;
            this.tempRect.set(this._windowBound.left * density, this._windowBound.top * density, this._windowBound.right * density, this._windowBound.bottom * density);
            this._viewRootImpl.dispatchResized(this.tempRect);
            let width = this._windowBound.width();
            let height = this._windowBound.height();
            this._canvas.width = width * density;
            this._canvas.height = height * density;
            this._canvas.style.width = width + "px";
            this._canvas.style.height = height + "px";
        }
        setContentView(view) {
            this._rootLayout.removeAllViews();
            this._rootLayout.addView(view, -1, -1);
        }
        addContentView(view, params = new ViewGroup.LayoutParams(-1, -1)) {
            this._rootLayout.addView(view, params);
        }
        findViewById(id) {
            return this._rootLayout.findViewById(id);
        }
    }
    AndroidUI.DomClassName = 'AndroidUI';
    AndroidUI.BindTOElementName = 'AndroidUI';
    androidui.AndroidUI = AndroidUI;
    let styleElement = document.createElement('style');
    styleElement.innerHTML += `
        .${AndroidUI.DomClassName} {
            position : relative;
            overflow : hidden;
            display : block;
            outline: none;
        }
        .${AndroidUI.DomClassName} * {
            overflow : hidden;
            border : none;
            outline: none;
        }
        .${AndroidUI.DomClassName} resources {
            display: none;
        }
        .${AndroidUI.DomClassName} Button {
            border: none;
            background: none;
        }
        .${AndroidUI.DomClassName} > canvas {
            position: absolute;
            left: 0;
            top: 0;
        }
        `;
    document.head.appendChild(styleElement);
    class RootLayout extends FrameLayout {
    }
})(androidui || (androidui = {}));
/**
 * Created by linfaxin on 15/10/11.
 */
///<reference path="../view/View.ts"/>
///<reference path="../view/ViewRootImpl.ts"/>
///<reference path="../widget/FrameLayout.ts"/>
///<reference path="../view/MotionEvent.ts"/>
///<reference path="../../androidui/AndroidUI.ts"/>
var android;
(function (android) {
    var app;
    (function (app) {
        var AndroidUI = androidui.AndroidUI;
        if (typeof HTMLDivElement !== 'function') {
            var _HTMLDivElement = function () { };
            _HTMLDivElement.prototype = HTMLDivElement.prototype;
            HTMLDivElement = _HTMLDivElement;
        }
        class Activity extends HTMLDivElement {
            onCreate() {
            }
            createdCallback() {
                requestAnimationFrame(() => {
                    this.AndroidUI = new AndroidUI(this);
                    this.onCreate();
                    let onCreateFunc = this.getAttribute('oncreate');
                    if (onCreateFunc && typeof window[onCreateFunc] === "function") {
                        window[onCreateFunc].call(this, this);
                    }
                });
            }
            attachedCallback() {
                if (this.AndroidUI) {
                    this.AndroidUI.notifySizeChange();
                }
                else {
                    setTimeout(() => {
                        this.AndroidUI.notifySizeChange();
                    }, 50);
                }
            }
            detachedCallback() {
            }
            attributeChangedCallback(attributeName, oldVal, newVal) {
            }
            setContentView(view) {
                this.AndroidUI.setContentView(view);
            }
            addContentView(view) {
                this.AndroidUI.addContentView(view);
            }
            findViewById(id) {
                return this.AndroidUI.findViewById(id);
            }
            static registerCustomElement() {
                document.registerElement("android-" + this.name, this);
            }
        }
        app.Activity = Activity;
        Activity.registerCustomElement();
    })(app = android.app || (android.app = {}));
})(android || (android = {}));
/**
 * Created by linfaxin on 15/11/16.
 */
///<reference path="../../android/view/View.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../android/widget/AbsListView.ts"/>
///<reference path="../../android/widget/ListAdapter.ts"/>
///<reference path="../../android/widget/BaseAdapter.ts"/>
///<reference path="../../android/widget/AdapterView.ts"/>
///<reference path="../../android/widget/SpinnerAdapter.ts"/>
///<reference path="../../android/database/DataSetObservable.ts"/>
///<reference path="../../android/database/DataSetObserver.ts"/>
var androidui;
(function (androidui) {
    var widget;
    (function (widget) {
        var View = android.view.View;
        var AbsListView = android.widget.AbsListView;
        var BaseAdapter = android.widget.BaseAdapter;
        var AdapterView = android.widget.AdapterView;
        class HtmlDataListAdapter extends BaseAdapter {
            onInflateAdapter(bindElement, rootElement, parent) {
                this.bindElementData = bindElement;
                this.rootElement = rootElement;
                if (parent instanceof AbsListView) {
                    parent.setAdapter(this);
                }
                bindElement[HtmlDataListAdapter.BindAdapterProperty] = this;
                this.registerHtmlDataObserver();
            }
            registerHtmlDataObserver() {
                const adapter = this;
                function callBack(arr, observer) {
                    adapter.notifyDataSetChanged();
                }
                let observer = new MutationObserver(callBack);
                observer.observe(this.bindElementData, { childList: true });
            }
            getItemViewType(position) {
                return AdapterView.ITEM_VIEW_TYPE_IGNORE;
            }
            getView(position, convertView, parent) {
                let element = this.getItem(position);
                let view = element[View.AndroidViewProperty];
                this.checkReplaceWithRef(element);
                if (!view) {
                    view = View.inflate(element, this.rootElement, parent);
                    element[View.AndroidViewProperty] = view;
                }
                return view;
            }
            getCount() {
                return this.bindElementData.children.length;
            }
            getItem(position) {
                let element = this.bindElementData.children[position];
                if (element.tagName === HtmlDataListAdapter.RefElementTag) {
                    element = element[HtmlDataListAdapter.RefElementProperty];
                    if (!element)
                        throw Error('Reference element is ' + element);
                }
                return element;
            }
            checkReplaceWithRef(element) {
                let refElement = element[HtmlDataListAdapter.RefElementProperty] || document.createElement(HtmlDataListAdapter.RefElementTag);
                refElement[HtmlDataListAdapter.RefElementProperty] = element;
                element[HtmlDataListAdapter.RefElementProperty] = refElement;
                if (element.parentNode === this.bindElementData) {
                    this.bindElementData.insertBefore(refElement, element);
                    this.bindElementData.removeChild(element);
                }
                return refElement;
            }
            removeElementRefAndRestoreToAdapter(childElement) {
                if (childElement.tagName === HtmlDataListAdapter.RefElementTag) {
                    let element = childElement[HtmlDataListAdapter.RefElementProperty];
                    this.bindElementData.insertBefore(element, childElement);
                    this.bindElementData.removeChild(childElement);
                }
            }
            notifyDataSizeMayChange() {
                for (let i = 0, count = this.bindElementData.children.length; i < count; i++) {
                    this.removeElementRefAndRestoreToAdapter(this.bindElementData.children[i]);
                }
                this.notifyDataSetChanged();
            }
            getItemId(position) {
                let id = this.getItem(position).id;
                let idNumber = Number.parseInt(id);
                if (Number.isInteger(idNumber))
                    return idNumber;
                return -1;
            }
        }
        HtmlDataListAdapter.RefElementTag = "ref-element".toUpperCase();
        HtmlDataListAdapter.RefElementProperty = "RefElement";
        HtmlDataListAdapter.BindAdapterProperty = "BindAdapter";
        widget.HtmlDataListAdapter = HtmlDataListAdapter;
    })(widget = androidui.widget || (androidui.widget = {}));
})(androidui || (androidui = {}));
/**
 * Created by linfaxin on 15/11/16.
 */
///<reference path="../../android/database/DataSetObservable.ts"/>
///<reference path="../../android/database/Observable.ts"/>
///<reference path="../../android/database/DataSetObserver.ts"/>
///<reference path="../../android/view/ViewGroup.ts"/>
///<reference path="../../android/support/v4/view/ViewPager.ts"/>
///<reference path="../../android/support/v4/view/PagerAdapter.ts"/>
var androidui;
(function (androidui) {
    var widget;
    (function (widget) {
        var View = android.view.View;
        var ViewPager = android.support.v4.view.ViewPager;
        var PagerAdapter = android.support.v4.view.PagerAdapter;
        class HtmlDataPagerAdapter extends PagerAdapter {
            onInflateAdapter(bindElement, rootElement, parent) {
                this.bindElementData = bindElement;
                this.rootElement = rootElement;
                if (parent instanceof ViewPager) {
                    parent.setAdapter(this);
                }
                bindElement[HtmlDataPagerAdapter.BindAdapterProperty] = this;
                this.registerHtmlDataObserver();
            }
            registerHtmlDataObserver() {
                const adapter = this;
                function callBack(arr, observer) {
                    adapter.notifyDataSetChanged();
                }
                let observer = new MutationObserver(callBack);
                observer.observe(this.bindElementData, { childList: true });
            }
            getCount() {
                return this.bindElementData.children.length;
            }
            instantiateItem(container, position) {
                let element = this.getItem(position);
                let view = element[View.AndroidViewProperty];
                this.checkReplaceWithRef(element);
                if (!view) {
                    view = View.inflate(element, this.rootElement, container);
                    element[View.AndroidViewProperty] = view;
                }
                container.addView(view);
                return view;
            }
            getItem(position) {
                let element = this.bindElementData.children[position];
                if (element.tagName === HtmlDataPagerAdapter.RefElementTag) {
                    element = element[HtmlDataPagerAdapter.RefElementProperty];
                    if (!element)
                        throw Error('Reference element is ' + element);
                }
                return element;
            }
            checkReplaceWithRef(element) {
                let refElement = element[HtmlDataPagerAdapter.RefElementProperty] || document.createElement(HtmlDataPagerAdapter.RefElementTag);
                refElement[HtmlDataPagerAdapter.RefElementProperty] = element;
                element[HtmlDataPagerAdapter.RefElementProperty] = refElement;
                if (element.parentNode === this.bindElementData) {
                    this.bindElementData.insertBefore(refElement, element);
                    this.bindElementData.removeChild(element);
                }
                return refElement;
            }
            removeElementRefAndRestoreToAdapter(childElement) {
                if (childElement.tagName === HtmlDataPagerAdapter.RefElementTag) {
                    let element = childElement[HtmlDataPagerAdapter.RefElementProperty];
                    this.bindElementData.insertBefore(element, childElement);
                    this.bindElementData.removeChild(childElement);
                }
            }
            notifyDataSizeMayChange() {
                for (let i = 0, count = this.bindElementData.children.length; i < count; i++) {
                    this.removeElementRefAndRestoreToAdapter(this.bindElementData.children[i]);
                }
                this.notifyDataSetChanged();
            }
            destroyItem(container, position, object) {
                let view = object;
                container.removeView(view);
            }
            isViewFromObject(view, object) {
                return view === object;
            }
            getItemPosition(object) {
                let position = PagerAdapter.POSITION_NONE;
                if (object == null)
                    return position;
                for (let i = 0, count = this.getCount(); i < count; i++) {
                    if (object === this.getItem(i)[View.AndroidViewProperty]) {
                        position = i;
                        break;
                    }
                }
                return position;
            }
        }
        HtmlDataPagerAdapter.RefElementTag = "ref-element".toUpperCase();
        HtmlDataPagerAdapter.RefElementProperty = "RefElement";
        HtmlDataPagerAdapter.BindAdapterProperty = "BindAdapter";
        widget.HtmlDataPagerAdapter = HtmlDataPagerAdapter;
    })(widget = androidui.widget || (androidui.widget = {}));
})(androidui || (androidui = {}));
/**
 * Created by linfaxin on 15/10/6.
 */
//use the deepest sub class as enter
///<reference path="android/view/ViewOverlay.ts"/>
///<reference path="android/view/GestureDetector.ts"/>
///<reference path="android/widget/FrameLayout.ts"/>
///<reference path="android/widget/ScrollView.ts"/>
///<reference path="android/widget/LinearLayout.ts"/>
///<reference path="android/widget/TextView.ts"/>
///<reference path="android/widget/Button.ts"/>
///<reference path="android/widget/ImageView.ts"/>
///<reference path="android/widget/ListView.ts"/>
///<reference path="android/widget/GridView.ts"/>
///<reference path="android/widget/HorizontalScrollView.ts"/>
///<reference path="android/support/v4/view/ViewPager.ts"/>
///<reference path="android/support/v4/widget/ViewDragHelper.ts"/>
///<reference path="lib/com/jakewharton/salvage/RecyclingPagerAdapter.ts"/>
///<reference path="android/app/Activity.ts"/>
///<reference path="androidui/AndroidUI.ts"/>
///<reference path="androidui/widget/HtmlImageView.ts"/>
///<reference path="androidui/widget/HtmlDataListAdapter.ts"/>
///<reference path="androidui/widget/HtmlDataPagerAdapter.ts"/>
window[`android`] = android;
window[`java`] = java;
window[`AndroidUI`] = androidui.AndroidUI;
